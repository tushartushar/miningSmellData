Implementation smell,Namespace,Class,File,Method,Description
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvParser,The method has 124 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The method has 199 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The method has 177 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The method has 119 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The method has 117 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The method has 149 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The method has 218 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The method has 142 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has 127 lines of code.
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,Cyclomatic complexity of the method is 13
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvParser,Cyclomatic complexity of the method is 13
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,Cyclomatic complexity of the method is 35
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,Cyclomatic complexity of the method is 11
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,SetStream,Cyclomatic complexity of the method is 20
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,Cyclomatic complexity of the method is 61
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,GetSource,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Refresh,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,DownloadContent,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,webclient_OpenReadCompleted,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,Cyclomatic complexity of the method is 17
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetKmzContents,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,Utilities,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Utilities.cs,PrefixProxy,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,Cyclomatic complexity of the method is 14
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,Cyclomatic complexity of the method is 19
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,Initialize,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentTileMatrixSet,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentDimensionValues,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,Cyclomatic complexity of the method is 14
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,Cyclomatic complexity of the method is 11
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,Cyclomatic complexity of the method is 40
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,Cyclomatic complexity of the method is 49
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractLatLonBox,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractEnvelope,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,Cyclomatic complexity of the method is 33
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,Cyclomatic complexity of the method is 8
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The method has 6 parameters.
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,SetPixelSlow,The method has 6 parameters.
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,SetPixelAtRowStart,The method has 6 parameters.
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleMapAsync,The method has 5 parameters.
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The method has 5 parameters.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The length of the statement  "					if ((!string.IsNullOrEmpty (row [j])) && double.IsNaN (x) && ((!string.IsNullOrEmpty (XFieldName) && XFieldName == headers [j]) || (string.IsNullOrEmpty (XFieldName) && LON_FIELDS.Contains (headers [j].ToLowerInvariant ())))) { " is 227.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The length of the statement  "					} else if ((!string.IsNullOrEmpty (row [j])) && double.IsNaN (y) && ((!string.IsNullOrEmpty (YFieldName) && YFieldName == headers [j]) || (string.IsNullOrEmpty (YFieldName) && LAT_FIELDS.Contains (headers [j].ToLowerInvariant ())))) { " is 234.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The length of the statement  "			if ((!string.IsNullOrEmpty (XFieldName) && XFieldName == headers [i]) || (string.IsNullOrEmpty (XFieldName) && LON_FIELDS.Contains (headers [i].ToLowerInvariant ()))) { " is 168.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The length of the statement  "			} else if ((!string.IsNullOrEmpty (YFieldName) && YFieldName == headers [i]) || (string.IsNullOrEmpty (YFieldName) && LAT_FIELDS.Contains (headers [i].ToLowerInvariant ()))) { " is 175.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,SetStream,The length of the statement  "				if (col.EndsWith ("\""' StringComparison.InvariantCultureIgnoreCase) && !col.EndsWith ("\\\""' StringComparison.InvariantCultureIgnoreCase) && col.Length != 1) { " is 161.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The length of the statement  "								if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) { " is 243.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The length of the statement  "					if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x)) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,StringToPoints,The length of the statement  "		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x)) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The length of the statement  "	return Math.Atan ((Math.Sin (lat1) * Math.Cos (lat2) * Math.Sin (lon - lon2) - Math.Sin (lat2) * Math.Cos (lat1) * Math.Sin (lon - lon1)) / (Math.Cos (lat1) * Math.Cos (lat2) * Math.Sin (lon1 - lon2))) / Math.PI * 180; " is 218.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The length of the statement  "	double lon2 = lon1 + Math.Atan2 (Math.Sin (brng) * Math.Sin (dR) * Math.Cos (lat1)' Math.Cos (dR) - Math.Sin (lat1) * Math.Sin (lat2)); " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,GetSource,The length of the statement  "	Envelope extent2 = new Envelope (extent.XMin - Intensity * res' extent.YMin - Intensity * res' extent.XMax + Intensity * res' extent.YMax + Intensity * res); " is 157.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The length of the statement  "			matrix [i * width + j] = (ushort)Math.Max ((size - (Math.Sqrt (Math.Pow (i - size + 1' 2) + Math.Pow (j - size + 1' 2))))' 0); " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Initialize,The length of the statement  "			// FolderIds 0 is the layer itself (Note : we can't test here the top folder visibility (folderid=1) since the kml document has not been parsed yet' so _hasRootContainer is not initialized yet) " is 193.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GenerateVisibilityIDs,The length of the statement  "	// Then go recursively through the sublayers and  concat with  the visible IDs of the sublayers (but don't go through the hierarchy for networklinks (i.e. _isRoot)) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,InternalGenerateVisibilityIDs,The length of the statement  "	// For NetworkLinks (i.e. _isRoot)' don't go through the hierarchy and return an empty enumeration (Network links visibility is not managed by arcgis.com) " is 154.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,InternalGenerateVisibilityIDs,The length of the statement  "	// Create an enumeration either empty (if the layer is not visible) or containing the current ID (if the layer is visible) " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "			// VisibleLayerIds is set --> layer created from a web map --> check that the layer must stay visible (_hasRootContainer is set only after the file has been parsed) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "			if (_hasRootContainer && !_visibleLayerIds.Contains (1))// FolderIds 1 is the top level folder that may not be visible in SL " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "			string fullPath = _fullPath == null ? (container.Name ?? string.Empty) : string.Concat (_fullPath' "/"' container.Name); " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "			// Note : use internal constructor' so properties such as MapTip' ProxyUrl' VisibleLayers.. are reported to the children " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "				kmlLayer.Visible = _visibleLayerIds != null ? _visibleLayerIds.Contains (kmlLayer._folderId) : IsContainerVisible (fullPath' container.Visible); " is 144.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsContainerVisible,The length of the statement  "	// look for a wildcard defined at a sublevel  (e.g. VisibleLayers="myFolder/*" makes visible all paths beginning by myFolder/) " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsContainerVisible,The length of the statement  "	IEnumerable<string> subpaths = path.Select ((c' ind) => c == '/' ? path.Substring (0' ind) : null).Where (subpath => subpath != null); " is 134.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,AssignFolderIDs,The length of the statement  "		// store the folderID as attribute of the in memory XML document' so the info is available when parsing the documents or folders " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,NeedNumericId,The length of the statement  "	bool needNumericId = name == "Folder" || name == "Placemark" || name == "Document" || name == "ScreenOverlay" || name == "GroundOverlay" || name == "NetworkLink" || name == "PhotoOverlay" || name == "Camera" || name == "MultiTrack" || name == "Track"; " is 251.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,NeedNumericId,The length of the statement  "		bool isCandidate = name == "BalloonStyle" || name == "LineStyle" || name == "IconStyle" || name == "Icon" || name == "LookAt" || name == "LineString" || name == "LinearRing" || name == "LabelStyle" || name == "Style" || name == "StyleMap" || name == "LinkNode" || name == "ListStyle" || name == "Model" || name == "Schema" || name == "Url"; " is 340.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,SetResolutionRange,The length of the statement  "		minimumResolution = RegionInfo.MaxLodPixels != -1 && !double.IsNaN (RegionInfo.MaxLodPixels) ? regionSize / RegionInfo.MaxLodPixels : 0.0; " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,SetResolutionRange,The length of the statement  "		foreach (var layer in ChildLayers.Where (l => !(l is KmlLayer) || (l as KmlLayer).Url == null))// Eliminate the networklinks from the list " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,Utilities,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Utilities.cs,PrefixProxy,The length of the statement  "		_proxyUrl = string.Format ("{0}://{1}:{2}{3}"' Application.Current.Host.Source.Scheme' Application.Current.Host.Source.Host' Application.Current.Host.Source.Port' _proxyUrl); " is 174.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,GetTileUrl,The length of the statement  "	string subDomain = _subDomains != null && _subDomains.Length > 0 ? _subDomains [(level + col + row) % _subDomains.Length] : null; " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,GetTileUrl,The length of the statement  "	string url = _templateUrl.Replace ("{level}"' levelValue).Replace ("{row}"' row.ToString (CultureInfo.InvariantCulture)).Replace ("{col}"' col.ToString (CultureInfo.InvariantCulture)); " is 184.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,Initialize,The length of the statement  "		string wmsUrl = CreateUrl (Url' string.Format ("service=WMS&request=GetCapabilities&version={0}"' GetValidVersionNumber ())); " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfos,The length of the statement  "	return (layers.Elements (XName.Get ("Layer"' ns)).Select (layer => CreateLayerInfo (layer' ns' inheritedAttribution)).ToList ()); " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "	layerInfo.Title = layer.Element (XName.Get ("Title"' ns)) == null ? null : layer.Element (XName.Get ("Title"' ns)).Value; " is 121.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "	layerInfo.Abstract = layer.Element (XName.Get ("Abstract"' ns)) == null ? null : layer.Element (XName.Get ("Abstract"' ns)).Value; " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "	var attribution = layer.Element (XName.Get ("Attribution"' ns)) == null ? null : layer.Element (XName.Get ("Attribution"' ns)); " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "		layerInfo.Attribution.Title = attribution.Element (XName.Get ("Title"' ns)) == null ? inheritedAttribution : attribution.Element (XName.Get ("Title"' ns)).Value; " is 161.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The length of the statement  "		Abstract = Service.Element (XName.Get ("Abstract"' ns)) == null ? null : Service.Element (XName.Get ("Abstract"' ns)).Value " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The length of the statement  "		where c.Descendants (XName.Get ("Format"' ns)).Select (t => (t.Value == "image/png" || t.Value == "image/jpeg")).Count () > 0 " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The length of the statement  "	// initialize with all wkid that supports crs and remove from the list when an EPSG:xxxx format is supported (prefered format for backward compatibility reason) " is 160.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "		var extent = new Envelope (element.Attribute ("minx") == null ? double.MinValue : double.Parse (element.Attribute ("minx").Value' CultureInfo.InvariantCulture)' element.Attribute ("miny") == null ? double.MinValue : double.Parse (element.Attribute ("miny").Value' CultureInfo.InvariantCulture)' element.Attribute ("maxx") == null ? double.MaxValue : double.Parse (element.Attribute ("maxx").Value' CultureInfo.InvariantCulture)' element.Attribute ("maxy") == null ? double.MaxValue : double.Parse (element.Attribute ("maxy").Value' CultureInfo.InvariantCulture)) { " is 564.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CheckForError,The length of the statement  "			ex = new System.Security.SecurityException (string.Format (Properties.Resources.MapService_SecurityException' "WMS")' ex); " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "	if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) { " is 139.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "		mapURL.AppendFormat (CultureInfo.InvariantCulture' "&bbox={0}'{1}'{2}'{3}"' extent.XMin' extent.YMin' extent.XMax' extent.YMax); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "			mapURL.AppendFormat (CultureInfo.InvariantCulture' "&BBOX={0}'{1}'{2}'{3}"' extent.YMin' extent.XMin' extent.YMax' extent.XMax); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "			mapURL.AppendFormat (CultureInfo.InvariantCulture' "&BBOX={0}'{1}'{2}'{3}"' extent.XMin' extent.YMin' extent.XMax' extent.YMax); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "	onComplete (Utilities.PrefixProxy (ProxyUrl' mapURL.ToString ()).AbsoluteUri' new ImageResult (new ESRI.ArcGIS.Client.Geometry.Envelope () { " is 140.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetLayerVisibility,The length of the statement  "	return Descendants (LayerList).Where (info => info.SubLayerID == layerID).Select (info => info.Visible).FirstOrDefault (); " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnTokenPropertyChanged,The length of the statement  "	// if the token has changed and if the initialization is on the way or has failed --> initialize again the layer with the new token " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnTokenPropertyChanged,The length of the statement  "	// if the initialization was OK with the previous token --> nothing to do since we assume that the token doesn't change the metadata " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,CheckForError,The length of the statement  "			ex = new System.Security.SecurityException (string.Format (Properties.Resources.MapService_SecurityException' "WMTS")' ex); " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "		if (CurrentTileMatrixSet == null || CurrentLayer == null || CurrentTileMatrixSet.Matrices == null || level < 0 || CurrentTileMatrixSet.Matrices.Count () <= level) " is 162.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "		TileMatrixLimitsInfo tileMatrixLimits = CurrentTileMatrixSetLink == null ? null : CurrentTileMatrixSetLink.TileMatrixLimits.FirstOrDefault (tml => tml.TileMatrix == matrix.Identifier); " is 184.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "		string resourceTemplateUrl = CurrentLayer.ResourceUrls.Where (r => r.Format == ImageFormat && r.ResourceType == "tile").Select (r => r.Template).FirstOrDefault (); " is 163.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentTileMatrixSet,The length of the statement  "		currentTileMatrixSetLink = CurrentLayer.TileMatrixSetLinks.FirstOrDefault (tmsl => tmsl.TileMatrixSet == TileMatrixSet); " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentTileMatrixSet,The length of the statement  "	bool needReinitialize = CurrentTileMatrixSetLink != currentTileMatrixSetLink || CurrentTileMatrixSet != currentTileMatrixSet; " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentDimensionValues,The length of the statement  "			WmtsDimensionValue wmtsDimensionValue = DimensionValues == null ? null : DimensionValues.FirstOrDefault (dv => dv.Identifier == dimensionInfo.Identifier); " is 154.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,BestFormat,The length of the statement  "	var format = formats.FirstOrDefault (f => f.StartsWith ("image/png")) ?? formats.FirstOrDefault (f => f.StartsWith ("image/jpg") || f.StartsWith ("image/jpeg")); " is 161.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetTileInfo,The length of the statement  "	if (CurrentTileMatrixSet.Matrices.Any (tm => tm.TileWidth != tileWidth || tm.TileHeight != tileHeight || !tm.TopLeftCorner.Equals (topLeftCorner))) " is 147.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetTileInfo,The length of the statement  "		matrices = CurrentTileMatrixSetLink.TileMatrixLimits.Join (CurrentTileMatrixSet.Matrices' tmsl => tmsl.TileMatrix' m => m.Identifier' (tmsl' m) => m); " is 150.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ConvertToResolution,The length of the statement  "	// GetScale for a map resolution of 1 (i.e one map unit by pixel) gives the number of pixels by map unit of the specified SR " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseCapabilities,The length of the statement  "		LayerInfos = contents.Elements (XName.Get ("Layer"' ns)).Select (layerElement => ParseLayer (layerElement' owsns.NamespaceName' ns)).ToList (); " is 143.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseCapabilities,The length of the statement  "		TileMatrixSets = contents.Elements (XName.Get ("TileMatrixSet"' ns)).Select (elt => ParseTileMatrixSet (elt' owsns.NamespaceName' ns)).ToList (); " is 145.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "		Styles = layerElement.Elements (XName.Get ("Style"' nsname)).Select (styleElement => ParseStyle (styleElement' owsnsname)).OrderByDescending (styleInfo => styleInfo.IsDefault).Select (styleInfo => styleInfo.Identifier).ToList ()' " is 229.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "		Formats = layerElement.Elements (XName.Get ("Format"' nsname)).Select (formatElement => formatElement.GetValue ()).ToList ()' " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "		TileMatrixSetLinks = layerElement.Elements (XName.Get ("TileMatrixSetLink"' nsname)).Select (element => ParseTileMatrixSetLink (element' nsname)).ToList ()' " is 156.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "		DimensionInfos = layerElement.Elements (XName.Get ("Dimension"' nsname)).Select (element => ParseDimension (element' owsnsname' nsname)).ToList ()' " is 147.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSetLink,The length of the statement  "	IEnumerable<TileMatrixLimitsInfo> tileMatrixLimits = tileMatrixSetLimitsElement == null ? Enumerable.Empty<TileMatrixLimitsInfo> () : tileMatrixSetLimitsElement.Elements (XName.Get ("TileMatrixLimits"' nsname)).Select (elt => ParseTileMatrixLimits (elt' nsname)); " is 263.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The length of the statement  "		Matrices = element.Elements (XName.Get ("TileMatrix"' nsname)).Select (elt => ParseTileMatrix (elt' owsnsname' nsname)).ToList () " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The length of the statement  "	tileMatrixSet.Extent = ParseEnvelope (element.Element (XName.Get ("BoundingBox"' owsnsname))' tileMatrixSet.SpatialReference' owsnsname); " is 137.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,XPathSelectElement,The length of the statement  "			element = element.Elements (XName.Get (eltName' ns.NamespaceName)).Where (elt => elt.GetAttributeValue (XName.Get (attName)) == value).FirstOrDefault (); " is 153.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetMapPoint,The length of the statement  "	return new MapPoint (double.Parse (points.First ()' CultureInfo.InvariantCulture)' double.Parse (points.Last ()' CultureInfo.InvariantCulture)); " is 144.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The length of the statement  "	var defaultIconSource = new MemoryStream (Convert.FromBase64String ("iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAMAAAARSr4IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA9QTFRF/xkAkpOSzMzMAAAA////5g9v4AAAADFJREFUeNpiYEQBDIwsCMDETDqXgQGCYbIMDCAeQjGYh0MWXS+5zmBCAswMzCgAIMAAMR8Cl/k132AAAAAASUVORK5CYII=")); " is 301.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The length of the statement  "				ComputeIconTranslationValues (style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage); " is 155.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,UpdateGraphicsAndRenderer,The length of the statement  "			ComputeIconTranslationValues (f.Symbol.style' graphic.Symbol as KmlPlaceMarkerSymbol' ((graphic.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage); " is 176.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "			// If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "		// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale) " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "		if (map != null && map.SpatialReference != null && IsWebMercator (map.SpatialReference) && envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326)// should always be the case " is 195.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "	// Process the styles if they are not already known (the styles are shared by all folders/documents' so process them only once) " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "		IEnumerable<XElement> styles = xElement.Descendants ().Where (e => e.Name.LocalName == "Style" && (string)e.Attribute ("id") != null); " is 134.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "		IEnumerable<XElement> styleMaps = xElement.Descendants ().Where (e => e.Name.LocalName == "StyleMap" && (string)e.Attribute ("id") != null); " is 140.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "	foreach (XElement container in xElement.Elements ().Where (element => element.Name.LocalName == "Folder" || element.Name.LocalName == "Document" || element.Name.LocalName == "NetworkLink")) { " is 191.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "	foreach (XElement element in xElement.Elements ().Where (element => element.Name == kmlNS + "Placemark" || element.Name == kmlNS + "GroundOverlay")) { " is 150.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			GetStyleUrlAsync (styleElement.Value' null' credentials' kmlStyle => CreateFeatureDefinition (kmlStyle' featureElement' null' context) " is 134.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "	// At this point' some inner styles are possibly on the way to being downloaded and so the feature definitions are not created yet " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "	if (!featureDefs.groundOverlays.Any () && !featureDefs.placemarks.Any () && singleContainer != null && folderId == 0 && (singleContainer.RegionInfo == null || !singleContainer.RegionInfo.HasLods ()) && string.IsNullOrEmpty (singleContainer.Url) && singleContainer.TimeExtent == null) { " is 285.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "		// Avoid useless level when there is no groundoverlay' no placemark and only one folder or document at the root level without any lod info " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,StyleDownloaded,The length of the statement  "		GetStyleUrlAsync (state.StyleId' xDoc' state.Credentials' kmlStyle => StoreZipfileAndCallback (kmlStyle' state.Callback' zipFile) " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The length of the statement  "		// kmlStyle is null when the placemark doesn't reference any shared style (or a shared style that we are not able to download) " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractEnvelope,The length of the statement  "	return north.HasValue && south.HasValue && east.HasValue && west.HasValue ? new Envelope (west.Value' south.Value' east.Value' north.Value) { " is 141.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractCoordinate,The length of the statement  "			if (double.TryParse (xy [0]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out x) && double.TryParse (xy [1]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out y)) { " is 215.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The length of the statement  "		// If there is no starting # and no KML doc referenced' we search also in current KML file (may happen that the # is missing in some KML doc) " is 141.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The length of the statement  "				XElement style = xDoc.Descendants ().FirstOrDefault (e => e.Name.LocalName == "Style" && (string)e.Attribute ("id") == styleId); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The length of the statement  "					style = xDoc.Descendants ().FirstOrDefault (e => e.Name.LocalName == "StyleMap" && (string)e.Attribute ("id") == styleId); " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtent,The length of the statement  "	return ExtractTimeExtentFromTimeSpan (element.Element (ns + "TimeSpan")' attributes) ?? ExtractTimeExtentFromTimeStamp (element.Element (ns + "TimeStamp")' attributes); " is 168.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The conditional expression  "(!string.IsNullOrEmpty (row [j])) && double.IsNaN (x) && ((!string.IsNullOrEmpty (XFieldName) && XFieldName == headers [j]) || (string.IsNullOrEmpty (XFieldName) && LON_FIELDS.Contains (headers [j].ToLowerInvariant ())))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The conditional expression  "(!string.IsNullOrEmpty (row [j])) && double.IsNaN (y) && ((!string.IsNullOrEmpty (YFieldName) && YFieldName == headers [j]) || (string.IsNullOrEmpty (YFieldName) && LAT_FIELDS.Contains (headers [j].ToLowerInvariant ())))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The conditional expression  "(!string.IsNullOrEmpty (XFieldName) && XFieldName == headers [i]) || (string.IsNullOrEmpty (XFieldName) && LON_FIELDS.Contains (headers [i].ToLowerInvariant ()))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The conditional expression  "(!string.IsNullOrEmpty (YFieldName) && YFieldName == headers [i]) || (string.IsNullOrEmpty (YFieldName) && LAT_FIELDS.Contains (headers [i].ToLowerInvariant ()))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,GetSource,The conditional expression  "p.X >= extent2.XMin && p.Y >= extent2.YMin && p.X <= extent2.XMax && p.Y <= extent2.YMax"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,RefreshOnRegionAsync,The conditional expression  "map == null || !NeedRefreshOnRegion || _isLoading || _isLoaded"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The conditional expression  "SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnUrlPropertyChanged,The conditional expression  "!SkipGetCapabilities && (IsInitialized || _initializing) && !string.IsNullOrEmpty (newUrl)"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The conditional expression  "CurrentTileMatrixSet == null || CurrentLayer == null || CurrentTileMatrixSet.Matrices == null || level < 0 || CurrentTileMatrixSet.Matrices.Count () <= level"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The conditional expression  "row < minTileRow || row > maxTileRow || col < minTileCol || col > maxTileCol"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The conditional expression  "map != null && map.SpatialReference != null && IsWebMercator (map.SpatialReference) && envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The conditional expression  "!featureDefs.groundOverlays.Any () && !featureDefs.placemarks.Any () && singleContainer != null && folderId == 0 && (singleContainer.RegionInfo == null || !singleContainer.RegionInfo.HasLods ()) && string.IsNullOrEmpty (singleContainer.Url) && singleContainer.TimeExtent == null"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractLatLonBox,The conditional expression  "north.HasValue && south.HasValue && east.HasValue && west.HasValue"  is complex.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetKmzContents,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetValidVersionNumber,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,LowerThan13Version,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetValidVersionNumber,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetIconImage,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has an empty catch block.
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvLayer,The following statement contains a magic number: SourceSpatialReference = new SpatialReference (4326);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRss.cs,loader_LoadCompleted,The following statement contains a magic number: this.SpatialReference = new Geometry.SpatialReference (4326);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result) {  	SyndicationFeed feed;  	List<SyndicationItem> feedItems = new List<SyndicationItem> ();  	using (XmlReader reader = XmlReader.Create (s)) {  		feed = SyndicationFeed.Load (reader);  		foreach (SyndicationItem feedItem in feed.Items) {  			SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  			string slong = "";  			string slat = "";  			Geometry.Geometry g = null;  			IDictionary<string' object> attributes = new Dictionary<string' object> ();  			foreach (SyndicationElementExtension ee in ec) {  				if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					//This is not part of the georss-simple spec' but this makes it support a common  					//use-case with geo:lat/geo:long coordinate pairs' as described at  					//http://www.w3.org/2003/01/geo/  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("lat"): {  						slat = xr.ReadElementContentAsString ();  						break;  					}  					case ("long"): {  						slong = xr.ReadElementContentAsString ();  						break;  					}  					case ("Point"): {  						XmlReader xmlPoint = xr.ReadSubtree ();  						while (xmlPoint.Read ()) {  							if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slat = xmlPoint.ReadElementContentAsString ();  							} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  								slong = xmlPoint.ReadElementContentAsString ();  							}  						}  						break;  					}  					}  				} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  					XmlReader xr = ee.GetReader ();  					switch (ee.OuterName) {  					case ("point"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						slong = sxsy [1];  						slat = sxsy [0];  						break;  					}  					case ("line"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polyline line = new Polyline () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Paths.Add (pnts);  							g = line;  						}  						break;  					}  					case ("polygon"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null) {  							Polygon line = new Polygon () {  								SpatialReference = new SpatialReference (4326)  							};  							line.Rings.Add (pnts);  							g = line;  						}  						break;  					}  					case ("box"): {  						string sp = xr.ReadElementContentAsString ();  						PointCollection pnts = StringToPoints (sp);  						if (pnts != null && pnts.Count == 2) {  							g = new Envelope (pnts [0]' pnts [1]) {  								SpatialReference = new SpatialReference (4326)  							};  						}  						break;  					}  					case ("circle"): {  						string sp = xr.ReadElementContentAsString ();  						string[] sxsy = sp.Split (new char[] {  							' '  						});  						if (sxsy.Length == 3) {  							double x = double.NaN' y = double.NaN' r = double.NaN;  							string stX = sxsy [1];  							string stY = sxsy [0];  							string stR = sxsy [2];  							if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  								g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  							}  						}  						break;  					}  					case ("where")://GeoRSS-GML  					 {  						//GML geometry parsing goes here. However this is not  						//part of GeoRSS-simple and not supported for this datasource  						//We'll just ignore these entries  						break;  					}  					#region Attributes  					case ("elev"): {  						string sp = xr.ReadElementContentAsString ();  						double elevation = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  							attributes.Add ("elev"' elevation);  						break;  					}  					case ("floor"): {  						string sp = xr.ReadElementContentAsString ();  						int floor = 0;  						if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  							attributes.Add ("floor"' floor);  						break;  					}  					case ("radius"): {  						string sp = xr.ReadElementContentAsString ();  						double radius = 0;  						if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  							attributes.Add ("radius"' radius);  						break;  					}  					//case ("featuretypetag"):  					//case ("relationshiptag"):  					//case ("featurename"):  					default: {  						string sp = xr.ReadElementContentAsString ();  						attributes.Add (ee.OuterName' sp);  						break;  					}  					#endregion  					}  				}  			}  			if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					g = new MapPoint (x' y' new SpatialReference (4326));  			}  			if (g != null) {  				Graphic graphic = new Graphic () {  					Geometry = g  				};  				if (feedItem.Title != null)  					graphic.Attributes.Add ("Title"' feedItem.Title.Text);  				if (feedItem.Summary != null)  					graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  				if (feedItem.PublishDate != null) {  					graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  					graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  				}  				if (feedItem.Links.Count > 0)  					graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  				graphic.Attributes.Add ("FeedItem"' feedItem);  				graphic.Attributes.Add ("Id"' feedItem.Id);  				foreach (var val in attributes)  					if (!graphic.Attributes.ContainsKey (val.Key))  						graphic.Attributes.Add (val.Key' val.Value);  				// Add attribute GeometryType used by renderer  				string gt = null;  				if (g is MapPoint)  					gt = "point";  				else if (g is Polyline)  					gt = "line";  				else if (g is Polygon || g is Envelope)  					gt = "polygon";  				if (gt != null)  					graphic.Attributes.Add (GeometryTypeAttribute' gt);  				graphics.Add (graphic);  			}  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (XmlReader reader = XmlReader.Create (s)) {  	feed = SyndicationFeed.Load (reader);  	foreach (SyndicationItem feedItem in feed.Items) {  		SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  		string slong = "";  		string slat = "";  		Geometry.Geometry g = null;  		IDictionary<string' object> attributes = new Dictionary<string' object> ();  		foreach (SyndicationElementExtension ee in ec) {  			if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				//This is not part of the georss-simple spec' but this makes it support a common  				//use-case with geo:lat/geo:long coordinate pairs' as described at  				//http://www.w3.org/2003/01/geo/  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("lat"): {  					slat = xr.ReadElementContentAsString ();  					break;  				}  				case ("long"): {  					slong = xr.ReadElementContentAsString ();  					break;  				}  				case ("Point"): {  					XmlReader xmlPoint = xr.ReadSubtree ();  					while (xmlPoint.Read ()) {  						if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slat = xmlPoint.ReadElementContentAsString ();  						} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  							slong = xmlPoint.ReadElementContentAsString ();  						}  					}  					break;  				}  				}  			} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  				XmlReader xr = ee.GetReader ();  				switch (ee.OuterName) {  				case ("point"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					slong = sxsy [1];  					slat = sxsy [0];  					break;  				}  				case ("line"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polyline line = new Polyline () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Paths.Add (pnts);  						g = line;  					}  					break;  				}  				case ("polygon"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null) {  						Polygon line = new Polygon () {  							SpatialReference = new SpatialReference (4326)  						};  						line.Rings.Add (pnts);  						g = line;  					}  					break;  				}  				case ("box"): {  					string sp = xr.ReadElementContentAsString ();  					PointCollection pnts = StringToPoints (sp);  					if (pnts != null && pnts.Count == 2) {  						g = new Envelope (pnts [0]' pnts [1]) {  							SpatialReference = new SpatialReference (4326)  						};  					}  					break;  				}  				case ("circle"): {  					string sp = xr.ReadElementContentAsString ();  					string[] sxsy = sp.Split (new char[] {  						' '  					});  					if (sxsy.Length == 3) {  						double x = double.NaN' y = double.NaN' r = double.NaN;  						string stX = sxsy [1];  						string stY = sxsy [0];  						string stR = sxsy [2];  						if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  							g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  						}  					}  					break;  				}  				case ("where")://GeoRSS-GML  				 {  					//GML geometry parsing goes here. However this is not  					//part of GeoRSS-simple and not supported for this datasource  					//We'll just ignore these entries  					break;  				}  				#region Attributes  				case ("elev"): {  					string sp = xr.ReadElementContentAsString ();  					double elevation = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  						attributes.Add ("elev"' elevation);  					break;  				}  				case ("floor"): {  					string sp = xr.ReadElementContentAsString ();  					int floor = 0;  					if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  						attributes.Add ("floor"' floor);  					break;  				}  				case ("radius"): {  					string sp = xr.ReadElementContentAsString ();  					double radius = 0;  					if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  						attributes.Add ("radius"' radius);  					break;  				}  				//case ("featuretypetag"):  				//case ("relationshiptag"):  				//case ("featurename"):  				default: {  					string sp = xr.ReadElementContentAsString ();  					attributes.Add (ee.OuterName' sp);  					break;  				}  				#endregion  				}  			}  		}  		if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  			double x = double.NaN;  			double y = double.NaN;  			if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  				g = new MapPoint (x' y' new SpatialReference (4326));  		}  		if (g != null) {  			Graphic graphic = new Graphic () {  				Geometry = g  			};  			if (feedItem.Title != null)  				graphic.Attributes.Add ("Title"' feedItem.Title.Text);  			if (feedItem.Summary != null)  				graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  			if (feedItem.PublishDate != null) {  				graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  				graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  			}  			if (feedItem.Links.Count > 0)  				graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  			graphic.Attributes.Add ("FeedItem"' feedItem);  			graphic.Attributes.Add ("Id"' feedItem.Id);  			foreach (var val in attributes)  				if (!graphic.Attributes.ContainsKey (val.Key))  					graphic.Attributes.Add (val.Key' val.Value);  			// Add attribute GeometryType used by renderer  			string gt = null;  			if (g is MapPoint)  				gt = "point";  			else if (g is Polyline)  				gt = "line";  			else if (g is Polygon || g is Envelope)  				gt = "polygon";  			if (gt != null)  				graphic.Attributes.Add (GeometryTypeAttribute' gt);  			graphics.Add (graphic);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationItem feedItem in feed.Items) {  	SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;  	string slong = "";  	string slat = "";  	Geometry.Geometry g = null;  	IDictionary<string' object> attributes = new Dictionary<string' object> ();  	foreach (SyndicationElementExtension ee in ec) {  		if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			//This is not part of the georss-simple spec' but this makes it support a common  			//use-case with geo:lat/geo:long coordinate pairs' as described at  			//http://www.w3.org/2003/01/geo/  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("lat"): {  				slat = xr.ReadElementContentAsString ();  				break;  			}  			case ("long"): {  				slong = xr.ReadElementContentAsString ();  				break;  			}  			case ("Point"): {  				XmlReader xmlPoint = xr.ReadSubtree ();  				while (xmlPoint.Read ()) {  					if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slat = xmlPoint.ReadElementContentAsString ();  					} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  						slong = xmlPoint.ReadElementContentAsString ();  					}  				}  				break;  			}  			}  		} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  			XmlReader xr = ee.GetReader ();  			switch (ee.OuterName) {  			case ("point"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				slong = sxsy [1];  				slat = sxsy [0];  				break;  			}  			case ("line"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polyline line = new Polyline () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Paths.Add (pnts);  					g = line;  				}  				break;  			}  			case ("polygon"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null) {  					Polygon line = new Polygon () {  						SpatialReference = new SpatialReference (4326)  					};  					line.Rings.Add (pnts);  					g = line;  				}  				break;  			}  			case ("box"): {  				string sp = xr.ReadElementContentAsString ();  				PointCollection pnts = StringToPoints (sp);  				if (pnts != null && pnts.Count == 2) {  					g = new Envelope (pnts [0]' pnts [1]) {  						SpatialReference = new SpatialReference (4326)  					};  				}  				break;  			}  			case ("circle"): {  				string sp = xr.ReadElementContentAsString ();  				string[] sxsy = sp.Split (new char[] {  					' '  				});  				if (sxsy.Length == 3) {  					double x = double.NaN' y = double.NaN' r = double.NaN;  					string stX = sxsy [1];  					string stY = sxsy [0];  					string stR = sxsy [2];  					if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  						g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  					}  				}  				break;  			}  			case ("where")://GeoRSS-GML  			 {  				//GML geometry parsing goes here. However this is not  				//part of GeoRSS-simple and not supported for this datasource  				//We'll just ignore these entries  				break;  			}  			#region Attributes  			case ("elev"): {  				string sp = xr.ReadElementContentAsString ();  				double elevation = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  					attributes.Add ("elev"' elevation);  				break;  			}  			case ("floor"): {  				string sp = xr.ReadElementContentAsString ();  				int floor = 0;  				if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  					attributes.Add ("floor"' floor);  				break;  			}  			case ("radius"): {  				string sp = xr.ReadElementContentAsString ();  				double radius = 0;  				if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  					attributes.Add ("radius"' radius);  				break;  			}  			//case ("featuretypetag"):  			//case ("relationshiptag"):  			//case ("featurename"):  			default: {  				string sp = xr.ReadElementContentAsString ();  				attributes.Add (ee.OuterName' sp);  				break;  			}  			#endregion  			}  		}  	}  	if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  		double x = double.NaN;  		double y = double.NaN;  		if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  			g = new MapPoint (x' y' new SpatialReference (4326));  	}  	if (g != null) {  		Graphic graphic = new Graphic () {  			Geometry = g  		};  		if (feedItem.Title != null)  			graphic.Attributes.Add ("Title"' feedItem.Title.Text);  		if (feedItem.Summary != null)  			graphic.Attributes.Add ("Summary"' feedItem.Summary.Text);  		if (feedItem.PublishDate != null) {  			graphic.Attributes.Add ("PublishDate"' feedItem.PublishDate);  			graphic.TimeExtent = new TimeExtent (feedItem.PublishDate.DateTime);  		}  		if (feedItem.Links.Count > 0)  			graphic.Attributes.Add ("Link"' feedItem.Links [0].Uri);  		graphic.Attributes.Add ("FeedItem"' feedItem);  		graphic.Attributes.Add ("Id"' feedItem.Id);  		foreach (var val in attributes)  			if (!graphic.Attributes.ContainsKey (val.Key))  				graphic.Attributes.Add (val.Key' val.Value);  		// Add attribute GeometryType used by renderer  		string gt = null;  		if (g is MapPoint)  			gt = "point";  		else if (g is Polyline)  			gt = "line";  		else if (g is Polygon || g is Envelope)  			gt = "polygon";  		if (gt != null)  			graphic.Attributes.Add (GeometryTypeAttribute' gt);  		graphics.Add (graphic);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationElementExtension ee in ec) {  	if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		//This is not part of the georss-simple spec' but this makes it support a common  		//use-case with geo:lat/geo:long coordinate pairs' as described at  		//http://www.w3.org/2003/01/geo/  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("lat"): {  			slat = xr.ReadElementContentAsString ();  			break;  		}  		case ("long"): {  			slong = xr.ReadElementContentAsString ();  			break;  		}  		case ("Point"): {  			XmlReader xmlPoint = xr.ReadSubtree ();  			while (xmlPoint.Read ()) {  				if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slat = xmlPoint.ReadElementContentAsString ();  				} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slong = xmlPoint.ReadElementContentAsString ();  				}  			}  			break;  		}  		}  	} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("point"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			slong = sxsy [1];  			slat = sxsy [0];  			break;  		}  		case ("line"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polyline line = new Polyline () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Paths.Add (pnts);  				g = line;  			}  			break;  		}  		case ("polygon"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polygon line = new Polygon () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Rings.Add (pnts);  				g = line;  			}  			break;  		}  		case ("box"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null && pnts.Count == 2) {  				g = new Envelope (pnts [0]' pnts [1]) {  					SpatialReference = new SpatialReference (4326)  				};  			}  			break;  		}  		case ("circle"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			if (sxsy.Length == 3) {  				double x = double.NaN' y = double.NaN' r = double.NaN;  				string stX = sxsy [1];  				string stY = sxsy [0];  				string stR = sxsy [2];  				if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  					g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  				}  			}  			break;  		}  		case ("where")://GeoRSS-GML  		 {  			//GML geometry parsing goes here. However this is not  			//part of GeoRSS-simple and not supported for this datasource  			//We'll just ignore these entries  			break;  		}  		#region Attributes  		case ("elev"): {  			string sp = xr.ReadElementContentAsString ();  			double elevation = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  				attributes.Add ("elev"' elevation);  			break;  		}  		case ("floor"): {  			string sp = xr.ReadElementContentAsString ();  			int floor = 0;  			if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  				attributes.Add ("floor"' floor);  			break;  		}  		case ("radius"): {  			string sp = xr.ReadElementContentAsString ();  			double radius = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  				attributes.Add ("radius"' radius);  			break;  		}  		//case ("featuretypetag"):  		//case ("relationshiptag"):  		//case ("featurename"):  		default: {  			string sp = xr.ReadElementContentAsString ();  			attributes.Add (ee.OuterName' sp);  			break;  		}  		#endregion  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationElementExtension ee in ec) {  	if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		//This is not part of the georss-simple spec' but this makes it support a common  		//use-case with geo:lat/geo:long coordinate pairs' as described at  		//http://www.w3.org/2003/01/geo/  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("lat"): {  			slat = xr.ReadElementContentAsString ();  			break;  		}  		case ("long"): {  			slong = xr.ReadElementContentAsString ();  			break;  		}  		case ("Point"): {  			XmlReader xmlPoint = xr.ReadSubtree ();  			while (xmlPoint.Read ()) {  				if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slat = xmlPoint.ReadElementContentAsString ();  				} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slong = xmlPoint.ReadElementContentAsString ();  				}  			}  			break;  		}  		}  	} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("point"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			slong = sxsy [1];  			slat = sxsy [0];  			break;  		}  		case ("line"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polyline line = new Polyline () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Paths.Add (pnts);  				g = line;  			}  			break;  		}  		case ("polygon"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polygon line = new Polygon () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Rings.Add (pnts);  				g = line;  			}  			break;  		}  		case ("box"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null && pnts.Count == 2) {  				g = new Envelope (pnts [0]' pnts [1]) {  					SpatialReference = new SpatialReference (4326)  				};  			}  			break;  		}  		case ("circle"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			if (sxsy.Length == 3) {  				double x = double.NaN' y = double.NaN' r = double.NaN;  				string stX = sxsy [1];  				string stY = sxsy [0];  				string stR = sxsy [2];  				if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  					g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  				}  			}  			break;  		}  		case ("where")://GeoRSS-GML  		 {  			//GML geometry parsing goes here. However this is not  			//part of GeoRSS-simple and not supported for this datasource  			//We'll just ignore these entries  			break;  		}  		#region Attributes  		case ("elev"): {  			string sp = xr.ReadElementContentAsString ();  			double elevation = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  				attributes.Add ("elev"' elevation);  			break;  		}  		case ("floor"): {  			string sp = xr.ReadElementContentAsString ();  			int floor = 0;  			if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  				attributes.Add ("floor"' floor);  			break;  		}  		case ("radius"): {  			string sp = xr.ReadElementContentAsString ();  			double radius = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  				attributes.Add ("radius"' radius);  			break;  		}  		//case ("featuretypetag"):  		//case ("relationshiptag"):  		//case ("featurename"):  		default: {  			string sp = xr.ReadElementContentAsString ();  			attributes.Add (ee.OuterName' sp);  			break;  		}  		#endregion  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationElementExtension ee in ec) {  	if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		//This is not part of the georss-simple spec' but this makes it support a common  		//use-case with geo:lat/geo:long coordinate pairs' as described at  		//http://www.w3.org/2003/01/geo/  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("lat"): {  			slat = xr.ReadElementContentAsString ();  			break;  		}  		case ("long"): {  			slong = xr.ReadElementContentAsString ();  			break;  		}  		case ("Point"): {  			XmlReader xmlPoint = xr.ReadSubtree ();  			while (xmlPoint.Read ()) {  				if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slat = xmlPoint.ReadElementContentAsString ();  				} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slong = xmlPoint.ReadElementContentAsString ();  				}  			}  			break;  		}  		}  	} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("point"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			slong = sxsy [1];  			slat = sxsy [0];  			break;  		}  		case ("line"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polyline line = new Polyline () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Paths.Add (pnts);  				g = line;  			}  			break;  		}  		case ("polygon"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polygon line = new Polygon () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Rings.Add (pnts);  				g = line;  			}  			break;  		}  		case ("box"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null && pnts.Count == 2) {  				g = new Envelope (pnts [0]' pnts [1]) {  					SpatialReference = new SpatialReference (4326)  				};  			}  			break;  		}  		case ("circle"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			if (sxsy.Length == 3) {  				double x = double.NaN' y = double.NaN' r = double.NaN;  				string stX = sxsy [1];  				string stY = sxsy [0];  				string stR = sxsy [2];  				if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  					g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  				}  			}  			break;  		}  		case ("where")://GeoRSS-GML  		 {  			//GML geometry parsing goes here. However this is not  			//part of GeoRSS-simple and not supported for this datasource  			//We'll just ignore these entries  			break;  		}  		#region Attributes  		case ("elev"): {  			string sp = xr.ReadElementContentAsString ();  			double elevation = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  				attributes.Add ("elev"' elevation);  			break;  		}  		case ("floor"): {  			string sp = xr.ReadElementContentAsString ();  			int floor = 0;  			if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  				attributes.Add ("floor"' floor);  			break;  		}  		case ("radius"): {  			string sp = xr.ReadElementContentAsString ();  			double radius = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  				attributes.Add ("radius"' radius);  			break;  		}  		//case ("featuretypetag"):  		//case ("relationshiptag"):  		//case ("featurename"):  		default: {  			string sp = xr.ReadElementContentAsString ();  			attributes.Add (ee.OuterName' sp);  			break;  		}  		#endregion  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationElementExtension ee in ec) {  	if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		//This is not part of the georss-simple spec' but this makes it support a common  		//use-case with geo:lat/geo:long coordinate pairs' as described at  		//http://www.w3.org/2003/01/geo/  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("lat"): {  			slat = xr.ReadElementContentAsString ();  			break;  		}  		case ("long"): {  			slong = xr.ReadElementContentAsString ();  			break;  		}  		case ("Point"): {  			XmlReader xmlPoint = xr.ReadSubtree ();  			while (xmlPoint.Read ()) {  				if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slat = xmlPoint.ReadElementContentAsString ();  				} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slong = xmlPoint.ReadElementContentAsString ();  				}  			}  			break;  		}  		}  	} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("point"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			slong = sxsy [1];  			slat = sxsy [0];  			break;  		}  		case ("line"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polyline line = new Polyline () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Paths.Add (pnts);  				g = line;  			}  			break;  		}  		case ("polygon"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polygon line = new Polygon () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Rings.Add (pnts);  				g = line;  			}  			break;  		}  		case ("box"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null && pnts.Count == 2) {  				g = new Envelope (pnts [0]' pnts [1]) {  					SpatialReference = new SpatialReference (4326)  				};  			}  			break;  		}  		case ("circle"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			if (sxsy.Length == 3) {  				double x = double.NaN' y = double.NaN' r = double.NaN;  				string stX = sxsy [1];  				string stY = sxsy [0];  				string stR = sxsy [2];  				if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  					g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  				}  			}  			break;  		}  		case ("where")://GeoRSS-GML  		 {  			//GML geometry parsing goes here. However this is not  			//part of GeoRSS-simple and not supported for this datasource  			//We'll just ignore these entries  			break;  		}  		#region Attributes  		case ("elev"): {  			string sp = xr.ReadElementContentAsString ();  			double elevation = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  				attributes.Add ("elev"' elevation);  			break;  		}  		case ("floor"): {  			string sp = xr.ReadElementContentAsString ();  			int floor = 0;  			if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  				attributes.Add ("floor"' floor);  			break;  		}  		case ("radius"): {  			string sp = xr.ReadElementContentAsString ();  			double radius = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  				attributes.Add ("radius"' radius);  			break;  		}  		//case ("featuretypetag"):  		//case ("relationshiptag"):  		//case ("featurename"):  		default: {  			string sp = xr.ReadElementContentAsString ();  			attributes.Add (ee.OuterName' sp);  			break;  		}  		#endregion  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationElementExtension ee in ec) {  	if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		//This is not part of the georss-simple spec' but this makes it support a common  		//use-case with geo:lat/geo:long coordinate pairs' as described at  		//http://www.w3.org/2003/01/geo/  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("lat"): {  			slat = xr.ReadElementContentAsString ();  			break;  		}  		case ("long"): {  			slong = xr.ReadElementContentAsString ();  			break;  		}  		case ("Point"): {  			XmlReader xmlPoint = xr.ReadSubtree ();  			while (xmlPoint.Read ()) {  				if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slat = xmlPoint.ReadElementContentAsString ();  				} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slong = xmlPoint.ReadElementContentAsString ();  				}  			}  			break;  		}  		}  	} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("point"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			slong = sxsy [1];  			slat = sxsy [0];  			break;  		}  		case ("line"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polyline line = new Polyline () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Paths.Add (pnts);  				g = line;  			}  			break;  		}  		case ("polygon"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polygon line = new Polygon () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Rings.Add (pnts);  				g = line;  			}  			break;  		}  		case ("box"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null && pnts.Count == 2) {  				g = new Envelope (pnts [0]' pnts [1]) {  					SpatialReference = new SpatialReference (4326)  				};  			}  			break;  		}  		case ("circle"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			if (sxsy.Length == 3) {  				double x = double.NaN' y = double.NaN' r = double.NaN;  				string stX = sxsy [1];  				string stY = sxsy [0];  				string stR = sxsy [2];  				if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  					g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  				}  			}  			break;  		}  		case ("where")://GeoRSS-GML  		 {  			//GML geometry parsing goes here. However this is not  			//part of GeoRSS-simple and not supported for this datasource  			//We'll just ignore these entries  			break;  		}  		#region Attributes  		case ("elev"): {  			string sp = xr.ReadElementContentAsString ();  			double elevation = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  				attributes.Add ("elev"' elevation);  			break;  		}  		case ("floor"): {  			string sp = xr.ReadElementContentAsString ();  			int floor = 0;  			if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  				attributes.Add ("floor"' floor);  			break;  		}  		case ("radius"): {  			string sp = xr.ReadElementContentAsString ();  			double radius = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  				attributes.Add ("radius"' radius);  			break;  		}  		//case ("featuretypetag"):  		//case ("relationshiptag"):  		//case ("featurename"):  		default: {  			string sp = xr.ReadElementContentAsString ();  			attributes.Add (ee.OuterName' sp);  			break;  		}  		#endregion  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationElementExtension ee in ec) {  	if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		//This is not part of the georss-simple spec' but this makes it support a common  		//use-case with geo:lat/geo:long coordinate pairs' as described at  		//http://www.w3.org/2003/01/geo/  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("lat"): {  			slat = xr.ReadElementContentAsString ();  			break;  		}  		case ("long"): {  			slong = xr.ReadElementContentAsString ();  			break;  		}  		case ("Point"): {  			XmlReader xmlPoint = xr.ReadSubtree ();  			while (xmlPoint.Read ()) {  				if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slat = xmlPoint.ReadElementContentAsString ();  				} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slong = xmlPoint.ReadElementContentAsString ();  				}  			}  			break;  		}  		}  	} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("point"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			slong = sxsy [1];  			slat = sxsy [0];  			break;  		}  		case ("line"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polyline line = new Polyline () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Paths.Add (pnts);  				g = line;  			}  			break;  		}  		case ("polygon"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polygon line = new Polygon () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Rings.Add (pnts);  				g = line;  			}  			break;  		}  		case ("box"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null && pnts.Count == 2) {  				g = new Envelope (pnts [0]' pnts [1]) {  					SpatialReference = new SpatialReference (4326)  				};  			}  			break;  		}  		case ("circle"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			if (sxsy.Length == 3) {  				double x = double.NaN' y = double.NaN' r = double.NaN;  				string stX = sxsy [1];  				string stY = sxsy [0];  				string stR = sxsy [2];  				if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  					g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  				}  			}  			break;  		}  		case ("where")://GeoRSS-GML  		 {  			//GML geometry parsing goes here. However this is not  			//part of GeoRSS-simple and not supported for this datasource  			//We'll just ignore these entries  			break;  		}  		#region Attributes  		case ("elev"): {  			string sp = xr.ReadElementContentAsString ();  			double elevation = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  				attributes.Add ("elev"' elevation);  			break;  		}  		case ("floor"): {  			string sp = xr.ReadElementContentAsString ();  			int floor = 0;  			if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  				attributes.Add ("floor"' floor);  			break;  		}  		case ("radius"): {  			string sp = xr.ReadElementContentAsString ();  			double radius = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  				attributes.Add ("radius"' radius);  			break;  		}  		//case ("featuretypetag"):  		//case ("relationshiptag"):  		//case ("featurename"):  		default: {  			string sp = xr.ReadElementContentAsString ();  			attributes.Add (ee.OuterName' sp);  			break;  		}  		#endregion  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: foreach (SyndicationElementExtension ee in ec) {  	if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		//This is not part of the georss-simple spec' but this makes it support a common  		//use-case with geo:lat/geo:long coordinate pairs' as described at  		//http://www.w3.org/2003/01/geo/  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("lat"): {  			slat = xr.ReadElementContentAsString ();  			break;  		}  		case ("long"): {  			slong = xr.ReadElementContentAsString ();  			break;  		}  		case ("Point"): {  			XmlReader xmlPoint = xr.ReadSubtree ();  			while (xmlPoint.Read ()) {  				if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slat = xmlPoint.ReadElementContentAsString ();  				} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  					slong = xmlPoint.ReadElementContentAsString ();  				}  			}  			break;  		}  		}  	} else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  		XmlReader xr = ee.GetReader ();  		switch (ee.OuterName) {  		case ("point"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			slong = sxsy [1];  			slat = sxsy [0];  			break;  		}  		case ("line"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polyline line = new Polyline () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Paths.Add (pnts);  				g = line;  			}  			break;  		}  		case ("polygon"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null) {  				Polygon line = new Polygon () {  					SpatialReference = new SpatialReference (4326)  				};  				line.Rings.Add (pnts);  				g = line;  			}  			break;  		}  		case ("box"): {  			string sp = xr.ReadElementContentAsString ();  			PointCollection pnts = StringToPoints (sp);  			if (pnts != null && pnts.Count == 2) {  				g = new Envelope (pnts [0]' pnts [1]) {  					SpatialReference = new SpatialReference (4326)  				};  			}  			break;  		}  		case ("circle"): {  			string sp = xr.ReadElementContentAsString ();  			string[] sxsy = sp.Split (new char[] {  				' '  			});  			if (sxsy.Length == 3) {  				double x = double.NaN' y = double.NaN' r = double.NaN;  				string stX = sxsy [1];  				string stY = sxsy [0];  				string stR = sxsy [2];  				if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  					g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  				}  			}  			break;  		}  		case ("where")://GeoRSS-GML  		 {  			//GML geometry parsing goes here. However this is not  			//part of GeoRSS-simple and not supported for this datasource  			//We'll just ignore these entries  			break;  		}  		#region Attributes  		case ("elev"): {  			string sp = xr.ReadElementContentAsString ();  			double elevation = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  				attributes.Add ("elev"' elevation);  			break;  		}  		case ("floor"): {  			string sp = xr.ReadElementContentAsString ();  			int floor = 0;  			if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  				attributes.Add ("floor"' floor);  			break;  		}  		case ("radius"): {  			string sp = xr.ReadElementContentAsString ();  			double radius = 0;  			if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  				attributes.Add ("radius"' radius);  			break;  		}  		//case ("featuretypetag"):  		//case ("relationshiptag"):  		//case ("featurename"):  		default: {  			string sp = xr.ReadElementContentAsString ();  			attributes.Add (ee.OuterName' sp);  			break;  		}  		#endregion  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	//This is not part of the georss-simple spec' but this makes it support a common  	//use-case with geo:lat/geo:long coordinate pairs' as described at  	//http://www.w3.org/2003/01/geo/  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("lat"): {  		slat = xr.ReadElementContentAsString ();  		break;  	}  	case ("long"): {  		slong = xr.ReadElementContentAsString ();  		break;  	}  	case ("Point"): {  		XmlReader xmlPoint = xr.ReadSubtree ();  		while (xmlPoint.Read ()) {  			if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slat = xmlPoint.ReadElementContentAsString ();  			} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slong = xmlPoint.ReadElementContentAsString ();  			}  		}  		break;  	}  	}  } else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	//This is not part of the georss-simple spec' but this makes it support a common  	//use-case with geo:lat/geo:long coordinate pairs' as described at  	//http://www.w3.org/2003/01/geo/  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("lat"): {  		slat = xr.ReadElementContentAsString ();  		break;  	}  	case ("long"): {  		slong = xr.ReadElementContentAsString ();  		break;  	}  	case ("Point"): {  		XmlReader xmlPoint = xr.ReadSubtree ();  		while (xmlPoint.Read ()) {  			if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slat = xmlPoint.ReadElementContentAsString ();  			} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slong = xmlPoint.ReadElementContentAsString ();  			}  		}  		break;  	}  	}  } else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	//This is not part of the georss-simple spec' but this makes it support a common  	//use-case with geo:lat/geo:long coordinate pairs' as described at  	//http://www.w3.org/2003/01/geo/  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("lat"): {  		slat = xr.ReadElementContentAsString ();  		break;  	}  	case ("long"): {  		slong = xr.ReadElementContentAsString ();  		break;  	}  	case ("Point"): {  		XmlReader xmlPoint = xr.ReadSubtree ();  		while (xmlPoint.Read ()) {  			if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slat = xmlPoint.ReadElementContentAsString ();  			} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slong = xmlPoint.ReadElementContentAsString ();  			}  		}  		break;  	}  	}  } else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	//This is not part of the georss-simple spec' but this makes it support a common  	//use-case with geo:lat/geo:long coordinate pairs' as described at  	//http://www.w3.org/2003/01/geo/  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("lat"): {  		slat = xr.ReadElementContentAsString ();  		break;  	}  	case ("long"): {  		slong = xr.ReadElementContentAsString ();  		break;  	}  	case ("Point"): {  		XmlReader xmlPoint = xr.ReadSubtree ();  		while (xmlPoint.Read ()) {  			if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slat = xmlPoint.ReadElementContentAsString ();  			} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slong = xmlPoint.ReadElementContentAsString ();  			}  		}  		break;  	}  	}  } else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	//This is not part of the georss-simple spec' but this makes it support a common  	//use-case with geo:lat/geo:long coordinate pairs' as described at  	//http://www.w3.org/2003/01/geo/  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("lat"): {  		slat = xr.ReadElementContentAsString ();  		break;  	}  	case ("long"): {  		slong = xr.ReadElementContentAsString ();  		break;  	}  	case ("Point"): {  		XmlReader xmlPoint = xr.ReadSubtree ();  		while (xmlPoint.Read ()) {  			if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slat = xmlPoint.ReadElementContentAsString ();  			} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slong = xmlPoint.ReadElementContentAsString ();  			}  		}  		break;  	}  	}  } else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	//This is not part of the georss-simple spec' but this makes it support a common  	//use-case with geo:lat/geo:long coordinate pairs' as described at  	//http://www.w3.org/2003/01/geo/  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("lat"): {  		slat = xr.ReadElementContentAsString ();  		break;  	}  	case ("long"): {  		slong = xr.ReadElementContentAsString ();  		break;  	}  	case ("Point"): {  		XmlReader xmlPoint = xr.ReadSubtree ();  		while (xmlPoint.Read ()) {  			if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slat = xmlPoint.ReadElementContentAsString ();  			} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slong = xmlPoint.ReadElementContentAsString ();  			}  		}  		break;  	}  	}  } else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	//This is not part of the georss-simple spec' but this makes it support a common  	//use-case with geo:lat/geo:long coordinate pairs' as described at  	//http://www.w3.org/2003/01/geo/  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("lat"): {  		slat = xr.ReadElementContentAsString ();  		break;  	}  	case ("long"): {  		slong = xr.ReadElementContentAsString ();  		break;  	}  	case ("Point"): {  		XmlReader xmlPoint = xr.ReadSubtree ();  		while (xmlPoint.Read ()) {  			if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slat = xmlPoint.ReadElementContentAsString ();  			} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  				slong = xmlPoint.ReadElementContentAsString ();  			}  		}  		break;  	}  	}  } else if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (ee.OuterNamespace.Equals (_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase)) {  	XmlReader xr = ee.GetReader ();  	switch (ee.OuterName) {  	case ("point"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		slong = sxsy [1];  		slat = sxsy [0];  		break;  	}  	case ("line"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polyline line = new Polyline () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Paths.Add (pnts);  			g = line;  		}  		break;  	}  	case ("polygon"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null) {  			Polygon line = new Polygon () {  				SpatialReference = new SpatialReference (4326)  			};  			line.Rings.Add (pnts);  			g = line;  		}  		break;  	}  	case ("box"): {  		string sp = xr.ReadElementContentAsString ();  		PointCollection pnts = StringToPoints (sp);  		if (pnts != null && pnts.Count == 2) {  			g = new Envelope (pnts [0]' pnts [1]) {  				SpatialReference = new SpatialReference (4326)  			};  		}  		break;  	}  	case ("circle"): {  		string sp = xr.ReadElementContentAsString ();  		string[] sxsy = sp.Split (new char[] {  			' '  		});  		if (sxsy.Length == 3) {  			double x = double.NaN' y = double.NaN' r = double.NaN;  			string stX = sxsy [1];  			string stY = sxsy [0];  			string stR = sxsy [2];  			if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  				g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  			}  		}  		break;  	}  	case ("where")://GeoRSS-GML  	 {  		//GML geometry parsing goes here. However this is not  		//part of GeoRSS-simple and not supported for this datasource  		//We'll just ignore these entries  		break;  	}  	#region Attributes  	case ("elev"): {  		string sp = xr.ReadElementContentAsString ();  		double elevation = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  			attributes.Add ("elev"' elevation);  		break;  	}  	case ("floor"): {  		string sp = xr.ReadElementContentAsString ();  		int floor = 0;  		if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  			attributes.Add ("floor"' floor);  		break;  	}  	case ("radius"): {  		string sp = xr.ReadElementContentAsString ();  		double radius = 0;  		if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  			attributes.Add ("radius"' radius);  		break;  	}  	//case ("featuretypetag"):  	//case ("relationshiptag"):  	//case ("featurename"):  	default: {  		string sp = xr.ReadElementContentAsString ();  		attributes.Add (ee.OuterName' sp);  		break;  	}  	#endregion  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: switch (ee.OuterName) {  case ("point"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	slong = sxsy [1];  	slat = sxsy [0];  	break;  }  case ("line"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polyline line = new Polyline () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Paths.Add (pnts);  		g = line;  	}  	break;  }  case ("polygon"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polygon line = new Polygon () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Rings.Add (pnts);  		g = line;  	}  	break;  }  case ("box"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null && pnts.Count == 2) {  		g = new Envelope (pnts [0]' pnts [1]) {  			SpatialReference = new SpatialReference (4326)  		};  	}  	break;  }  case ("circle"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	if (sxsy.Length == 3) {  		double x = double.NaN' y = double.NaN' r = double.NaN;  		string stX = sxsy [1];  		string stY = sxsy [0];  		string stR = sxsy [2];  		if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  			g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  		}  	}  	break;  }  case ("where")://GeoRSS-GML   {  	//GML geometry parsing goes here. However this is not  	//part of GeoRSS-simple and not supported for this datasource  	//We'll just ignore these entries  	break;  }  #region Attributes  case ("elev"): {  	string sp = xr.ReadElementContentAsString ();  	double elevation = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  		attributes.Add ("elev"' elevation);  	break;  }  case ("floor"): {  	string sp = xr.ReadElementContentAsString ();  	int floor = 0;  	if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  		attributes.Add ("floor"' floor);  	break;  }  case ("radius"): {  	string sp = xr.ReadElementContentAsString ();  	double radius = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  		attributes.Add ("radius"' radius);  	break;  }  //case ("featuretypetag"):  //case ("relationshiptag"):  //case ("featurename"):  default: {  	string sp = xr.ReadElementContentAsString ();  	attributes.Add (ee.OuterName' sp);  	break;  }  #endregion  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: switch (ee.OuterName) {  case ("point"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	slong = sxsy [1];  	slat = sxsy [0];  	break;  }  case ("line"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polyline line = new Polyline () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Paths.Add (pnts);  		g = line;  	}  	break;  }  case ("polygon"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polygon line = new Polygon () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Rings.Add (pnts);  		g = line;  	}  	break;  }  case ("box"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null && pnts.Count == 2) {  		g = new Envelope (pnts [0]' pnts [1]) {  			SpatialReference = new SpatialReference (4326)  		};  	}  	break;  }  case ("circle"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	if (sxsy.Length == 3) {  		double x = double.NaN' y = double.NaN' r = double.NaN;  		string stX = sxsy [1];  		string stY = sxsy [0];  		string stR = sxsy [2];  		if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  			g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  		}  	}  	break;  }  case ("where")://GeoRSS-GML   {  	//GML geometry parsing goes here. However this is not  	//part of GeoRSS-simple and not supported for this datasource  	//We'll just ignore these entries  	break;  }  #region Attributes  case ("elev"): {  	string sp = xr.ReadElementContentAsString ();  	double elevation = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  		attributes.Add ("elev"' elevation);  	break;  }  case ("floor"): {  	string sp = xr.ReadElementContentAsString ();  	int floor = 0;  	if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  		attributes.Add ("floor"' floor);  	break;  }  case ("radius"): {  	string sp = xr.ReadElementContentAsString ();  	double radius = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  		attributes.Add ("radius"' radius);  	break;  }  //case ("featuretypetag"):  //case ("relationshiptag"):  //case ("featurename"):  default: {  	string sp = xr.ReadElementContentAsString ();  	attributes.Add (ee.OuterName' sp);  	break;  }  #endregion  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: switch (ee.OuterName) {  case ("point"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	slong = sxsy [1];  	slat = sxsy [0];  	break;  }  case ("line"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polyline line = new Polyline () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Paths.Add (pnts);  		g = line;  	}  	break;  }  case ("polygon"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polygon line = new Polygon () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Rings.Add (pnts);  		g = line;  	}  	break;  }  case ("box"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null && pnts.Count == 2) {  		g = new Envelope (pnts [0]' pnts [1]) {  			SpatialReference = new SpatialReference (4326)  		};  	}  	break;  }  case ("circle"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	if (sxsy.Length == 3) {  		double x = double.NaN' y = double.NaN' r = double.NaN;  		string stX = sxsy [1];  		string stY = sxsy [0];  		string stR = sxsy [2];  		if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  			g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  		}  	}  	break;  }  case ("where")://GeoRSS-GML   {  	//GML geometry parsing goes here. However this is not  	//part of GeoRSS-simple and not supported for this datasource  	//We'll just ignore these entries  	break;  }  #region Attributes  case ("elev"): {  	string sp = xr.ReadElementContentAsString ();  	double elevation = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  		attributes.Add ("elev"' elevation);  	break;  }  case ("floor"): {  	string sp = xr.ReadElementContentAsString ();  	int floor = 0;  	if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  		attributes.Add ("floor"' floor);  	break;  }  case ("radius"): {  	string sp = xr.ReadElementContentAsString ();  	double radius = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  		attributes.Add ("radius"' radius);  	break;  }  //case ("featuretypetag"):  //case ("relationshiptag"):  //case ("featurename"):  default: {  	string sp = xr.ReadElementContentAsString ();  	attributes.Add (ee.OuterName' sp);  	break;  }  #endregion  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: switch (ee.OuterName) {  case ("point"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	slong = sxsy [1];  	slat = sxsy [0];  	break;  }  case ("line"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polyline line = new Polyline () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Paths.Add (pnts);  		g = line;  	}  	break;  }  case ("polygon"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polygon line = new Polygon () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Rings.Add (pnts);  		g = line;  	}  	break;  }  case ("box"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null && pnts.Count == 2) {  		g = new Envelope (pnts [0]' pnts [1]) {  			SpatialReference = new SpatialReference (4326)  		};  	}  	break;  }  case ("circle"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	if (sxsy.Length == 3) {  		double x = double.NaN' y = double.NaN' r = double.NaN;  		string stX = sxsy [1];  		string stY = sxsy [0];  		string stR = sxsy [2];  		if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  			g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  		}  	}  	break;  }  case ("where")://GeoRSS-GML   {  	//GML geometry parsing goes here. However this is not  	//part of GeoRSS-simple and not supported for this datasource  	//We'll just ignore these entries  	break;  }  #region Attributes  case ("elev"): {  	string sp = xr.ReadElementContentAsString ();  	double elevation = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  		attributes.Add ("elev"' elevation);  	break;  }  case ("floor"): {  	string sp = xr.ReadElementContentAsString ();  	int floor = 0;  	if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  		attributes.Add ("floor"' floor);  	break;  }  case ("radius"): {  	string sp = xr.ReadElementContentAsString ();  	double radius = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  		attributes.Add ("radius"' radius);  	break;  }  //case ("featuretypetag"):  //case ("relationshiptag"):  //case ("featurename"):  default: {  	string sp = xr.ReadElementContentAsString ();  	attributes.Add (ee.OuterName' sp);  	break;  }  #endregion  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: switch (ee.OuterName) {  case ("point"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	slong = sxsy [1];  	slat = sxsy [0];  	break;  }  case ("line"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polyline line = new Polyline () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Paths.Add (pnts);  		g = line;  	}  	break;  }  case ("polygon"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polygon line = new Polygon () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Rings.Add (pnts);  		g = line;  	}  	break;  }  case ("box"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null && pnts.Count == 2) {  		g = new Envelope (pnts [0]' pnts [1]) {  			SpatialReference = new SpatialReference (4326)  		};  	}  	break;  }  case ("circle"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	if (sxsy.Length == 3) {  		double x = double.NaN' y = double.NaN' r = double.NaN;  		string stX = sxsy [1];  		string stY = sxsy [0];  		string stR = sxsy [2];  		if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  			g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  		}  	}  	break;  }  case ("where")://GeoRSS-GML   {  	//GML geometry parsing goes here. However this is not  	//part of GeoRSS-simple and not supported for this datasource  	//We'll just ignore these entries  	break;  }  #region Attributes  case ("elev"): {  	string sp = xr.ReadElementContentAsString ();  	double elevation = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  		attributes.Add ("elev"' elevation);  	break;  }  case ("floor"): {  	string sp = xr.ReadElementContentAsString ();  	int floor = 0;  	if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  		attributes.Add ("floor"' floor);  	break;  }  case ("radius"): {  	string sp = xr.ReadElementContentAsString ();  	double radius = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  		attributes.Add ("radius"' radius);  	break;  }  //case ("featuretypetag"):  //case ("relationshiptag"):  //case ("featurename"):  default: {  	string sp = xr.ReadElementContentAsString ();  	attributes.Add (ee.OuterName' sp);  	break;  }  #endregion  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: switch (ee.OuterName) {  case ("point"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	slong = sxsy [1];  	slat = sxsy [0];  	break;  }  case ("line"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polyline line = new Polyline () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Paths.Add (pnts);  		g = line;  	}  	break;  }  case ("polygon"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polygon line = new Polygon () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Rings.Add (pnts);  		g = line;  	}  	break;  }  case ("box"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null && pnts.Count == 2) {  		g = new Envelope (pnts [0]' pnts [1]) {  			SpatialReference = new SpatialReference (4326)  		};  	}  	break;  }  case ("circle"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	if (sxsy.Length == 3) {  		double x = double.NaN' y = double.NaN' r = double.NaN;  		string stX = sxsy [1];  		string stY = sxsy [0];  		string stR = sxsy [2];  		if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  			g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  		}  	}  	break;  }  case ("where")://GeoRSS-GML   {  	//GML geometry parsing goes here. However this is not  	//part of GeoRSS-simple and not supported for this datasource  	//We'll just ignore these entries  	break;  }  #region Attributes  case ("elev"): {  	string sp = xr.ReadElementContentAsString ();  	double elevation = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  		attributes.Add ("elev"' elevation);  	break;  }  case ("floor"): {  	string sp = xr.ReadElementContentAsString ();  	int floor = 0;  	if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  		attributes.Add ("floor"' floor);  	break;  }  case ("radius"): {  	string sp = xr.ReadElementContentAsString ();  	double radius = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  		attributes.Add ("radius"' radius);  	break;  }  //case ("featuretypetag"):  //case ("relationshiptag"):  //case ("featurename"):  default: {  	string sp = xr.ReadElementContentAsString ();  	attributes.Add (ee.OuterName' sp);  	break;  }  #endregion  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: switch (ee.OuterName) {  case ("point"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	slong = sxsy [1];  	slat = sxsy [0];  	break;  }  case ("line"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polyline line = new Polyline () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Paths.Add (pnts);  		g = line;  	}  	break;  }  case ("polygon"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null) {  		Polygon line = new Polygon () {  			SpatialReference = new SpatialReference (4326)  		};  		line.Rings.Add (pnts);  		g = line;  	}  	break;  }  case ("box"): {  	string sp = xr.ReadElementContentAsString ();  	PointCollection pnts = StringToPoints (sp);  	if (pnts != null && pnts.Count == 2) {  		g = new Envelope (pnts [0]' pnts [1]) {  			SpatialReference = new SpatialReference (4326)  		};  	}  	break;  }  case ("circle"): {  	string sp = xr.ReadElementContentAsString ();  	string[] sxsy = sp.Split (new char[] {  		' '  	});  	if (sxsy.Length == 3) {  		double x = double.NaN' y = double.NaN' r = double.NaN;  		string stX = sxsy [1];  		string stY = sxsy [0];  		string stR = sxsy [2];  		if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  			g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  		}  	}  	break;  }  case ("where")://GeoRSS-GML   {  	//GML geometry parsing goes here. However this is not  	//part of GeoRSS-simple and not supported for this datasource  	//We'll just ignore these entries  	break;  }  #region Attributes  case ("elev"): {  	string sp = xr.ReadElementContentAsString ();  	double elevation = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  		attributes.Add ("elev"' elevation);  	break;  }  case ("floor"): {  	string sp = xr.ReadElementContentAsString ();  	int floor = 0;  	if (int.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  		attributes.Add ("floor"' floor);  	break;  }  case ("radius"): {  	string sp = xr.ReadElementContentAsString ();  	double radius = 0;  	if (double.TryParse (sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  		attributes.Add ("radius"' radius);  	break;  }  //case ("featuretypetag"):  //case ("relationshiptag"):  //case ("featurename"):  default: {  	string sp = xr.ReadElementContentAsString ();  	attributes.Add (ee.OuterName' sp);  	break;  }  #endregion  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (pnts != null) {  	Polyline line = new Polyline () {  		SpatialReference = new SpatialReference (4326)  	};  	line.Paths.Add (pnts);  	g = line;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (pnts != null) {  	Polygon line = new Polygon () {  		SpatialReference = new SpatialReference (4326)  	};  	line.Rings.Add (pnts);  	g = line;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (pnts != null && pnts.Count == 2) {  	g = new Envelope (pnts [0]' pnts [1]) {  		SpatialReference = new SpatialReference (4326)  	};  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (pnts != null && pnts.Count == 2) {  	g = new Envelope (pnts [0]' pnts [1]) {  		SpatialReference = new SpatialReference (4326)  	};  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: g = new Envelope (pnts [0]' pnts [1]) {  	SpatialReference = new SpatialReference (4326)  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (sxsy.Length == 3) {  	double x = double.NaN' y = double.NaN' r = double.NaN;  	string stX = sxsy [1];  	string stY = sxsy [0];  	string stR = sxsy [2];  	if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  		g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (sxsy.Length == 3) {  	double x = double.NaN' y = double.NaN' r = double.NaN;  	string stX = sxsy [1];  	string stY = sxsy [0];  	string stR = sxsy [2];  	if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  		g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (sxsy.Length == 3) {  	double x = double.NaN' y = double.NaN' r = double.NaN;  	string stX = sxsy [1];  	string stY = sxsy [0];  	string stR = sxsy [2];  	if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  		g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (double.TryParse (stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) && double.TryParse (stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r)) {  	g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: g = GetRadiusAsPolygonGeodesic (new MapPoint (x' y)' r' 360);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (!string.IsNullOrEmpty (slong) && !string.IsNullOrEmpty (slat)) {  	double x = double.NaN;  	double y = double.NaN;  	if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  		g = new MapPoint (x' y' new SpatialReference (4326));  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  	g = new MapPoint (x' y' new SpatialReference (4326));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: g = new MapPoint (x' y' new SpatialReference (4326));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,StringToPoints,The following statement contains a magic number: for (int i = 0; i < sxsy.Length - 1; i += 2) {  	string slat = sxsy [i];  	string slong = sxsy [i + 1];  	double x = double.NaN;  	double y = double.NaN;  	if (double.TryParse (slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) && double.TryParse (slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  		pnts.Add (new MapPoint (x' y));  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,StringToPoints,The following statement contains a magic number: i += 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1) {  	PointCollection ring = line.Paths [0];  	MapPoint last = ring [ring.Count - 1];  	for (int i = 1; i < line.Paths.Count; i++) {  		PointCollection pnts = line.Paths [i];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		last = pnts [0];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		foreach (MapPoint p in pnts)  			ring.Add (p);  		last = pnts [pnts.Count - 1];  	}  	poly.Rings.Add (ring);  } else {  	poly.Rings.Add (line.Paths [0]);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1) {  	PointCollection ring = line.Paths [0];  	MapPoint last = ring [ring.Count - 1];  	for (int i = 1; i < line.Paths.Count; i++) {  		PointCollection pnts = line.Paths [i];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		last = pnts [0];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		foreach (MapPoint p in pnts)  			ring.Add (p);  		last = pnts [pnts.Count - 1];  	}  	poly.Rings.Add (ring);  } else {  	poly.Rings.Add (line.Paths [0]);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1) {  	PointCollection ring = line.Paths [0];  	MapPoint last = ring [ring.Count - 1];  	for (int i = 1; i < line.Paths.Count; i++) {  		PointCollection pnts = line.Paths [i];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		last = pnts [0];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		foreach (MapPoint p in pnts)  			ring.Add (p);  		last = pnts [pnts.Count - 1];  	}  	poly.Rings.Add (ring);  } else {  	poly.Rings.Add (line.Paths [0]);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1) {  	PointCollection ring = line.Paths [0];  	MapPoint last = ring [ring.Count - 1];  	for (int i = 1; i < line.Paths.Count; i++) {  		PointCollection pnts = line.Paths [i];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		last = pnts [0];  		ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  		foreach (MapPoint p in pnts)  			ring.Add (p);  		last = pnts [pnts.Count - 1];  	}  	poly.Rings.Add (ring);  } else {  	poly.Rings.Add (line.Paths [0]);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: for (int i = 1; i < line.Paths.Count; i++) {  	PointCollection pnts = line.Paths [i];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	last = pnts [0];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	foreach (MapPoint p in pnts)  		ring.Add (p);  	last = pnts [pnts.Count - 1];  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: for (int i = 1; i < line.Paths.Count; i++) {  	PointCollection pnts = line.Paths [i];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	last = pnts [0];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	foreach (MapPoint p in pnts)  		ring.Add (p);  	last = pnts [pnts.Count - 1];  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: for (int i = 1; i < line.Paths.Count; i++) {  	PointCollection pnts = line.Paths [i];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	last = pnts [0];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	foreach (MapPoint p in pnts)  		ring.Add (p);  	last = pnts [pnts.Count - 1];  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: for (int i = 1; i < line.Paths.Count; i++) {  	PointCollection pnts = line.Paths [i];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	last = pnts [0];  	ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  	foreach (MapPoint p in pnts)  		ring.Add (p);  	last = pnts [pnts.Count - 1];  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add (new MapPoint (180 * Math.Sign (last.X)' 90 * Math.Sign (center.Y)));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2) {  	PointCollection pnts = new PointCollection ();  	pnts.Add (new MapPoint (-180' -90));  	pnts.Add (new MapPoint (180' -90));  	pnts.Add (new MapPoint (180' 90));  	pnts.Add (new MapPoint (-180' 90));  	pnts.Add (new MapPoint (-180' -90));  	poly.Rings.Add (pnts);  	//Exterior  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (-180' -90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (-180' -90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (180' -90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (180' -90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (180' 90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (180' 90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (-180' 90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (-180' 90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (-180' -90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add (new MapPoint (-180' -90));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	//double angle = i / 180.0 * Math.PI;  	MapPoint p = GetPointFromHeadingGeodesic (center' distance' i);  	if (pnts.Count > 0) {  		MapPoint lastPoint = pnts [pnts.Count - 1];  		int sign = Math.Sign (p.X);  		if (Math.Abs (p.X - lastPoint.X) > 180) {  			//We crossed the date line  			double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  			pnts.Add (new MapPoint (sign * -180' lat));  			pnts = new PointCollection ();  			line.Paths.Add (pnts);  			pnts.Add (new MapPoint (sign * 180' lat));  		}  	}  	pnts.Add (p);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	//double angle = i / 180.0 * Math.PI;  	MapPoint p = GetPointFromHeadingGeodesic (center' distance' i);  	if (pnts.Count > 0) {  		MapPoint lastPoint = pnts [pnts.Count - 1];  		int sign = Math.Sign (p.X);  		if (Math.Abs (p.X - lastPoint.X) > 180) {  			//We crossed the date line  			double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  			pnts.Add (new MapPoint (sign * -180' lat));  			pnts = new PointCollection ();  			line.Paths.Add (pnts);  			pnts.Add (new MapPoint (sign * 180' lat));  		}  	}  	pnts.Add (p);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	//double angle = i / 180.0 * Math.PI;  	MapPoint p = GetPointFromHeadingGeodesic (center' distance' i);  	if (pnts.Count > 0) {  		MapPoint lastPoint = pnts [pnts.Count - 1];  		int sign = Math.Sign (p.X);  		if (Math.Abs (p.X - lastPoint.X) > 180) {  			//We crossed the date line  			double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  			pnts.Add (new MapPoint (sign * -180' lat));  			pnts = new PointCollection ();  			line.Paths.Add (pnts);  			pnts.Add (new MapPoint (sign * 180' lat));  		}  	}  	pnts.Add (p);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++) {  	//double angle = i / 180.0 * Math.PI;  	MapPoint p = GetPointFromHeadingGeodesic (center' distance' i);  	if (pnts.Count > 0) {  		MapPoint lastPoint = pnts [pnts.Count - 1];  		int sign = Math.Sign (p.X);  		if (Math.Abs (p.X - lastPoint.X) > 180) {  			//We crossed the date line  			double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  			pnts.Add (new MapPoint (sign * -180' lat));  			pnts = new PointCollection ();  			line.Paths.Add (pnts);  			pnts.Add (new MapPoint (sign * 180' lat));  		}  	}  	pnts.Add (p);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (pnts.Count > 0) {  	MapPoint lastPoint = pnts [pnts.Count - 1];  	int sign = Math.Sign (p.X);  	if (Math.Abs (p.X - lastPoint.X) > 180) {  		//We crossed the date line  		double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  		pnts.Add (new MapPoint (sign * -180' lat));  		pnts = new PointCollection ();  		line.Paths.Add (pnts);  		pnts.Add (new MapPoint (sign * 180' lat));  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (pnts.Count > 0) {  	MapPoint lastPoint = pnts [pnts.Count - 1];  	int sign = Math.Sign (p.X);  	if (Math.Abs (p.X - lastPoint.X) > 180) {  		//We crossed the date line  		double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  		pnts.Add (new MapPoint (sign * -180' lat));  		pnts = new PointCollection ();  		line.Paths.Add (pnts);  		pnts.Add (new MapPoint (sign * 180' lat));  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (pnts.Count > 0) {  	MapPoint lastPoint = pnts [pnts.Count - 1];  	int sign = Math.Sign (p.X);  	if (Math.Abs (p.X - lastPoint.X) > 180) {  		//We crossed the date line  		double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  		pnts.Add (new MapPoint (sign * -180' lat));  		pnts = new PointCollection ();  		line.Paths.Add (pnts);  		pnts.Add (new MapPoint (sign * 180' lat));  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (pnts.Count > 0) {  	MapPoint lastPoint = pnts [pnts.Count - 1];  	int sign = Math.Sign (p.X);  	if (Math.Abs (p.X - lastPoint.X) > 180) {  		//We crossed the date line  		double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  		pnts.Add (new MapPoint (sign * -180' lat));  		pnts = new PointCollection ();  		line.Paths.Add (pnts);  		pnts.Add (new MapPoint (sign * 180' lat));  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (Math.Abs (p.X - lastPoint.X) > 180) {  	//We crossed the date line  	double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  	pnts.Add (new MapPoint (sign * -180' lat));  	pnts = new PointCollection ();  	line.Paths.Add (pnts);  	pnts.Add (new MapPoint (sign * 180' lat));  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (Math.Abs (p.X - lastPoint.X) > 180) {  	//We crossed the date line  	double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  	pnts.Add (new MapPoint (sign * -180' lat));  	pnts = new PointCollection ();  	line.Paths.Add (pnts);  	pnts.Add (new MapPoint (sign * 180' lat));  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (Math.Abs (p.X - lastPoint.X) > 180) {  	//We crossed the date line  	double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  	pnts.Add (new MapPoint (sign * -180' lat));  	pnts = new PointCollection ();  	line.Paths.Add (pnts);  	pnts.Add (new MapPoint (sign * 180' lat));  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: if (Math.Abs (p.X - lastPoint.X) > 180) {  	//We crossed the date line  	double lat = LatitudeAtLongitude (lastPoint' p' sign * -180);  	pnts.Add (new MapPoint (sign * -180' lat));  	pnts = new PointCollection ();  	line.Paths.Add (pnts);  	pnts.Add (new MapPoint (sign * 180' lat));  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: pnts.Add (new MapPoint (sign * -180' lat));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: pnts.Add (new MapPoint (sign * 180' lat));  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: lon = lon / 180 * Math.PI;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: return Math.Atan ((Math.Sin (lat1) * Math.Cos (lat2) * Math.Sin (lon - lon2) - Math.Sin (lat2) * Math.Cos (lat1) * Math.Sin (lon - lon1)) / (Math.Cos (lat1) * Math.Cos (lat2) * Math.Sin (lon1 - lon2))) / Math.PI * 180;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon < -180)  	lon += 360;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon < -180)  	lon += 360;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lon += 360;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat < -90)  	lat += 180;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat < -90)  	lat += 180;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lat += 180;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon > 180)  	lon -= 360;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon > 180)  	lon -= 360;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lon -= 360;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat > 90)  	lat -= 180;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat > 90)  	lat -= 180;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lat -= 180;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add (new GradientStop () {  	Color = Colors.Blue'  	Offset = .5  });  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add (new GradientStop () {  	Color = Colors.Red'  	Offset = .75  });  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add (new GradientStop () {  	Color = Colors.Yellow'  	Offset = .8  });  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,OnIntensityPropertyChanged,The following statement contains a magic number: if (dp.IsInitialized) {  	if (dp.timer == null) {  		dp.timer = new System.Windows.Threading.DispatcherTimer () {  			Interval = TimeSpan.FromMilliseconds (50)  		};  		dp.timer.Tick += (s' e2) => {  			dp.timer.Stop ();  			dp.OnLayerChanged ();  		};  	}  	dp.timer.Stop ();  	dp.timer.Start ();  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,OnIntensityPropertyChanged,The following statement contains a magic number: if (dp.timer == null) {  	dp.timer = new System.Windows.Threading.DispatcherTimer () {  		Interval = TimeSpan.FromMilliseconds (50)  	};  	dp.timer.Tick += (s' e2) => {  		dp.timer.Stop ();  		dp.OnLayerChanged ();  	};  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,OnIntensityPropertyChanged,The following statement contains a magic number: dp.timer = new System.Windows.Threading.DispatcherTimer () {  	Interval = TimeSpan.FromMilliseconds (50)  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: size = size * 2 + 1;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: if (max < 2)  	max = 2;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: if (max < 2)  	max = 2;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: max = 2;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: for (int idx = 0; idx < height; idx++)// Height (y)   {  	#if SILVERLIGHT  	int rowstart = ei.GetRowStart (idx);  	#endif  	for (int jdx = 0; jdx < width; jdx++)// Width (x)  	 {  		Color c = InterpolateColor (output [idx * width + jdx] / (float)max' stops);  		#if SILVERLIGHT  		ei.SetPixelAtRowStart (jdx' rowstart' c.R' c.G' c.B' c.A);  		#else  							int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B; 					pixels[idx * width + jdx] = color; #endif  	}  	if (worker.CancellationPending) {  		e.Cancel = true;  		e.Result = null;  		output = null;  		#if SILVERLIGHT  		ei = null;  		#else  							pixels = null; #endif  		return;  	}  	//Raise the progress event for each line rendered  	worker.ReportProgress ((idx + 1) * 100 / height);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: worker.ReportProgress ((idx + 1) * 100 / height);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int i = 0; i < size * 2 - 1; i++) {  	int start = (y - size + 1 + i) * width + x - size;  	for (int j = 0; j < size * 2 - 1; j++) {  		if (j + x - size < 0 || j + x - size >= width)  			continue;  		int idx = start + j;  		if (idx < 0 || idx >= intensityMap.Length)  			continue;  		intensityMap [idx] += distanceMatrix [i * (size * 2 - 1) + j];  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int i = 0; i < size * 2 - 1; i++) {  	int start = (y - size + 1 + i) * width + x - size;  	for (int j = 0; j < size * 2 - 1; j++) {  		if (j + x - size < 0 || j + x - size >= width)  			continue;  		int idx = start + j;  		if (idx < 0 || idx >= intensityMap.Length)  			continue;  		intensityMap [idx] += distanceMatrix [i * (size * 2 - 1) + j];  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int i = 0; i < size * 2 - 1; i++) {  	int start = (y - size + 1 + i) * width + x - size;  	for (int j = 0; j < size * 2 - 1; j++) {  		if (j + x - size < 0 || j + x - size >= width)  			continue;  		int idx = start + j;  		if (idx < 0 || idx >= intensityMap.Length)  			continue;  		intensityMap [idx] += distanceMatrix [i * (size * 2 - 1) + j];  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int j = 0; j < size * 2 - 1; j++) {  	if (j + x - size < 0 || j + x - size >= width)  		continue;  	int idx = start + j;  	if (idx < 0 || idx >= intensityMap.Length)  		continue;  	intensityMap [idx] += distanceMatrix [i * (size * 2 - 1) + j];  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int j = 0; j < size * 2 - 1; j++) {  	if (j + x - size < 0 || j + x - size >= width)  		continue;  	int idx = start + j;  	if (idx < 0 || idx >= intensityMap.Length)  		continue;  	intensityMap [idx] += distanceMatrix [i * (size * 2 - 1) + j];  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: intensityMap [idx] += distanceMatrix [i * (size * 2 - 1) + j];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: for (int i = 0; i < width; i++) {  	for (int j = 0; j < width; j++) {  		matrix [i * width + j] = (ushort)Math.Max ((size - (Math.Sqrt (Math.Pow (i - size + 1' 2) + Math.Pow (j - size + 1' 2))))' 0);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: for (int i = 0; i < width; i++) {  	for (int j = 0; j < width; j++) {  		matrix [i * width + j] = (ushort)Math.Max ((size - (Math.Sqrt (Math.Pow (i - size + 1' 2) + Math.Pow (j - size + 1' 2))))' 0);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: for (int j = 0; j < width; j++) {  	matrix [i * width + j] = (ushort)Math.Max ((size - (Math.Sqrt (Math.Pow (i - size + 1' 2) + Math.Pow (j - size + 1' 2))))' 0);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: for (int j = 0; j < width; j++) {  	matrix [i * width + j] = (ushort)Math.Max ((size - (Math.Sqrt (Math.Pow (i - size + 1' 2) + Math.Pow (j - size + 1' 2))))' 0);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: matrix [i * width + j] = (ushort)Math.Max ((size - (Math.Sqrt (Math.Pow (i - size + 1' 2) + Math.Pow (j - size + 1' 2))))' 0);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: matrix [i * width + j] = (ushort)Math.Max ((size - (Math.Sqrt (Math.Pow (i - size + 1' 2) + Math.Pow (j - size + 1' 2))))' 0);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,SetPixelSlow,The following statement contains a magic number: start += ((blockNum + 1) * 5);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,SetPixelSlow,The following statement contains a magic number: _buffer [start + 2] = blue;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,SetPixelSlow,The following statement contains a magic number: _buffer [start + 3] = alpha;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,SetPixelAtRowStart,The following statement contains a magic number: _buffer [start + 2] = blue;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,SetPixelAtRowStart,The following statement contains a magic number: _buffer [start + 3] = alpha;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,GetRowStart,The following statement contains a magic number: start += ((blockNum + 1) * 5);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: size = BitConverter.GetBytes ((uint)13);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [3];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [2];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [3];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [2];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [3];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [2];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = 8;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = 6;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: currIndex += 3;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: currIndex += 4;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: size = BitConverter.GetBytes ((uint)4);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [3];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [2];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: size = BitConverter.GetBytes (1 * 100000);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [3];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [2];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: currIndex += 4;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: size = BitConverter.GetBytes (dcSize + 2 + 4 + blockCount * 5);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: size = BitConverter.GetBytes (dcSize + 2 + 4 + blockCount * 5);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: size = BitConverter.GetBytes (dcSize + 2 + 4 + blockCount * 5);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [3];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = size [2];  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: currIndex += 4;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: currIndex += 4;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: currIndex += 4;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = 81;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = 189;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = 159;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,PngEncoder,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\PngEncoder.cs,PrepareBuffer,The following statement contains a magic number: _buffer [currIndex] = 125;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The following statement contains a magic number: if (e.Error != null) {  	this.InitializationFailure = new ArgumentException (Properties.Resources.KmlLayer_DocumentParsingFailed);  } else {  	// Create graphic features from definitions -- this code requires the UI thread  	FeatureDefinition fd = (FeatureDefinition)e.Result;  	// Initialize the layer name with the name info coming from the KML document  	Name = fd.name;  	_hasRootContainer = _isRoot && fd.hasRootContainer;  	// the root container has been collapsed (info needed to generate internal folderIDs)  	if (_visibleLayerIds != null && !IsInitialized) {  		// VisibleLayerIds is set --> layer created from a web map --> check that the layer must stay visible (_hasRootContainer is set only after the file has been parsed)  		if (_hasRootContainer && !_visibleLayerIds.Contains (1))// FolderIds 1 is the top level folder that may not be visible in SL  		 {  			Visible = false;  			_isLoading = false;  			base.Initialize ();  			return;  		}  	}  	// Store the parsed styles to be able to pass them to children  	_context.Styles = fd.styles;  	// Create ground overlays and add to element layer  	if (fd.groundOverlays.Any ()) {  		ElementLayer elementLayer = new ElementLayer {  			ID = Properties.Resources.KmlLayer_GroundOverlaysSublayer  		};  		fd.CreateGroundOverlays (elementLayer' _context.Images' Map);  		ChildLayers.Add (elementLayer);  		if (IsInitialized)  			elementLayer.Initialize ();  		// should be done by the group layer (to remove when Bug#2718 is fixed)  	}  	// Create graphics and add to graphics layer  	if (fd.placemarks.Any ()) {  		KmlGraphicsLayer kmlGraphicsLayer = new KmlGraphicsLayer {  			ID = Properties.Resources.KmlLayer_PlacemarksSublayer'  			ProjectionService = ProjectionService'  			IsHidden = _hideChildren  		};  		fd.CreateGraphics (kmlGraphicsLayer' _context.Images);  		#if !WINDOWS_PHONE  		kmlGraphicsLayer.MapTip = MapTip;  		#endif  		ChildLayers.Add (kmlGraphicsLayer);  		if (IsInitialized)  			kmlGraphicsLayer.Initialize ();  		// should be done by the group layer  (to remove when Bug#2718 is fixed)  		// Setting the Spatial Reference of the KML layer to 4326:  		if (this.SpatialReference == null) {  			this.SpatialReference = new Geometry.SpatialReference (4326);  		}  	}  	// Create a sub KML layer for each container  	foreach (ContainerInfo container in fd.containers) {  		string fullPath = _fullPath == null ? (container.Name ?? string.Empty) : string.Concat (_fullPath' "/"' container.Name);  		// Note : use internal constructor' so properties such as MapTip' ProxyUrl' VisibleLayers.. are reported to the children  		var kmlLayer = new KmlLayer (this) {  			ID = container.Name'  			Name = container.Name'  			_fullPath = fullPath'  			RefreshInterval = TimeSpan.FromSeconds (container.RefreshInterval)'  			VisibleTimeExtent = container.TimeExtent'  			RegionInfo = container.RegionInfo'  			_folderId = container.FolderId'  			_hideChildren = container.HideChildren'  			IsHidden = _hideChildren  		};  		bool isOk = true;  		if (string.IsNullOrEmpty (container.Url)) {  			// Set the visibility of the layer  			// There are 3 ways to define the visibility of a folder or document' by priority order:  			//    - by the internal VisibleLayerIds property (for the layers inside a web map)  			//    - by the public VisibleLayers property  			//    - by the visibility defined in the KML document  			kmlLayer.Visible = _visibleLayerIds != null ? _visibleLayerIds.Contains (kmlLayer._folderId) : IsContainerVisible (fullPath' container.Visible);  			kmlLayer._visibleLayerIds = _visibleLayerIds;  			// Subfolder : Create a context object and initialize a KmlLayer with it  			kmlLayer._context = new KmlLayerContext {  				Element = container.Element'  				// The XElement that the KML layer has to process  				Styles = _context.Styles'  				Images = _context.Images'  				AtomAuthor = container.AtomAuthor'  				AtomHref = container.AtomHref  			};  		} else {  			// NetworkLink : initialize the Url  			Uri containerUri = GetUri (container.Url' GetBaseUri ());  			if (containerUri != null) {  				kmlLayer.Url = containerUri;  				kmlLayer.ViewRefreshMode = container.ViewRefreshMode;  			} else  				isOk = false;  			// bad url' don't create the child layer  			// Set the visibility of the layer  			// For a network link' the internal VisibleLayerIds property is not used.  			kmlLayer.Visible = IsContainerVisible (fullPath' container.Visible);  		}  		if (isOk) {  			ChildLayers.Add (kmlLayer);  			if (IsInitialized)  				kmlLayer.Initialize ();  			// should be done by the group layer --> to remove later (after or with CR2718)  		}  	}  	// Check that the layer refresh interval is compatible with infos coming from NetworkLinkControl  	if (fd.networkLinkControl != null) {  		if (RefreshInterval != TimeSpan.Zero && fd.networkLinkControl.MinRefreshPeriod > 0.0)  			RefreshInterval = TimeSpan.FromSeconds (Math.Max (RefreshInterval.Seconds' fd.networkLinkControl.MinRefreshPeriod));  	}  	// Set resolution range from the Region/Lods info of the parent  	SetResolutionRange ();  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The following statement contains a magic number: if (fd.placemarks.Any ()) {  	KmlGraphicsLayer kmlGraphicsLayer = new KmlGraphicsLayer {  		ID = Properties.Resources.KmlLayer_PlacemarksSublayer'  		ProjectionService = ProjectionService'  		IsHidden = _hideChildren  	};  	fd.CreateGraphics (kmlGraphicsLayer' _context.Images);  	#if !WINDOWS_PHONE  	kmlGraphicsLayer.MapTip = MapTip;  	#endif  	ChildLayers.Add (kmlGraphicsLayer);  	if (IsInitialized)  		kmlGraphicsLayer.Initialize ();  	// should be done by the group layer  (to remove when Bug#2718 is fixed)  	// Setting the Spatial Reference of the KML layer to 4326:  	if (this.SpatialReference == null) {  		this.SpatialReference = new Geometry.SpatialReference (4326);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The following statement contains a magic number: if (this.SpatialReference == null) {  	this.SpatialReference = new Geometry.SpatialReference (4326);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The following statement contains a magic number: this.SpatialReference = new Geometry.SpatialReference (4326);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsStreamCompressed,The following statement contains a magic number: if (reader.BaseStream.Position < reader.BaseStream.Length) {  	int headerSignature = reader.ReadInt32 ();  	if (headerSignature == 67324752)  		//PKZIP  		isCompressed = true;  	// Reset stream back to beginning  	inputStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsStreamCompressed,The following statement contains a magic number: if (headerSignature == 67324752)  	//PKZIP  	isCompressed = true;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: if (!spatialReference.Equals (new SpatialReference (102100)) && !spatialReference.Equals (new SpatialReference (4326)))  	return;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: if (!spatialReference.Equals (new SpatialReference (102100)) && !spatialReference.Equals (new SpatialReference (4326)))  	return;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectAsync,The following statement contains a magic number: if (outSpatialReference == null || outSpatialReference.WKID != 4326 && !outSpatialReference.Equals (MercatorSref)) {  	//This projector doesn't support this out sref -> Return geometry untouched  	ProjectCompleted (this' new Tasks.GraphicsEventArgs (graphics.ToList ()' null));  } else {  	//Perform projection  	var result = graphics.Where (g => g != null).Select (g => new Graphic {  		Geometry = Project (g.Geometry' outSpatialReference)  	});  	ProjectCompleted (this' new Tasks.GraphicsEventArgs (result.ToList ()' null));  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Project,The following statement contains a magic number: if (geometry != null && geometry.SpatialReference != null && !geometry.SpatialReference.Equals (outSpatialReference)) {  	Projection.WebMercator projector = new Projection.WebMercator ();  	if (toMercator && geometry.SpatialReference.WKID == 4326)  		//Data is 4326 and must projected to webmercator  		return projector.FromGeographic (geometry);  	if (!toMercator && MercatorSref.Equals (geometry.SpatialReference))  		//Data is in webmercator and must be projected to 4326  		return projector.ToGeographic (geometry);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Project,The following statement contains a magic number: if (toMercator && geometry.SpatialReference.WKID == 4326)  	//Data is 4326 and must projected to webmercator  	return projector.FromGeographic (geometry);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo {  	Height = 256'  	Width = 256'  	Origin = new MapPoint (-CornerCoordinate' CornerCoordinate) {  		SpatialReference = SpatialReference  	}'  	SpatialReference = SpatialReference'  	Lods = new Lod[19]  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo {  	Height = 256'  	Width = 256'  	Origin = new MapPoint (-CornerCoordinate' CornerCoordinate) {  		SpatialReference = SpatialReference  	}'  	SpatialReference = SpatialReference'  	Lods = new Lod[19]  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo {  	Height = 256'  	Width = 256'  	Origin = new MapPoint (-CornerCoordinate' CornerCoordinate) {  		SpatialReference = SpatialReference  	}'  	SpatialReference = SpatialReference'  	Lods = new Lod[19]  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: for (int i = 0; i < TileInfo.Lods.Length; i++) {  	TileInfo.Lods [i] = new Lod {  		Resolution = resolution  	};  	resolution /= 2;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: resolution /= 2;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int> {  	4326'  	4269'  	4267  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int> {  	4326'  	4269'  	4267  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int> {  	4326'  	4269'  	4267  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: foreach (var element in SRSs) {  	string value = element.Value;  	if (value == "EPSG:4326")  		_useCrsFormat.Remove (4326);  	else if (value == "EPSG:4269")  		_useCrsFormat.Remove (4269);  	else if (value == "EPSG:4267")  		_useCrsFormat.Remove (4267);  	var sref = GetSpatialReference (value);  	if (sref != null && !supportedIDs.Contains (sref.WKID))  		supportedIDs.Add (sref.WKID);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: foreach (var element in SRSs) {  	string value = element.Value;  	if (value == "EPSG:4326")  		_useCrsFormat.Remove (4326);  	else if (value == "EPSG:4269")  		_useCrsFormat.Remove (4269);  	else if (value == "EPSG:4267")  		_useCrsFormat.Remove (4267);  	var sref = GetSpatialReference (value);  	if (sref != null && !supportedIDs.Contains (sref.WKID))  		supportedIDs.Add (sref.WKID);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: foreach (var element in SRSs) {  	string value = element.Value;  	if (value == "EPSG:4326")  		_useCrsFormat.Remove (4326);  	else if (value == "EPSG:4269")  		_useCrsFormat.Remove (4269);  	else if (value == "EPSG:4267")  		_useCrsFormat.Remove (4267);  	var sref = GetSpatialReference (value);  	if (sref != null && !supportedIDs.Contains (sref.WKID))  		supportedIDs.Add (sref.WKID);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (value == "EPSG:4326")  	_useCrsFormat.Remove (4326);  else if (value == "EPSG:4269")  	_useCrsFormat.Remove (4269);  else if (value == "EPSG:4267")  	_useCrsFormat.Remove (4267);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (value == "EPSG:4326")  	_useCrsFormat.Remove (4326);  else if (value == "EPSG:4269")  	_useCrsFormat.Remove (4269);  else if (value == "EPSG:4267")  	_useCrsFormat.Remove (4267);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (value == "EPSG:4326")  	_useCrsFormat.Remove (4326);  else if (value == "EPSG:4269")  	_useCrsFormat.Remove (4269);  else if (value == "EPSG:4267")  	_useCrsFormat.Remove (4267);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat.Remove (4326);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (value == "EPSG:4269")  	_useCrsFormat.Remove (4269);  else if (value == "EPSG:4267")  	_useCrsFormat.Remove (4267);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (value == "EPSG:4269")  	_useCrsFormat.Remove (4269);  else if (value == "EPSG:4267")  	_useCrsFormat.Remove (4267);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat.Remove (4269);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (value == "EPSG:4267")  	_useCrsFormat.Remove (4267);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat.Remove (4267);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (elements.Any ()) {  	FullExtent = GetEnvelope (elements.First ()' lowerThan13);  	if (FullExtent != null)  		SpatialReference = FullExtent.SpatialReference;  } else if (lowerThan13) {  	// Get Extent from former "LatLonBoundingBox" element  	var element = xDoc.Descendants (XName.Get ("LatLonBoundingBox"' ns)).First ();  	SpatialReference = new SpatialReference (4326);  	FullExtent = GetEnvelope (element' true);  	if (FullExtent != null)  		FullExtent.SpatialReference = SpatialReference;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (lowerThan13) {  	// Get Extent from former "LatLonBoundingBox" element  	var element = xDoc.Descendants (XName.Get ("LatLonBoundingBox"' ns)).First ();  	SpatialReference = new SpatialReference (4326);  	FullExtent = GetEnvelope (element' true);  	if (FullExtent != null)  		FullExtent.SpatialReference = SpatialReference;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: SpatialReference = new SpatialReference (4326);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null && (extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)) {  	if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  		if (SupportedSpatialReferenceIDs.Contains (3857))  			extentWKID = 3857;  		else if (SupportedSpatialReferenceIDs.Contains (102100))  			extentWKID = 102100;  		else if (SupportedSpatialReferenceIDs.Contains (102113))  			extentWKID = 102113;  		else if (SupportedSpatialReferenceIDs.Contains (900913))  			extentWKID = 900913;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (!SupportedSpatialReferenceIDs.Contains (extentWKID)) {  	if (SupportedSpatialReferenceIDs.Contains (3857))  		extentWKID = 3857;  	else if (SupportedSpatialReferenceIDs.Contains (102100))  		extentWKID = 102100;  	else if (SupportedSpatialReferenceIDs.Contains (102113))  		extentWKID = 102113;  	else if (SupportedSpatialReferenceIDs.Contains (900913))  		extentWKID = 900913;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (3857))  	extentWKID = 3857;  else if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: extentWKID = 3857;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102100))  	extentWKID = 102100;  else if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: extentWKID = 102100;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (102113))  	extentWKID = 102113;  else if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: extentWKID = 102113;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs.Contains (900913))  	extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: extentWKID = 900913;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (!string.IsNullOrEmpty (crs)) {  	if (crs.Contains ("EPSG:")) {  		int.TryParse (crs.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  	} else if (crs == "CRS:84")  		// WGS84  		wkid = 4326;  	else if (crs == "CRS:83")  		// NAD83  		wkid = 4269;  	else if (crs == "CRS:27")  		// NAD27  		wkid = 4267;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (!string.IsNullOrEmpty (crs)) {  	if (crs.Contains ("EPSG:")) {  		int.TryParse (crs.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  	} else if (crs == "CRS:84")  		// WGS84  		wkid = 4326;  	else if (crs == "CRS:83")  		// NAD83  		wkid = 4269;  	else if (crs == "CRS:27")  		// NAD27  		wkid = 4267;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (!string.IsNullOrEmpty (crs)) {  	if (crs.Contains ("EPSG:")) {  		int.TryParse (crs.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  	} else if (crs == "CRS:84")  		// WGS84  		wkid = 4326;  	else if (crs == "CRS:83")  		// NAD83  		wkid = 4269;  	else if (crs == "CRS:27")  		// NAD27  		wkid = 4267;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs.Contains ("EPSG:")) {  	int.TryParse (crs.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  } else if (crs == "CRS:84")  	// WGS84  	wkid = 4326;  else if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs.Contains ("EPSG:")) {  	int.TryParse (crs.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  } else if (crs == "CRS:84")  	// WGS84  	wkid = 4326;  else if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs.Contains ("EPSG:")) {  	int.TryParse (crs.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  } else if (crs == "CRS:84")  	// WGS84  	wkid = 4326;  else if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs == "CRS:84")  	// WGS84  	wkid = 4326;  else if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs == "CRS:84")  	// WGS84  	wkid = 4326;  else if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs == "CRS:84")  	// WGS84  	wkid = 4326;  else if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: wkid = 4326;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs == "CRS:83")  	// NAD83  	wkid = 4269;  else if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: wkid = 4269;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (crs == "CRS:27")  	// NAD27  	wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: wkid = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: if (wkid == 4326)  	return "CRS:84";  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: if (wkid == 4269)  	return "CRS:83";  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: if (wkid == 4267)  	return "CRS:27";  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The following statement contains a magic number: if (tileMatrixSet.SpatialReference.WKID == 3857) {  	useLatLon = tileMatrixSet.Matrices.First ().TopLeftCorner.Y < -2E7;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The following statement contains a magic number: if (tileMatrixSet.SpatialReference.WKID == 3857) {  	useLatLon = tileMatrixSet.Matrices.First ().TopLeftCorner.Y < -2E7;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The following statement contains a magic number: useLatLon = tileMatrixSet.Matrices.First ().TopLeftCorner.Y < -2E7;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetMapPoint,The following statement contains a magic number: if (points.Count () != 2)  	return null;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null) {  	if (CRS.Contains ("EPSG:")) {  		int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  	} else if (CRS.EndsWith ("CRS84"))  		// WGS84  		WKID = 4326;  	else if (CRS.EndsWith ("CRS83"))  		// NAD83  		WKID = 4269;  	else if (CRS.EndsWith ("CRS27"))  		// NAD27  		WKID = 4267;  	if (WKID == 900913)  		WKID = 3857;  	// change google ID to the normalized one (EPSG:900913 is not supposed to exist)  	if (WKID == 0)  		throw new Exception ("Unrecognized SR : " + CRS);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null) {  	if (CRS.Contains ("EPSG:")) {  		int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  	} else if (CRS.EndsWith ("CRS84"))  		// WGS84  		WKID = 4326;  	else if (CRS.EndsWith ("CRS83"))  		// NAD83  		WKID = 4269;  	else if (CRS.EndsWith ("CRS27"))  		// NAD27  		WKID = 4267;  	if (WKID == 900913)  		WKID = 3857;  	// change google ID to the normalized one (EPSG:900913 is not supposed to exist)  	if (WKID == 0)  		throw new Exception ("Unrecognized SR : " + CRS);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null) {  	if (CRS.Contains ("EPSG:")) {  		int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  	} else if (CRS.EndsWith ("CRS84"))  		// WGS84  		WKID = 4326;  	else if (CRS.EndsWith ("CRS83"))  		// NAD83  		WKID = 4269;  	else if (CRS.EndsWith ("CRS27"))  		// NAD27  		WKID = 4267;  	if (WKID == 900913)  		WKID = 3857;  	// change google ID to the normalized one (EPSG:900913 is not supposed to exist)  	if (WKID == 0)  		throw new Exception ("Unrecognized SR : " + CRS);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null) {  	if (CRS.Contains ("EPSG:")) {  		int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  	} else if (CRS.EndsWith ("CRS84"))  		// WGS84  		WKID = 4326;  	else if (CRS.EndsWith ("CRS83"))  		// NAD83  		WKID = 4269;  	else if (CRS.EndsWith ("CRS27"))  		// NAD27  		WKID = 4267;  	if (WKID == 900913)  		WKID = 3857;  	// change google ID to the normalized one (EPSG:900913 is not supposed to exist)  	if (WKID == 0)  		throw new Exception ("Unrecognized SR : " + CRS);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null) {  	if (CRS.Contains ("EPSG:")) {  		int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  	} else if (CRS.EndsWith ("CRS84"))  		// WGS84  		WKID = 4326;  	else if (CRS.EndsWith ("CRS83"))  		// NAD83  		WKID = 4269;  	else if (CRS.EndsWith ("CRS27"))  		// NAD27  		WKID = 4267;  	if (WKID == 900913)  		WKID = 3857;  	// change google ID to the normalized one (EPSG:900913 is not supposed to exist)  	if (WKID == 0)  		throw new Exception ("Unrecognized SR : " + CRS);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.Contains ("EPSG:")) {  	int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  } else if (CRS.EndsWith ("CRS84"))  	// WGS84  	WKID = 4326;  else if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.Contains ("EPSG:")) {  	int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  } else if (CRS.EndsWith ("CRS84"))  	// WGS84  	WKID = 4326;  else if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.Contains ("EPSG:")) {  	int.TryParse (CRS.Split (':').Last ()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  } else if (CRS.EndsWith ("CRS84"))  	// WGS84  	WKID = 4326;  else if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.EndsWith ("CRS84"))  	// WGS84  	WKID = 4326;  else if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.EndsWith ("CRS84"))  	// WGS84  	WKID = 4326;  else if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.EndsWith ("CRS84"))  	// WGS84  	WKID = 4326;  else if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: WKID = 4326;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.EndsWith ("CRS83"))  	// NAD83  	WKID = 4269;  else if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: WKID = 4269;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS.EndsWith ("CRS27"))  	// NAD27  	WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: WKID = 4267;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (WKID == 900913)  	WKID = 3857;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (WKID == 900913)  	WKID = 3857;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: WKID = 3857;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconHotspotX = 0.5;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconHotspotY = 0.5;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb (255' 255' 255' 255);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The following statement contains a magic number: return new KmlPlaceMarkerSymbol () {  	Height = 40'  	Width = 40'  	Fill = new ImageBrush () {  		ImageSource = bmp  	}  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The following statement contains a magic number: return new KmlPlaceMarkerSymbol () {  	Height = 40'  	Width = 40'  	Fill = new ImageBrush () {  		ImageSource = bmp  	}  };  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: foreach (PlacemarkDescriptor feature in placemarks) {  	KMLStyle style = feature.Symbol.style;  	if (style.ZipFile != null) {  		// Look for the image in the zip file  		if (style.IconImage == null && !String.IsNullOrEmpty (style.IconHref)) {  			style.IconImage = GetIconImage (style.ZipFile' style.IconHref.ToLower ());  		}  		style.ZipFile.Dispose ();  		style.ZipFile = null;  	}  	//Define handlers upfront so we can unhook from them  	#if SILVERLIGHT  	EventHandler<RoutedEventArgs>   	#else  	                EventHandler #endif  	imageCompleted = null;  	#if SILVERLIGHT  	EventHandler<ExceptionRoutedEventArgs>   	#else  	                EventHandler<ExceptionEventArgs> #endif  	imageFailed = null;  	// If the style has an HREF then it is associated with an image  	if (style.IconImage == null && !String.IsNullOrEmpty (style.IconHref)) {  		// If the image is already loaded in the image dictionary' use it  		if (images.ContainsKey (style.IconHref.ToLower ()))  			style.IconImage = images [style.IconHref.ToLower ()];  		else {  			// Get the image using the HREF and store the image in the images dictionary so that if  			// other features reference it' it is cached  			style.IconImage = GetIconImage (style.IconHref);  			if (style.IconImage != null && (style.IconImage as ImageBrush).ImageSource != null) {  				var bi = (style.IconImage as ImageBrush).ImageSource as BitmapImage;  				if (bi != null) {  					imageFailed = (s' e) => {  						var b = s as BitmapImage;  						#if SILVERLIGHT  						if (imageCompleted != null)  							b.ImageOpened -= imageCompleted;  						if (imageFailed != null)  							b.ImageFailed -= imageFailed;  						#else  						                                    if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                     if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  						var key = b.GetValue (BitmapImageKeyProperty) as string;  						layer.Dispatcher.BeginInvoke ((Action)delegate {  							UpdateGraphicsAndRenderer (layer' renderer' key);  						});  					};  					#if SILVERLIGHT  					bi.ImageFailed += imageFailed;  					#else  					                                bi.DownloadFailed += imageFailed; #endif  				}  			}  			images.Add (style.IconHref.ToLower ()' style.IconImage);  		}  	}  	// Create a new graphic from the metadata and construct the symbol using polymorphism  	Graphic g = new Graphic () {  		Geometry = feature.Geometry'  		Symbol = feature.Symbol.CreateSymbol ()'  		TimeExtent = feature.TimeExtent  	};  	g.SetValue (FeaturePlacemarkerDescriptorProperty' feature);  	// Create legend entry  	string label;  	string description;  	GetRendererInfo (feature' style' out label' out description);  	if (!string.IsNullOrEmpty (label) && !renderer.Infos.Any (info => info.Label == label))  		renderer.Infos.Add (new UniqueValueInfo {  			Label = label'  			Description = description'  			Symbol = g.Symbol  		});  	// Adjust and assign picture marker symbol properties  	if (g.Geometry is ESRI.ArcGIS.Client.Geometry.MapPoint && g.Symbol is KmlPlaceMarkerSymbol) {  		try {  			KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;  			// To match sizing of Google Earth' default size of point images is 40x40  			ms.Height = 40;  			ms.Width = 40;  			ms.Fill = style.IconImage;  			ms.IconColor = style.IconColor;  			// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  			ImageBrush ib = ms.Fill;  			BitmapImage bi = ib.ImageSource as BitmapImage;  			#if SILVERLIGHT  			if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  			#else  									if (bi.IsDownloading) #endif  			 {  				imageCompleted = (s' e) => {  					var b = s as BitmapImage;  					#if SILVERLIGHT  					if (imageCompleted != null)  						b.ImageOpened -= imageCompleted;  					if (imageFailed != null)  						b.ImageFailed -= imageFailed;  					#else  					                                if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                 if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  					ComputeIconTranslationValues (style' ms' b);  				};  				#if SILVERLIGHT  				bi.ImageOpened += imageCompleted;  				#else  				                            bi.DownloadCompleted += imageCompleted; #endif  			} else {  				ComputeIconTranslationValues (style' ms' bi);  			}  		} catch {  			g.Symbol = PointSymbolDescriptor.GetDefaultSymbol ();  			ComputeIconTranslationValues (style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  			var info = renderer.Infos.FirstOrDefault (i => i.Label == label);  			if (info != null) {  				info.Symbol = g.Symbol;  			}  		}  	}  	// Copy attributes values from metadata to graphic  	foreach (var attribute in feature.Attributes) {  		g.Attributes.Add (attribute.Key' attribute.Value);  	}  	// If the balloontext property has been assigned a value in the style associated with this  	// graphic feature' then add it to the attributes collection.  	if (!String.IsNullOrEmpty (style.BalloonText)) {  		g.Attributes.Add ("balloonText"' style.BalloonText);  	}  	// Add graphic to graphics layer  	graphics.Add (g);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: foreach (PlacemarkDescriptor feature in placemarks) {  	KMLStyle style = feature.Symbol.style;  	if (style.ZipFile != null) {  		// Look for the image in the zip file  		if (style.IconImage == null && !String.IsNullOrEmpty (style.IconHref)) {  			style.IconImage = GetIconImage (style.ZipFile' style.IconHref.ToLower ());  		}  		style.ZipFile.Dispose ();  		style.ZipFile = null;  	}  	//Define handlers upfront so we can unhook from them  	#if SILVERLIGHT  	EventHandler<RoutedEventArgs>   	#else  	                EventHandler #endif  	imageCompleted = null;  	#if SILVERLIGHT  	EventHandler<ExceptionRoutedEventArgs>   	#else  	                EventHandler<ExceptionEventArgs> #endif  	imageFailed = null;  	// If the style has an HREF then it is associated with an image  	if (style.IconImage == null && !String.IsNullOrEmpty (style.IconHref)) {  		// If the image is already loaded in the image dictionary' use it  		if (images.ContainsKey (style.IconHref.ToLower ()))  			style.IconImage = images [style.IconHref.ToLower ()];  		else {  			// Get the image using the HREF and store the image in the images dictionary so that if  			// other features reference it' it is cached  			style.IconImage = GetIconImage (style.IconHref);  			if (style.IconImage != null && (style.IconImage as ImageBrush).ImageSource != null) {  				var bi = (style.IconImage as ImageBrush).ImageSource as BitmapImage;  				if (bi != null) {  					imageFailed = (s' e) => {  						var b = s as BitmapImage;  						#if SILVERLIGHT  						if (imageCompleted != null)  							b.ImageOpened -= imageCompleted;  						if (imageFailed != null)  							b.ImageFailed -= imageFailed;  						#else  						                                    if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                     if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  						var key = b.GetValue (BitmapImageKeyProperty) as string;  						layer.Dispatcher.BeginInvoke ((Action)delegate {  							UpdateGraphicsAndRenderer (layer' renderer' key);  						});  					};  					#if SILVERLIGHT  					bi.ImageFailed += imageFailed;  					#else  					                                bi.DownloadFailed += imageFailed; #endif  				}  			}  			images.Add (style.IconHref.ToLower ()' style.IconImage);  		}  	}  	// Create a new graphic from the metadata and construct the symbol using polymorphism  	Graphic g = new Graphic () {  		Geometry = feature.Geometry'  		Symbol = feature.Symbol.CreateSymbol ()'  		TimeExtent = feature.TimeExtent  	};  	g.SetValue (FeaturePlacemarkerDescriptorProperty' feature);  	// Create legend entry  	string label;  	string description;  	GetRendererInfo (feature' style' out label' out description);  	if (!string.IsNullOrEmpty (label) && !renderer.Infos.Any (info => info.Label == label))  		renderer.Infos.Add (new UniqueValueInfo {  			Label = label'  			Description = description'  			Symbol = g.Symbol  		});  	// Adjust and assign picture marker symbol properties  	if (g.Geometry is ESRI.ArcGIS.Client.Geometry.MapPoint && g.Symbol is KmlPlaceMarkerSymbol) {  		try {  			KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;  			// To match sizing of Google Earth' default size of point images is 40x40  			ms.Height = 40;  			ms.Width = 40;  			ms.Fill = style.IconImage;  			ms.IconColor = style.IconColor;  			// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  			ImageBrush ib = ms.Fill;  			BitmapImage bi = ib.ImageSource as BitmapImage;  			#if SILVERLIGHT  			if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  			#else  									if (bi.IsDownloading) #endif  			 {  				imageCompleted = (s' e) => {  					var b = s as BitmapImage;  					#if SILVERLIGHT  					if (imageCompleted != null)  						b.ImageOpened -= imageCompleted;  					if (imageFailed != null)  						b.ImageFailed -= imageFailed;  					#else  					                                if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                 if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  					ComputeIconTranslationValues (style' ms' b);  				};  				#if SILVERLIGHT  				bi.ImageOpened += imageCompleted;  				#else  				                            bi.DownloadCompleted += imageCompleted; #endif  			} else {  				ComputeIconTranslationValues (style' ms' bi);  			}  		} catch {  			g.Symbol = PointSymbolDescriptor.GetDefaultSymbol ();  			ComputeIconTranslationValues (style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  			var info = renderer.Infos.FirstOrDefault (i => i.Label == label);  			if (info != null) {  				info.Symbol = g.Symbol;  			}  		}  	}  	// Copy attributes values from metadata to graphic  	foreach (var attribute in feature.Attributes) {  		g.Attributes.Add (attribute.Key' attribute.Value);  	}  	// If the balloontext property has been assigned a value in the style associated with this  	// graphic feature' then add it to the attributes collection.  	if (!String.IsNullOrEmpty (style.BalloonText)) {  		g.Attributes.Add ("balloonText"' style.BalloonText);  	}  	// Add graphic to graphics layer  	graphics.Add (g);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: if (g.Geometry is ESRI.ArcGIS.Client.Geometry.MapPoint && g.Symbol is KmlPlaceMarkerSymbol) {  	try {  		KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;  		// To match sizing of Google Earth' default size of point images is 40x40  		ms.Height = 40;  		ms.Width = 40;  		ms.Fill = style.IconImage;  		ms.IconColor = style.IconColor;  		// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  		ImageBrush ib = ms.Fill;  		BitmapImage bi = ib.ImageSource as BitmapImage;  		#if SILVERLIGHT  		if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  		#else  								if (bi.IsDownloading) #endif  		 {  			imageCompleted = (s' e) => {  				var b = s as BitmapImage;  				#if SILVERLIGHT  				if (imageCompleted != null)  					b.ImageOpened -= imageCompleted;  				if (imageFailed != null)  					b.ImageFailed -= imageFailed;  				#else  				                                if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                 if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  				ComputeIconTranslationValues (style' ms' b);  			};  			#if SILVERLIGHT  			bi.ImageOpened += imageCompleted;  			#else  			                            bi.DownloadCompleted += imageCompleted; #endif  		} else {  			ComputeIconTranslationValues (style' ms' bi);  		}  	} catch {  		g.Symbol = PointSymbolDescriptor.GetDefaultSymbol ();  		ComputeIconTranslationValues (style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  		var info = renderer.Infos.FirstOrDefault (i => i.Label == label);  		if (info != null) {  			info.Symbol = g.Symbol;  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: if (g.Geometry is ESRI.ArcGIS.Client.Geometry.MapPoint && g.Symbol is KmlPlaceMarkerSymbol) {  	try {  		KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;  		// To match sizing of Google Earth' default size of point images is 40x40  		ms.Height = 40;  		ms.Width = 40;  		ms.Fill = style.IconImage;  		ms.IconColor = style.IconColor;  		// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  		ImageBrush ib = ms.Fill;  		BitmapImage bi = ib.ImageSource as BitmapImage;  		#if SILVERLIGHT  		if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  		#else  								if (bi.IsDownloading) #endif  		 {  			imageCompleted = (s' e) => {  				var b = s as BitmapImage;  				#if SILVERLIGHT  				if (imageCompleted != null)  					b.ImageOpened -= imageCompleted;  				if (imageFailed != null)  					b.ImageFailed -= imageFailed;  				#else  				                                if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                 if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  				ComputeIconTranslationValues (style' ms' b);  			};  			#if SILVERLIGHT  			bi.ImageOpened += imageCompleted;  			#else  			                            bi.DownloadCompleted += imageCompleted; #endif  		} else {  			ComputeIconTranslationValues (style' ms' bi);  		}  	} catch {  		g.Symbol = PointSymbolDescriptor.GetDefaultSymbol ();  		ComputeIconTranslationValues (style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  		var info = renderer.Infos.FirstOrDefault (i => i.Label == label);  		if (info != null) {  			info.Symbol = g.Symbol;  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: try {  	KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;  	// To match sizing of Google Earth' default size of point images is 40x40  	ms.Height = 40;  	ms.Width = 40;  	ms.Fill = style.IconImage;  	ms.IconColor = style.IconColor;  	// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  	ImageBrush ib = ms.Fill;  	BitmapImage bi = ib.ImageSource as BitmapImage;  	#if SILVERLIGHT  	if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  	#else  							if (bi.IsDownloading) #endif  	 {  		imageCompleted = (s' e) => {  			var b = s as BitmapImage;  			#if SILVERLIGHT  			if (imageCompleted != null)  				b.ImageOpened -= imageCompleted;  			if (imageFailed != null)  				b.ImageFailed -= imageFailed;  			#else  			                                if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                 if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  			ComputeIconTranslationValues (style' ms' b);  		};  		#if SILVERLIGHT  		bi.ImageOpened += imageCompleted;  		#else  		                            bi.DownloadCompleted += imageCompleted; #endif  	} else {  		ComputeIconTranslationValues (style' ms' bi);  	}  } catch {  	g.Symbol = PointSymbolDescriptor.GetDefaultSymbol ();  	ComputeIconTranslationValues (style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  	var info = renderer.Infos.FirstOrDefault (i => i.Label == label);  	if (info != null) {  		info.Symbol = g.Symbol;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: try {  	KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;  	// To match sizing of Google Earth' default size of point images is 40x40  	ms.Height = 40;  	ms.Width = 40;  	ms.Fill = style.IconImage;  	ms.IconColor = style.IconColor;  	// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  	ImageBrush ib = ms.Fill;  	BitmapImage bi = ib.ImageSource as BitmapImage;  	#if SILVERLIGHT  	if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  	#else  							if (bi.IsDownloading) #endif  	 {  		imageCompleted = (s' e) => {  			var b = s as BitmapImage;  			#if SILVERLIGHT  			if (imageCompleted != null)  				b.ImageOpened -= imageCompleted;  			if (imageFailed != null)  				b.ImageFailed -= imageFailed;  			#else  			                                if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                 if (imageFailed != null) b.DownloadFailed -= imageFailed; #endif  			ComputeIconTranslationValues (style' ms' b);  		};  		#if SILVERLIGHT  		bi.ImageOpened += imageCompleted;  		#else  		                            bi.DownloadCompleted += imageCompleted; #endif  	} else {  		ComputeIconTranslationValues (style' ms' bi);  	}  } catch {  	g.Symbol = PointSymbolDescriptor.GetDefaultSymbol ();  	ComputeIconTranslationValues (style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  	var info = renderer.Infos.FirstOrDefault (i => i.Label == label);  	if (info != null) {  		info.Symbol = g.Symbol;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: ms.Height = 40;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: ms.Width = 40;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: foreach (GroundOverlayDescriptor feature in groundOverlays) {  	UIElement uiElement;  	if (!String.IsNullOrEmpty (feature.IconHref)) {  		ImageSource imageSource;  		// If the image is provided in kmz content' use it  		if (images.ContainsKey (feature.IconHref.ToLower ())) {  			imageSource = images [feature.IconHref.ToLower ()].ImageSource;  		} else {  			// Get the image using the HREF  			imageSource = new BitmapImage (KmlLayer.GetUri (feature.IconHref' _baseUri));  		}  		// If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon  		double opacity;  		bool needBlendEffect;  		if (feature.Color.R == byte.MaxValue && feature.Color.G == byte.MaxValue && feature.Color.B == byte.MaxValue) {  			opacity = (double)feature.Color.A / byte.MaxValue;  			needBlendEffect = false;  		} else {  			opacity = 1.0;  			needBlendEffect = true;  		}  		uiElement = new Image {  			Source = imageSource'  			Stretch = Stretch.Fill'  			Opacity = opacity  		};  		if (needBlendEffect) {  			uiElement.Effect = new MultiplyBlendEffect {  				BlendColor = feature.Color  			};  		}  	} else {  		// Just add a rectangle  		uiElement = new Rectangle {  			Fill = new SolidColorBrush (feature.Color)  		};  	}  	// Set the time extent  	if (feature.TimeExtent != null)  		ElementLayer.SetTimeExtent (uiElement' feature.TimeExtent);  	// Set the rotation  	if (feature.Rotation != 0.0) {  		uiElement.RenderTransformOrigin = new Point (0.5' 0.5);  		uiElement.RenderTransform = new RotateTransform {  			Angle = -feature.Rotation  		};  		// KML rotations are specified in a counterclockwise direction  	}  	// Set the envelope  	var elementLayerEnvelopeProperty = ElementLayer.EnvelopeProperty;  	var envelope = feature.Envelope;  	// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale)  	if (map != null && map.SpatialReference != null && IsWebMercator (map.SpatialReference) && envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326)// should always be the case  	 {  		envelope = (new Projection.WebMercator ()).FromGeographic (envelope) as Envelope;  	}  	uiElement.SetValue (elementLayerEnvelopeProperty' envelope);  	// Add element to element layer  	layer.Children.Add (uiElement);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: foreach (GroundOverlayDescriptor feature in groundOverlays) {  	UIElement uiElement;  	if (!String.IsNullOrEmpty (feature.IconHref)) {  		ImageSource imageSource;  		// If the image is provided in kmz content' use it  		if (images.ContainsKey (feature.IconHref.ToLower ())) {  			imageSource = images [feature.IconHref.ToLower ()].ImageSource;  		} else {  			// Get the image using the HREF  			imageSource = new BitmapImage (KmlLayer.GetUri (feature.IconHref' _baseUri));  		}  		// If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon  		double opacity;  		bool needBlendEffect;  		if (feature.Color.R == byte.MaxValue && feature.Color.G == byte.MaxValue && feature.Color.B == byte.MaxValue) {  			opacity = (double)feature.Color.A / byte.MaxValue;  			needBlendEffect = false;  		} else {  			opacity = 1.0;  			needBlendEffect = true;  		}  		uiElement = new Image {  			Source = imageSource'  			Stretch = Stretch.Fill'  			Opacity = opacity  		};  		if (needBlendEffect) {  			uiElement.Effect = new MultiplyBlendEffect {  				BlendColor = feature.Color  			};  		}  	} else {  		// Just add a rectangle  		uiElement = new Rectangle {  			Fill = new SolidColorBrush (feature.Color)  		};  	}  	// Set the time extent  	if (feature.TimeExtent != null)  		ElementLayer.SetTimeExtent (uiElement' feature.TimeExtent);  	// Set the rotation  	if (feature.Rotation != 0.0) {  		uiElement.RenderTransformOrigin = new Point (0.5' 0.5);  		uiElement.RenderTransform = new RotateTransform {  			Angle = -feature.Rotation  		};  		// KML rotations are specified in a counterclockwise direction  	}  	// Set the envelope  	var elementLayerEnvelopeProperty = ElementLayer.EnvelopeProperty;  	var envelope = feature.Envelope;  	// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale)  	if (map != null && map.SpatialReference != null && IsWebMercator (map.SpatialReference) && envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326)// should always be the case  	 {  		envelope = (new Projection.WebMercator ()).FromGeographic (envelope) as Envelope;  	}  	uiElement.SetValue (elementLayerEnvelopeProperty' envelope);  	// Add element to element layer  	layer.Children.Add (uiElement);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: foreach (GroundOverlayDescriptor feature in groundOverlays) {  	UIElement uiElement;  	if (!String.IsNullOrEmpty (feature.IconHref)) {  		ImageSource imageSource;  		// If the image is provided in kmz content' use it  		if (images.ContainsKey (feature.IconHref.ToLower ())) {  			imageSource = images [feature.IconHref.ToLower ()].ImageSource;  		} else {  			// Get the image using the HREF  			imageSource = new BitmapImage (KmlLayer.GetUri (feature.IconHref' _baseUri));  		}  		// If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon  		double opacity;  		bool needBlendEffect;  		if (feature.Color.R == byte.MaxValue && feature.Color.G == byte.MaxValue && feature.Color.B == byte.MaxValue) {  			opacity = (double)feature.Color.A / byte.MaxValue;  			needBlendEffect = false;  		} else {  			opacity = 1.0;  			needBlendEffect = true;  		}  		uiElement = new Image {  			Source = imageSource'  			Stretch = Stretch.Fill'  			Opacity = opacity  		};  		if (needBlendEffect) {  			uiElement.Effect = new MultiplyBlendEffect {  				BlendColor = feature.Color  			};  		}  	} else {  		// Just add a rectangle  		uiElement = new Rectangle {  			Fill = new SolidColorBrush (feature.Color)  		};  	}  	// Set the time extent  	if (feature.TimeExtent != null)  		ElementLayer.SetTimeExtent (uiElement' feature.TimeExtent);  	// Set the rotation  	if (feature.Rotation != 0.0) {  		uiElement.RenderTransformOrigin = new Point (0.5' 0.5);  		uiElement.RenderTransform = new RotateTransform {  			Angle = -feature.Rotation  		};  		// KML rotations are specified in a counterclockwise direction  	}  	// Set the envelope  	var elementLayerEnvelopeProperty = ElementLayer.EnvelopeProperty;  	var envelope = feature.Envelope;  	// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale)  	if (map != null && map.SpatialReference != null && IsWebMercator (map.SpatialReference) && envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326)// should always be the case  	 {  		envelope = (new Projection.WebMercator ()).FromGeographic (envelope) as Envelope;  	}  	uiElement.SetValue (elementLayerEnvelopeProperty' envelope);  	// Add element to element layer  	layer.Children.Add (uiElement);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: if (feature.Rotation != 0.0) {  	uiElement.RenderTransformOrigin = new Point (0.5' 0.5);  	uiElement.RenderTransform = new RotateTransform {  		Angle = -feature.Rotation  	};  	// KML rotations are specified in a counterclockwise direction  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: if (feature.Rotation != 0.0) {  	uiElement.RenderTransformOrigin = new Point (0.5' 0.5);  	uiElement.RenderTransform = new RotateTransform {  		Angle = -feature.Rotation  	};  	// KML rotations are specified in a counterclockwise direction  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: uiElement.RenderTransformOrigin = new Point (0.5' 0.5);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: uiElement.RenderTransformOrigin = new Point (0.5' 0.5);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: if (map != null && map.SpatialReference != null && IsWebMercator (map.SpatialReference) && envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326)// should always be the case   {  	envelope = (new Projection.WebMercator ()).FromGeographic (envelope) as Envelope;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following statement contains a magic number: ms.Height = 40;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following statement contains a magic number: ms.Width = 40;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: foreach (XElement container in xElement.Elements ().Where (element => element.Name.LocalName == "Folder" || element.Name.LocalName == "Document" || element.Name.LocalName == "NetworkLink")) {  	ContainerInfo containerInfo = new ContainerInfo {  		Element = container'  		Url = null'  		// only for networklink  		Visible = true'  		AtomAuthor = context.AtomAuthor'  		// Use parent value by default  		AtomHref = context.AtomHref  	// Use parent value by default  	};  	XNamespace kmlContainerNS = container.Name.Namespace;  	if (container.Name.LocalName == "NetworkLink") {  		string hrefValue = "";  		string composite = "";  		string layerids = "";  		// Link takes precedence over Url from KML version 2.1 and later:  		XElement url = container.Element (kmlContainerNS + "Link") ?? container.Element (kmlContainerNS + "Url");  		if (url != null) {  			XElement href = url.Element (kmlContainerNS + "href");  			if (href != null) {  				hrefValue = href.Value;  			}  			// This next section is to parse special elements that only occur when an ArcGIS Server KML   			// is to be processed.  			XElement view = url.Element (kmlContainerNS + "viewFormat");  			if (view != null) {  				int begIdx = view.Value.IndexOf ("Composite");  				if (begIdx != -1) {  					int endIdx = view.Value.IndexOf ("&"' begIdx);  					if (endIdx != -1)  						composite = view.Value.Substring (begIdx' endIdx - begIdx);  				}  				begIdx = view.Value.IndexOf ("LayerIDs");  				if (begIdx != -1) {  					int endIdx = view.Value.IndexOf ("&"' begIdx);  					if (endIdx != -1)  						layerids = view.Value.Substring (begIdx' endIdx - begIdx);  				}  			}  			// If network link URL is successfully extracted' then add to container list  			if (!String.IsNullOrEmpty (hrefValue)) {  				// extract refreshInterval  				XElement refreshMode = url.Element (kmlContainerNS + "refreshMode");  				if (refreshMode != null && refreshMode.Value == "onInterval") {  					XElement refreshInterval = url.Element (kmlContainerNS + "refreshInterval");  					if (refreshInterval != null)  						containerInfo.RefreshInterval = GetDoubleValue (refreshInterval);  					else  						containerInfo.RefreshInterval = 4;  					// default value   				}  				XElement viewRefreshMode = url.Element (kmlContainerNS + "viewRefreshMode");  				if (viewRefreshMode != null) {  					ViewRefreshMode viewRefreshModeEnum;  					try// Enum.TryParse doesn't exist in 3.5  					 {  						viewRefreshModeEnum = (ViewRefreshMode)Enum.Parse (typeof(ViewRefreshMode)' viewRefreshMode.Value' true);  						containerInfo.ViewRefreshMode = viewRefreshModeEnum;  					} catch {  					}  				}  				// the following values are for processing specialized ArcGIS Server KML links  				// generated from REST endpoints.  				if (!String.IsNullOrEmpty (composite))  					hrefValue += "?" + composite;  				if (!String.IsNullOrEmpty (layerids)) {  					if (!String.IsNullOrEmpty (hrefValue))  						hrefValue += "&" + layerids;  					else  						hrefValue += "?" + layerids;  				}  				containerInfo.Url = hrefValue;  			} else  				containerInfo = null;  			// Link without href. Should not happen. Skip it.  		} else  			containerInfo = null;  		// NetworkLink without Link/Url. Should not happen. Skip it.  	} else {  		// Folder or Document XElement   		XElement linkElement = container.Elements (atomNS + "link").Where (element => element.HasAttributes).FirstOrDefault ();  		if (linkElement != null) {  			// Overwrite global default value only upon successful extraction from element  			string tempHref = GetAtomHref (linkElement);  			if (!String.IsNullOrEmpty (tempHref))  				containerInfo.AtomHref = new Uri (tempHref);  		}  		XElement authorElement = container.Element (atomNS + "author");  		if (authorElement != null) {  			// Overwrite global default value only upon successful extraction from element  			string tempAuthor = GetAtomAuthor (authorElement);  			if (!String.IsNullOrEmpty (tempAuthor))  				containerInfo.AtomAuthor = tempAuthor;  		}  	}  	if (containerInfo != null) {  		XElement visibilityElement = container.Element (kmlContainerNS + "visibility");  		if (visibilityElement != null) {  			containerInfo.Visible = GetBooleanValue (visibilityElement);  		}  		XElement nameElement = container.Element (kmlContainerNS + "name");  		if (nameElement != null) {  			containerInfo.Name = nameElement.Value.Trim ();  		}  		containerInfo.RegionInfo = ExtractRegion (container);  		// Look for a listItemType element that can be set to 'checkHideChildren' to prevent cildren to be seen in the legend  		XElement listItemTypeElement = container.XPathSelectElement ("Style/ListStyle/listItemType"' kmlContainerNS);  		if (listItemTypeElement != null) {  			if (listItemTypeElement.Value == "checkHideChildren")  				containerInfo.HideChildren = true;  		}  		if (container.HasAttributes && container.Attribute (KmlLayer.FolderIdAttributeName) != null) {  			containerInfo.FolderId = (int)container.Attribute (KmlLayer.FolderIdAttributeName);  		}  		containerInfo.TimeExtent = ExtractTimeExtent (container);  		featureDefs.AddContainer (containerInfo);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: if (container.Name.LocalName == "NetworkLink") {  	string hrefValue = "";  	string composite = "";  	string layerids = "";  	// Link takes precedence over Url from KML version 2.1 and later:  	XElement url = container.Element (kmlContainerNS + "Link") ?? container.Element (kmlContainerNS + "Url");  	if (url != null) {  		XElement href = url.Element (kmlContainerNS + "href");  		if (href != null) {  			hrefValue = href.Value;  		}  		// This next section is to parse special elements that only occur when an ArcGIS Server KML   		// is to be processed.  		XElement view = url.Element (kmlContainerNS + "viewFormat");  		if (view != null) {  			int begIdx = view.Value.IndexOf ("Composite");  			if (begIdx != -1) {  				int endIdx = view.Value.IndexOf ("&"' begIdx);  				if (endIdx != -1)  					composite = view.Value.Substring (begIdx' endIdx - begIdx);  			}  			begIdx = view.Value.IndexOf ("LayerIDs");  			if (begIdx != -1) {  				int endIdx = view.Value.IndexOf ("&"' begIdx);  				if (endIdx != -1)  					layerids = view.Value.Substring (begIdx' endIdx - begIdx);  			}  		}  		// If network link URL is successfully extracted' then add to container list  		if (!String.IsNullOrEmpty (hrefValue)) {  			// extract refreshInterval  			XElement refreshMode = url.Element (kmlContainerNS + "refreshMode");  			if (refreshMode != null && refreshMode.Value == "onInterval") {  				XElement refreshInterval = url.Element (kmlContainerNS + "refreshInterval");  				if (refreshInterval != null)  					containerInfo.RefreshInterval = GetDoubleValue (refreshInterval);  				else  					containerInfo.RefreshInterval = 4;  				// default value   			}  			XElement viewRefreshMode = url.Element (kmlContainerNS + "viewRefreshMode");  			if (viewRefreshMode != null) {  				ViewRefreshMode viewRefreshModeEnum;  				try// Enum.TryParse doesn't exist in 3.5  				 {  					viewRefreshModeEnum = (ViewRefreshMode)Enum.Parse (typeof(ViewRefreshMode)' viewRefreshMode.Value' true);  					containerInfo.ViewRefreshMode = viewRefreshModeEnum;  				} catch {  				}  			}  			// the following values are for processing specialized ArcGIS Server KML links  			// generated from REST endpoints.  			if (!String.IsNullOrEmpty (composite))  				hrefValue += "?" + composite;  			if (!String.IsNullOrEmpty (layerids)) {  				if (!String.IsNullOrEmpty (hrefValue))  					hrefValue += "&" + layerids;  				else  					hrefValue += "?" + layerids;  			}  			containerInfo.Url = hrefValue;  		} else  			containerInfo = null;  		// Link without href. Should not happen. Skip it.  	} else  		containerInfo = null;  	// NetworkLink without Link/Url. Should not happen. Skip it.  } else {  	// Folder or Document XElement   	XElement linkElement = container.Elements (atomNS + "link").Where (element => element.HasAttributes).FirstOrDefault ();  	if (linkElement != null) {  		// Overwrite global default value only upon successful extraction from element  		string tempHref = GetAtomHref (linkElement);  		if (!String.IsNullOrEmpty (tempHref))  			containerInfo.AtomHref = new Uri (tempHref);  	}  	XElement authorElement = container.Element (atomNS + "author");  	if (authorElement != null) {  		// Overwrite global default value only upon successful extraction from element  		string tempAuthor = GetAtomAuthor (authorElement);  		if (!String.IsNullOrEmpty (tempAuthor))  			containerInfo.AtomAuthor = tempAuthor;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: if (url != null) {  	XElement href = url.Element (kmlContainerNS + "href");  	if (href != null) {  		hrefValue = href.Value;  	}  	// This next section is to parse special elements that only occur when an ArcGIS Server KML   	// is to be processed.  	XElement view = url.Element (kmlContainerNS + "viewFormat");  	if (view != null) {  		int begIdx = view.Value.IndexOf ("Composite");  		if (begIdx != -1) {  			int endIdx = view.Value.IndexOf ("&"' begIdx);  			if (endIdx != -1)  				composite = view.Value.Substring (begIdx' endIdx - begIdx);  		}  		begIdx = view.Value.IndexOf ("LayerIDs");  		if (begIdx != -1) {  			int endIdx = view.Value.IndexOf ("&"' begIdx);  			if (endIdx != -1)  				layerids = view.Value.Substring (begIdx' endIdx - begIdx);  		}  	}  	// If network link URL is successfully extracted' then add to container list  	if (!String.IsNullOrEmpty (hrefValue)) {  		// extract refreshInterval  		XElement refreshMode = url.Element (kmlContainerNS + "refreshMode");  		if (refreshMode != null && refreshMode.Value == "onInterval") {  			XElement refreshInterval = url.Element (kmlContainerNS + "refreshInterval");  			if (refreshInterval != null)  				containerInfo.RefreshInterval = GetDoubleValue (refreshInterval);  			else  				containerInfo.RefreshInterval = 4;  			// default value   		}  		XElement viewRefreshMode = url.Element (kmlContainerNS + "viewRefreshMode");  		if (viewRefreshMode != null) {  			ViewRefreshMode viewRefreshModeEnum;  			try// Enum.TryParse doesn't exist in 3.5  			 {  				viewRefreshModeEnum = (ViewRefreshMode)Enum.Parse (typeof(ViewRefreshMode)' viewRefreshMode.Value' true);  				containerInfo.ViewRefreshMode = viewRefreshModeEnum;  			} catch {  			}  		}  		// the following values are for processing specialized ArcGIS Server KML links  		// generated from REST endpoints.  		if (!String.IsNullOrEmpty (composite))  			hrefValue += "?" + composite;  		if (!String.IsNullOrEmpty (layerids)) {  			if (!String.IsNullOrEmpty (hrefValue))  				hrefValue += "&" + layerids;  			else  				hrefValue += "?" + layerids;  		}  		containerInfo.Url = hrefValue;  	} else  		containerInfo = null;  	// Link without href. Should not happen. Skip it.  } else  	containerInfo = null;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: if (!String.IsNullOrEmpty (hrefValue)) {  	// extract refreshInterval  	XElement refreshMode = url.Element (kmlContainerNS + "refreshMode");  	if (refreshMode != null && refreshMode.Value == "onInterval") {  		XElement refreshInterval = url.Element (kmlContainerNS + "refreshInterval");  		if (refreshInterval != null)  			containerInfo.RefreshInterval = GetDoubleValue (refreshInterval);  		else  			containerInfo.RefreshInterval = 4;  		// default value   	}  	XElement viewRefreshMode = url.Element (kmlContainerNS + "viewRefreshMode");  	if (viewRefreshMode != null) {  		ViewRefreshMode viewRefreshModeEnum;  		try// Enum.TryParse doesn't exist in 3.5  		 {  			viewRefreshModeEnum = (ViewRefreshMode)Enum.Parse (typeof(ViewRefreshMode)' viewRefreshMode.Value' true);  			containerInfo.ViewRefreshMode = viewRefreshModeEnum;  		} catch {  		}  	}  	// the following values are for processing specialized ArcGIS Server KML links  	// generated from REST endpoints.  	if (!String.IsNullOrEmpty (composite))  		hrefValue += "?" + composite;  	if (!String.IsNullOrEmpty (layerids)) {  		if (!String.IsNullOrEmpty (hrefValue))  			hrefValue += "&" + layerids;  		else  			hrefValue += "?" + layerids;  	}  	containerInfo.Url = hrefValue;  } else  	containerInfo = null;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: if (refreshMode != null && refreshMode.Value == "onInterval") {  	XElement refreshInterval = url.Element (kmlContainerNS + "refreshInterval");  	if (refreshInterval != null)  		containerInfo.RefreshInterval = GetDoubleValue (refreshInterval);  	else  		containerInfo.RefreshInterval = 4;  	// default value   }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: if (refreshInterval != null)  	containerInfo.RefreshInterval = GetDoubleValue (refreshInterval);  else  	containerInfo.RefreshInterval = 4;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: containerInfo.RefreshInterval = 4;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,DownloadStyleAsync,The following statement contains a magic number: if (styleUrl.StartsWith ("http://") || styleUrl.StartsWith ("https://")) {  	// Split style into file URL and style id  	string[] tokens = styleUrl.Split ('#');  	if (tokens.Length == 2) {  		// Store current state so event handler can resume  		DownloadStyleState state = new DownloadStyleState ('#' + tokens [1]' credentials' callback  		#if !SILVERLIGHT  		' clientCertificate #endif  		);  		WebClient webClient = Utilities.CreateWebClient ();  		if (credentials != null)  			webClient.Credentials = credentials;  		#if !SILVERLIGHT  							if (clientCertificate != null) 						(webClient as CompressResponseWebClient).ClientCertificate = clientCertificate; #endif  		webClient.OpenReadCompleted += StyleDownloaded;  		webClient.OpenReadAsync (Utilities.PrefixProxy (ProxyUrl' tokens [0])' state);  		_waitHelper.AddOne ();  		return;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,DownloadStyleAsync,The following statement contains a magic number: if (tokens.Length == 2) {  	// Store current state so event handler can resume  	DownloadStyleState state = new DownloadStyleState ('#' + tokens [1]' credentials' callback  	#if !SILVERLIGHT  	' clientCertificate #endif  	);  	WebClient webClient = Utilities.CreateWebClient ();  	if (credentials != null)  		webClient.Credentials = credentials;  	#if !SILVERLIGHT  						if (clientCertificate != null) 						(webClient as CompressResponseWebClient).ClientCertificate = clientCertificate; #endif  	webClient.OpenReadCompleted += StyleDownloaded;  	webClient.OpenReadAsync (Utilities.PrefixProxy (ProxyUrl' tokens [0])' state);  	_waitHelper.AddOne ();  	return;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following statement contains a magic number: if (feature.Name.LocalName == "Placemark") {  	// kmlStyle is null when the placemark doesn't reference any shared style (or a shared style that we are not able to download)  	// in this case' use a default style  	if (kmlStyle == null)  		kmlStyle = new KMLStyle ();  	// Determine what kind of feature is present in the placemark. If an input geometry is present' then the  	// style has already been determined and this method is being called recursively for each child element  	// of a multi-geometry placemarker.  	XElement geomElement = null;  	if (geometry != null) {  		geomElement = geometry;  	} else {  		geomElement = GetFeatureType (feature);  		// Override any settings from the inline style "Style" node  		XElement styleElement = feature.Element (kmlNS + "Style");  		if (styleElement != null) {  			GetStyle (styleElement' kmlStyle);  		}  	}  	PlacemarkDescriptor fd = null;  	if (geomElement != null && geomElement.Name != null) {  		switch (geomElement.Name.LocalName) {  		case "Point":  			fd = ExtractPoint (kmlStyle' geomElement);  			break;  		case "LineString":  			fd = ExtractPolyLine (kmlStyle' geomElement);  			break;  		case "LinearRing":  			fd = ExtractLinearRing (kmlStyle' geomElement);  			break;  		case "Polygon":  			fd = ExtractPolygon (kmlStyle' geomElement);  			break;  		case "MultiGeometry":  			foreach (XElement item in geomElement.Elements ()) {  				// Use recursion to walk the hierarchy of embedded definitions  				CreateFeatureDefinition (kmlStyle' feature' item' context);  			}  			break;  		case "LatLonBox":  			ExtractFeatureStyleInfo (kmlStyle' feature);  			fd = ExtractLatLonBox (kmlStyle' geomElement);  			break;  		}  		// If a feature definition was created' then assign timeextent' attributes and add to collection  		if (fd != null) {  			fd.TimeExtent = ExtractTimeExtent (feature' fd.Attributes);  			if (fd.Geometry != null)  				fd.Geometry.SpatialReference = new SpatialReference (4326);  			XElement descElement = feature.Element (kmlNS + "description");  			if (descElement != null)  				fd.Attributes.Add ("description"' descElement.Value);  			XElement nameElement = feature.Element (kmlNS + "name");  			if (nameElement != null)  				fd.Attributes.Add ("name"' nameElement.Value);  			if (atomNS != null) {  				// Initialize to parent value  				Uri atomHrefValue = context.AtomHref;  				// If node exists' has attributes' and can be successfully extracted' then extract  				// this value.  				XElement atomHrefElement = feature.Element (atomNS + "link");  				if (atomHrefElement != null && atomHrefElement.HasAttributes) {  					string tempHref = GetAtomHref (atomHrefElement);  					if (!String.IsNullOrEmpty (tempHref))  						atomHrefValue = new Uri (tempHref);  				}  				// If a value was extracted or assigned from a parent' then add to attributes  				if (atomHrefValue != null)  					fd.Attributes.Add ("atomHref"' atomHrefValue);  				// AtomAuthor : Initialize to parent value  				string atomValue = context.AtomAuthor;  				// If node exists' has attributes' and can be successfully extracted' then extract  				// this value.  				XElement atomAuthorElement = feature.Element (atomNS + "author");  				if (atomAuthorElement != null) {  					string tempAuthor = GetAtomAuthor (atomAuthorElement);  					if (!String.IsNullOrEmpty (tempAuthor))  						atomValue = tempAuthor;  				}  				// If a value was extracted or assigned from a parent' then add to attributes  				if (!String.IsNullOrEmpty (atomValue))  					fd.Attributes.Add ("atomAuthor"' atomValue);  			}  			// Extract extended information  			XElement extendedDataElement = feature.Element (kmlNS + "ExtendedData");  			if (extendedDataElement != null) {  				List<KmlExtendedData> extendedList = new List<KmlExtendedData> ();  				IEnumerable<XElement> dataElements = from e in extendedDataElement.Descendants (kmlNS + "Data")  				select e;  				foreach (XElement data in dataElements) {  					XAttribute name = data.Attribute ("name");  					if (name != null) {  						KmlExtendedData listItem = new KmlExtendedData ();  						listItem.Name = name.Value;  						foreach (XElement dataChild in data.Descendants ()) {  							if (dataChild.Name == kmlNS + "displayName")  								listItem.DisplayName = dataChild.Value;  							else if (dataChild.Name == kmlNS + "value")  								listItem.Value = dataChild.Value;  						}  						extendedList.Add (listItem);  					}  				}  				if (extendedList.Count > 0)  					fd.Attributes.Add ("extendedData"' extendedList);  			}  			featureDefs.AddPlacemark (fd);  		}  	}  } else if (feature.Name.LocalName == "GroundOverlay") {  	XElement latLonBoxElement = feature.Element (kmlNS + "LatLonBox");  	if (latLonBoxElement != null) {  		GroundOverlayDescriptor fd = new GroundOverlayDescriptor {  			Envelope = ExtractEnvelope (latLonBoxElement)'  			TimeExtent = ExtractTimeExtent (feature)  		};  		XElement rotationElement = latLonBoxElement.Element (kmlNS + "rotation");  		if (rotationElement != null)  			fd.Rotation = GetDoubleValue (rotationElement);  		XElement colorElement = feature.Element (kmlNS + "color");  		if (colorElement != null)  			fd.Color = GetColorFromHexString (colorElement.Value);  		else  			fd.Color = System.Windows.Media.Colors.White;  		// Default = white  		XElement iconElement = feature.Element (kmlNS + "Icon");  		if (iconElement != null) {  			XElement href = iconElement.Element (kmlNS + "href");  			if (href != null) {  				fd.IconHref = href.Value;  			}  		}  		featureDefs.AddGroundOverlay (fd);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following statement contains a magic number: if (geomElement != null && geomElement.Name != null) {  	switch (geomElement.Name.LocalName) {  	case "Point":  		fd = ExtractPoint (kmlStyle' geomElement);  		break;  	case "LineString":  		fd = ExtractPolyLine (kmlStyle' geomElement);  		break;  	case "LinearRing":  		fd = ExtractLinearRing (kmlStyle' geomElement);  		break;  	case "Polygon":  		fd = ExtractPolygon (kmlStyle' geomElement);  		break;  	case "MultiGeometry":  		foreach (XElement item in geomElement.Elements ()) {  			// Use recursion to walk the hierarchy of embedded definitions  			CreateFeatureDefinition (kmlStyle' feature' item' context);  		}  		break;  	case "LatLonBox":  		ExtractFeatureStyleInfo (kmlStyle' feature);  		fd = ExtractLatLonBox (kmlStyle' geomElement);  		break;  	}  	// If a feature definition was created' then assign timeextent' attributes and add to collection  	if (fd != null) {  		fd.TimeExtent = ExtractTimeExtent (feature' fd.Attributes);  		if (fd.Geometry != null)  			fd.Geometry.SpatialReference = new SpatialReference (4326);  		XElement descElement = feature.Element (kmlNS + "description");  		if (descElement != null)  			fd.Attributes.Add ("description"' descElement.Value);  		XElement nameElement = feature.Element (kmlNS + "name");  		if (nameElement != null)  			fd.Attributes.Add ("name"' nameElement.Value);  		if (atomNS != null) {  			// Initialize to parent value  			Uri atomHrefValue = context.AtomHref;  			// If node exists' has attributes' and can be successfully extracted' then extract  			// this value.  			XElement atomHrefElement = feature.Element (atomNS + "link");  			if (atomHrefElement != null && atomHrefElement.HasAttributes) {  				string tempHref = GetAtomHref (atomHrefElement);  				if (!String.IsNullOrEmpty (tempHref))  					atomHrefValue = new Uri (tempHref);  			}  			// If a value was extracted or assigned from a parent' then add to attributes  			if (atomHrefValue != null)  				fd.Attributes.Add ("atomHref"' atomHrefValue);  			// AtomAuthor : Initialize to parent value  			string atomValue = context.AtomAuthor;  			// If node exists' has attributes' and can be successfully extracted' then extract  			// this value.  			XElement atomAuthorElement = feature.Element (atomNS + "author");  			if (atomAuthorElement != null) {  				string tempAuthor = GetAtomAuthor (atomAuthorElement);  				if (!String.IsNullOrEmpty (tempAuthor))  					atomValue = tempAuthor;  			}  			// If a value was extracted or assigned from a parent' then add to attributes  			if (!String.IsNullOrEmpty (atomValue))  				fd.Attributes.Add ("atomAuthor"' atomValue);  		}  		// Extract extended information  		XElement extendedDataElement = feature.Element (kmlNS + "ExtendedData");  		if (extendedDataElement != null) {  			List<KmlExtendedData> extendedList = new List<KmlExtendedData> ();  			IEnumerable<XElement> dataElements = from e in extendedDataElement.Descendants (kmlNS + "Data")  			select e;  			foreach (XElement data in dataElements) {  				XAttribute name = data.Attribute ("name");  				if (name != null) {  					KmlExtendedData listItem = new KmlExtendedData ();  					listItem.Name = name.Value;  					foreach (XElement dataChild in data.Descendants ()) {  						if (dataChild.Name == kmlNS + "displayName")  							listItem.DisplayName = dataChild.Value;  						else if (dataChild.Name == kmlNS + "value")  							listItem.Value = dataChild.Value;  					}  					extendedList.Add (listItem);  				}  			}  			if (extendedList.Count > 0)  				fd.Attributes.Add ("extendedData"' extendedList);  		}  		featureDefs.AddPlacemark (fd);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following statement contains a magic number: if (fd != null) {  	fd.TimeExtent = ExtractTimeExtent (feature' fd.Attributes);  	if (fd.Geometry != null)  		fd.Geometry.SpatialReference = new SpatialReference (4326);  	XElement descElement = feature.Element (kmlNS + "description");  	if (descElement != null)  		fd.Attributes.Add ("description"' descElement.Value);  	XElement nameElement = feature.Element (kmlNS + "name");  	if (nameElement != null)  		fd.Attributes.Add ("name"' nameElement.Value);  	if (atomNS != null) {  		// Initialize to parent value  		Uri atomHrefValue = context.AtomHref;  		// If node exists' has attributes' and can be successfully extracted' then extract  		// this value.  		XElement atomHrefElement = feature.Element (atomNS + "link");  		if (atomHrefElement != null && atomHrefElement.HasAttributes) {  			string tempHref = GetAtomHref (atomHrefElement);  			if (!String.IsNullOrEmpty (tempHref))  				atomHrefValue = new Uri (tempHref);  		}  		// If a value was extracted or assigned from a parent' then add to attributes  		if (atomHrefValue != null)  			fd.Attributes.Add ("atomHref"' atomHrefValue);  		// AtomAuthor : Initialize to parent value  		string atomValue = context.AtomAuthor;  		// If node exists' has attributes' and can be successfully extracted' then extract  		// this value.  		XElement atomAuthorElement = feature.Element (atomNS + "author");  		if (atomAuthorElement != null) {  			string tempAuthor = GetAtomAuthor (atomAuthorElement);  			if (!String.IsNullOrEmpty (tempAuthor))  				atomValue = tempAuthor;  		}  		// If a value was extracted or assigned from a parent' then add to attributes  		if (!String.IsNullOrEmpty (atomValue))  			fd.Attributes.Add ("atomAuthor"' atomValue);  	}  	// Extract extended information  	XElement extendedDataElement = feature.Element (kmlNS + "ExtendedData");  	if (extendedDataElement != null) {  		List<KmlExtendedData> extendedList = new List<KmlExtendedData> ();  		IEnumerable<XElement> dataElements = from e in extendedDataElement.Descendants (kmlNS + "Data")  		select e;  		foreach (XElement data in dataElements) {  			XAttribute name = data.Attribute ("name");  			if (name != null) {  				KmlExtendedData listItem = new KmlExtendedData ();  				listItem.Name = name.Value;  				foreach (XElement dataChild in data.Descendants ()) {  					if (dataChild.Name == kmlNS + "displayName")  						listItem.DisplayName = dataChild.Value;  					else if (dataChild.Name == kmlNS + "value")  						listItem.Value = dataChild.Value;  				}  				extendedList.Add (listItem);  			}  		}  		if (extendedList.Count > 0)  			fd.Attributes.Add ("extendedData"' extendedList);  	}  	featureDefs.AddPlacemark (fd);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following statement contains a magic number: if (fd.Geometry != null)  	fd.Geometry.SpatialReference = new SpatialReference (4326);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following statement contains a magic number: fd.Geometry.SpatialReference = new SpatialReference (4326);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractEnvelope,The following statement contains a magic number: return north.HasValue && south.HasValue && east.HasValue && west.HasValue ? new Envelope (west.Value' south.Value' east.Value' north.Value) {  	SpatialReference = new SpatialReference (4326)  } : null;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractCoordinate,The following statement contains a magic number: if (!String.IsNullOrEmpty (coordinate)) {  	// Split input string into an array of strings using comma as the delimiter  	string[] xy = coordinate.Split (new string[] {  		"'"  	}' StringSplitOptions.RemoveEmptyEntries);  	// Make sure X and Y coordinate strings are available  	if (xy.Length >= 2) {  		double x' y;  		// Create new MapPoint object passing in X and Y values to constructor  		if (double.TryParse (xy [0]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out x) && double.TryParse (xy [1]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out y)) {  			mp = new MapPoint (x' y);  		}  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractCoordinate,The following statement contains a magic number: if (xy.Length >= 2) {  	double x' y;  	// Create new MapPoint object passing in X and Y values to constructor  	if (double.TryParse (xy [0]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out x) && double.TryParse (xy [1]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out y)) {  		mp = new MapPoint (x' y);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null) {  	XElement icon = iconStyle.Element (kmlNS + "Icon");  	if (icon != null) {  		XElement href = icon.Element (kmlNS + "href");  		if (href != null) {  			string iconUrl = href.Value;  			const string googlePal = "root://icons/palette-";  			if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  				// Replace Google earth built-in palette URL by the real URL  				int x = 0;  				int y = 0;  				int numPalette = 0;  				XElement xElement = icon.Element (kmlNS + "x");  				if (xElement != null)  					int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  				XElement yElement = icon.Element (kmlNS + "y");  				if (yElement != null)  					int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  				string pal = iconUrl.Substring (googlePal.Length' 1);  				int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  				if (numPalette > 0) {  					int numIcon = 8 * (7 - y / 32) + x / 32;  					iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  				}  			}  			kmlStyle.IconHref = iconUrl;  		}  	}  	// Extract IconColor  	XElement iconColor = iconStyle.Element (kmlNS + "color");  	if (iconColor != null) {  		kmlStyle.IconColor = GetColorFromHexString (iconColor.Value);  	}  	// If the hotspot element is present' make use of it  	XElement hotspot = iconStyle.Element (kmlNS + "hotSpot");  	if (hotspot != null) {  		XAttribute units;  		XAttribute val;  		units = hotspot.Attribute ("xunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("x");  				if (val != null) {  					double x;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))  						kmlStyle.IconHotspotX = x;  				}  			} catch {  			}  		}  		units = hotspot.Attribute ("yunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("y");  				if (val != null) {  					double y;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))  						kmlStyle.IconHotspotY = y;  				}  			} catch {  			}  		}  	}  	// If the heading element is present' make use of it  	XElement heading = iconStyle.Element (kmlNS + "heading");  	if (heading != null) {  		double degrees;  		if (double.TryParse (heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))  			kmlStyle.IconHeading = degrees;  	}  	// If the scale element is present' make use of it  	XElement scale = iconStyle.Element (kmlNS + "scale");  	if (scale != null) {  		double scaleAmount;  		if (double.TryParse (scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))  			kmlStyle.IconScale = scaleAmount;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null) {  	XElement icon = iconStyle.Element (kmlNS + "Icon");  	if (icon != null) {  		XElement href = icon.Element (kmlNS + "href");  		if (href != null) {  			string iconUrl = href.Value;  			const string googlePal = "root://icons/palette-";  			if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  				// Replace Google earth built-in palette URL by the real URL  				int x = 0;  				int y = 0;  				int numPalette = 0;  				XElement xElement = icon.Element (kmlNS + "x");  				if (xElement != null)  					int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  				XElement yElement = icon.Element (kmlNS + "y");  				if (yElement != null)  					int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  				string pal = iconUrl.Substring (googlePal.Length' 1);  				int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  				if (numPalette > 0) {  					int numIcon = 8 * (7 - y / 32) + x / 32;  					iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  				}  			}  			kmlStyle.IconHref = iconUrl;  		}  	}  	// Extract IconColor  	XElement iconColor = iconStyle.Element (kmlNS + "color");  	if (iconColor != null) {  		kmlStyle.IconColor = GetColorFromHexString (iconColor.Value);  	}  	// If the hotspot element is present' make use of it  	XElement hotspot = iconStyle.Element (kmlNS + "hotSpot");  	if (hotspot != null) {  		XAttribute units;  		XAttribute val;  		units = hotspot.Attribute ("xunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("x");  				if (val != null) {  					double x;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))  						kmlStyle.IconHotspotX = x;  				}  			} catch {  			}  		}  		units = hotspot.Attribute ("yunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("y");  				if (val != null) {  					double y;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))  						kmlStyle.IconHotspotY = y;  				}  			} catch {  			}  		}  	}  	// If the heading element is present' make use of it  	XElement heading = iconStyle.Element (kmlNS + "heading");  	if (heading != null) {  		double degrees;  		if (double.TryParse (heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))  			kmlStyle.IconHeading = degrees;  	}  	// If the scale element is present' make use of it  	XElement scale = iconStyle.Element (kmlNS + "scale");  	if (scale != null) {  		double scaleAmount;  		if (double.TryParse (scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))  			kmlStyle.IconScale = scaleAmount;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null) {  	XElement icon = iconStyle.Element (kmlNS + "Icon");  	if (icon != null) {  		XElement href = icon.Element (kmlNS + "href");  		if (href != null) {  			string iconUrl = href.Value;  			const string googlePal = "root://icons/palette-";  			if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  				// Replace Google earth built-in palette URL by the real URL  				int x = 0;  				int y = 0;  				int numPalette = 0;  				XElement xElement = icon.Element (kmlNS + "x");  				if (xElement != null)  					int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  				XElement yElement = icon.Element (kmlNS + "y");  				if (yElement != null)  					int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  				string pal = iconUrl.Substring (googlePal.Length' 1);  				int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  				if (numPalette > 0) {  					int numIcon = 8 * (7 - y / 32) + x / 32;  					iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  				}  			}  			kmlStyle.IconHref = iconUrl;  		}  	}  	// Extract IconColor  	XElement iconColor = iconStyle.Element (kmlNS + "color");  	if (iconColor != null) {  		kmlStyle.IconColor = GetColorFromHexString (iconColor.Value);  	}  	// If the hotspot element is present' make use of it  	XElement hotspot = iconStyle.Element (kmlNS + "hotSpot");  	if (hotspot != null) {  		XAttribute units;  		XAttribute val;  		units = hotspot.Attribute ("xunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("x");  				if (val != null) {  					double x;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))  						kmlStyle.IconHotspotX = x;  				}  			} catch {  			}  		}  		units = hotspot.Attribute ("yunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("y");  				if (val != null) {  					double y;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))  						kmlStyle.IconHotspotY = y;  				}  			} catch {  			}  		}  	}  	// If the heading element is present' make use of it  	XElement heading = iconStyle.Element (kmlNS + "heading");  	if (heading != null) {  		double degrees;  		if (double.TryParse (heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))  			kmlStyle.IconHeading = degrees;  	}  	// If the scale element is present' make use of it  	XElement scale = iconStyle.Element (kmlNS + "scale");  	if (scale != null) {  		double scaleAmount;  		if (double.TryParse (scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))  			kmlStyle.IconScale = scaleAmount;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null) {  	XElement icon = iconStyle.Element (kmlNS + "Icon");  	if (icon != null) {  		XElement href = icon.Element (kmlNS + "href");  		if (href != null) {  			string iconUrl = href.Value;  			const string googlePal = "root://icons/palette-";  			if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  				// Replace Google earth built-in palette URL by the real URL  				int x = 0;  				int y = 0;  				int numPalette = 0;  				XElement xElement = icon.Element (kmlNS + "x");  				if (xElement != null)  					int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  				XElement yElement = icon.Element (kmlNS + "y");  				if (yElement != null)  					int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  				string pal = iconUrl.Substring (googlePal.Length' 1);  				int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  				if (numPalette > 0) {  					int numIcon = 8 * (7 - y / 32) + x / 32;  					iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  				}  			}  			kmlStyle.IconHref = iconUrl;  		}  	}  	// Extract IconColor  	XElement iconColor = iconStyle.Element (kmlNS + "color");  	if (iconColor != null) {  		kmlStyle.IconColor = GetColorFromHexString (iconColor.Value);  	}  	// If the hotspot element is present' make use of it  	XElement hotspot = iconStyle.Element (kmlNS + "hotSpot");  	if (hotspot != null) {  		XAttribute units;  		XAttribute val;  		units = hotspot.Attribute ("xunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("x");  				if (val != null) {  					double x;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))  						kmlStyle.IconHotspotX = x;  				}  			} catch {  			}  		}  		units = hotspot.Attribute ("yunits");  		if (units != null) {  			try {  				kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse (typeof(HotSpotUnitType)' units.Value' true);  				val = hotspot.Attribute ("y");  				if (val != null) {  					double y;  					if (double.TryParse (val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))  						kmlStyle.IconHotspotY = y;  				}  			} catch {  			}  		}  	}  	// If the heading element is present' make use of it  	XElement heading = iconStyle.Element (kmlNS + "heading");  	if (heading != null) {  		double degrees;  		if (double.TryParse (heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))  			kmlStyle.IconHeading = degrees;  	}  	// If the scale element is present' make use of it  	XElement scale = iconStyle.Element (kmlNS + "scale");  	if (scale != null) {  		double scaleAmount;  		if (double.TryParse (scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))  			kmlStyle.IconScale = scaleAmount;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (icon != null) {  	XElement href = icon.Element (kmlNS + "href");  	if (href != null) {  		string iconUrl = href.Value;  		const string googlePal = "root://icons/palette-";  		if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  			// Replace Google earth built-in palette URL by the real URL  			int x = 0;  			int y = 0;  			int numPalette = 0;  			XElement xElement = icon.Element (kmlNS + "x");  			if (xElement != null)  				int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  			XElement yElement = icon.Element (kmlNS + "y");  			if (yElement != null)  				int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  			string pal = iconUrl.Substring (googlePal.Length' 1);  			int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  			if (numPalette > 0) {  				int numIcon = 8 * (7 - y / 32) + x / 32;  				iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  			}  		}  		kmlStyle.IconHref = iconUrl;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (icon != null) {  	XElement href = icon.Element (kmlNS + "href");  	if (href != null) {  		string iconUrl = href.Value;  		const string googlePal = "root://icons/palette-";  		if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  			// Replace Google earth built-in palette URL by the real URL  			int x = 0;  			int y = 0;  			int numPalette = 0;  			XElement xElement = icon.Element (kmlNS + "x");  			if (xElement != null)  				int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  			XElement yElement = icon.Element (kmlNS + "y");  			if (yElement != null)  				int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  			string pal = iconUrl.Substring (googlePal.Length' 1);  			int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  			if (numPalette > 0) {  				int numIcon = 8 * (7 - y / 32) + x / 32;  				iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  			}  		}  		kmlStyle.IconHref = iconUrl;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (icon != null) {  	XElement href = icon.Element (kmlNS + "href");  	if (href != null) {  		string iconUrl = href.Value;  		const string googlePal = "root://icons/palette-";  		if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  			// Replace Google earth built-in palette URL by the real URL  			int x = 0;  			int y = 0;  			int numPalette = 0;  			XElement xElement = icon.Element (kmlNS + "x");  			if (xElement != null)  				int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  			XElement yElement = icon.Element (kmlNS + "y");  			if (yElement != null)  				int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  			string pal = iconUrl.Substring (googlePal.Length' 1);  			int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  			if (numPalette > 0) {  				int numIcon = 8 * (7 - y / 32) + x / 32;  				iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  			}  		}  		kmlStyle.IconHref = iconUrl;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (icon != null) {  	XElement href = icon.Element (kmlNS + "href");  	if (href != null) {  		string iconUrl = href.Value;  		const string googlePal = "root://icons/palette-";  		if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  			// Replace Google earth built-in palette URL by the real URL  			int x = 0;  			int y = 0;  			int numPalette = 0;  			XElement xElement = icon.Element (kmlNS + "x");  			if (xElement != null)  				int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  			XElement yElement = icon.Element (kmlNS + "y");  			if (yElement != null)  				int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  			string pal = iconUrl.Substring (googlePal.Length' 1);  			int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  			if (numPalette > 0) {  				int numIcon = 8 * (7 - y / 32) + x / 32;  				iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  			}  		}  		kmlStyle.IconHref = iconUrl;  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (href != null) {  	string iconUrl = href.Value;  	const string googlePal = "root://icons/palette-";  	if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  		// Replace Google earth built-in palette URL by the real URL  		int x = 0;  		int y = 0;  		int numPalette = 0;  		XElement xElement = icon.Element (kmlNS + "x");  		if (xElement != null)  			int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  		XElement yElement = icon.Element (kmlNS + "y");  		if (yElement != null)  			int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  		string pal = iconUrl.Substring (googlePal.Length' 1);  		int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  		if (numPalette > 0) {  			int numIcon = 8 * (7 - y / 32) + x / 32;  			iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  		}  	}  	kmlStyle.IconHref = iconUrl;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (href != null) {  	string iconUrl = href.Value;  	const string googlePal = "root://icons/palette-";  	if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  		// Replace Google earth built-in palette URL by the real URL  		int x = 0;  		int y = 0;  		int numPalette = 0;  		XElement xElement = icon.Element (kmlNS + "x");  		if (xElement != null)  			int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  		XElement yElement = icon.Element (kmlNS + "y");  		if (yElement != null)  			int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  		string pal = iconUrl.Substring (googlePal.Length' 1);  		int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  		if (numPalette > 0) {  			int numIcon = 8 * (7 - y / 32) + x / 32;  			iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  		}  	}  	kmlStyle.IconHref = iconUrl;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (href != null) {  	string iconUrl = href.Value;  	const string googlePal = "root://icons/palette-";  	if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  		// Replace Google earth built-in palette URL by the real URL  		int x = 0;  		int y = 0;  		int numPalette = 0;  		XElement xElement = icon.Element (kmlNS + "x");  		if (xElement != null)  			int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  		XElement yElement = icon.Element (kmlNS + "y");  		if (yElement != null)  			int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  		string pal = iconUrl.Substring (googlePal.Length' 1);  		int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  		if (numPalette > 0) {  			int numIcon = 8 * (7 - y / 32) + x / 32;  			iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  		}  	}  	kmlStyle.IconHref = iconUrl;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (href != null) {  	string iconUrl = href.Value;  	const string googlePal = "root://icons/palette-";  	if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  		// Replace Google earth built-in palette URL by the real URL  		int x = 0;  		int y = 0;  		int numPalette = 0;  		XElement xElement = icon.Element (kmlNS + "x");  		if (xElement != null)  			int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  		XElement yElement = icon.Element (kmlNS + "y");  		if (yElement != null)  			int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  		string pal = iconUrl.Substring (googlePal.Length' 1);  		int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  		if (numPalette > 0) {  			int numIcon = 8 * (7 - y / 32) + x / 32;  			iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  		}  	}  	kmlStyle.IconHref = iconUrl;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  	// Replace Google earth built-in palette URL by the real URL  	int x = 0;  	int y = 0;  	int numPalette = 0;  	XElement xElement = icon.Element (kmlNS + "x");  	if (xElement != null)  		int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  	XElement yElement = icon.Element (kmlNS + "y");  	if (yElement != null)  		int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  	string pal = iconUrl.Substring (googlePal.Length' 1);  	int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  	if (numPalette > 0) {  		int numIcon = 8 * (7 - y / 32) + x / 32;  		iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  	// Replace Google earth built-in palette URL by the real URL  	int x = 0;  	int y = 0;  	int numPalette = 0;  	XElement xElement = icon.Element (kmlNS + "x");  	if (xElement != null)  		int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  	XElement yElement = icon.Element (kmlNS + "y");  	if (yElement != null)  		int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  	string pal = iconUrl.Substring (googlePal.Length' 1);  	int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  	if (numPalette > 0) {  		int numIcon = 8 * (7 - y / 32) + x / 32;  		iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  	// Replace Google earth built-in palette URL by the real URL  	int x = 0;  	int y = 0;  	int numPalette = 0;  	XElement xElement = icon.Element (kmlNS + "x");  	if (xElement != null)  		int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  	XElement yElement = icon.Element (kmlNS + "y");  	if (yElement != null)  		int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  	string pal = iconUrl.Substring (googlePal.Length' 1);  	int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  	if (numPalette > 0) {  		int numIcon = 8 * (7 - y / 32) + x / 32;  		iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconUrl.StartsWith (googlePal' StringComparison.OrdinalIgnoreCase)) {  	// Replace Google earth built-in palette URL by the real URL  	int x = 0;  	int y = 0;  	int numPalette = 0;  	XElement xElement = icon.Element (kmlNS + "x");  	if (xElement != null)  		int.TryParse (xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);  	XElement yElement = icon.Element (kmlNS + "y");  	if (yElement != null)  		int.TryParse (yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);  	string pal = iconUrl.Substring (googlePal.Length' 1);  	int.TryParse (pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);  	if (numPalette > 0) {  		int numIcon = 8 * (7 - y / 32) + x / 32;  		iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (numPalette > 0) {  	int numIcon = 8 * (7 - y / 32) + x / 32;  	iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (numPalette > 0) {  	int numIcon = 8 * (7 - y / 32) + x / 32;  	iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (numPalette > 0) {  	int numIcon = 8 * (7 - y / 32) + x / 32;  	iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (numPalette > 0) {  	int numIcon = 8 * (7 - y / 32) + x / 32;  	iconUrl = string.Format ("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8) {  	// Be advised that the values are not ARGB' but instead ABGR.  	byte a = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte b = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (4' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (6' 2)' 16);  	return System.Windows.Media.Color.FromArgb (a' r' g' b);  } else {  	byte b = System.Convert.ToByte (s.Substring (0' 2)' 16);  	byte g = System.Convert.ToByte (s.Substring (2' 2)' 16);  	byte r = System.Convert.ToByte (s.Substring (4' 2)' 16);  	return System.Windows.Media.Color.FromArgb (255' r' g' b);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: return System.Windows.Media.Color.FromArgb (255' r' g' b);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtentFromDate,The following statement contains a magic number: if (strsDate.Length > 2 && !int.TryParse (strsDate [2]' out day))  	return null;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtentFromDate,The following statement contains a magic number: if (strsDate.Length > 2 && !int.TryParse (strsDate [2]' out day))  	return null;  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (-4' SeekOrigin.End);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: while (reader.ReadInt32 () != 101010256) {  	reader.BaseStream.Seek (-5' SeekOrigin.Current);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: while (reader.ReadInt32 () != 101010256) {  	reader.BaseStream.Seek (-5' SeekOrigin.Current);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (-5' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (6' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	int headerSignature = reader.ReadInt32 ();  	if (headerSignature == 33639248)//Central directory file header signature   	 {  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		short flag = reader.ReadInt16 ();  		if (flag == 8)//Silverlight doesn't like this format  		 {  			needsFixing = true;  		}  		reader.BaseStream.Seek (6' SeekOrigin.Current);  		int crc32 = reader.ReadInt32 ();  		int compressedSize = reader.ReadInt32 ();  		int unCompressedSize = reader.ReadInt32 ();  		short fileNameLenght = reader.ReadInt16 ();  		short extraFieldLength = reader.ReadInt16 ();  		short fileCommentLength = reader.ReadInt16 ();  		reader.BaseStream.Seek (8' SeekOrigin.Current);  		int fileStart = reader.ReadInt32 ();  		string filename = new string (reader.ReadChars (fileNameLenght));  		entries.Add (new FileEntry () {  			Filename = filename'  			FileStart = fileStart'  			CRC32 = crc32'  			CompressedSize = compressedSize'  			UncompressedSize = unCompressedSize  		});  		reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	int headerSignature = reader.ReadInt32 ();  	if (headerSignature == 33639248)//Central directory file header signature   	 {  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		short flag = reader.ReadInt16 ();  		if (flag == 8)//Silverlight doesn't like this format  		 {  			needsFixing = true;  		}  		reader.BaseStream.Seek (6' SeekOrigin.Current);  		int crc32 = reader.ReadInt32 ();  		int compressedSize = reader.ReadInt32 ();  		int unCompressedSize = reader.ReadInt32 ();  		short fileNameLenght = reader.ReadInt16 ();  		short extraFieldLength = reader.ReadInt16 ();  		short fileCommentLength = reader.ReadInt16 ();  		reader.BaseStream.Seek (8' SeekOrigin.Current);  		int fileStart = reader.ReadInt32 ();  		string filename = new string (reader.ReadChars (fileNameLenght));  		entries.Add (new FileEntry () {  			Filename = filename'  			FileStart = fileStart'  			CRC32 = crc32'  			CompressedSize = compressedSize'  			UncompressedSize = unCompressedSize  		});  		reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	int headerSignature = reader.ReadInt32 ();  	if (headerSignature == 33639248)//Central directory file header signature   	 {  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		short flag = reader.ReadInt16 ();  		if (flag == 8)//Silverlight doesn't like this format  		 {  			needsFixing = true;  		}  		reader.BaseStream.Seek (6' SeekOrigin.Current);  		int crc32 = reader.ReadInt32 ();  		int compressedSize = reader.ReadInt32 ();  		int unCompressedSize = reader.ReadInt32 ();  		short fileNameLenght = reader.ReadInt16 ();  		short extraFieldLength = reader.ReadInt16 ();  		short fileCommentLength = reader.ReadInt16 ();  		reader.BaseStream.Seek (8' SeekOrigin.Current);  		int fileStart = reader.ReadInt32 ();  		string filename = new string (reader.ReadChars (fileNameLenght));  		entries.Add (new FileEntry () {  			Filename = filename'  			FileStart = fileStart'  			CRC32 = crc32'  			CompressedSize = compressedSize'  			UncompressedSize = unCompressedSize  		});  		reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	int headerSignature = reader.ReadInt32 ();  	if (headerSignature == 33639248)//Central directory file header signature   	 {  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		short flag = reader.ReadInt16 ();  		if (flag == 8)//Silverlight doesn't like this format  		 {  			needsFixing = true;  		}  		reader.BaseStream.Seek (6' SeekOrigin.Current);  		int crc32 = reader.ReadInt32 ();  		int compressedSize = reader.ReadInt32 ();  		int unCompressedSize = reader.ReadInt32 ();  		short fileNameLenght = reader.ReadInt16 ();  		short extraFieldLength = reader.ReadInt16 ();  		short fileCommentLength = reader.ReadInt16 ();  		reader.BaseStream.Seek (8' SeekOrigin.Current);  		int fileStart = reader.ReadInt32 ();  		string filename = new string (reader.ReadChars (fileNameLenght));  		entries.Add (new FileEntry () {  			Filename = filename'  			FileStart = fileStart'  			CRC32 = crc32'  			CompressedSize = compressedSize'  			UncompressedSize = unCompressedSize  		});  		reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	int headerSignature = reader.ReadInt32 ();  	if (headerSignature == 33639248)//Central directory file header signature   	 {  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		short flag = reader.ReadInt16 ();  		if (flag == 8)//Silverlight doesn't like this format  		 {  			needsFixing = true;  		}  		reader.BaseStream.Seek (6' SeekOrigin.Current);  		int crc32 = reader.ReadInt32 ();  		int compressedSize = reader.ReadInt32 ();  		int unCompressedSize = reader.ReadInt32 ();  		short fileNameLenght = reader.ReadInt16 ();  		short extraFieldLength = reader.ReadInt16 ();  		short fileCommentLength = reader.ReadInt16 ();  		reader.BaseStream.Seek (8' SeekOrigin.Current);  		int fileStart = reader.ReadInt32 ();  		string filename = new string (reader.ReadChars (fileNameLenght));  		entries.Add (new FileEntry () {  			Filename = filename'  			FileStart = fileStart'  			CRC32 = crc32'  			CompressedSize = compressedSize'  			UncompressedSize = unCompressedSize  		});  		reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  	}  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (headerSignature == 33639248)//Central directory file header signature    {  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	short flag = reader.ReadInt16 ();  	if (flag == 8)//Silverlight doesn't like this format  	 {  		needsFixing = true;  	}  	reader.BaseStream.Seek (6' SeekOrigin.Current);  	int crc32 = reader.ReadInt32 ();  	int compressedSize = reader.ReadInt32 ();  	int unCompressedSize = reader.ReadInt32 ();  	short fileNameLenght = reader.ReadInt16 ();  	short extraFieldLength = reader.ReadInt16 ();  	short fileCommentLength = reader.ReadInt16 ();  	reader.BaseStream.Seek (8' SeekOrigin.Current);  	int fileStart = reader.ReadInt32 ();  	string filename = new string (reader.ReadChars (fileNameLenght));  	entries.Add (new FileEntry () {  		Filename = filename'  		FileStart = fileStart'  		CRC32 = crc32'  		CompressedSize = compressedSize'  		UncompressedSize = unCompressedSize  	});  	reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (headerSignature == 33639248)//Central directory file header signature    {  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	short flag = reader.ReadInt16 ();  	if (flag == 8)//Silverlight doesn't like this format  	 {  		needsFixing = true;  	}  	reader.BaseStream.Seek (6' SeekOrigin.Current);  	int crc32 = reader.ReadInt32 ();  	int compressedSize = reader.ReadInt32 ();  	int unCompressedSize = reader.ReadInt32 ();  	short fileNameLenght = reader.ReadInt16 ();  	short extraFieldLength = reader.ReadInt16 ();  	short fileCommentLength = reader.ReadInt16 ();  	reader.BaseStream.Seek (8' SeekOrigin.Current);  	int fileStart = reader.ReadInt32 ();  	string filename = new string (reader.ReadChars (fileNameLenght));  	entries.Add (new FileEntry () {  		Filename = filename'  		FileStart = fileStart'  		CRC32 = crc32'  		CompressedSize = compressedSize'  		UncompressedSize = unCompressedSize  	});  	reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (headerSignature == 33639248)//Central directory file header signature    {  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	short flag = reader.ReadInt16 ();  	if (flag == 8)//Silverlight doesn't like this format  	 {  		needsFixing = true;  	}  	reader.BaseStream.Seek (6' SeekOrigin.Current);  	int crc32 = reader.ReadInt32 ();  	int compressedSize = reader.ReadInt32 ();  	int unCompressedSize = reader.ReadInt32 ();  	short fileNameLenght = reader.ReadInt16 ();  	short extraFieldLength = reader.ReadInt16 ();  	short fileCommentLength = reader.ReadInt16 ();  	reader.BaseStream.Seek (8' SeekOrigin.Current);  	int fileStart = reader.ReadInt32 ();  	string filename = new string (reader.ReadChars (fileNameLenght));  	entries.Add (new FileEntry () {  		Filename = filename'  		FileStart = fileStart'  		CRC32 = crc32'  		CompressedSize = compressedSize'  		UncompressedSize = unCompressedSize  	});  	reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (headerSignature == 33639248)//Central directory file header signature    {  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	short flag = reader.ReadInt16 ();  	if (flag == 8)//Silverlight doesn't like this format  	 {  		needsFixing = true;  	}  	reader.BaseStream.Seek (6' SeekOrigin.Current);  	int crc32 = reader.ReadInt32 ();  	int compressedSize = reader.ReadInt32 ();  	int unCompressedSize = reader.ReadInt32 ();  	short fileNameLenght = reader.ReadInt16 ();  	short extraFieldLength = reader.ReadInt16 ();  	short fileCommentLength = reader.ReadInt16 ();  	reader.BaseStream.Seek (8' SeekOrigin.Current);  	int fileStart = reader.ReadInt32 ();  	string filename = new string (reader.ReadChars (fileNameLenght));  	entries.Add (new FileEntry () {  		Filename = filename'  		FileStart = fileStart'  		CRC32 = crc32'  		CompressedSize = compressedSize'  		UncompressedSize = unCompressedSize  	});  	reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (headerSignature == 33639248)//Central directory file header signature    {  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	short flag = reader.ReadInt16 ();  	if (flag == 8)//Silverlight doesn't like this format  	 {  		needsFixing = true;  	}  	reader.BaseStream.Seek (6' SeekOrigin.Current);  	int crc32 = reader.ReadInt32 ();  	int compressedSize = reader.ReadInt32 ();  	int unCompressedSize = reader.ReadInt32 ();  	short fileNameLenght = reader.ReadInt16 ();  	short extraFieldLength = reader.ReadInt16 ();  	short fileCommentLength = reader.ReadInt16 ();  	reader.BaseStream.Seek (8' SeekOrigin.Current);  	int fileStart = reader.ReadInt32 ();  	string filename = new string (reader.ReadChars (fileNameLenght));  	entries.Add (new FileEntry () {  		Filename = filename'  		FileStart = fileStart'  		CRC32 = crc32'  		CompressedSize = compressedSize'  		UncompressedSize = unCompressedSize  	});  	reader.BaseStream.Seek (extraFieldLength + fileCommentLength' SeekOrigin.Current);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (flag == 8)//Silverlight doesn't like this format   {  	needsFixing = true;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (6' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (8' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: if (needsFixing) {  	//We are using a zipformat that Silverlight doesn't like.   	//Zipfiles where the file size is reported after the compressed data  	//is a no-go' so we rebuild the header and report the information there.  	MemoryStream newZip = new MemoryStream ();  	BinaryWriter writer = new BinaryWriter (newZip);  	//Rebuild file entries  	foreach (FileEntry entry in entries) {  		FileEntry e = entry;  		reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  		e.FileStart = (int)writer.BaseStream.Position;  		CopyBytes (reader' writer' 6);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 6);  		writer.Write (entry.CRC32);  		//Update CRC  		writer.Write (entry.CompressedSize);  		//Update Compressed size  		writer.Write (entry.UncompressedSize);  		//Update Uncompressed size  		writer.Write ((short)entry.Filename.Length);  		reader.BaseStream.Seek (14' SeekOrigin.Current);  		short fieldLength = reader.ReadInt16 ();  		writer.Write (fieldLength);  		CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  	}  	//Rebuild directory  	reader.BaseStream.Seek (directoryStart' SeekOrigin.Begin);  	for (int i = 0; i < entryCount; i++) {  		CopyBytes (reader' writer' 8);  		writer.Write ((short)2);  		//This flag needs to be replaced to indicate the new format  		reader.BaseStream.Seek (2' SeekOrigin.Current);  		CopyBytes (reader' writer' 18);  		short filenamelength = reader.ReadInt16 ();  		writer.Write (filenamelength);  		short extrafieldlength = reader.ReadInt16 ();  		writer.Write (extrafieldlength);  		short filecommentlength = reader.ReadInt16 ();  		writer.Write (filecommentlength);  		CopyBytes (reader' writer' 8);  		writer.Write (entries [i].FileStart);  		reader.BaseStream.Seek (4' SeekOrigin.Current);  		CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  	}  	CopyBytes (reader' writer' (int)(reader.BaseStream.Length - reader.BaseStream.Position));  	this.stream = newZip;  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: foreach (FileEntry entry in entries) {  	FileEntry e = entry;  	reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  	e.FileStart = (int)writer.BaseStream.Position;  	CopyBytes (reader' writer' 6);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 6);  	writer.Write (entry.CRC32);  	//Update CRC  	writer.Write (entry.CompressedSize);  	//Update Compressed size  	writer.Write (entry.UncompressedSize);  	//Update Uncompressed size  	writer.Write ((short)entry.Filename.Length);  	reader.BaseStream.Seek (14' SeekOrigin.Current);  	short fieldLength = reader.ReadInt16 ();  	writer.Write (fieldLength);  	CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: foreach (FileEntry entry in entries) {  	FileEntry e = entry;  	reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  	e.FileStart = (int)writer.BaseStream.Position;  	CopyBytes (reader' writer' 6);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 6);  	writer.Write (entry.CRC32);  	//Update CRC  	writer.Write (entry.CompressedSize);  	//Update Compressed size  	writer.Write (entry.UncompressedSize);  	//Update Uncompressed size  	writer.Write ((short)entry.Filename.Length);  	reader.BaseStream.Seek (14' SeekOrigin.Current);  	short fieldLength = reader.ReadInt16 ();  	writer.Write (fieldLength);  	CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: foreach (FileEntry entry in entries) {  	FileEntry e = entry;  	reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  	e.FileStart = (int)writer.BaseStream.Position;  	CopyBytes (reader' writer' 6);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 6);  	writer.Write (entry.CRC32);  	//Update CRC  	writer.Write (entry.CompressedSize);  	//Update Compressed size  	writer.Write (entry.UncompressedSize);  	//Update Uncompressed size  	writer.Write ((short)entry.Filename.Length);  	reader.BaseStream.Seek (14' SeekOrigin.Current);  	short fieldLength = reader.ReadInt16 ();  	writer.Write (fieldLength);  	CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: foreach (FileEntry entry in entries) {  	FileEntry e = entry;  	reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  	e.FileStart = (int)writer.BaseStream.Position;  	CopyBytes (reader' writer' 6);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 6);  	writer.Write (entry.CRC32);  	//Update CRC  	writer.Write (entry.CompressedSize);  	//Update Compressed size  	writer.Write (entry.UncompressedSize);  	//Update Uncompressed size  	writer.Write ((short)entry.Filename.Length);  	reader.BaseStream.Seek (14' SeekOrigin.Current);  	short fieldLength = reader.ReadInt16 ();  	writer.Write (fieldLength);  	CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: foreach (FileEntry entry in entries) {  	FileEntry e = entry;  	reader.BaseStream.Seek (entry.FileStart' SeekOrigin.Begin);  	e.FileStart = (int)writer.BaseStream.Position;  	CopyBytes (reader' writer' 6);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 6);  	writer.Write (entry.CRC32);  	//Update CRC  	writer.Write (entry.CompressedSize);  	//Update Compressed size  	writer.Write (entry.UncompressedSize);  	//Update Uncompressed size  	writer.Write ((short)entry.Filename.Length);  	reader.BaseStream.Seek (14' SeekOrigin.Current);  	short fieldLength = reader.ReadInt16 ();  	writer.Write (fieldLength);  	CopyBytes (reader' writer' entry.Filename.Length + fieldLength + entry.CompressedSize);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: CopyBytes (reader' writer' 6);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: writer.Write ((short)2);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: CopyBytes (reader' writer' 6);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (14' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	CopyBytes (reader' writer' 8);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 18);  	short filenamelength = reader.ReadInt16 ();  	writer.Write (filenamelength);  	short extrafieldlength = reader.ReadInt16 ();  	writer.Write (extrafieldlength);  	short filecommentlength = reader.ReadInt16 ();  	writer.Write (filecommentlength);  	CopyBytes (reader' writer' 8);  	writer.Write (entries [i].FileStart);  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	CopyBytes (reader' writer' 8);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 18);  	short filenamelength = reader.ReadInt16 ();  	writer.Write (filenamelength);  	short extrafieldlength = reader.ReadInt16 ();  	writer.Write (extrafieldlength);  	short filecommentlength = reader.ReadInt16 ();  	writer.Write (filecommentlength);  	CopyBytes (reader' writer' 8);  	writer.Write (entries [i].FileStart);  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	CopyBytes (reader' writer' 8);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 18);  	short filenamelength = reader.ReadInt16 ();  	writer.Write (filenamelength);  	short extrafieldlength = reader.ReadInt16 ();  	writer.Write (extrafieldlength);  	short filecommentlength = reader.ReadInt16 ();  	writer.Write (filecommentlength);  	CopyBytes (reader' writer' 8);  	writer.Write (entries [i].FileStart);  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	CopyBytes (reader' writer' 8);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 18);  	short filenamelength = reader.ReadInt16 ();  	writer.Write (filenamelength);  	short extrafieldlength = reader.ReadInt16 ();  	writer.Write (extrafieldlength);  	short filecommentlength = reader.ReadInt16 ();  	writer.Write (filecommentlength);  	CopyBytes (reader' writer' 8);  	writer.Write (entries [i].FileStart);  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	CopyBytes (reader' writer' 8);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 18);  	short filenamelength = reader.ReadInt16 ();  	writer.Write (filenamelength);  	short extrafieldlength = reader.ReadInt16 ();  	writer.Write (extrafieldlength);  	short filecommentlength = reader.ReadInt16 ();  	writer.Write (filecommentlength);  	CopyBytes (reader' writer' 8);  	writer.Write (entries [i].FileStart);  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: for (int i = 0; i < entryCount; i++) {  	CopyBytes (reader' writer' 8);  	writer.Write ((short)2);  	//This flag needs to be replaced to indicate the new format  	reader.BaseStream.Seek (2' SeekOrigin.Current);  	CopyBytes (reader' writer' 18);  	short filenamelength = reader.ReadInt16 ();  	writer.Write (filenamelength);  	short extrafieldlength = reader.ReadInt16 ();  	writer.Write (extrafieldlength);  	short filecommentlength = reader.ReadInt16 ();  	writer.Write (filecommentlength);  	CopyBytes (reader' writer' 8);  	writer.Write (entries [i].FileStart);  	reader.BaseStream.Seek (4' SeekOrigin.Current);  	CopyBytes (reader' writer' filenamelength + extrafieldlength + filecommentlength);  }  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: CopyBytes (reader' writer' 8);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: writer.Write ((short)2);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (2' SeekOrigin.Current);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: CopyBytes (reader' writer' 18);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: CopyBytes (reader' writer' 8);  
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,ZipFile,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\ZipFile.cs,ParseCentralDirectory,The following statement contains a magic number: reader.BaseStream.Seek (4' SeekOrigin.Current);  
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The following switch statement is missing a default case: switch (expectedValueType) {  case Field.FieldType.Date:  	if (!(valueObject is DateTime)) {  		try {  			if (valueObject is string) {  				string str_date = ((string)valueObject).ToLower ();  				if (str_date.Contains ("utc")) {  					str_date = str_date.Replace ("utc"' "");  					result = DateTime.Parse ((string)str_date' numericCulture' DateTimeStyles.AssumeUniversal);  				} else  					result = DateTime.Parse ((string)valueObject' numericCulture);  			} else {  				long time = 0;  				if (valueObject.GetType () == typeof(long))  					time = (long)valueObject;  				else if (valueObject.GetType () == typeof(int))  					time = (int)valueObject;  				else  					time = Convert.ToInt64 (valueObject' numericCulture);  				result = Epoch.AddMilliseconds ((double)time);  			}  		} catch {  		}  	}  	break;  case Field.FieldType.Double:  	if (valueObject.GetType () != typeof(double)) {  		try {  			result = Convert.ToDouble (valueObject' numericCulture);  		} catch {  		}  	}  	break;  case Field.FieldType.Single:  	if (valueObject.GetType () != typeof(float)) {  		try {  			result = Convert.ToSingle (valueObject' numericCulture);  		} catch {  		}  	}  	break;  case Field.FieldType.Integer:  	if (valueObject.GetType () != typeof(int)) {  		try {  			result = Convert.ToInt32 (valueObject' numericCulture);  		} catch {  		}  	}  	break;  case Field.FieldType.SmallInteger:  	if (valueObject.GetType () != typeof(short)) {  		try {  			result = Convert.ToInt16 (valueObject' numericCulture);  		} catch {  		}  	}  	break;  case Field.FieldType.GUID:  	if (valueObject.GetType () != typeof(Guid)) {  		Guid output;  		var valueStr = Convert.ToString (valueObject' numericCulture);  		if (!string.IsNullOrEmpty (valueStr)) {  			if (Guid.TryParse (valueStr' out output))  				result = output;  		}  	}  	break;  }  
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following switch statement is missing a default case: switch (ee.OuterName) {  case ("lat"): {  	slat = xr.ReadElementContentAsString ();  	break;  }  case ("long"): {  	slong = xr.ReadElementContentAsString ();  	break;  }  case ("Point"): {  	XmlReader xmlPoint = xr.ReadSubtree ();  	while (xmlPoint.Read ()) {  		if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  			slat = xmlPoint.ReadElementContentAsString ();  		} else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_) {  			slong = xmlPoint.ReadElementContentAsString ();  		}  	}  	break;  }  }  
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetKmzContents,The following switch statement is missing a default case: switch (filename.Substring (lastPeriod).ToLower ()) {  case ".jpg":  case ".jpeg":  case ".png":  	#if !SILVERLIGHT  	                    case ".bmp":                     case ".gif": #endif  	// If the file is an image' then add it to the dictionary of images and use  	// its filename as the key since this will match the subsequent KML style  	// information for point features.  	try {  		BitmapImage thumbnailBitmap = new BitmapImage ();  		#if SILVERLIGHT  		thumbnailBitmap.SetSource (ms);  		#else  		                            thumbnailBitmap.BeginInit();                             thumbnailBitmap.StreamSource = ms;                             thumbnailBitmap.EndInit(); #endif  		ImageBrush ib = new ImageBrush ();  		ib.ImageSource = thumbnailBitmap;  		_context.Images.Add (filename.ToLower ()' ib);  	} catch {  	}  	break;  case ".kml":  	// Create the XDocument object from the input stream  	xDoc = LoadDocument (ms);  	break;  }  
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following switch statement is missing a default case: switch (style.IconHotspotUnitsX) {  case HotSpotUnitType.Pixels:  	ms.TranslateX = style.IconHotspotX * -1;  	break;  case HotSpotUnitType.Fraction:  	ms.TranslateX = (ms.Width * style.IconHotspotX) * -1;  	break;  }  
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following switch statement is missing a default case: switch (style.IconHotspotUnitsY) {  case HotSpotUnitType.Pixels:  	ms.TranslateY = (ms.Height - style.IconHotspotY) * -1;  	break;  case HotSpotUnitType.Fraction:  	ms.TranslateY = (ms.Height * style.IconHotspotY) * -1;  	break;  }  
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetKmzContents,The following switch statement is missing a default case: switch (filename.Substring (lastPeriod).ToLower ()) {  case ".kml":  	// Create the XDocument object from the input stream  	xDoc = KmlLayer.LoadDocument (ms);  	break;  }  
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,F:\newReposMay17\Esri_arcgis-toolkit-sl-wpf\src\Silverlight\API\ESRI.ArcGIS.Client.Toolkit.DataSources\..\..\..\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following switch statement is missing a default case: switch (geomElement.Name.LocalName) {  case "Point":  	fd = ExtractPoint (kmlStyle' geomElement);  	break;  case "LineString":  	fd = ExtractPolyLine (kmlStyle' geomElement);  	break;  case "LinearRing":  	fd = ExtractLinearRing (kmlStyle' geomElement);  	break;  case "Polygon":  	fd = ExtractPolygon (kmlStyle' geomElement);  	break;  case "MultiGeometry":  	foreach (XElement item in geomElement.Elements ()) {  		// Use recursion to walk the hierarchy of embedded definitions  		CreateFeatureDefinition (kmlStyle' feature' item' context);  	}  	break;  case "LatLonBox":  	ExtractFeatureStyleInfo (kmlStyle' feature);  	fd = ExtractLatLonBox (kmlStyle' geomElement);  	break;  }  
