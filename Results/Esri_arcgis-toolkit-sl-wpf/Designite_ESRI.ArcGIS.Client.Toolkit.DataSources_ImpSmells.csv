Implementation smell,Namespace,Class,File,Method,Description
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvParser,The method has 134 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The method has 229 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The method has 131 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The method has 108 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The method has 160 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The method has 253 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The method has 163 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has 152 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The method has 431 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The method has 294 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The method has 206 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The method has 159 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The method has 212 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The method has 113 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The method has 198 lines of code.
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvParser,Cyclomatic complexity of the method is 25
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,Cyclomatic complexity of the method is 19
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,Cyclomatic complexity of the method is 15
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,Cyclomatic complexity of the method is 43
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,Cyclomatic complexity of the method is 15
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetMapUnits,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,GetSource,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,InterpolateColor,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Refresh,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,DownloadContent,Cyclomatic complexity of the method is 16
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,webclient_OpenReadCompleted,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,Cyclomatic complexity of the method is 17
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,Cyclomatic complexity of the method is 13
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,Cyclomatic complexity of the method is 18
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,BuildLayersAttribution,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,Cyclomatic complexity of the method is 15
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentTileMatrixSet,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentDimensionValues,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,Cyclomatic complexity of the method is 14
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,Cyclomatic complexity of the method is 38
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,Cyclomatic complexity of the method is 37
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractLatLonBox,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractEnvelope,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,Cyclomatic complexity of the method is 31
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtentFromDate,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,Cyclomatic complexity of the method is 54
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Flush,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,Cyclomatic complexity of the method is 43
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,Cyclomatic complexity of the method is 38
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Sync,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,Cyclomatic complexity of the method is 26
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,Cyclomatic complexity of the method is 14
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,Cyclomatic complexity of the method is 9
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The method has 6 parameters. Parameters: distanceMatrix' size' x' y' intensityMap' width
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleMapAsync,The method has 5 parameters. Parameters: styleMap' xDoc' credentials' callback' clientCertificate
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The method has 5 parameters. Parameters: styleUrl' xDoc' credentials' callback' clientCertificate
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Init,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,StaticTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZlibBaseStream,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZlibStream.cs,ZlibBaseStream,The method has 5 parameters. Parameters: stream' compressionMode' level' wantRfc1950Header' leaveOpen
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,,The length of the parameter SourceSpatialReferenceProperty is 30.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,,The length of the parameter FeaturePlacemarkerDescriptorProperty is 36.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryRecordSignature is 41.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryLocatorSignature is 42.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter EndOfCentralDirectorySignature is 30.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter ZipEntryDataDescriptorSignature is 31.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,,The length of the parameter _TrimVolumeFromFullyQualifiedPaths is 34.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The length of the statement  "							if ((!string.IsNullOrEmpty(row[j])) && double.IsNaN(x) && ((!string.IsNullOrEmpty(XFieldName) && XFieldName == headers[j]) || " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The length of the statement  "							else if ((!string.IsNullOrEmpty(row[j])) && double.IsNaN(y) && ((!string.IsNullOrEmpty(YFieldName) && YFieldName == headers[j]) || " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,SetStream,The length of the statement  "						if (col.EndsWith("\""' StringComparison.InvariantCultureIgnoreCase) && !col.EndsWith("\\\""' StringComparison.InvariantCultureIgnoreCase) && col.Length != 1) " is 157.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The length of the statement  "			double lon2 = lon1 + Math.Atan2(Math.Sin(brng) * Math.Sin(dR) * Math.Cos(lat1)' Math.Cos(dR) - Math.Sin(lat1) * Math.Sin(lat2)); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateLocation,The length of the statement  "				MapPoint newLocation = new ESRI.ArcGIS.Client.Geometry.MapPoint(GeoCoordinate.Longitude' GeoCoordinate.Latitude) { SpatialReference = new SpatialReference(4326) }; " is 163.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The length of the statement  "					matrix[i * width + j] = (ushort)Math.Max((size - (Math.Sqrt(Math.Pow(i - size + 1' 2) + Math.Pow(j - size + 1' 2))))' 0); " is 121.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,OnMapChanged,The length of the statement  "            ResetRefreshTimer();  // stopping the timer when newmap is null allows to avoid memory leak when the layer is removed from the map " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Initialize,The length of the statement  "				if (!_visibleLayerIds.Contains(0)) // FolderIds 0 is the layer itself (Note : we can't test here the top folder visibility (folderid=1) since the kml document has not been parsed yet' so _hasRootContainer is not initialized yet) " is 228.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GenerateVisibilityIDs,The length of the statement  "			// Then go recursively through the sublayers and  concat with  the visible IDs of the sublayers (but don't go through the hierarchy for networklinks (i.e. _isRoot)) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GenerateVisibilityIDs,The length of the statement  "			return ownIDs.Concat(ChildLayers.OfType<KmlLayer>().SelectMany(InternalGenerateVisibilityIDs)).ToArray(); // ToArray freezes the result " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,InternalGenerateVisibilityIDs,The length of the statement  "			// For NetworkLinks (i.e. _isRoot)' don't go through the hierarchy and return an empty enumeration (Network links visibility is not managed by arcgis.com) " is 154.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,InternalGenerateVisibilityIDs,The length of the statement  "			// Create an enumeration either empty (if the layer is not visible) or containing the current ID (if the layer is visible) " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "				_hasRootContainer = _isRoot && fd.hasRootContainer; // the root container has been collapsed (info needed to generate internal folderIDs) " is 137.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "					// VisibleLayerIds is set --> layer created from a web map --> check that the layer must stay visible (_hasRootContainer is set only after the file has been parsed) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "					if (_hasRootContainer && !_visibleLayerIds.Contains(1)) // FolderIds 1 is the top level folder that may not be visible in SL " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "					// Note : use internal constructor' so properties such as MapTip' ProxyUrl' VisibleLayers.. are reported to the children " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "						kmlLayer.Visible = _visibleLayerIds != null ? _visibleLayerIds.Contains(kmlLayer._folderId) : IsContainerVisible(fullPath' container.Visible); " is 142.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetBaseUri,The length of the statement  "			return GetParentsAndSelf(this).Select(l => l.Url).FirstOrDefault(u => u != null); // Go up the hierarchy and return the first Url " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsContainerVisible,The length of the statement  "			// look for a wildcard defined at a sublevel  (e.g. VisibleLayers="myFolder/*" makes visible all paths beginning by myFolder/) " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsContainerVisible,The length of the statement  "			IEnumerable<string> subpaths = path.Select((c' ind) => c == '/' ? path.Substring(0' ind) : null).Where(subpath => subpath != null); " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,AssignFolderIDs,The length of the statement  "				// store the folderID as attribute of the in memory XML document' so the info is available when parsing the documents or folders " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,NeedNumericId,The length of the statement  "				bool isCandidate = name == "BalloonStyle" || name == "LineStyle" || name == "IconStyle" || name == "Icon" || name == "LookAt" " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsInRegion,The length of the statement  "			return !(lod < RegionInfo.MinLodPixels || (lod > RegionInfo.MaxLodPixels && RegionInfo.MaxLodPixels != -1)); // Keep ! to take care of NaN " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,SetResolutionRange,The length of the statement  "				foreach (var layer in ChildLayers.Where(l => !(l is KmlLayer) || (l as KmlLayer).Url == null)) // Eliminate the networklinks from the list " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectAsync,The length of the statement  "				var result = graphics.Where(g => g != null).Select(g => new Graphic {Geometry = Project(g.Geometry' outSpatialReference)}); " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfos,The length of the statement  "			return (layers.Elements(XName.Get("Layer"' ns)).Select(layer => CreateLayerInfo(layer' ns' inheritedAttribution)).ToList()); " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "			layerInfo.Abstract = layer.Element(XName.Get("Abstract"' ns)) == null ? null : layer.Element(XName.Get("Abstract"' ns)).Value; " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "			var attribution = layer.Element(XName.Get("Attribution"' ns)) == null ? null : layer.Element(XName.Get("Attribution"' ns)); " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "				layerInfo.Attribution.Title = attribution.Element(XName.Get("Title"' ns)) == null ? inheritedAttribution : attribution.Element(XName.Get("Title"' ns)).Value; " is 157.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The length of the statement  "				SupportedImageFormats = new ReadOnlyCollection<string>(new List<string>(from c in formats where c.Value != null select c.Value)); " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The length of the statement  "			_useCrsFormat = new List<int>{4326' 4269' 4267}; // initialize with all wkid that supports crs and remove from the list when an EPSG:xxxx format is supported (prefered format for backward compatibility reason) " is 209.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("minx") == null ? double.MinValue : double.Parse(element.Attribute("minx").Value' CultureInfo.InvariantCulture)' " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("miny") == null ? double.MinValue : double.Parse(element.Attribute("miny").Value' CultureInfo.InvariantCulture)' " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("maxx") == null ? double.MaxValue : double.Parse(element.Attribute("maxx").Value' CultureInfo.InvariantCulture)' " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("maxy") == null ? double.MaxValue : double.Parse(element.Attribute("maxy").Value' CultureInfo.InvariantCulture) " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "				envelope = useLatLon ? new Envelope(extent.YMin' extent.XMin' extent.YMax' extent.XMax) { SpatialReference = sref } : extent; " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "			bool useCrsFormat = _useCrsFormat != null && _useCrsFormat.Contains(extentWKID); // Need to use CRS:xx format ==> x'y order " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "			onComplete(Utilities.PrefixProxy(ProxyUrl' mapURL.ToString()).AbsoluteUri' new ImageResult(new ESRI.ArcGIS.Client.Geometry.Envelope() " is 133.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnTokenPropertyChanged,The length of the statement  "			// if the token has changed and if the initialization is on the way or has failed --> initialize again the layer with the new token " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnTokenPropertyChanged,The length of the statement  "			// if the initialization was OK with the previous token --> nothing to do since we assume that the token doesn't change the metadata " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "				TileMatrixLimitsInfo tileMatrixLimits = CurrentTileMatrixSetLink == null ? null : CurrentTileMatrixSetLink.TileMatrixLimits.FirstOrDefault(tml => tml.TileMatrix == matrix.Identifier); " is 183.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "					if (CurrentTileMatrixSetLink != null && CurrentTileMatrixSetLink.TileMatrixLimits.Any()) // some limits are specified --> no limits for one level means no tile for this level " is 174.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "				string resourceTemplateUrl = CurrentLayer.ResourceUrls.Where(r => r.Format == ImageFormat && r.ResourceType == "tile").Select(r => r.Template).FirstOrDefault(); " is 160.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentDimensionValues,The length of the statement  "					WmtsDimensionValue wmtsDimensionValue = DimensionValues == null ? null : DimensionValues.FirstOrDefault(dv => dv.Identifier == dimensionInfo.Identifier); " is 153.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetTileInfo,The length of the statement  "			if (CurrentTileMatrixSet.Matrices.Any(tm => tm.TileWidth != tileWidth || tm.TileHeight != tileHeight || !tm.TopLeftCorner.Equals(topLeftCorner))) " is 145.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetTileInfo,The length of the statement  "				matrices = CurrentTileMatrixSetLink.TileMatrixLimits.Join(CurrentTileMatrixSet.Matrices' tmsl => tmsl.TileMatrix' m => m.Identifier' (tmsl' m) => m); " is 149.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ConvertToResolution,The length of the statement  "			// GetScale for a map resolution of 1 (i.e one map unit by pixel) gives the number of pixels by map unit of the specified SR " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseCapabilities,The length of the statement  "				LayerInfos = contents.Elements(XName.Get("Layer"' ns)).Select(layerElement => ParseLayer(layerElement' owsns.NamespaceName' ns)).ToList(); " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseCapabilities,The length of the statement  "				TileMatrixSets = contents.Elements(XName.Get("TileMatrixSet"' ns)).Select(elt => ParseTileMatrixSet(elt' owsns.NamespaceName' ns)).ToList(); " is 140.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "				Formats = layerElement.Elements(XName.Get("Format"' nsname)).Select(formatElement => formatElement.GetValue()).ToList()' " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "				TileMatrixSetLinks = layerElement.Elements(XName.Get("TileMatrixSetLink"' nsname)).Select(element => ParseTileMatrixSetLink(element' nsname)).ToList()' " is 151.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSetLink,The length of the statement  "			                                                     	: tileMatrixSetLimitsElement.Elements(XName.Get("TileMatrixLimits"' nsname)).Select(elt => ParseTileMatrixLimits(elt' nsname)); " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The length of the statement  "				Matrices = element.Elements(XName.Get("TileMatrix"' nsname)).Select(elt => ParseTileMatrix(elt' owsnsname' nsname)).ToList() " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The length of the statement  "			tileMatrixSet.Extent = ParseEnvelope(element.Element(XName.Get("BoundingBox"' owsnsname))' tileMatrixSet.SpatialReference' owsnsname); " is 134.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,XPathSelectElement,The length of the statement  "					element = element.Elements(XName.Get(eltName' ns.NamespaceName)).Where(elt => elt.GetAttributeValue(XName.Get(attName)) == value).FirstOrDefault(); " is 147.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The length of the statement  "			var defaultIconSource = new MemoryStream(Convert.FromBase64String("iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAMAAAARSr4IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA9QTFRF/xkAkpOSzMzMAAAA////5g9v4AAAADFJREFUeNpiYEQBDIwsCMDETDqXgQGCYbIMDCAeQjGYh0MWXS+5zmBCAswMzCgAIMAAMR8Cl/k132AAAAAASUVORK5CYII=")); " is 299.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The length of the statement  "			UniqueValueRenderer renderer = new UniqueValueRenderer(); // dummy renderer used to create the legend items (since creation of the swatches from the symbol is not that obvious)  " is 176.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The length of the statement  "						ComputeIconTranslationValues(style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage); " is 154.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,UpdateGraphicsAndRenderer,The length of the statement  "					ComputeIconTranslationValues(f.Symbol.style' graphic.Symbol as KmlPlaceMarkerSymbol' ((graphic.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage); " is 175.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "                    // If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "					uiElement.RenderTransform = new RotateTransform {Angle = -feature.Rotation}; // KML rotations are specified in a counterclockwise direction " is 139.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "				// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale) " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			// Process the styles if they are not already known (the styles are shared by all folders/documents' so process them only once) " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "				IEnumerable<XElement> styles = xElement.Descendants().Where(e => e.Name.LocalName == "Style" && (string)e.Attribute("id") != null); " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "				IEnumerable<XElement> styleMaps = xElement.Descendants().Where(e => e.Name.LocalName == "StyleMap" && (string)e.Attribute("id") != null); " is 137.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			foreach (XElement container in xElement.Elements().Where(element => element.Name.LocalName == "Folder" || element.Name.LocalName == "Document" || element.Name.LocalName == "NetworkLink")) " is 187.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			foreach (XElement element in xElement.Elements().Where(element => element.Name == kmlNS + "Placemark" || element.Name == kmlNS + "GroundOverlay" )) " is 147.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "					GetStyleUrlAsync(styleElement.Value' null' credentials' kmlStyle => CreateFeatureDefinition(kmlStyle' featureElement' null' context) " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			// At this point' some inner styles are possibly on the way to being downloaded and so the feature definitions are not created yet " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "				// Avoid useless level when there is no groundoverlay' no placemark and only one folder or document at the root level without any lod info " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,StyleDownloaded,The length of the statement  "				GetStyleUrlAsync(state.StyleId' xDoc' state.Credentials' kmlStyle => StoreZipfileAndCallback(kmlStyle' state.Callback' zipFile) " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The length of the statement  "				// kmlStyle is null when the placemark doesn't reference any shared style (or a shared style that we are not able to download) " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractCoordinate,The length of the statement  "                    if (double.TryParse(xy[0]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out x) && double.TryParse(xy[1]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out y)) " is 209.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The length of the statement  "				// If there is no starting # and no KML doc referenced' we search also in current KML file (may happen that the # is missing in some KML doc) " is 141.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The length of the statement  "						XElement style = xDoc.Descendants().FirstOrDefault(e => e.Name.LocalName == "Style" && (string)e.Attribute("id") == styleId); " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,GetCrc32AndCopy,The length of the statement  "                    //    _RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table[(buffer[i]) ^ ((_RunningCrc32Result) & 0x000000FF)]; " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The length of the statement  "            if (day <= 0) { day = 1; } // ArcGIS server returns 0x0020 as date : not sure of the meaning (winzip displays the current date) " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00)); " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800)); " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                    throw new BadReadException(String.Format("  ZipEntry::ReadDirEntry(): Bad signature (0x{0:X8}) at position 0x{1:X8}"' signature' s.Position)); " is 142.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "            zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256); " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                zde._LocalFileName = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.Utf8StringFromBuffer(block' block.Length); " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                zde._LocalFileName = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.StringFromBuffer(block' block.Length' expectedEncoding); " is 140.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                    zde._Comment = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.Utf8StringFromBuffer(block' block.Length); " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                    zde._Comment = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.StringFromBuffer(block' block.Length' expectedEncoding); " is 134.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The length of the statement  "                    throw new BadReadException(String.Format("  ZipEntry::ReadHeader(): Bad signature (0x{0:X8}) at position  0x{1:X8}"' signature' ze.ArchiveStream.Position)); " is 156.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The length of the statement  "                //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position)); " is 196.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The length of the statement  "                    long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature); " is 150.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_ExtractOne,The length of the statement  "                ? new ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.DeflateStream(input2' ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.CompressionMode.Decompress' true) " is 155.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead)); " is 145.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead)); " is 168.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead)); " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead)); " is 157.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead)); " is 169.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The length of the statement  "                throw new BadReadException(String.Format("  ZipFile::Read(): Bad signature (0x{0:X8}) looking for ZIP64 EoCD Record at position 0x{1:X8}"' datum' s.Position)); " is 159.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,VerifyBeginningOfZipFile,The length of the statement  "                throw new BadReadException(String.Format("  ZipFile::Read(): Bad signature (0x{0:X8}) at start of file at position 0x{1:X8}"' datum' s.Position)); " is 146.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The length of the statement  "                throw new BadReadException(String.Format("  ZipFile::Read(): Bad signature ({0:X8}) at position 0x{1:X8}"' signature' s.Position)); " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Extract,The length of the statement  "                throw new ZipException("Cannot extract."' new ArgumentException("The OutputStream must be a writable stream."' "outputStream")); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Extract,The length of the statement  "                throw new ZipException("Cannot extract."' new ArgumentException("The file name must be neither null nor empty."' "fileName")); " is 126.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The conditional expression  "(!string.IsNullOrEmpty(row[j])) && double.IsNaN(x) && ((!string.IsNullOrEmpty(XFieldName) && XFieldName == headers[j]) ||  								(string.IsNullOrEmpty(XFieldName) && LON_FIELDS.Contains(headers[j].ToLowerInvariant())))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The conditional expression  "(!string.IsNullOrEmpty(row[j])) && double.IsNaN(y) && ((!string.IsNullOrEmpty(YFieldName) && YFieldName == headers[j]) ||  								(string.IsNullOrEmpty(YFieldName) && LAT_FIELDS.Contains(headers[j].ToLowerInvariant())))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The conditional expression  "(!string.IsNullOrEmpty(XFieldName) && XFieldName == headers[i]) ||                          (string.IsNullOrEmpty(XFieldName) && LON_FIELDS.Contains(headers[i].ToLowerInvariant()))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The conditional expression  "(!string.IsNullOrEmpty(YFieldName) && YFieldName == headers[i]) ||                                  (string.IsNullOrEmpty(YFieldName) && LAT_FIELDS.Contains(headers[i].ToLowerInvariant()))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,TryStartGps,The conditional expression  "permission && Visible && Map != null && IsEnabled && GeoPositionWatcher != null"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,TryStartGps,The conditional expression  "result && GeoPositionWatcher != null && GeoPositionWatcher.Position != null &&  				GeoPositionWatcher.Position.Location != null && !GeoPositionWatcher.Position.Location.IsUnknown"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateLocation,The conditional expression  "Map != null && Map.SpatialReference != null && GeoCoordinate != null && GeoCoordinate != GeoCoordinate.Unknown"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateRing,The conditional expression  "!double.IsNaN(Radius) && Radius > 0 && Center != null && PointCount > 2"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,GetSource,The conditional expression  "p.X >= extent2.XMin && p.Y >= extent2.YMin &&  						p.X <= extent2.XMax && p.Y <= extent2.YMax"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,RefreshOnRegionAsync,The conditional expression  "map == null || !NeedRefreshOnRegion || _isLoading || _isLoaded"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The conditional expression  "SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnUrlPropertyChanged,The conditional expression  "!SkipGetCapabilities && (IsInitialized || _initializing) && !string.IsNullOrEmpty(newUrl)"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The conditional expression  "CurrentTileMatrixSet == null || CurrentLayer == null || CurrentTileMatrixSet.Matrices == null ||  					level < 0 || CurrentTileMatrixSet.Matrices.Count() <= level"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The conditional expression  "row < minTileRow || row > maxTileRow || col < minTileCol || col > maxTileCol"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The conditional expression  "map != null && map.SpatialReference != null && IsWebMercator(map.SpatialReference)  					&& envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The conditional expression  "!featureDefs.groundOverlays.Any() && !featureDefs.placemarks.Any() && singleContainer != null && folderId == 0  				&& (singleContainer.RegionInfo == null || !singleContainer.RegionInfo.HasLods())   				&& string.IsNullOrEmpty(singleContainer.Url) && singleContainer.TimeExtent ==  null"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractLatLonBox,The conditional expression  "north.HasValue && south.HasValue && east.HasValue && west.HasValue"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The conditional expression  "(_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,VerifyBeginningOfZipFile,The conditional expression  "datum != ZipConstants.PackedToRemovableMedia  // weird edge case                  && datum != ZipConstants.ZipEntrySignature   // normal BOF marker                  && datum != ZipConstants.EndOfCentralDirectorySignature  // for zip file with no entries                  && (datum & 0x0000FFFF) != 0x00005A4D"  is complex.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetKmzContents,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetValidVersionNumber,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,LowerThan13Version,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetValidVersionNumber,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetIconImage,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,ReadSignature,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZlibBaseStream,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZlibStream.cs,Close,The method has an empty catch block.
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvLayer,The following statement contains a magic number: SourceSpatialReference = new SpatialReference(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRss.cs,loader_LoadCompleted,The following statement contains a magic number: this.SpatialReference = new Geometry.SpatialReference(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: g = new MapPoint(x' y' new SpatialReference(4326));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: Polygon poly = new Polygon() { SpatialReference = new SpatialReference(4326) };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(-180' -90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(-180' -90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(180' -90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(180' -90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(180' 90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(180' 90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(-180' 90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(-180' 90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(-180' -90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: pnts.Add(new MapPoint(-180' -90));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: double lat = LatitudeAtLongitude(lastPoint' p' sign * -180);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: pnts.Add(new MapPoint(sign * -180' lat));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: pnts.Add(new MapPoint(sign * 180' lat));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: Math.Abs(p.X - lastPoint.X) > 180
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lon1 = p1.X / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lon2 = p2.X / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lat1 = p1.Y / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lat2 = p2.Y / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: lon = lon / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: return Math.Atan((Math.Sin(lat1) * Math.Cos(lat2) * Math.Sin(lon - lon2)  	 - Math.Sin(lat2) * Math.Cos(lat1) * Math.Sin(lon - lon1)) / (Math.Cos(lat1) * Math.Cos(lat2) * Math.Sin(lon1 - lon2)))  			/ Math.PI * 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double brng = heading / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lon1 = start.X / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lat1 = start.Y / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double dR = distance / 6378137;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lon = lon2 / Math.PI * 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lat = lat2 / Math.PI * 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lon += 360;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lon < -180
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lat += 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lat < -90
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lon -= 360;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lon > 180
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lat -= 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: lat > 90
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: animationTimerLocation.Interval = TimeSpan.FromMilliseconds(33);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: animationTimerAccuracy.Interval = TimeSpan.FromMilliseconds(33);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,TryStartGps,The following statement contains a magic number: result = GeoPositionWatcher.TryStart(true' TimeSpan.FromSeconds(10));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateAccuracyCircle,The following statement contains a magic number: GeoCoordinate == null || double.IsNaN(GeoCoordinate.HorizontalAccuracy) || GeoCoordinate.HorizontalAccuracy < 15
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateLocation,The following statement contains a magic number: MapPoint newLocation = new ESRI.ArcGIS.Client.Geometry.MapPoint(GeoCoordinate.Longitude' GeoCoordinate.Latitude) { SpatialReference = new SpatialReference(4326) };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnitsFromScale,The following statement contains a magic number: var resInMeters = (96 * resolution) / scale * 39.3700787;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnitsFromScale,The following statement contains a magic number: var resInMeters = (96 * resolution) / scale * 39.3700787;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetMapUnits,The following statement contains a magic number: Map.SpatialReference.WKID == 4326
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetMapUnits,The following statement contains a magic number: Map.SpatialReference.Equals(new SpatialReference(102100))
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,Circle,The following statement contains a magic number: PointCount = 90;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateRing,The following statement contains a magic number: double rad = 2 * Math.PI / PointCount * i;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateRing,The following statement contains a magic number: !double.IsNaN(Radius) && Radius > 0 && Center != null && PointCount > 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add(new GradientStop() { Color = Colors.Blue' Offset = .5 });
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add(new GradientStop() { Color = Colors.Red' Offset = .75 });
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add(new GradientStop() { Color = Colors.Yellow' Offset = .8 });
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,OnIntensityPropertyChanged,The following statement contains a magic number: dp.timer = new System.Windows.Threading.DispatcherTimer() { Interval = TimeSpan.FromMilliseconds(50) };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: int height = (int)args[2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: int size = (int)args[3];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: List<ThreadSafeGradientStop> stops = (List<ThreadSafeGradientStop>)args[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: List<HeatPoint> points = (List<HeatPoint>)args[5];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: OnImageComplete onComplete = (OnImageComplete)args[6];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: size = size * 2 + 1;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: max = 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: max < 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: worker.ReportProgress((idx + 1) * 100 / height);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: int height = (int)result[2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: Envelope extent = (Envelope)result[3];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: OnImageComplete onComplete = (OnImageComplete)result[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: int stride = width * (pf.BitsPerPixel / 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: BitmapSource image = BitmapSource.Create(width' height' 96' 96' pf' palette' (int[])result[0]' stride);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: BitmapSource image = BitmapSource.Create(width' height' 96' 96' pf' palette' (int[])result[0]' stride);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,InterpolateColor,The following statement contains a magic number: value < 1 / 255f
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: intensityMap[idx] += distanceMatrix[i * (size * 2 - 1) + j];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: j < size * 2 - 1
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: i < size * 2 - 1
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: int width = size * 2 - 1;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: ushort[] matrix = new ushort[(int)Math.Pow(width' 2)];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: matrix[i * width + j] = (ushort)Math.Max((size - (Math.Sqrt(Math.Pow(i - size + 1' 2) + Math.Pow(j - size + 1' 2))))' 0);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: matrix[i * width + j] = (ushort)Math.Max((size - (Math.Sqrt(Math.Pow(i - size + 1' 2) + Math.Pow(j - size + 1' 2))))' 0);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: Rectangle rect = new Rectangle() { Height = 20' Width = 20' Fill = brush };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: Rectangle rect = new Rectangle() { Height = 20' Width = 20' Fill = brush };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsStreamCompressed,The following statement contains a magic number: headerSignature == 67324752
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: !spatialReference.Equals(new SpatialReference(102100)) && !spatialReference.Equals(new SpatialReference(4326))
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: !spatialReference.Equals(new SpatialReference(102100)) && !spatialReference.Equals(new SpatialReference(4326))
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: var webMercatorSR = new SpatialReference(102100);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: var wgs84SR = new SpatialReference(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectAsync,The following statement contains a magic number: outSpatialReference == null ||  				outSpatialReference.WKID != 4326 &&  				!outSpatialReference.Equals(MercatorSref)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Project,The following statement contains a magic number: var toMercator = outSpatialReference.WKID != 4326;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Project,The following statement contains a magic number: toMercator && geometry.SpatialReference.WKID == 4326
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo  			{  				Height = 256'  				Width = 256'  				Origin = new MapPoint(-CornerCoordinate' CornerCoordinate) { SpatialReference = SpatialReference }'  				SpatialReference = SpatialReference'  				Lods = new Lod[19]  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo  			{  				Height = 256'  				Width = 256'  				Origin = new MapPoint(-CornerCoordinate' CornerCoordinate) { SpatialReference = SpatialReference }'  				SpatialReference = SpatialReference'  				Lods = new Lod[19]  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo  			{  				Height = 256'  				Width = 256'  				Origin = new MapPoint(-CornerCoordinate' CornerCoordinate) { SpatialReference = SpatialReference }'  				SpatialReference = SpatialReference'  				Lods = new Lod[19]  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: double resolution = CornerCoordinate * 2 / 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: double resolution = CornerCoordinate * 2 / 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: resolution /= 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int>{4326' 4269' 4267};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int>{4326' 4269' 4267};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int>{4326' 4269' 4267};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat.Remove(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: extentWKID = 3857;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: SupportedSpatialReferenceIDs.Contains(3857)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,UseLatLon,The following statement contains a magic number: int length = LatLongCRSRanges.Length / 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: wkid == 4326
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: wkid == 4269
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: wkid == 4267
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const double inchesPerMeter = 10000.0 / 254.0;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const double inchesPerMeter = 10000.0 / 254.0;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const double sqrt2 = 1.4142;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const int dpi = 96;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,UseLatLon,The following statement contains a magic number: int length = _latLongCrsRanges.Length / 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The following statement contains a magic number: useLatLon = tileMatrixSet.Matrices.First().TopLeftCorner.Y < -2E7;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The following statement contains a magic number: tileMatrixSet.SpatialReference.WKID == 3857
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetMapPoint,The following statement contains a magic number: points.Count() != 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: WKID = 3857;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: WKID == 900913
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Gps,GpsSymbol,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsSymbol.cs,GpsSymbol,The following statement contains a magic number: Size = 20;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconHotspotX = 0.5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconHotspotY = 0.5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The following statement contains a magic number: return new KmlPlaceMarkerSymbol() { Height = 40' Width = 40' Fill = new ImageBrush() { ImageSource = bmp } };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The following statement contains a magic number: return new KmlPlaceMarkerSymbol() { Height = 40' Width = 40' Fill = new ImageBrush() { ImageSource = bmp } };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: ms.Height = 40;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: ms.Width = 40;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: uiElement.RenderTransformOrigin = new Point(0.5' 0.5);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: uiElement.RenderTransformOrigin = new Point(0.5' 0.5);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: map != null && map.SpatialReference != null && IsWebMercator(map.SpatialReference)  					&& envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following statement contains a magic number: ms.Height = 40;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following statement contains a magic number: ms.Width = 40;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,DownloadStyleAsync,The following statement contains a magic number: tokens.Length == 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following statement contains a magic number: fd.Geometry.SpatialReference = new SpatialReference(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractEnvelope,The following statement contains a magic number: return north.HasValue && south.HasValue && east.HasValue && west.HasValue  			       	? new Envelope(west.Value' south.Value' east.Value' north.Value) { SpatialReference = new SpatialReference(4326)}  			       	: null;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractCoordinate,The following statement contains a magic number: xy.Length >= 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: int numIcon = 8 * (7 - y/32) + x/32;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: int numIcon = 8 * (7 - y/32) + x/32;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: int numIcon = 8 * (7 - y/32) + x/32;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: int numIcon = 8 * (7 - y/32) + x/32;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: s.Length == 8
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtentFromDate,The following statement contains a magic number: strsDate.Length > 2 && !int.TryParse(strsDate[2]' out day)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtentFromDate,The following statement contains a magic number: strsDate.Length > 2 && !int.TryParse(strsDate[2]' out day)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,ComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,SlurpBlock,The following statement contains a magic number: _RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table[(block[x]) ^ ((_RunningCrc32Result) & 0x000000FF)];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,CRC32,The following statement contains a magic number: crc32Table = new UInt32[256];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,CRC32,The following statement contains a magic number: i < 256
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: k < (20)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: k < (15)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: c -= 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: q - r > 0 && 2 > (q - r)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: t += tp[tp_index_t_3 + 2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 64) == 0
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Sync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Sync,The following statement contains a magic number: m != 4
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: r[2] = (int) (q - u[h - 1] - j);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea(19);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result != Z_OK || (bd[0] == 0 && nl > 257)
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,initWorkArea,The following statement contains a magic number: r = new int[3];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,initWorkArea,The following statement contains a magic number: i < 3
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,RoundToEvenSecond,The following statement contains a magic number: (source.Second % 2) == 1
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,TrimVolumeAndSwapSlashes,The following statement contains a magic number: pathName.Length < 2
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,TrimVolumeAndSwapSlashes,The following statement contains a magic number: return (((pathName[1] == ':') && (pathName[2] == '\\')) ? pathName.Substring(3) : pathName)                  .Replace('\\'' '/');
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,TrimVolumeAndSwapSlashes,The following statement contains a magic number: return (((pathName[1] == ':') && (pathName[2] == '\\')) ? pathName.Substring(3) : pathName)                  .Replace('\\'' '/');
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: byte[] block = new byte[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: int BATCH_SIZE = 65536;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: byte[] targetBytes = new byte[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[0] = (byte)(SignatureToFind >> 24);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[1] = (byte)((SignatureToFind & 0x00FF0000) >> 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[3] = (byte)(SignatureToFind & 0x000000FF);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: batch[i] == targetBytes[3]
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: long bytesRead = (stream.Position - startingPosition) - 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: return new System.DateTime(1995' 1' 1' 0' 0' 0' 0);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: Int16 packedDate = (Int16)((packedDateTime & 0xffff0000) >> 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int month = (packedDate & 0x01E0) >> 5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int hour = (packedTime & 0xF800) >> 11;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int minute = (packedTime & 0x07E0) >> 5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int second = (packedTime & 0x001F) * 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: second >= 60
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: minute >= 60
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: hour >= 24
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: Int32 result = (Int32)(((UInt32)(packedDate << 16)) | packedTime);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GetTempFilename,The following statement contains a magic number: candidate = "DotNetZip-" + GenerateRandomStringImpl(8' 97) + ".tmp";
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GetTempFilename,The following statement contains a magic number: candidate = "DotNetZip-" + GenerateRandomStringImpl(8' 97) + ".tmp";
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GenerateRandomStringImpl,The following statement contains a magic number: delta = (_rnd.Next(2) == 0) ? 65 : 97;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GenerateRandomStringImpl,The following statement contains a magic number: delta = (_rnd.Next(2) == 0) ? 65 : 97;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GenerateRandomStringImpl,The following statement contains a magic number: delta = (_rnd.Next(2) == 0) ? 65 : 97;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GetOneRandomChar,The following statement contains a magic number: return (char)(_rnd.Next(26) + delta);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SharedUtils.URShift((dist)' 7))]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SharedUtils.URShift((dist)' 7))]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SharedUtils.URShift((dist)' 7))]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,gen_codes,The following statement contains a magic number: tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: byte[] block = new byte[42];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionMadeBy = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionNeeded = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._BitField = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressionMethod = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._commentLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: i += 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._InternalFileAttrs = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedFileDataSize -= 12;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: bytesRead += 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze.ArchiveStream.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: byte[] block = new byte[26];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._VersionNeeded = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._BitField = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressionMethod = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: block = new byte[20];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: n != 20
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._LengthOfTrailer += 24;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: SizeOfDataRead += 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._WeakEncryptionHeader = new byte[12];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedFileDataSize -= 12;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: int additionalBytesRead = s.Read(buffer' 0' 12);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: additionalBytesRead != 12
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,Read,The following statement contains a magic number: int DescriptorSize = (entry._InputUsesZip64) ? 24 : 16;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,Read,The following statement contains a magic number: int DescriptorSize = (entry._InputUsesZip64) ? 24 : 16;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,HandlePK00Prefix,The following statement contains a magic number: s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: blockZip64 = new byte[4 + 28];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: blockZip64 = new byte[4 + 28];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: s1 = SlashFixed.Substring(3);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: (_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: (_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: commentEncoding.CodePage == 437
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: j += 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: j = start + DataSize + 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: this._LengthOfHeader = 30 + extraFieldLength + filenameLength;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: this.__FileDataPosition = _RelativeOffsetOfLocalHeader + 30 + filenameLength + extraFieldLength;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: this.__FileDataPosition += 12;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: long posn = s.Length - 64;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: long maxSeekback = Math.Max(s.Length - 0x4000' 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: byte[] block = new byte[16];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: int i = 12;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: byte[] block = new byte[16];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Seek(-40' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: Int64 Offset64 = BitConverter.ToInt64(block' 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: Offset64 = BitConverter.ToInt64(block' 36);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[8 + 44];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[8 + 44];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: DataSize < 44
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i = 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: i += 8;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[DataSize - 44];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[16];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[16];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadZipFileComment,The following statement contains a magic number: byte[] block = new byte[2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadZipFileComment,The following statement contains a magic number: Int16 commentLength = (short)(block[0] + block[1] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: long s2 = (adler >> 16) & 0xffff;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: k -= 16;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: k >= 16
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The following switch statement is missing a default case: switch (expectedValueType)  			{  				case Field.FieldType.Date:  					if (!(valueObject is DateTime))  					{  						try  						{  							if (valueObject is string)  							{                                        string str_date = ((string)valueObject).ToLower();                                  if (str_date.Contains("utc"))                                  {                                      str_date = str_date.Replace("utc"' "");                                      result = DateTime.Parse((string)str_date' numericCulture' DateTimeStyles.AssumeUniversal);                                  }                                  else                                      result = DateTime.Parse((string)valueObject' numericCulture);  							}  							else  							{  								long time = 0;  								if (valueObject.GetType() == typeof(long)) time = (long)valueObject;  								else if (valueObject.GetType() == typeof(int)) time = (int)valueObject;  								else time = Convert.ToInt64(valueObject' numericCulture);  								result = Epoch.AddMilliseconds((double)time);  							}  						}  						catch { }  					}  					break;  				case Field.FieldType.Double:  					if (valueObject.GetType() != typeof(double))  					{  						try { result = Convert.ToDouble(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.Single:  					if (valueObject.GetType() != typeof(float))  					{  						try { result = Convert.ToSingle(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.Integer:  					if (valueObject.GetType() != typeof(int))  					{  						try { result = Convert.ToInt32(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.SmallInteger:  					if (valueObject.GetType() != typeof(short))  					{  						try { result = Convert.ToInt16(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.GUID:  					if (valueObject.GetType() != typeof(Guid))  					{  						Guid output;  						var valueStr = Convert.ToString(valueObject' numericCulture);  						if (!string.IsNullOrEmpty(valueStr))  						{  							if (Guid.TryParse(valueStr' out output))  								result = output;  						}  					}  					break;  			}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following switch statement is missing a default case: switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,watcher_StatusChanged,The following switch statement is missing a default case: switch (e.Status)  			{  				case GeoPositionStatus.Disabled:  				case GeoPositionStatus.Initializing:  				case GeoPositionStatus.NoData:  					UpdateLocation();  					UpdateAccuracyCircle();  					GeoCoordinate = null;  					Position = null;  					break;  				case GeoPositionStatus.Ready:  					//  					break;  			}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetKmzContents,The following switch statement is missing a default case: switch (filename.Substring(lastPeriod).ToLower())                  {                      case ".jpg":                      case ".jpeg":                      case ".png":  #if !SILVERLIGHT                      case ".bmp":                      case ".gif":  #endif  						// If the file is an image' then add it to the dictionary of images and use                          // its filename as the key since this will match the subsequent KML style                          // information for point features.  						try  						{                              BitmapImage thumbnailBitmap = new BitmapImage();  #if SILVERLIGHT                              thumbnailBitmap.SetSource(ms);  #else                              thumbnailBitmap.BeginInit();                              thumbnailBitmap.StreamSource = ms;                              thumbnailBitmap.EndInit();  #endif                              ImageBrush ib = new ImageBrush();                              ib.ImageSource = thumbnailBitmap;                              _context.Images.Add(filename.ToLower()' ib);  						}  						catch { }                            break;                        case ".kml":                          // Create the XDocument object from the input stream  						xDoc = LoadDocument(ms);                          break;                    }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following switch statement is missing a default case: switch (style.IconHotspotUnitsX)              {                  case HotSpotUnitType.Pixels:                      ms.TranslateX = style.IconHotspotX * -1;                      break;                    case HotSpotUnitType.Fraction:                      ms.TranslateX = (ms.Width * style.IconHotspotX) * -1;                      break;              }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following switch statement is missing a default case: switch (style.IconHotspotUnitsY)              {                  case HotSpotUnitType.Pixels:                      ms.TranslateY = (ms.Height - style.IconHotspotY) * -1;                      break;                    case HotSpotUnitType.Fraction:                      ms.TranslateY = (ms.Height * style.IconHotspotY) * -1;                      break;              }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetKmzContents,The following switch statement is missing a default case: switch (filename.Substring(lastPeriod).ToLower())  				{  					case ".kml":  						// Create the XDocument object from the input stream  						xDoc = KmlLayer.LoadDocument(ms);  						break;  				}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following switch statement is missing a default case: switch (geomElement.Name.LocalName)  					{  						case "Point":  							fd = ExtractPoint(kmlStyle' geomElement);  							break;    						case "LineString":  							fd = ExtractPolyLine(kmlStyle' geomElement);  							break;    						case "LinearRing":  							fd = ExtractLinearRing(kmlStyle' geomElement);  							break;    						case "Polygon":  							fd = ExtractPolygon(kmlStyle' geomElement);  							break;    						case "MultiGeometry":  							foreach (XElement item in geomElement.Elements())  							{  								// Use recursion to walk the hierarchy of embedded definitions  								CreateFeatureDefinition(kmlStyle' feature' item' context);  							}  							break;    						case "LatLonBox":  							ExtractFeatureStyleInfo(kmlStyle' feature);  							fd = ExtractLatLonBox(kmlStyle' geomElement);  							break;  					}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following switch statement is missing a default case: switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,D:\research\architectureSmells\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following switch statement is missing a default case: switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }
