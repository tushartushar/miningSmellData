Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ReadHeader,The method has 153 lines of code.
Long Method,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,WriteHeader,The method has 122 lines of code.
Long Method,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The method has 253 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,OpenWrite,The method has 162 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,Update,The method has 146 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The method has 212 lines of code.
Complex Method,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Tar,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Remove,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Tar,TarredFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFile.cs,TarredFile,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Tar,TarredFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFolder.cs,TarredFolder,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ReadHeader,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,Cyclomatic complexity of the method is 29
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,OpenRead,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,OpenWrite,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,Update,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,UpdateItems,Cyclomatic complexity of the method is 15
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,Cyclomatic complexity of the method is 40
Complex Method,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,AddItem,Cyclomatic complexity of the method is 29
Complex Method,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Utils.Storage,StorageKeyComparer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageKeyComparer.cs,Compare,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamCopy.cs,Copy,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,StreamSearcher,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamSearcher.cs,FindImpl,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Streams,StreamSearcher,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamSearcher.cs,ReverseFindImpl,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,Cyclomatic complexity of the method is 8
Long Parameter List,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Tar,The method has 5 parameters.
Long Parameter List,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Tar,The method has 6 parameters.
Long Parameter List,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Tar,The method has 8 parameters.
Long Parameter List,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Tar,The method has 9 parameters.
Long Parameter List,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,The method has 7 parameters.
Long Parameter List,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,The method has 10 parameters.
Long Parameter List,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,The method has 7 parameters.
Long Parameter List,Xceed.Tar,TarredFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFile.cs,BuildList,The method has 6 parameters.
Long Parameter List,Xceed.Tar,TarredFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFolder.cs,BuildList,The method has 6 parameters.
Long Parameter List,Xceed.Tar,TarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorage.cs,ReadItem,The method has 5 parameters.
Long Parameter List,Xceed.Tar.Streaming,StreamingTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTar.cs,Untar,The method has 6 parameters.
Long Parameter List,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The method has 6 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,ReadItem,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,OnItemRead,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The method has 5 parameters.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Tar,The length of the statement  "	Tar (tarFileName' replaceExistingFiles' recursive' preservePaths' false' byteProgressionCallback' itemProgressionCallback' userParams' filesToTar); " is 147.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Tar,The length of the statement  "			List<FileSystemItem> fileSystemItemList = mg_quickTarCompression.CreateItemListFromPaths (tarArchive' true' filesToTar' recursive' notFilter); " is 142.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,The length of the statement  "	Untar (tarFileName' destinationFolder' replaceExistingFiles' recursive' preservePaths' isTarCompressed' null' null' null' filesToUntar); " is 136.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,The length of the statement  "			List<FileSystemItem> fileSystemItemList = mg_quickTarCompression.CreateItemListFromPaths (tarArchive' false' filesToUntar' recursive' notFilter); " is 145.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,Untar,The length of the statement  "		throw new QuickTarException ("An error occurred while extracting files from the tar file. See the InnerException property for details."' exception); " is 148.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,GetTarContents,The length of the statement  "		AbstractQuickActionItem[] abstractQuickItems = mg_quickTarCompression.GetFolderContents (tarArchive' recursive' filters); " is 121.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,GetTarContents,The length of the statement  "		quickTarItems = Array.ConvertAll (abstractQuickItems' new Converter<AbstractQuickActionItem' QuickTarItem> (ConvertToQuickTarItem)); " is 132.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,OnByteProgression,The length of the statement  "	byteProgressionCallback (currentItemName' e.CurrentFileBytes.Processed' e.CurrentFileBytes.Total' e.CurrentFileBytes.Percent' e.AllFilesBytes.Processed' e.AllFilesBytes.Total' e.AllFilesBytes.Percent' userParams); " is 213.
Long Statement,Xceed.Tar,QuickTar,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Quick)\QuickTar.cs,OnItemProgression,The length of the statement  "	itemProgressionCallback (currentItemName' e.AllItems.Processed' e.AllItems.Total' e.AllItems.Percent' ref abort' userParams); " is 125.
Long Statement,Xceed.Tar,TarredFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFile.cs,DoCreate,The length of the statement  "				throw new FileSystemInternalException ("An unexpected attempt was made to create an item in a folder that does not exist."' this); " is 130.
Long Statement,Xceed.Tar,TarredFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFolder.cs,DoCreate,The length of the statement  "				throw new FileSystemInternalException ("An unexpected attempt was made to create an item in a folder that does not exist."' this); " is 130.
Long Statement,Xceed.Tar,TarredFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFolder.cs,DoGetFile,The length of the statement  "		System.Diagnostics.Debug.Assert (fileName.IndexOf (Path.DirectorySeparatorChar.ToString ()) == -1' "The fileName parameter cannot end with a directory separator char."); " is 169.
Long Statement,Xceed.Tar,TarredFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFolder.cs,DoGetFolder,The length of the statement  "		System.Diagnostics.Debug.Assert (folderName.IndexOf (Path.DirectorySeparatorChar.ToString ()) == -1' "The folderName parameter cannot end with a directory separator char."); " is 173.
Long Statement,Xceed.Tar,TarredFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFolder.cs,DoGetFolder,The length of the statement  "		System.Diagnostics.Debug.Assert (folderName.Length > 0' "We return a new instance of ourself. We probably have an invalid foldername."); " is 136.
Long Statement,Xceed.Tar,TarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorage.cs,ReadItem,The length of the statement  "	TarStorageItem item = base.ReadItem (session' readItemsSession' source' spannedStream' ref endOfStorage) as TarStorageItem; " is 123.
Long Statement,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ComputeChecksum,The length of the statement  "	System.Diagnostics.Debug.Assert (headerStream.Length == TarStorageHandler.BlockSize' string.Format ("The header does not equal to {0} bytes in length."' TarStorageHandler.BlockSize)); " is 183.
Long Statement,Xceed.Tar,TarStorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItemHandler.cs,OnClosingWriteStream,The length of the statement  "	int padding = (TarStorageHandler.BlockSize - unchecked((int)(this.TarItem.Size % TarStorageHandler.BlockSize))) % TarStorageHandler.BlockSize; " is 142.
Long Statement,Xceed.Tar.Streaming,StreamingTarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorageItem.cs,SkipData,The length of the statement  "         working FileSystemItem for progression and information. */long dataSize = (long)TarStorageHandler.BlockSize * (long)this.DataBlockCount; " is 136.
Long Statement,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The length of the statement  "       * This should be easy when the ReferenceFile/ReferenceFolder engine is functional. */FileSystemItem fileSystemItem = null; " is 122.
Long Statement,Xceed.Utils.Exceptions,ExceptionFilter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Exceptions\ExceptionFilter.cs,IsPublicException,The length of the statement  "	exception is OutOfMemoryException || exception is System.Security.SecurityException || exception is UnauthorizedAccessException || exception is System.IO.PathTooLongException || exception is ArgumentException || exception is System.Reflection.TargetInvocationException); " is 270.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,SetBatchUpdateable,The length of the statement  "		MethodInfo getBatchUpdateableInfo = item.GetType ().GetProperty ("BatchUpdateable"' BindingFlags.NonPublic | BindingFlags.Instance).GetGetMethod (true); " is 152.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,DoAddWriteReference,The length of the statement  "           * one file' this will fail. But we're ready for this with the try/catch. */m_writingFile = m_matchingFile.ParentFolder.GetFile (m_originalName); " is 144.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,DoReleaseWriteReference,The length of the statement  "					throw new FileSystemIOException ("Though the changes may have been committed' the temporary file could not be deleted."' m_writingFile' except); " is 144.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,DoReleaseWriteReference,The length of the statement  "			throw new FileSystemIOException ("The temporary file could not be copied over its destination file."' m_writingFile' except); " is 125.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,AddWriteReference,The length of the statement  "		System.Diagnostics.Debug.Assert (m_writingRef == 1' "The current implementation does not support opening a file more than once for writing."); " is 142.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "		System.Diagnostics.Debug.Assert (m_writingRef == 1' "The current implementation does not support opening a file more than once for writing."); " is 142.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "								throw new FileSystemIOException ("Could not delete the temporary file while reverting changes."' m_writingFile' except); " is 120.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "								throw new FileSystemIOException ("Could not delete the temporary file while reverting changes. The original file could not be renamed to its original name."' m_writingFile' except); " is 181.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,OpenRead,The length of the statement  "					throw new FileSystemInternalException ("A non-seekable stream was open on a file' with a position already behind the target offset."); " is 134.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,The length of the statement  "                 * won't be able to be updated since we never know on which disk a footer is located */m_canUpdateInPlace &= /*item.AllowsUpdateInPlace &&*/(!this.IsSplitOrSpanned && !this.IsSplittingOrSpanning); " is 195.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,The length of the statement  "				m_canUpdateInPlace = m_canUpdateInPlace && ((location.HeaderSize == 0) || (location.HeaderSize == item.CurrentHeaderSize)); " is 123.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,OpenWrite,The length of the statement  "				System.Diagnostics.Debug.Fail ("OpenWrite should always write at the end of the file. The cached offset should match the end of the last item."); " is 145.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,UpdateItems,The length of the statement  "			System.Diagnostics.Debug.Fail ("This should not happen as we made sure this storage did not require an ending header and did not have invalid items."); " is 151.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The length of the statement  "				bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove); " is 132.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,BuildAddItemException,The length of the statement  "		message = String.Format ("{0} {1}\nItem: '{2}'. at {3}. Nearest item is {4}/{5}' '{6}' {{{7}}} at {8}."' message' section' item.FullName' item.Location' nearestIndex' this.m_items.Count' nearest.FullName' nearest.GetType ().Name' nearest.Location); " is 248.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,BuildAddItemException,The length of the statement  "		message = String.Format ("{0} {1}\nItem: '{2}'. at {3}. Nearest item not found. {4} total."' message' section' item.FullName' item.Location' this.m_items.Count); " is 161.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,GetItem,The length of the statement  "		System.Diagnostics.Debug.Assert (!itemHandler.IsRootFolder' "The root item should have been found by m_itemHandlers.Contains above."); " is 134.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,RenameItem,The length of the statement  "	System.Diagnostics.Debug.Assert (m_itemHandlers.ContainsKey (currentFullName)' "The itemHandler must not have been renamed yet."); " is 130.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,ReleaseReference,The length of the statement  "               decisions on whether to refresh or not later. *//* PERFORMANCE NOTE: I'd like to avoid making yet another call to Exists as it may" is 130.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageItemHandler.cs,AddChild,The length of the statement  "		System.Diagnostics.Debug.Assert (current.m_children.Count == child.m_children.Count' "A folder being replaced must be addressed by caller."); " is 141.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameChild,The length of the statement  "	System.Diagnostics.Debug.Assert (m_children.ContainsKey (currentFullName)' "The StorageHandler.GetItem mechanism should have populated item's children."); " is 154.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameChild,The length of the statement  "			string message = String.Format ("RenameChild() is attempting to replace an existing child <{0}> of state '{1}' with " + "another item. The existing child should either be not in the list or be unassigned or " + "have been discarded."' newFullName' state); " is 255.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameTo,The length of the statement  "		SortedList<string' StorageItemHandler> children = new SortedList<string' StorageItemHandler> (m_children' StringComparer.OrdinalIgnoreCase); " is 140.
Long Statement,Xceed.Utils.Streams,NotifyStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\NotifyStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("size"' size' "The size can be -1 for up to end-of-stream copy' or a value greater than 0."); " is 142.
Long Statement,Xceed.Utils.Streams,StreamSearcher,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamSearcher.cs,ReverseFindImpl,The length of the statement  "		if ((bytesRead = m_stream.Read (buffer' 0' (bytesLeftToRead < buffer.Length ? (int)bytesLeftToRead : buffer.Length))) > 0) { " is 124.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,Seek,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("origin"' origin' "The seek origin is not a valid SeekOrigin member."); " is 120.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,The length of the statement  "		throw new ArgumentOutOfRangeException ("count"' "The count parameter exceeds the buffer's remaining length after offset."); " is 123.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The length of the statement  "	/* TODO: Store 'currentLength' and supply it to EndWrite() *///long currentLength = ( m_innerStream.CanSeek && m_length != -1 ) ? m_innerStream.Length : 0; " is 155.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,CheckInnerStream,The length of the statement  "			throw new IOException ("The inner stream of the WindowStream has been accessed directly' preventing the WindowStream from working properly."); " is 142.
Virtual Method Call from Constructor,Xceed.Tar,TarredFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFile.cs,TarredFile,The constructor "TarredFile" calls a virtual method "CreateSession".
Virtual Method Call from Constructor,Xceed.Tar,TarredFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarredFolder.cs,TarredFolder,The constructor "TarredFolder" calls a virtual method "CreateSession".
Empty Catch Block,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The method has an empty catch block.
Empty Catch Block,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The method has an empty catch block.
Empty Catch Block,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The method has an empty catch block.
Empty Catch Block,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,SetBatchUpdateable,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,OpenWriteStorageFile,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,ReleaseReference,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,The method has an empty catch block.
Magic Number,Xceed.Tar,TarEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Events)\TarEventsSession.cs,OnReadingTarItemCompletion,The following statement contains a magic number: if ((m_tarEvents.WantsReadingTarItemProgression) && (m_readingTarItemProgressionArgs.AllItems.Processed > 0)) {  	System.Diagnostics.Debug.Assert (m_readingTarItemProgressionArgs.AllItems.Percent == 100);  	m_readingTarItemProgressionArgs.UserData = m_userData;  	try {  		m_tarEvents.OnReadingTarItemProgression (m_sender' m_readingTarItemProgressionArgs);  	}  	catch (Exception handlerException) {  		throw new System.Reflection.TargetInvocationException (handlerException);  	}  	m_readingTarItemProgressionArgs.CurrentItem = null;  	m_readingTarItemProgressionArgs.TargetItem = null;  	m_userData = m_readingTarItemProgressionArgs.UserData;  }  
Magic Number,Xceed.Tar,TarEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\(Events)\TarEventsSession.cs,OnReadingTarItemCompletion,The following statement contains a magic number: System.Diagnostics.Debug.Assert (m_readingTarItemProgressionArgs.AllItems.Percent == 100);  
Magic Number,Xceed.Tar,TarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorage.cs,ReadItem,The following statement contains a magic number: if ((item != null) && (item.IsEmpty)) {  	// Should we behave as the standard says or read the whole archive?  	if (!TarStorageHandler.IgnoreEndingHeaders) {  		if (++m_emptyHeaderCount >= 2)  			endOfStorage = true;  	}  	return null;  }  
Magic Number,Xceed.Tar,TarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorage.cs,ReadItem,The following statement contains a magic number: if (!TarStorageHandler.IgnoreEndingHeaders) {  	if (++m_emptyHeaderCount >= 2)  		endOfStorage = true;  }  
Magic Number,Xceed.Tar,TarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorage.cs,ReadItem,The following statement contains a magic number: if (++m_emptyHeaderCount >= 2)  	endOfStorage = true;  
Magic Number,Xceed.Tar,TarStorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageHandler.cs,GetStorageHandler,The following statement contains a magic number: lock (mg_tarHandlers.SyncRoot) {  	// Check if already in list and return reference.  	if (mg_tarHandlers.Contains (tarFile)) {  		WeakReference weakHandler = mg_tarHandlers [tarFile] as WeakReference;  		if (weakHandler == null) {  			System.Diagnostics.Debug.Fail ("The WeakReference's Target can become null' but the ref itself shouldn't.");  			// Clean up!  			mg_tarHandlers.Remove (tarFile);  		}  		else {  			handler = weakHandler.Target as TarStorageHandler;  			if (handler == null) {  				// Clean up!  				mg_tarHandlers.Remove (tarFile);  			}  		}  	}  	if (handler == null) {  		if (mg_lastCleanupCount + 50 < mg_tarHandlers.Count) {  			CleanStorageHandlers ();  		}  		// TarStorageHandler not found' add it to the list in a weak reference  		handler = new TarStorageHandler (session' tarFile);  		mg_tarHandlers.Add (tarFile' new WeakReference (handler));  	}  }  
Magic Number,Xceed.Tar,TarStorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageHandler.cs,GetStorageHandler,The following statement contains a magic number: if (handler == null) {  	if (mg_lastCleanupCount + 50 < mg_tarHandlers.Count) {  		CleanStorageHandlers ();  	}  	// TarStorageHandler not found' add it to the list in a weak reference  	handler = new TarStorageHandler (session' tarFile);  	mg_tarHandlers.Add (tarFile' new WeakReference (handler));  }  
Magic Number,Xceed.Tar,TarStorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageHandler.cs,GetStorageHandler,The following statement contains a magic number: if (mg_lastCleanupCount + 50 < mg_tarHandlers.Count) {  	CleanStorageHandlers ();  }  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToInt,The following statement contains a magic number: try {  	if (!String.IsNullOrEmpty (octal)) {  		result = System.Convert.ToInt32 (octal' 8);  	}  }  catch {  	success = false;  }  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToInt,The following statement contains a magic number: if (!String.IsNullOrEmpty (octal)) {  	result = System.Convert.ToInt32 (octal' 8);  }  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToInt,The following statement contains a magic number: result = System.Convert.ToInt32 (octal' 8);  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToUInt,The following statement contains a magic number: try {  	if (!String.IsNullOrEmpty (octal)) {  		result = System.Convert.ToUInt32 (octal' 8);  	}  }  catch {  	success = false;  }  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToUInt,The following statement contains a magic number: if (!String.IsNullOrEmpty (octal)) {  	result = System.Convert.ToUInt32 (octal' 8);  }  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToUInt,The following statement contains a magic number: result = System.Convert.ToUInt32 (octal' 8);  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToLong,The following statement contains a magic number: try {  	if (!String.IsNullOrEmpty (octal)) {  		result = System.Convert.ToInt64 (octal' 8);  	}  }  catch {  	success = false;  }  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToLong,The following statement contains a magic number: if (!String.IsNullOrEmpty (octal)) {  	result = System.Convert.ToInt64 (octal' 8);  }  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,ConvertOctalToLong,The following statement contains a magic number: result = System.Convert.ToInt64 (octal' 8);  
Magic Number,Xceed.Tar,TarStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\TarStorageItem.cs,GetHeaderEncoding,The following statement contains a magic number: return Encoding.GetEncoding (28591);  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: if (number < 8)  	return number.ToString ();  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: return (ToOctal (System.Convert.ToInt32 (number / 8)) + (number % 8));  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: return (ToOctal (System.Convert.ToInt32 (number / 8)) + (number % 8));  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: if (number < 8)  	return number.ToString ();  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: return (ToOctal (System.Convert.ToUInt32 (number / 8)) + (number % 8));  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: return (ToOctal (System.Convert.ToUInt32 (number / 8)) + (number % 8));  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: if (number < 8)  	return number.ToString ();  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: return (ToOctal (System.Convert.ToInt64 (number / 8)) + (number % 8));  
Magic Number,Xceed.Utils,Convert,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Convert\Convert.cs,ToOctal,The following statement contains a magic number: return (ToOctal (System.Convert.ToInt64 (number / 8)) + (number % 8));  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)((dateTime.Year - 1980) << 9);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)((dateTime.Year - 1980) << 9);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)(dateTime.Month << 5);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Hour << 11);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Minute << 5);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Second / 2);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToUnixDateTime,The following statement contains a magic number: fileTime /= 10000000;  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Dates\Dates.cs,ToUnixDateTime,The following statement contains a magic number: System.Diagnostics.Debug.Assert ((fileTime >> 32) == 0' "This date is bigger than what can handle a time_t");  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (needsUpdate) {  	// Before changing our offset' we need to seek to our data.  	if (item.Location.DataSize > 0) {  		uint itemDiskNumber = item.Location.DiskNumber;  		if (itemDiskNumber != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  		}  		OnMoveItemsSeekToData (session' sourceStream' item);  	}  	if (spannedDestStream != null)  		item.Location.DiskNumber = spannedDestStream.DiskNumber;  	else  		item.Location.DiskNumber = destStorage.CurrentDiskNumber;  	// Remember current offset  	item.Location.Offset = destStream.Position;  	// Write Header  	item.Location.HeaderSize = item.WriteHeader (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.HeaderSize);  	// Move existing data if present' or write empty data if newly created.  	if (item.Location.DataSize > 0) {  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  	}  	else {  		item.Location.DataSize = item.WriteEmptyData (destStream);  	}  	// Write the footer.  	item.Location.FooterSize = item.WriteFooter (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.FooterSize);  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  	}  	if (session != null)  		OnItemMoved (session' item' destStream);  	// The item is responsible for updating its state.  	System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (needsUpdate) {  	// Before changing our offset' we need to seek to our data.  	if (item.Location.DataSize > 0) {  		uint itemDiskNumber = item.Location.DiskNumber;  		if (itemDiskNumber != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  		}  		OnMoveItemsSeekToData (session' sourceStream' item);  	}  	if (spannedDestStream != null)  		item.Location.DiskNumber = spannedDestStream.DiskNumber;  	else  		item.Location.DiskNumber = destStorage.CurrentDiskNumber;  	// Remember current offset  	item.Location.Offset = destStream.Position;  	// Write Header  	item.Location.HeaderSize = item.WriteHeader (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.HeaderSize);  	// Move existing data if present' or write empty data if newly created.  	if (item.Location.DataSize > 0) {  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  	}  	else {  		item.Location.DataSize = item.WriteEmptyData (destStream);  	}  	// Write the footer.  	item.Location.FooterSize = item.WriteFooter (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.FooterSize);  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  	}  	if (session != null)  		OnItemMoved (session' item' destStream);  	// The item is responsible for updating its state.  	System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.Location.DataSize > 0) {  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  }  else {  	item.Location.DataSize = item.WriteEmptyData (destStream);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.Location.DataSize > 0) {  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  }  else {  	item.Location.DataSize = item.WriteEmptyData (destStream);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  }  else {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  }  else {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageItemHandler.cs,GetNextUniqueFullName,The following statement contains a magic number: if (m_duplicateIndex == 0) {  	string fullName = this.FullName;  	string name = this.Name;  	// First time we get called. We must determine the fixed path  	// and dynamic name pattern.  	int lastSeparator = fullName.LastIndexOf (Path.DirectorySeparatorChar);  	System.Diagnostics.Debug.Assert (lastSeparator != -1' "The FullName must at least be rooted.");  	m_duplicatePath = fullName.Substring (0' lastSeparator + 1);  	string _filename' _extension;  	#if USE_XCEED_UTILS_PATHS  	_filename = Xceed.Utils.Paths.Path.GetFileNameWithoutExtensionSimple (name);  	_extension = Xceed.Utils.Paths.Path.GetExtensionSimple (name);  	#else  	        _filename = Path.GetFileNameWithoutExtension( name );         _extension = Path.GetExtension( name );         #endif  	m_duplicateName = _filename;  	m_duplicateExtension = "{{{0}}}" + _extension;  	// This pair may exceed the limit' but it will get handled below.  	m_duplicateIndex = 2;  }  
Magic Number,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Storage\StorageItemHandler.cs,GetNextUniqueFullName,The following statement contains a magic number: m_duplicateIndex = 2;  
Magic Number,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,The following statement contains a magic number: if (m_innerStream.CanRead) {  	byte[] buffer = new byte[(skip < 32768 ? skip : 32768)];  	while (skip != 0) {  		// We call our public implementation so it updates our position.  		int read = this.Read (buffer' 0' unchecked((int)(skip < buffer.Length ? skip : buffer.Length)));  		// Have we reached the end of the stream? It's accepted to seek behond  		// the end of the stream.  		if (read == 0)  			break;  		skip -= read;  	}  }  else if (skip != 0) {  	throw new NotSupportedException ("Cannot seek a non-seekable write-only stream.");  }  
Magic Number,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,The following statement contains a magic number: if (m_innerStream.CanRead) {  	byte[] buffer = new byte[(skip < 32768 ? skip : 32768)];  	while (skip != 0) {  		// We call our public implementation so it updates our position.  		int read = this.Read (buffer' 0' unchecked((int)(skip < buffer.Length ? skip : buffer.Length)));  		// Have we reached the end of the stream? It's accepted to seek behond  		// the end of the stream.  		if (read == 0)  			break;  		skip -= read;  	}  }  else if (skip != 0) {  	throw new NotSupportedException ("Cannot seek a non-seekable write-only stream.");  }  
Magic Number,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The following statement contains a magic number: return StreamCopy.Copy (source' dest' size' 8192' null);  
Magic Number,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The following statement contains a magic number: return StreamCopy.Copy (source' dest' size' 8192' onBytesWritten);  
Duplicate Code,Xceed.Tar.Streaming,StreamingTarStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Streaming\StreamingTarStorage.cs,OnItemRead,The method contains a code clone-set at the following line numbers (starting from the method definition): ((62' 83)' (139' 160))
Missing Default,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Tar.Blueprint\Utils\Streams\WindowStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin: {  	beginOffset = offset;  	offset += m_beginOffset;  	break;  }  case SeekOrigin.Current: {  	beginOffset = (m_innerStream.Position - m_beginOffset) + offset;  	break;  }  case SeekOrigin.End: {  	if (m_length != -1) {  		beginOffset = m_length + offset;  		offset -= (m_innerStream.Length - m_beginOffset - m_length);  	}  	else  		beginOffset = m_innerStream.Length + offset;  	break;  }  }  
