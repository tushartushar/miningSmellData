Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The method has 114 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainGtU,The method has 185 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The method has 242 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The method has 178 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The method has 125 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The method has 120 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The method has 281 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The method has 740 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The method has 263 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The method has 187 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The method has 142 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The method has 156 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The method has 116 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The method has 151 lines of code.
Long Method,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,The method has 127 lines of code.
Long Method,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The method has 106 lines of code.
Long Method,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The method has 119 lines of code.
Long Method,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,The method has 113 lines of code.
Long Method,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Compress,The method has 112 lines of code.
Long Method,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Decompress,The method has 125 lines of code.
Long Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The method has 115 lines of code.
Complex Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,Cyclomatic complexity of the method is 17
Complex Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,Cyclomatic complexity of the method is 47
Complex Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSimpleSort,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,Cyclomatic complexity of the method is 17
Complex Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,Cyclomatic complexity of the method is 44
Complex Method,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompress,Cyclomatic complexity of the method is 18
Complex Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,add_pair_to_block,Cyclomatic complexity of the method is 32
Complex Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,copy_input_until_stop,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,handle_compress,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,Cyclomatic complexity of the method is 26
Complex Method,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,Cyclomatic complexity of the method is 20
Complex Method,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,Cyclomatic complexity of the method is 18
Complex Method,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,Cyclomatic complexity of the method is 88
Complex Method,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,Cyclomatic complexity of the method is 181
Complex Method,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_MTF_VAL,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.CompressionEngine.Managed,Huffman,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbCreateDecodeTables,Cyclomatic complexity of the method is 17
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,Cyclomatic complexity of the method is 96
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,Cyclomatic complexity of the method is 87
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,Cyclomatic complexity of the method is 18
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,Cyclomatic complexity of the method is 27
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_stored,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,fill_window,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,Cyclomatic complexity of the method is 97
Complex Method,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,Cyclomatic complexity of the method is 33
Complex Method,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Write,Cyclomatic complexity of the method is 29
Complex Method,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Dispose,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Compression,ManagedPPMdDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdDecompressor.cs,Decompress,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,Cyclomatic complexity of the method is 20
Complex Method,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,Cyclomatic complexity of the method is 21
Complex Method,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,Cyclomatic complexity of the method is 20
Complex Method,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Compress,Cyclomatic complexity of the method is 27
Complex Method,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Decompress,Cyclomatic complexity of the method is 27
Complex Method,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Encode,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Decode,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,Cyclomatic complexity of the method is 21
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,Cyclomatic complexity of the method is 15
Complex Method,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\CombinedStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\CombinedStream.cs,Read,Cyclomatic complexity of the method is 8
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fpush,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fpop,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mpush,The method has 7 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mpop,The method has 7 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mnextswap,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainGtU,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSimpleSort,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The method has 7 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The method has 7 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffDecompress,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_BITS,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_MTF_VAL,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Huffman,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbAssignCodes,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Huffman,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbCreateDecodeTables,The method has 7 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,LOAD,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,UPDATE,The method has 7 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,NEEDBITS,The method has 9 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,GRABBITS,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,UNGRAB,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,LEAVE,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,FLUSH,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The method has 9 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The method has 11 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,copy_block,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_stored_block,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,DeflateInit2,The method has 6 parameters.
Long Parameter List,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The method has 6 parameters.
Long Parameter List,Xceed.Compression.Coder,CoderInputStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderInputStream.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Compression,Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Compressor.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression,ManagedPPMdDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdDecompressor.cs,Decompress,The method has 6 parameters.
Long Parameter List,Xceed.Compression,ManagedPPMdCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdCompressor.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression,ManagedPPMdCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdCompressor.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression,Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Decompressor.cs,Decompress,The method has 6 parameters.
Long Parameter List,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The method has 6 parameters.
Long Parameter List,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,The method has 6 parameters.
Long Parameter List,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Decompress,The method has 5 parameters.
Long Parameter List,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Encode,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,PipeStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\PipeStream.cs,Read,The method has 7 parameters.
Long Statement,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The length of the statement  "		med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d)); " is 146.
Long Statement,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The length of the statement  "							BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1); " is 124.
Long Statement,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The length of the statement  "			BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock)); " is 160.
Long Statement,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The length of the statement  "					BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC); " is 128.
Long Statement,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The length of the statement  "	if (dest == null || source == null || blockSize100k < 1 || blockSize100k > 9 || verbosity < 0 || verbosity > 4 || workFactor < 0 || workFactor > 250) " is 149.
Long Statement,Xceed.Compression.CompressionEngine.Managed,BZLibCommon,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLibCommon.cs,BZ2_bz__AssertH__fail,The length of the statement  "	Assert (false' "\n\nbzip2/libbzip2: internal error number %d.\n" + "This is a bug in bzip2/libbzip2' %s.\n" + "Please report it to me at: jseward@acm.org.  If this happened\n" + "when you were using some program which uses libbzip2 as a\n" + "component' you should also report this bug to the author(s)\n" + "of that program.  Please make an effort to report this bug;\n" + "timely and accurate bug reports eventually lead to higher\n" + "quality software.  Thanks.  Julian Seward' 21 March 2000.\n\n" + errcode + "\n" + BZ2_bzlibVersion ()); " is 542.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The length of the statement  "		BZLibCommon.VPrintf ("      {0} in block' {1} after MTF & 1-2 coding' " + "{2}+2 syms in use\n"' s.nblock' s.nMTF' s.nInUse); " is 125.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The length of the statement  "				BZLibCommon.VPrintf ("      initial group {0}' [{1} .. {2}]' " + "has {3} syms ({4:f})\n"' nPart' gs' ge' aFreq' (100.0 * (float)aFreq) / (float)(s.nMTF)); " is 155.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The length of the statement  "			---*//*--- Compute MTF values for the selectors. ---*//*--- Assign actual codes for the tables. --*//*--- Transmit the mapping table. ---*//*--- Now the selectors. ---*//*--- Now the coding tables. ---*//*--- And finally' the block data proper ---*/} " is 250.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The length of the statement  "				bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]); " is 152.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The length of the statement  "				bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]); " is 123.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The length of the statement  "			BZLibCommon.VPrintf ("    block {0}: crc = 0x{1:x}' " + "combined CRC = 0x{2:x}' size = {3}\n"' s.blockNo' s.blockCRC' s.combinedCRC' s.nblock); " is 144.
Long Statement,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadUInt32,The length of the statement  "	UInt32 bRes = (UInt32)(((m_streamData [iIndex + 3] | (m_streamData [iIndex + 2] << 8)) | (m_streamData [iIndex + 1] << 0x10)) | (m_streamData [iIndex] << 0x18)); " is 161.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "	if (s.state == BZLib.BZDecompressionState.BZ_X_MAGIC_1 || (s.state == BZLib.BZDecompressionState.BZ_X_MAGIC_4 && s.bSmallSig != 0)) { " is 133.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "	if (s.state == BZLib.BZDecompressionState.BZ_X_CODING_1 || s.state == BZLib.BZDecompressionState.BZ_X_CODING_2 || s.state == BZLib.BZDecompressionState.BZ_X_CODING_3) { " is 168.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "	if (s.state == BZLib.BZDecompressionState.BZ_X_MTF_3 || s.state == BZLib.BZDecompressionState.BZ_X_MTF_4 || s.state == BZLib.BZDecompressionState.BZ_X_MTF_5 || s.state == BZLib.BZDecompressionState.BZ_X_MTF_6) { " is 211.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "	/*--- Now the coding tables ---*//*--- Create the Huffman decoding tables ---*//*--- Now the MTF values ---*//*-- MTF init --*//*-- end MTF init --*//* Now we know what nblock is' we can do a better sanity" is 205.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "		Huffman.BZ2_hbCreateDecodeTables (ref s.limit [t]' ref s.m_base [t]' ref s.perm [t]' ref s.len [t]' minLen' maxLen' alphaSize); " is 127.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_1' BZLib.BZDecompressionState.BZ_X_MTF_2' ref nextSym' ref s)) { " is 140.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "		if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) { " is 252.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "				if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) { " is 140.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The length of the statement  "			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) { " is 140.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "	/* bytes to end of window or read pointer */// The "t" variable was used for both a temp storage of values and return codes. " is 124.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "	/* copy input/output information to locals (UPDATE macro restores) */LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s); " is 123.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "			/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE); " is 135.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "				returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z); " is 147.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The length of the statement  "	/* copy input/output information to locals (UPDATE macro restores) */InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s); " is 132.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The length of the statement  "	/* copy source pointer *//* load input' output' bit values */InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s); " is 124.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The length of the statement  "		/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z); " is 130.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The length of the statement  "	/* Return Z_BUF_ERROR if we were given an incomplete table */return (y != 0 && g != 1) ? ReturnCode.Z_BUF_ERROR : ReturnCode.Z_OK; " is 130.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The length of the statement  "	/* index of last bit length code of non zero freq *//* Build the Huffman trees unless a stored block is forced */if (s.level > 0) { " is 131.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_tree,The length of the statement  "		/* Create a new node father of n and m */tree [node].freq_code = unchecked((ushort)(tree [n].freq_code + tree [m].freq_code)); " is 126.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_bl_tree,The length of the statement  "	/* index of last bit length code of non zero freq *//* Determine the bit length frequencies for literal and distance trees */scan_tree (s' s.dyn_ltree' s.l_desc.max_code); " is 171.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_bl_tree,The length of the statement  "	/* Update opt_len to include the bit length tree and counts */s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4)); " is 128.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The length of the statement  "			dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff))); " is 125.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The length of the statement  "			/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow"); " is 173.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The length of the statement  "	Debug.Assert (lcodes <= (int)XDeflate.Constant.L_CODES && dcodes <= (int)XDeflate.Constant.D_CODES && blcodes <= (int)XDeflate.Constant.BL_CODES' "too many codes"); " is 164.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,pqdownheap,The length of the statement  "		/* Set j to the smallest of the two sons: */if (j < s.heap_len && smaller (tree' s.heap [j + 1]' s.heap [j]' s.depth)) { " is 120.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,gen_codes,The length of the statement  "         */Debug.Assert (code + bl_count [(int)XDeflate.Constant.MAX_BITS] - 1 == (1 << (int)XDeflate.Constant.MAX_BITS) - 1' "inconsistent bit counts"); " is 144.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,smaller,The length of the statement  "	return (tree [n].freq_code < tree [m].freq_code || (tree [n].freq_code == tree [m].freq_code && depth [n] <= depth [m])); " is 121.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The length of the statement  "	if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) { " is 239.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The length of the statement  "	if (strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (s.status == StreamStatus.FINISH_STATE && flush != FlushValue.Z_FINISH)) { " is 151.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The length of the statement  "	/* User must not provide more input after the first FINISH: */if (s.status == StreamStatus.FINISH_STATE && strm.avail_in != 0) { " is 128.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The length of the statement  "	/* Start a new block or continue the current one. */if (strm.avail_in != 0 || s.lookahead != 0 || (flush != FlushValue.Z_NO_FLUSH && s.status != StreamStatus.FINISH_STATE)) { " is 174.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_stored,The length of the statement  "			/* strstart == 0 is possible when wraparound on 16-bit machine *///System.Diagnostics.Debug.Assert( false' "The lines inside this \"if\" were never tested" ); " is 158.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_fast,The length of the statement  "	/* set if current block must be flushed */System.Diagnostics.Debug.Assert (s.method != (int)XZLib.Constant.Z_DEFLATED64); " is 121.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The length of the statement  "	/* set if current block must be flushed */System.Diagnostics.Debug.Assert (s.method != (int)XZLib.Constant.Z_DEFLATED64); " is 121.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The length of the statement  "			/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) { " is 215.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The length of the statement  "			/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush); " is 157.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,_tr_tally,The length of the statement  "		/* dist = match distance - 1 */System.Diagnostics.Debug.Assert (dist < s.max_dist && lc <= (s.max_match - (uint)Constant.MIN_MATCH) && Tree.d_code (dist) < (int)Constant.D_CODES' "_tr_tally: bad match"); " is 203.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The length of the statement  "         */if (s.window [match + best_len] != scan_end || s.window [match + best_len - 1] != scan_end1 || s.window [match] != s.window [scan] || s.window [++match] != s.window [scan + 1]) " is 178.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The length of the statement  "		while (s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && scan < strend); " is 366.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,FLUSH_BLOCK_ONLY,The length of the statement  "	Tree._tr_flush_block (s' (s.block_start >= 0 ? s.window : null)' s.block_start' unchecked((uint)(s.strstart - s.block_start))' eof); " is 132.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,InflateInit,The length of the statement  "	/* create inflate_blocks state */if ((((internal_state)z.state).blocks = InfBlock.inflate_blocks_new (ref z' ((internal_state)z.state).nowrap == 0' (uint)1 << w)) == null) { " is 173.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,DeflateInit,The length of the statement  "	return XZLib.DeflateInit2 (strm' level' (int)Constant.Z_DEFLATED' (int)Constant.MAX_WBITS' (int)Constant.DEF_MEM_LEVEL' CompressionStrategy.Z_DEFAULT_STRATEGY); " is 160.
Long Statement,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The length of the statement  "         * we know that LZMA is stuck waiting for data or has finished the job. */// If an exception has been thrown in the LZMA thread " is 126.
Long Statement,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The length of the statement  "	// decompression has already finished its work or it's the last data and we never started decompressing (an empty stream situation) " is 131.
Long Statement,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The length of the statement  "			throw new CompressionException ("Decompression exception. See the InnerException property for details."' this.m_exception); " is 123.
Long Statement,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The length of the statement  "				throw new OverflowException ("The remaining data after LZMA compressed data is " + _remaining.ToString () + " bytes' which is larger than an 32-bit integer can take."); " is 168.
Long Statement,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,The length of the statement  "			m_decompressedCount = m_decompressor.Decompress (m_compressed' m_compressedOffset' toDecompress' ref m_endOfData' out m_decompressed' out remaining); " is 149.
Long Statement,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Write,The length of the statement  "				System.Diagnostics.Debug.Assert (compressed != null && compressed.Length >= bytesWritten' "Compress returned a greater number of bytes that are available in the compressed buffer"); " is 181.
Long Statement,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,WillUseCompression,The length of the statement  "	if (level == CompressionLevel.None && (method != CompressionMethod.Deflated && method != CompressionMethod.Deflated64)) { " is 121.
Long Statement,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,SetupPPMdDecompression,The length of the statement  "	if (ManagedPPMdDecompressor.ReadPPMdZipHeader (compressedStream' out allocatorSize' out maximumModelOrder' out method)) { " is 121.
Long Statement,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,SetupPPMdDecompression,The length of the statement  "			throw new CompressionException ("Incorrect parameters read from the stream prevented the creation of the PPMd decompression engine. This is usually caused by invalid/corrupt stream data."' exception); " is 200.
Long Statement,Xceed.Compression,ManagedPPMdDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdDecompressor.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,ManagedPPMdCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdCompressor.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("method"' method' "The compression method is not a valid CompressionMethod member."); " is 134.
Long Statement,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression,QuickCompression,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\QuickCompression.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("method"' method' "The compression method is not a valid DecompressionMethod member."); " is 136.
Long Statement,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderNormalize,The length of the statement  "	while ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true)) { " is 124.
Long Statement,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderNormalize,The length of the statement  "	while (resume || ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true))) { " is 136.
Long Statement,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The length of the statement  "			currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00)); " is 122.
Long Statement,Xceed.Utils.Exceptions,ExceptionFilter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Exceptions\ExceptionFilter.cs,IsPublicException,The length of the statement  "	exception is OutOfMemoryException || exception is System.Security.SecurityException || exception is UnauthorizedAccessException || exception is System.IO.PathTooLongException || exception is ArgumentException || exception is System.Reflection.TargetInvocationException); " is 270.
Long Statement,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\CombinedStream.cs,SetLength,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("value"' value' "The length of the stream must be greater than zero."); " is 120.
Long Statement,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\CombinedStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "Count must be less than the buffer's remaining length after the specified offset."); " is 150.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The conditional expression  "strm == null || blockSize100k < 1 || blockSize100k > 9 || workFactor < 0 || workFactor > 250"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompress,The conditional expression  "progress && // need this to avoid error flushing  (s.avail_in_expect > 0 || !isempty_RL (ref s) || s.state_out_pos < s.numZ)"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The conditional expression  "dest == null || source == null || blockSize100k < 1 || blockSize100k > 9 || verbosity < 0 || verbosity > 4 || workFactor < 0 || workFactor > 250"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffDecompress,The conditional expression  "dest == null || source == null || verbosity < 0 || verbosity > 4"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The conditional expression  "ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The conditional expression  "s.state == BZLib.BZDecompressionState.BZ_X_MTF_3 || s.state == BZLib.BZDecompressionState.BZ_X_MTF_4 || s.state == BZLib.BZDecompressionState.BZ_X_MTF_5 || s.state == BZLib.BZDecompressionState.BZ_X_MTF_6"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The conditional expression  "forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The conditional expression  "memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The conditional expression  "strm == null || strm.state == null || flush > FlushValue.Z_FINISH || flush < 0"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (s.status == StreamStatus.FINISH_STATE && flush != FlushValue.Z_FINISH)"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || s.lookahead != 0 || (flush != FlushValue.Z_NO_FLUSH && s.status != StreamStatus.FINISH_STATE)"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflateParams,The conditional expression  "level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The conditional expression  "s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The conditional expression  "s.window [match + best_len] != scan_end || s.window [match + best_len - 1] != scan_end1 || s.window [match] != s.window [scan] || s.window [++match] != s.window [scan + 1]"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The conditional expression  "s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && scan < strend"  is complex.
Complex Conditional,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The conditional expression  "count <= 0 && (!endOfData || this.m_endOfData || (endOfData && this.m_inputStream == null))"  is complex.
Complex Conditional,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The conditional expression  "count <= 0 && (!endOfData || this.m_endOfData || (endOfData && this.m_inputStream == null))"  is complex.
Empty Catch Block,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\CombinedStream.cs,CombinedStream,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\CombinedStream.cs,Dispose,The method has an empty catch block.
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,SET_BH,The following statement contains a magic number: bhtab [(zz) >> 5] |= (UInt32)((UInt32)1 << ((zz) & 31));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,SET_BH,The following statement contains a magic number: bhtab [(zz) >> 5] |= (UInt32)((UInt32)1 << ((zz) & 31));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,CLEAR_BH,The following statement contains a magic number: bhtab [(zz) >> 5] &= ~(UInt32)((UInt32)1 << ((zz) & 31));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,CLEAR_BH,The following statement contains a magic number: bhtab [(zz) >> 5] &= ~(UInt32)((UInt32)1 << ((zz) & 31));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,ISSET_BH,The following statement contains a magic number: return ((bhtab [(zz) >> 5] & ((UInt32)((UInt32)1 << ((zz) & 31))))) != 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,ISSET_BH,The following statement contains a magic number: return ((bhtab [(zz) >> 5] & ((UInt32)((UInt32)1 << ((zz) & 31))))) != 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,WORD_BH,The following statement contains a magic number: return bhtab [(zz) >> 5];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BIGFREQ,The following statement contains a magic number: return (ftab [((b) + 1) << 8] - ftab [(b) << 8]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BIGFREQ,The following statement contains a magic number: return (ftab [((b) + 1) << 8] - ftab [(b) << 8]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: if (hi - lo > 3) {  	for (i = hi - 4; i >= lo; i--) {  		tmp = (Int32)fmap [i];  		ec_tmp = eclass [tmp];  		for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  			fmap [j - 4] = fmap [j];  		fmap [j - 4] = (UInt32)tmp;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: if (hi - lo > 3) {  	for (i = hi - 4; i >= lo; i--) {  		tmp = (Int32)fmap [i];  		ec_tmp = eclass [tmp];  		for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  			fmap [j - 4] = fmap [j];  		fmap [j - 4] = (UInt32)tmp;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: if (hi - lo > 3) {  	for (i = hi - 4; i >= lo; i--) {  		tmp = (Int32)fmap [i];  		ec_tmp = eclass [tmp];  		for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  			fmap [j - 4] = fmap [j];  		fmap [j - 4] = (UInt32)tmp;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: if (hi - lo > 3) {  	for (i = hi - 4; i >= lo; i--) {  		tmp = (Int32)fmap [i];  		ec_tmp = eclass [tmp];  		for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  			fmap [j - 4] = fmap [j];  		fmap [j - 4] = (UInt32)tmp;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: if (hi - lo > 3) {  	for (i = hi - 4; i >= lo; i--) {  		tmp = (Int32)fmap [i];  		ec_tmp = eclass [tmp];  		for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  			fmap [j - 4] = fmap [j];  		fmap [j - 4] = (UInt32)tmp;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: if (hi - lo > 3) {  	for (i = hi - 4; i >= lo; i--) {  		tmp = (Int32)fmap [i];  		ec_tmp = eclass [tmp];  		for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  			fmap [j - 4] = fmap [j];  		fmap [j - 4] = (UInt32)tmp;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (i = hi - 4; i >= lo; i--) {  	tmp = (Int32)fmap [i];  	ec_tmp = eclass [tmp];  	for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  		fmap [j - 4] = fmap [j];  	fmap [j - 4] = (UInt32)tmp;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (i = hi - 4; i >= lo; i--) {  	tmp = (Int32)fmap [i];  	ec_tmp = eclass [tmp];  	for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  		fmap [j - 4] = fmap [j];  	fmap [j - 4] = (UInt32)tmp;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (i = hi - 4; i >= lo; i--) {  	tmp = (Int32)fmap [i];  	ec_tmp = eclass [tmp];  	for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  		fmap [j - 4] = fmap [j];  	fmap [j - 4] = (UInt32)tmp;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (i = hi - 4; i >= lo; i--) {  	tmp = (Int32)fmap [i];  	ec_tmp = eclass [tmp];  	for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  		fmap [j - 4] = fmap [j];  	fmap [j - 4] = (UInt32)tmp;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (i = hi - 4; i >= lo; i--) {  	tmp = (Int32)fmap [i];  	ec_tmp = eclass [tmp];  	for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  		fmap [j - 4] = fmap [j];  	fmap [j - 4] = (UInt32)tmp;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: i = hi - 4
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  	fmap [j - 4] = fmap [j];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  	fmap [j - 4] = fmap [j];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: for (j = i + 4; j <= hi && ec_tmp > eclass [fmap [j]]; j += 4)  	fmap [j - 4] = fmap [j];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: j = i + 4
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: j += 4
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: fmap [j - 4] = fmap [j];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSimpleSort,The following statement contains a magic number: fmap [j - 4] = (UInt32)tmp;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < FALLBACK_QSORT_STACK_SIZE' 1004);  	fpop (ref lo' ref hi' ref sp' ref stackLo' ref stackHi);  	if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {  		fallbackSimpleSort (ref fmap' ref eclass' lo' hi);  		continue;  	}  	/* Random partitioning.  Median of 3 sometimes fails to 				   avoid bad cases.  Median of 9 seems to help but  				   looks rather expensive.  This too seems to work but 				   is cheaper.  Guidance for the magic constants  				   7621 and 32768 is taken from Sedgewick's algorithms 				   book' chapter 35. 				*/r = ((r * 7621) + 1) % 32768;  	r3 = r % 3;  	if (r3 == 0)  		med = eclass [fmap [lo]];  	else if (r3 == 1)  		med = eclass [fmap [(lo + hi) >> 1]];  	else  		med = eclass [fmap [hi]];  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unLo]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unLo]' ref fmap [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unHi]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unHi]' ref fmap [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		fswap (ref fmap [unLo]' ref fmap [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "fallbackQSort3(2)");  	if (gtHi < ltLo)  		continue;  	n = fmin (ltLo - lo' unLo - ltLo);  	fvswap (lo' unLo - n' n' ref fmap);  	m = fmin (hi - gtHi' gtHi - unHi);  	fvswap (unLo' hi - m + 1' m' ref fmap);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	if (n - lo > hi - m) {  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  	}  	else {  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < FALLBACK_QSORT_STACK_SIZE' 1004);  	fpop (ref lo' ref hi' ref sp' ref stackLo' ref stackHi);  	if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {  		fallbackSimpleSort (ref fmap' ref eclass' lo' hi);  		continue;  	}  	/* Random partitioning.  Median of 3 sometimes fails to 				   avoid bad cases.  Median of 9 seems to help but  				   looks rather expensive.  This too seems to work but 				   is cheaper.  Guidance for the magic constants  				   7621 and 32768 is taken from Sedgewick's algorithms 				   book' chapter 35. 				*/r = ((r * 7621) + 1) % 32768;  	r3 = r % 3;  	if (r3 == 0)  		med = eclass [fmap [lo]];  	else if (r3 == 1)  		med = eclass [fmap [(lo + hi) >> 1]];  	else  		med = eclass [fmap [hi]];  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unLo]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unLo]' ref fmap [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unHi]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unHi]' ref fmap [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		fswap (ref fmap [unLo]' ref fmap [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "fallbackQSort3(2)");  	if (gtHi < ltLo)  		continue;  	n = fmin (ltLo - lo' unLo - ltLo);  	fvswap (lo' unLo - n' n' ref fmap);  	m = fmin (hi - gtHi' gtHi - unHi);  	fvswap (unLo' hi - m + 1' m' ref fmap);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	if (n - lo > hi - m) {  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  	}  	else {  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < FALLBACK_QSORT_STACK_SIZE' 1004);  	fpop (ref lo' ref hi' ref sp' ref stackLo' ref stackHi);  	if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {  		fallbackSimpleSort (ref fmap' ref eclass' lo' hi);  		continue;  	}  	/* Random partitioning.  Median of 3 sometimes fails to 				   avoid bad cases.  Median of 9 seems to help but  				   looks rather expensive.  This too seems to work but 				   is cheaper.  Guidance for the magic constants  				   7621 and 32768 is taken from Sedgewick's algorithms 				   book' chapter 35. 				*/r = ((r * 7621) + 1) % 32768;  	r3 = r % 3;  	if (r3 == 0)  		med = eclass [fmap [lo]];  	else if (r3 == 1)  		med = eclass [fmap [(lo + hi) >> 1]];  	else  		med = eclass [fmap [hi]];  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unLo]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unLo]' ref fmap [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unHi]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unHi]' ref fmap [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		fswap (ref fmap [unLo]' ref fmap [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "fallbackQSort3(2)");  	if (gtHi < ltLo)  		continue;  	n = fmin (ltLo - lo' unLo - ltLo);  	fvswap (lo' unLo - n' n' ref fmap);  	m = fmin (hi - gtHi' gtHi - unHi);  	fvswap (unLo' hi - m + 1' m' ref fmap);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	if (n - lo > hi - m) {  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  	}  	else {  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < FALLBACK_QSORT_STACK_SIZE' 1004);  	fpop (ref lo' ref hi' ref sp' ref stackLo' ref stackHi);  	if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {  		fallbackSimpleSort (ref fmap' ref eclass' lo' hi);  		continue;  	}  	/* Random partitioning.  Median of 3 sometimes fails to 				   avoid bad cases.  Median of 9 seems to help but  				   looks rather expensive.  This too seems to work but 				   is cheaper.  Guidance for the magic constants  				   7621 and 32768 is taken from Sedgewick's algorithms 				   book' chapter 35. 				*/r = ((r * 7621) + 1) % 32768;  	r3 = r % 3;  	if (r3 == 0)  		med = eclass [fmap [lo]];  	else if (r3 == 1)  		med = eclass [fmap [(lo + hi) >> 1]];  	else  		med = eclass [fmap [hi]];  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unLo]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unLo]' ref fmap [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = (Int32)eclass [fmap [unHi]] - (Int32)med;  			if (n == 0) {  				fswap (ref fmap [unHi]' ref fmap [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		fswap (ref fmap [unLo]' ref fmap [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "fallbackQSort3(2)");  	if (gtHi < ltLo)  		continue;  	n = fmin (ltLo - lo' unLo - ltLo);  	fvswap (lo' unLo - n' n' ref fmap);  	m = fmin (hi - gtHi' gtHi - unHi);  	fvswap (unLo' hi - m + 1' m' ref fmap);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	if (n - lo > hi - m) {  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  	}  	else {  		fpush (m' hi' ref sp' ref stackLo' ref stackHi);  		fpush (lo' n' ref sp' ref stackLo' ref stackHi);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: BZLibCommon.AssertH (sp < FALLBACK_QSORT_STACK_SIZE' 1004);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: r = ((r * 7621) + 1) % 32768;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: r = ((r * 7621) + 1) % 32768;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackQSort3,The following statement contains a magic number: r3 = r % 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("        bucket sorting ...\n");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: for (i = 0; i < 257; i++)  	ftab [i] = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: for (i = 0; i < 256; i++)  	ftabCopy [i] = ftab [i];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: for (i = 1; i < 257; i++)  	ftab [i] += ftab [i - 1];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: nBhtab = (Int32)(2 + (nblock / 32));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: nBhtab = (Int32)(2 + (nblock / 32));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: for (i = 0; i < 256; i++)  	SET_BH (ftab [i]' ref bhtab);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: for (i = 0; i < 32; i++) {  	SET_BH ((Int32)(nblock + 2 * i)' ref bhtab);  	CLEAR_BH ((Int32)(nblock + 2 * i + 1)' ref bhtab);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: for (i = 0; i < 32; i++) {  	SET_BH ((Int32)(nblock + 2 * i)' ref bhtab);  	CLEAR_BH ((Int32)(nblock + 2 * i + 1)' ref bhtab);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: for (i = 0; i < 32; i++) {  	SET_BH ((Int32)(nblock + 2 * i)' ref bhtab);  	CLEAR_BH ((Int32)(nblock + 2 * i + 1)' ref bhtab);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: SET_BH ((Int32)(nblock + 2 * i)' ref bhtab);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: CLEAR_BH ((Int32)(nblock + 2 * i + 1)' ref bhtab);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (true) {  	if (verb >= 4)  		BZLibCommon.VPrintf ("        depth {0} has "' H);  	j = 0;  	for (i = 0; i < nblock; i++) {  		if (ISSET_BH (i' ref bhtab))  			j = i;  		k = ((Int32)fmap [i]) - H;  		if (k < 0)  			k += (Int32)nblock;  		eclass [k] = (UInt32)j;  	}  	nNotDone = 0;  	r = -1;  	while (true) {  		/*-- find the next non-singleton bucket --*/k = r + 1;  		while (ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0xffffffff)  				k += 32;  			while (ISSET_BH (k' ref bhtab))  				k++;  		}  		l = k - 1;  		if (l >= nblock)  			break;  		while (!ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (!ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0x00000000)  				k += 32;  			while (!ISSET_BH (k' ref bhtab))  				k++;  		}  		r = k - 1;  		if (r >= nblock)  			break;  		/*-- now [l' r] bracket current bucket --*/if (r > l) {  			nNotDone += (r - l + 1);  			fallbackQSort3 (ref fmap' ref eclass' l' r);  			/*-- scan bucket and generate header bits-- */cc = -1;  			for (i = l; i <= r; i++) {  				cc1 = (Int32)eclass [fmap [i]];  				if (cc != cc1) {  					SET_BH (i' ref bhtab);  					cc = cc1;  				}  				;  			}  		}  	}  	if (verb >= 4)  		BZLibCommon.VPrintf ("{0} unresolved strings\n"' nNotDone);  	H *= 2;  	if (H > nblock || nNotDone == 0)  		break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (true) {  	if (verb >= 4)  		BZLibCommon.VPrintf ("        depth {0} has "' H);  	j = 0;  	for (i = 0; i < nblock; i++) {  		if (ISSET_BH (i' ref bhtab))  			j = i;  		k = ((Int32)fmap [i]) - H;  		if (k < 0)  			k += (Int32)nblock;  		eclass [k] = (UInt32)j;  	}  	nNotDone = 0;  	r = -1;  	while (true) {  		/*-- find the next non-singleton bucket --*/k = r + 1;  		while (ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0xffffffff)  				k += 32;  			while (ISSET_BH (k' ref bhtab))  				k++;  		}  		l = k - 1;  		if (l >= nblock)  			break;  		while (!ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (!ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0x00000000)  				k += 32;  			while (!ISSET_BH (k' ref bhtab))  				k++;  		}  		r = k - 1;  		if (r >= nblock)  			break;  		/*-- now [l' r] bracket current bucket --*/if (r > l) {  			nNotDone += (r - l + 1);  			fallbackQSort3 (ref fmap' ref eclass' l' r);  			/*-- scan bucket and generate header bits-- */cc = -1;  			for (i = l; i <= r; i++) {  				cc1 = (Int32)eclass [fmap [i]];  				if (cc != cc1) {  					SET_BH (i' ref bhtab);  					cc = cc1;  				}  				;  			}  		}  	}  	if (verb >= 4)  		BZLibCommon.VPrintf ("{0} unresolved strings\n"' nNotDone);  	H *= 2;  	if (H > nblock || nNotDone == 0)  		break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (true) {  	if (verb >= 4)  		BZLibCommon.VPrintf ("        depth {0} has "' H);  	j = 0;  	for (i = 0; i < nblock; i++) {  		if (ISSET_BH (i' ref bhtab))  			j = i;  		k = ((Int32)fmap [i]) - H;  		if (k < 0)  			k += (Int32)nblock;  		eclass [k] = (UInt32)j;  	}  	nNotDone = 0;  	r = -1;  	while (true) {  		/*-- find the next non-singleton bucket --*/k = r + 1;  		while (ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0xffffffff)  				k += 32;  			while (ISSET_BH (k' ref bhtab))  				k++;  		}  		l = k - 1;  		if (l >= nblock)  			break;  		while (!ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (!ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0x00000000)  				k += 32;  			while (!ISSET_BH (k' ref bhtab))  				k++;  		}  		r = k - 1;  		if (r >= nblock)  			break;  		/*-- now [l' r] bracket current bucket --*/if (r > l) {  			nNotDone += (r - l + 1);  			fallbackQSort3 (ref fmap' ref eclass' l' r);  			/*-- scan bucket and generate header bits-- */cc = -1;  			for (i = l; i <= r; i++) {  				cc1 = (Int32)eclass [fmap [i]];  				if (cc != cc1) {  					SET_BH (i' ref bhtab);  					cc = cc1;  				}  				;  			}  		}  	}  	if (verb >= 4)  		BZLibCommon.VPrintf ("{0} unresolved strings\n"' nNotDone);  	H *= 2;  	if (H > nblock || nNotDone == 0)  		break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (true) {  	if (verb >= 4)  		BZLibCommon.VPrintf ("        depth {0} has "' H);  	j = 0;  	for (i = 0; i < nblock; i++) {  		if (ISSET_BH (i' ref bhtab))  			j = i;  		k = ((Int32)fmap [i]) - H;  		if (k < 0)  			k += (Int32)nblock;  		eclass [k] = (UInt32)j;  	}  	nNotDone = 0;  	r = -1;  	while (true) {  		/*-- find the next non-singleton bucket --*/k = r + 1;  		while (ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0xffffffff)  				k += 32;  			while (ISSET_BH (k' ref bhtab))  				k++;  		}  		l = k - 1;  		if (l >= nblock)  			break;  		while (!ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (!ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0x00000000)  				k += 32;  			while (!ISSET_BH (k' ref bhtab))  				k++;  		}  		r = k - 1;  		if (r >= nblock)  			break;  		/*-- now [l' r] bracket current bucket --*/if (r > l) {  			nNotDone += (r - l + 1);  			fallbackQSort3 (ref fmap' ref eclass' l' r);  			/*-- scan bucket and generate header bits-- */cc = -1;  			for (i = l; i <= r; i++) {  				cc1 = (Int32)eclass [fmap [i]];  				if (cc != cc1) {  					SET_BH (i' ref bhtab);  					cc = cc1;  				}  				;  			}  		}  	}  	if (verb >= 4)  		BZLibCommon.VPrintf ("{0} unresolved strings\n"' nNotDone);  	H *= 2;  	if (H > nblock || nNotDone == 0)  		break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (true) {  	if (verb >= 4)  		BZLibCommon.VPrintf ("        depth {0} has "' H);  	j = 0;  	for (i = 0; i < nblock; i++) {  		if (ISSET_BH (i' ref bhtab))  			j = i;  		k = ((Int32)fmap [i]) - H;  		if (k < 0)  			k += (Int32)nblock;  		eclass [k] = (UInt32)j;  	}  	nNotDone = 0;  	r = -1;  	while (true) {  		/*-- find the next non-singleton bucket --*/k = r + 1;  		while (ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0xffffffff)  				k += 32;  			while (ISSET_BH (k' ref bhtab))  				k++;  		}  		l = k - 1;  		if (l >= nblock)  			break;  		while (!ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  			k++;  		if (!ISSET_BH (k' ref bhtab)) {  			while (WORD_BH (k' ref bhtab) == 0x00000000)  				k += 32;  			while (!ISSET_BH (k' ref bhtab))  				k++;  		}  		r = k - 1;  		if (r >= nblock)  			break;  		/*-- now [l' r] bracket current bucket --*/if (r > l) {  			nNotDone += (r - l + 1);  			fallbackQSort3 (ref fmap' ref eclass' l' r);  			/*-- scan bucket and generate header bits-- */cc = -1;  			for (i = l; i <= r; i++) {  				cc1 = (Int32)eclass [fmap [i]];  				if (cc != cc1) {  					SET_BH (i' ref bhtab);  					cc = cc1;  				}  				;  			}  		}  	}  	if (verb >= 4)  		BZLibCommon.VPrintf ("{0} unresolved strings\n"' nNotDone);  	H *= 2;  	if (H > nblock || nNotDone == 0)  		break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("        depth {0} has "' H);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (true) {  	/*-- find the next non-singleton bucket --*/k = r + 1;  	while (ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  		k++;  	if (ISSET_BH (k' ref bhtab)) {  		while (WORD_BH (k' ref bhtab) == 0xffffffff)  			k += 32;  		while (ISSET_BH (k' ref bhtab))  			k++;  	}  	l = k - 1;  	if (l >= nblock)  		break;  	while (!ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  		k++;  	if (!ISSET_BH (k' ref bhtab)) {  		while (WORD_BH (k' ref bhtab) == 0x00000000)  			k += 32;  		while (!ISSET_BH (k' ref bhtab))  			k++;  	}  	r = k - 1;  	if (r >= nblock)  		break;  	/*-- now [l' r] bracket current bucket --*/if (r > l) {  		nNotDone += (r - l + 1);  		fallbackQSort3 (ref fmap' ref eclass' l' r);  		/*-- scan bucket and generate header bits-- */cc = -1;  		for (i = l; i <= r; i++) {  			cc1 = (Int32)eclass [fmap [i]];  			if (cc != cc1) {  				SET_BH (i' ref bhtab);  				cc = cc1;  			}  			;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (true) {  	/*-- find the next non-singleton bucket --*/k = r + 1;  	while (ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  		k++;  	if (ISSET_BH (k' ref bhtab)) {  		while (WORD_BH (k' ref bhtab) == 0xffffffff)  			k += 32;  		while (ISSET_BH (k' ref bhtab))  			k++;  	}  	l = k - 1;  	if (l >= nblock)  		break;  	while (!ISSET_BH (k' ref bhtab) && UNALIGNED_BH (k))  		k++;  	if (!ISSET_BH (k' ref bhtab)) {  		while (WORD_BH (k' ref bhtab) == 0x00000000)  			k += 32;  		while (!ISSET_BH (k' ref bhtab))  			k++;  	}  	r = k - 1;  	if (r >= nblock)  		break;  	/*-- now [l' r] bracket current bucket --*/if (r > l) {  		nNotDone += (r - l + 1);  		fallbackQSort3 (ref fmap' ref eclass' l' r);  		/*-- scan bucket and generate header bits-- */cc = -1;  		for (i = l; i <= r; i++) {  			cc1 = (Int32)eclass [fmap [i]];  			if (cc != cc1) {  				SET_BH (i' ref bhtab);  				cc = cc1;  			}  			;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: if (ISSET_BH (k' ref bhtab)) {  	while (WORD_BH (k' ref bhtab) == 0xffffffff)  		k += 32;  	while (ISSET_BH (k' ref bhtab))  		k++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (WORD_BH (k' ref bhtab) == 0xffffffff)  	k += 32;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: k += 32;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: if (!ISSET_BH (k' ref bhtab)) {  	while (WORD_BH (k' ref bhtab) == 0x00000000)  		k += 32;  	while (!ISSET_BH (k' ref bhtab))  		k++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: while (WORD_BH (k' ref bhtab) == 0x00000000)  	k += 32;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: k += 32;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("{0} unresolved strings\n"' nNotDone);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: H *= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("        reconstructing block ...\n");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: BZLibCommon.AssertH (j < 256' 1005);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,fallbackSort,The following statement contains a magic number: BZLibCommon.AssertH (j < 256' 1005);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainGtU,The following statement contains a magic number: k = (Int32)nblock + 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainGtU,The following statement contains a magic number: do {  	/* 1 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];   	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	/* 2 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];   	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	/* 3 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];   	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	/* 4 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];   	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	/* 5 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];   	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	/* 6 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];   	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	/* 7 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];   	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	/* 8 */c1 = block.ReadByte (i1);  	c2 = block.ReadByte (i2);  	if (c1 != c2)  		return (c1 > c2);  	//s1 = quadrant[i1];  	s1 = block.ReadUInt16 (i1 + quadrantPos);  	//s2 = quadrant[i2];  	s2 = block.ReadUInt16 (i2 + quadrantPos);  	if (s1 != s2)  		return (s1 > s2);  	i1++;  	i2++;  	if (i1 >= nblock)  		i1 -= nblock;  	if (i2 >= nblock)  		i2 -= nblock;  	k -= 8;  	(budget)--;  }  while (k >= 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainGtU,The following statement contains a magic number: k -= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSimpleSort,The following statement contains a magic number: if (bigN < 2)  	return;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: while (sp > 0) {  	BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  	mpop (ref lo' ref hi' ref d' ref sp' stackLo' stackHi' stackD);  	if (hi - lo < MAIN_QSORT_SMALL_THRESH || d > MAIN_QSORT_DEPTH_THRESH) {  		mainSimpleSort (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' d' ref budget);  		if (budget < 0)  			return;  		continue;  	}  	med = (Int32)mmed3 (block.ReadByte ((Int32)ptr [lo] + d)' block.ReadByte ((Int32)ptr [hi] + d)' block.ReadByte ((Int32)ptr [(lo + hi) >> 1] + d));  	unLo = ltLo = lo;  	unHi = gtHi = hi;  	while (true) {  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unLo] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unLo]' ref ptr [ltLo]);  				ltLo++;  				unLo++;  				continue;  			}  			;  			if (n > 0)  				break;  			unLo++;  		}  		while (true) {  			if (unLo > unHi)  				break;  			n = ((Int32)block.ReadByte ((Int32)ptr [unHi] + d)) - med;  			if (n == 0) {  				mswap (ref ptr [unHi]' ref ptr [gtHi]);  				gtHi--;  				unHi--;  				continue;  			}  			;  			if (n < 0)  				break;  			unHi--;  		}  		if (unLo > unHi)  			break;  		mswap (ref ptr [unLo]' ref ptr [unHi]);  		unLo++;  		unHi--;  	}  	BZLibCommon.AssertD (unHi == unLo - 1' "mainQSort3(2)");  	if (gtHi < ltLo) {  		mpush (lo' hi' d + 1' ref stackLo' ref stackHi' ref stackD' ref sp);  		continue;  	}  	n = mmin (ltLo - lo' unLo - ltLo);  	mvswap (lo' unLo - n' n' ref ptr);  	m = mmin (hi - gtHi' gtHi - unHi);  	mvswap (unLo' hi - m + 1' m' ref ptr);  	n = lo + unLo - ltLo - 1;  	m = hi - (gtHi - unHi) + 1;  	nextLo [0] = lo;  	nextHi [0] = n;  	nextD [0] = d;  	nextLo [1] = m;  	nextHi [1] = hi;  	nextD [1] = d;  	nextLo [2] = n + 1;  	nextHi [2] = m - 1;  	nextD [2] = d + 1;  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  		mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  	if (mnextsize (0' ref nextLo' ref nextHi) < mnextsize (1' ref nextLo' ref nextHi))  		mnextswap (0' 1' ref nextLo' ref nextHi' ref nextD);  	BZLibCommon.AssertD (mnextsize (0' ref nextLo' ref nextHi) >= mnextsize (1' ref nextLo' ref nextHi)' "mainQSort3(8)");  	BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  	mpush (nextLo [0]' nextHi [0]' nextD [0]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [1]' nextHi [1]' nextD [1]' ref stackLo' ref stackHi' ref stackD' ref sp);  	mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: BZLibCommon.AssertH (sp < MAIN_QSORT_STACK_SIZE' 1001);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: nextLo [2] = n + 1;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: nextHi [2] = m - 1;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: nextD [2] = d + 1;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  	mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: if (mnextsize (1' ref nextLo' ref nextHi) < mnextsize (2' ref nextLo' ref nextHi))  	mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: mnextswap (1' 2' ref nextLo' ref nextHi' ref nextD);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: BZLibCommon.AssertD (mnextsize (1' ref nextLo' ref nextHi) >= mnextsize (2' ref nextLo' ref nextHi)' "mainQSort3(9)");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainQSort3,The following statement contains a magic number: mpush (nextLo [2]' nextHi [2]' nextD [2]' ref stackLo' ref stackHi' ref stackD' ref sp);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("        main sort initialise ...\n");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 65536; i++)  	ftab [i] = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = block.ReadByte (0) << 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  	ftab [j]++;  	//quadrant[i - 1] = 0;  	block.WriteUInt16 (i - 1 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  	ftab [j]++;  	//quadrant[i - 2] = 0;  	block.WriteUInt16 (i - 2 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  	ftab [j]++;  	//quadrant[i - 3] = 0;  	block.WriteUInt16 (i - 3 + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: i -= 4
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = ((j >> 8) | (((UInt16)block.ReadByte (i)) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 1)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: block.WriteUInt16 (i - 2 + quadrantPos' 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 2)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: block.WriteUInt16 (i - 3 + quadrantPos' 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i - 3)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 0; i--) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 0; i--) {  	//quadrant[i] = 0;  	block.WriteUInt16 (i + quadrantPos' 0);  	j = (j >> 8) | (((UInt16)block.ReadByte (i)) << 8);  	ftab [j]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (j >> 8) | (((UInt16)block.ReadByte (i)) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("        bucket sorting ...\n");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 1; i <= 65536; i++)  	ftab [i] += ftab [i - 1];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)(block.ReadByte (0) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 3; i -= 4) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 1;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 2;  	s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i - 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: i -= 4
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 1) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 2) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: ptr [j] = (UInt32)i - 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i - 3) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: ptr [j] = (UInt32)i - 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 0; i--) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (; i >= 0; i--) {  	s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  	j = (Int32)ftab [s] - 1;  	ftab [s] = (UInt32)j;  	ptr [j] = (UInt32)i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: s = (UInt16)((s >> 8) | (block.ReadByte (i) << 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	bigDone [i] = false;  	runningOrder [i] = (Int32)i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: do  	h = 3 * h + 1;  while (h <= 256);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: do  	h = 3 * h + 1;  while (h <= 256);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: h = 3 * h + 1;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while (BIGFREQ (runningOrder [j - h]' ftab) > BIGFREQ (vv' ftab)) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1))  				goto zero;  		}  		zero:  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: do {  	h = h / 3;  	for (i = h; i <= 255; i++) {  		vv = runningOrder [i];  		j = i;  		while (BIGFREQ (runningOrder [j - h]' ftab) > BIGFREQ (vv' ftab)) {  			runningOrder [j] = runningOrder [j - h];  			j = j - h;  			if (j <= (h - 1))  				goto zero;  		}  		zero:  		runningOrder [j] = vv;  	}  }  while (h != 1);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: h = h / 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = h; i <= 255; i++) {  	vv = runningOrder [i];  	j = i;  	while (BIGFREQ (runningOrder [j - h]' ftab) > BIGFREQ (vv' ftab)) {  		runningOrder [j] = runningOrder [j - h];  		j = j - h;  		if (j <= (h - 1))  			goto zero;  	}  	zero:  	runningOrder [j] = vv;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (i = 0; i <= 255; i++) {  	/*-- 				   Process big buckets' starting with the least full. 				   Basically this is a 3-step process in which we call 				   mainQSort3 to sort the small buckets [ss' j]' but 				   also make a big effort to avoid the calls if we can. 				--*/ss = runningOrder [i];  	/*-- 				   Step 1: 				   Complete the big bucket [ss] by quicksorting 				   any unsorted small buckets [ss' j]' for j != ss.   				   Hopefully previous pointer-scanning phases have already 				   completed many of the small buckets [ss' j]' so 				   we don't have to sort them at all. 				--*/for (j = 0; j <= 255; j++) {  		if (j != ss) {  			sb = (Int32)((ss << 8) + j);  			if ((ftab [sb] & SETMASK) == 0) {  				Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  				Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  				if (hi > lo) {  					if (verb >= 4)  						BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  					mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  					numQSorted += (hi - lo + 1);  					if (budget < 0)  						return;  				}  			}  			ftab [sb] |= SETMASK;  		}  	}  	BZLibCommon.AssertH (!bigDone [ss]' 1006);  	/*-- 				   Step 2: 				   Now scan this big bucket [ss] so as to synthesise the 				   sorted order for small buckets [t' ss] for all t' 				   including' magically' the bucket [ss'ss] too. 				   This will avoid doing Real Work in subsequent Step 1's. 				--*/{  		for (j = 0; j <= 255; j++) {  			copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  			copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  		}  		for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  			if (ptr [j] > 0)  				k = (Int32)ptr [j] - 1;  			else  				k = (Int32)nblock - 1;  			//if (k < 0) k += nblock;  			c1 = block.ReadByte (k);  			if (!bigDone [c1])  				ptr [copyStart [c1]++] = (UInt32)k;  		}  		if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  			for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  				if (ptr [j] > 0)  					k = (Int32)ptr [j] - 1;  				else  					k = nblock - 1;  				c1 = block.ReadByte (k);  				if (!bigDone [c1]) {  					ptr [copyEnd [c1]--] = (UInt32)k;  				}  			}  		}  	/*-- 				   Step 3: 				   The [ss] big bucket is now done.  Record this fact' 				   and update the quadrant descriptors.  Remember to 				   update quadrants in the overshoot area too' if 				   necessary.  The "if (i < 255)" test merely skips 				   this updating for the last bucket processed' since 				   updating for the last bucket is pointless.  				   The quadrant array provides a way to incrementally 				   cache sort orderings' as they appear' so as to  				   make subsequent comparisons in fullGtU() complete 				   faster.  For repetitive blocks this makes a big 				   difference (but not big enough to be able to avoid 				   the fallback sorting mechanism' exponential radix sort).  				   The precise meaning is: at all times:  					  for 0 <= i < nblock and 0 <= j <= nblock  					  if block.ReadByte(i] != block.ReadByte(j]'   						 then the relative values of quadrant[i] and  							  quadrant[j] are meaningless.  						 else { 							if quadrant[i] < quadrant[j] 							   then the string starting at i lexicographically 							   precedes the string starting at j  							else if quadrant[i] > quadrant[j] 							   then the string starting at j lexicographically 							   precedes the string starting at i  							else 							   the relative ordering of the strings starting 							   at i and j has not yet been determined. 						 } 				--*/}  	BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  	for (j = 0; j <= 255; j++)  		ftab [(j << 8) + ss] |= SETMASK;  	bigDone [ss] = true;  	if (i < 255) {  		Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  		Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  		Int32 shifts = 0;  		while ((bbSize >> shifts) > 65534)  			shifts++;  		if (bbSize > 0)//fixed overflow on bbSize  		 {  			for (j = bbSize - 1; j >= 0; j--) {  				Int32 a2update = (Int32)ptr [bbStart + j];  				UInt16 qVal = (UInt16)(j >> shifts);  				//quadrant[a2update] = qVal;  				block.WriteUInt16 (a2update + quadrantPos' qVal);  				if (a2update < BZ_N_OVERSHOOT)  					//quadrant[a2update + nblock] = qVal;  					block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  			}  		}  		BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	if (j != ss) {  		sb = (Int32)((ss << 8) + j);  		if ((ftab [sb] & SETMASK) == 0) {  			Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  			Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  			if (hi > lo) {  				if (verb >= 4)  					BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  				mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  				numQSorted += (hi - lo + 1);  				if (budget < 0)  					return;  			}  		}  		ftab [sb] |= SETMASK;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	if (j != ss) {  		sb = (Int32)((ss << 8) + j);  		if ((ftab [sb] & SETMASK) == 0) {  			Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  			Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  			if (hi > lo) {  				if (verb >= 4)  					BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  				mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  				numQSorted += (hi - lo + 1);  				if (budget < 0)  					return;  			}  		}  		ftab [sb] |= SETMASK;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	if (j != ss) {  		sb = (Int32)((ss << 8) + j);  		if ((ftab [sb] & SETMASK) == 0) {  			Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  			Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  			if (hi > lo) {  				if (verb >= 4)  					BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  				mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  				numQSorted += (hi - lo + 1);  				if (budget < 0)  					return;  			}  		}  		ftab [sb] |= SETMASK;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (j != ss) {  	sb = (Int32)((ss << 8) + j);  	if ((ftab [sb] & SETMASK) == 0) {  		Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  		Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  		if (hi > lo) {  			if (verb >= 4)  				BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  			mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  			numQSorted += (hi - lo + 1);  			if (budget < 0)  				return;  		}  	}  	ftab [sb] |= SETMASK;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (j != ss) {  	sb = (Int32)((ss << 8) + j);  	if ((ftab [sb] & SETMASK) == 0) {  		Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  		Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  		if (hi > lo) {  			if (verb >= 4)  				BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  			mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  			numQSorted += (hi - lo + 1);  			if (budget < 0)  				return;  		}  	}  	ftab [sb] |= SETMASK;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: sb = (Int32)((ss << 8) + j);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if ((ftab [sb] & SETMASK) == 0) {  	Int32 lo = (Int32)(ftab [sb] & CLEARMASK);  	Int32 hi = (Int32)((ftab [sb + 1] & CLEARMASK) - 1);  	if (hi > lo) {  		if (verb >= 4)  			BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  		mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  		numQSorted += (hi - lo + 1);  		if (budget < 0)  			return;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (hi > lo) {  	if (verb >= 4)  		BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  	mainQSort3 (ref ptr' ref block' ref quadrantPos' nblock' lo' hi' BZ_N_RADIX' ref budget);  	numQSorted += (hi - lo + 1);  	if (budget < 0)  		return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("        qsort [0x{0:x}' 0x{1:x}   " + "done {2}   this {3}\n"' ss' (Int32)j' numQSorted' hi - lo + 1);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: BZLibCommon.AssertH (!bigDone [ss]' 1006);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  	copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  	copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++) {  	copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  	copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: copyStart [j] = (Int32)(ftab [(j << 8) + ss] & CLEARMASK);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: copyEnd [j] = (Int32)((ftab [(j << 8) + ss + 1] & CLEARMASK) - 1);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = ((Int32)ftab [ss << 8] & CLEARMASK); j < copyStart [ss]; j++) {  	if (ptr [j] > 0)  		k = (Int32)ptr [j] - 1;  	else  		k = (Int32)nblock - 1;  	//if (k < 0) k += nblock;  	c1 = block.ReadByte (k);  	if (!bigDone [c1])  		ptr [copyStart [c1]++] = (UInt32)k;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = ((Int32)ftab [ss << 8] & CLEARMASK)
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  	for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  		if (ptr [j] > 0)  			k = (Int32)ptr [j] - 1;  		else  			k = nblock - 1;  		c1 = block.ReadByte (k);  		if (!bigDone [c1]) {  			ptr [copyEnd [c1]--] = (UInt32)k;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if ((ftab [(ss + 1) << 8] & CLEARMASK) > 0) {  	for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  		if (ptr [j] > 0)  			k = (Int32)ptr [j] - 1;  		else  			k = nblock - 1;  		c1 = block.ReadByte (k);  		if (!bigDone [c1]) {  			ptr [copyEnd [c1]--] = (UInt32)k;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1); j > copyEnd [ss]; j--) {  	if (ptr [j] > 0)  		k = (Int32)ptr [j] - 1;  	else  		k = nblock - 1;  	c1 = block.ReadByte (k);  	if (!bigDone [c1]) {  		ptr [copyEnd [c1]--] = (UInt32)k;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: j = (((Int32)ftab [(ss + 1) << 8] & CLEARMASK) - 1)
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: BZLibCommon.AssertH (copyStart [ss] - 1 == copyEnd [ss]' 1007);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++)  	ftab [(j << 8) + ss] |= SETMASK;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: for (j = 0; j <= 255; j++)  	ftab [(j << 8) + ss] |= SETMASK;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: ftab [(j << 8) + ss] |= SETMASK;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (i < 255) {  	Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  	Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	Int32 shifts = 0;  	while ((bbSize >> shifts) > 65534)  		shifts++;  	if (bbSize > 0)//fixed overflow on bbSize  	 {  		for (j = bbSize - 1; j >= 0; j--) {  			Int32 a2update = (Int32)ptr [bbStart + j];  			UInt16 qVal = (UInt16)(j >> shifts);  			//quadrant[a2update] = qVal;  			block.WriteUInt16 (a2update + quadrantPos' qVal);  			if (a2update < BZ_N_OVERSHOOT)  				//quadrant[a2update + nblock] = qVal;  				block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  		}  	}  	BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (i < 255) {  	Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  	Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	Int32 shifts = 0;  	while ((bbSize >> shifts) > 65534)  		shifts++;  	if (bbSize > 0)//fixed overflow on bbSize  	 {  		for (j = bbSize - 1; j >= 0; j--) {  			Int32 a2update = (Int32)ptr [bbStart + j];  			UInt16 qVal = (UInt16)(j >> shifts);  			//quadrant[a2update] = qVal;  			block.WriteUInt16 (a2update + quadrantPos' qVal);  			if (a2update < BZ_N_OVERSHOOT)  				//quadrant[a2update + nblock] = qVal;  				block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  		}  	}  	BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (i < 255) {  	Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  	Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	Int32 shifts = 0;  	while ((bbSize >> shifts) > 65534)  		shifts++;  	if (bbSize > 0)//fixed overflow on bbSize  	 {  		for (j = bbSize - 1; j >= 0; j--) {  			Int32 a2update = (Int32)ptr [bbStart + j];  			UInt16 qVal = (UInt16)(j >> shifts);  			//quadrant[a2update] = qVal;  			block.WriteUInt16 (a2update + quadrantPos' qVal);  			if (a2update < BZ_N_OVERSHOOT)  				//quadrant[a2update + nblock] = qVal;  				block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  		}  	}  	BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (i < 255) {  	Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  	Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	Int32 shifts = 0;  	while ((bbSize >> shifts) > 65534)  		shifts++;  	if (bbSize > 0)//fixed overflow on bbSize  	 {  		for (j = bbSize - 1; j >= 0; j--) {  			Int32 a2update = (Int32)ptr [bbStart + j];  			UInt16 qVal = (UInt16)(j >> shifts);  			//quadrant[a2update] = qVal;  			block.WriteUInt16 (a2update + quadrantPos' qVal);  			if (a2update < BZ_N_OVERSHOOT)  				//quadrant[a2update + nblock] = qVal;  				block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  		}  	}  	BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (i < 255) {  	Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  	Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	Int32 shifts = 0;  	while ((bbSize >> shifts) > 65534)  		shifts++;  	if (bbSize > 0)//fixed overflow on bbSize  	 {  		for (j = bbSize - 1; j >= 0; j--) {  			Int32 a2update = (Int32)ptr [bbStart + j];  			UInt16 qVal = (UInt16)(j >> shifts);  			//quadrant[a2update] = qVal;  			block.WriteUInt16 (a2update + quadrantPos' qVal);  			if (a2update < BZ_N_OVERSHOOT)  				//quadrant[a2update + nblock] = qVal;  				block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  		}  	}  	BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (i < 255) {  	Int32 bbStart = (Int32)ftab [ss << 8] & CLEARMASK;  	Int32 bbSize = (Int32)(ftab [(ss + 1) << 8] & CLEARMASK) - bbStart;  	Int32 shifts = 0;  	while ((bbSize >> shifts) > 65534)  		shifts++;  	if (bbSize > 0)//fixed overflow on bbSize  	 {  		for (j = bbSize - 1; j >= 0; j--) {  			Int32 a2update = (Int32)ptr [bbStart + j];  			UInt16 qVal = (UInt16)(j >> shifts);  			//quadrant[a2update] = qVal;  			block.WriteUInt16 (a2update + quadrantPos' qVal);  			if (a2update < BZ_N_OVERSHOOT)  				//quadrant[a2update + nblock] = qVal;  				block.WriteUInt16 (a2update + nblock + quadrantPos' qVal);  		}  	}  	BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: while ((bbSize >> shifts) > 65534)  	shifts++;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: BZLibCommon.AssertH (((bbSize - 1) >> shifts) <= 65535' 1002);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,mainSort,The following statement contains a magic number: if (verb >= 4)  	BZLibCommon.VPrintf ("        {0} pointers' {1} sorted' {2} scanned\n"' nblock' numQSorted' nblock - numQSorted);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (nblock < 10000) {  	fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  }  else {  	/* Calculate the location for quadrant' remembering to get 				   the alignment right.  Assumes that &(block.ReadByte(0]) is at least 				   2-byte aligned -- this should be ok since block is really 				   the first section of arr2. 				*/i = nblock + BZ_N_OVERSHOOT;  	if ((i & 1) != 0)  		i++;  	// now quadrand is used as DataStream with index quadrantPos  	//quadrant = (UInt16*)(&(block[i]));  	Int32 quadrantPos = i >> 1;  	/* (wfact-1) / 3 puts the default-factor-30 				   transition point at very roughly the same place as  				   with v0.1 and v0.9.0.   				   Not that it particularly matters any more' since the 				   resulting compressed stream is now the same regardless 				   of whether or not we use the main sort or fallback sort. 				*/if (wfact < 1)  		wfact = 1;  	if (wfact > 100)  		wfact = 100;  	budgetInit = (Int32)nblock * ((wfact - 1) / 3);  	budget = budgetInit;  	mainSort (ref ptr' ref block' ref quadrantPos' ref ftab' nblock' verb' ref budget);  	if (verb >= 3)  		BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock));  	if (budget < 0) {  		if (verb >= 2)  			BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  		fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (nblock < 10000) {  	fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  }  else {  	/* Calculate the location for quadrant' remembering to get 				   the alignment right.  Assumes that &(block.ReadByte(0]) is at least 				   2-byte aligned -- this should be ok since block is really 				   the first section of arr2. 				*/i = nblock + BZ_N_OVERSHOOT;  	if ((i & 1) != 0)  		i++;  	// now quadrand is used as DataStream with index quadrantPos  	//quadrant = (UInt16*)(&(block[i]));  	Int32 quadrantPos = i >> 1;  	/* (wfact-1) / 3 puts the default-factor-30 				   transition point at very roughly the same place as  				   with v0.1 and v0.9.0.   				   Not that it particularly matters any more' since the 				   resulting compressed stream is now the same regardless 				   of whether or not we use the main sort or fallback sort. 				*/if (wfact < 1)  		wfact = 1;  	if (wfact > 100)  		wfact = 100;  	budgetInit = (Int32)nblock * ((wfact - 1) / 3);  	budget = budgetInit;  	mainSort (ref ptr' ref block' ref quadrantPos' ref ftab' nblock' verb' ref budget);  	if (verb >= 3)  		BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock));  	if (budget < 0) {  		if (verb >= 2)  			BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  		fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (nblock < 10000) {  	fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  }  else {  	/* Calculate the location for quadrant' remembering to get 				   the alignment right.  Assumes that &(block.ReadByte(0]) is at least 				   2-byte aligned -- this should be ok since block is really 				   the first section of arr2. 				*/i = nblock + BZ_N_OVERSHOOT;  	if ((i & 1) != 0)  		i++;  	// now quadrand is used as DataStream with index quadrantPos  	//quadrant = (UInt16*)(&(block[i]));  	Int32 quadrantPos = i >> 1;  	/* (wfact-1) / 3 puts the default-factor-30 				   transition point at very roughly the same place as  				   with v0.1 and v0.9.0.   				   Not that it particularly matters any more' since the 				   resulting compressed stream is now the same regardless 				   of whether or not we use the main sort or fallback sort. 				*/if (wfact < 1)  		wfact = 1;  	if (wfact > 100)  		wfact = 100;  	budgetInit = (Int32)nblock * ((wfact - 1) / 3);  	budget = budgetInit;  	mainSort (ref ptr' ref block' ref quadrantPos' ref ftab' nblock' verb' ref budget);  	if (verb >= 3)  		BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock));  	if (budget < 0) {  		if (verb >= 2)  			BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  		fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (nblock < 10000) {  	fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  }  else {  	/* Calculate the location for quadrant' remembering to get 				   the alignment right.  Assumes that &(block.ReadByte(0]) is at least 				   2-byte aligned -- this should be ok since block is really 				   the first section of arr2. 				*/i = nblock + BZ_N_OVERSHOOT;  	if ((i & 1) != 0)  		i++;  	// now quadrand is used as DataStream with index quadrantPos  	//quadrant = (UInt16*)(&(block[i]));  	Int32 quadrantPos = i >> 1;  	/* (wfact-1) / 3 puts the default-factor-30 				   transition point at very roughly the same place as  				   with v0.1 and v0.9.0.   				   Not that it particularly matters any more' since the 				   resulting compressed stream is now the same regardless 				   of whether or not we use the main sort or fallback sort. 				*/if (wfact < 1)  		wfact = 1;  	if (wfact > 100)  		wfact = 100;  	budgetInit = (Int32)nblock * ((wfact - 1) / 3);  	budget = budgetInit;  	mainSort (ref ptr' ref block' ref quadrantPos' ref ftab' nblock' verb' ref budget);  	if (verb >= 3)  		BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock));  	if (budget < 0) {  		if (verb >= 2)  			BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  		fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (nblock < 10000) {  	fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  }  else {  	/* Calculate the location for quadrant' remembering to get 				   the alignment right.  Assumes that &(block.ReadByte(0]) is at least 				   2-byte aligned -- this should be ok since block is really 				   the first section of arr2. 				*/i = nblock + BZ_N_OVERSHOOT;  	if ((i & 1) != 0)  		i++;  	// now quadrand is used as DataStream with index quadrantPos  	//quadrant = (UInt16*)(&(block[i]));  	Int32 quadrantPos = i >> 1;  	/* (wfact-1) / 3 puts the default-factor-30 				   transition point at very roughly the same place as  				   with v0.1 and v0.9.0.   				   Not that it particularly matters any more' since the 				   resulting compressed stream is now the same regardless 				   of whether or not we use the main sort or fallback sort. 				*/if (wfact < 1)  		wfact = 1;  	if (wfact > 100)  		wfact = 100;  	budgetInit = (Int32)nblock * ((wfact - 1) / 3);  	budget = budgetInit;  	mainSort (ref ptr' ref block' ref quadrantPos' ref ftab' nblock' verb' ref budget);  	if (verb >= 3)  		BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock));  	if (budget < 0) {  		if (verb >= 2)  			BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  		fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (nblock < 10000) {  	fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  }  else {  	/* Calculate the location for quadrant' remembering to get 				   the alignment right.  Assumes that &(block.ReadByte(0]) is at least 				   2-byte aligned -- this should be ok since block is really 				   the first section of arr2. 				*/i = nblock + BZ_N_OVERSHOOT;  	if ((i & 1) != 0)  		i++;  	// now quadrand is used as DataStream with index quadrantPos  	//quadrant = (UInt16*)(&(block[i]));  	Int32 quadrantPos = i >> 1;  	/* (wfact-1) / 3 puts the default-factor-30 				   transition point at very roughly the same place as  				   with v0.1 and v0.9.0.   				   Not that it particularly matters any more' since the 				   resulting compressed stream is now the same regardless 				   of whether or not we use the main sort or fallback sort. 				*/if (wfact < 1)  		wfact = 1;  	if (wfact > 100)  		wfact = 100;  	budgetInit = (Int32)nblock * ((wfact - 1) / 3);  	budget = budgetInit;  	mainSort (ref ptr' ref block' ref quadrantPos' ref ftab' nblock' verb' ref budget);  	if (verb >= 3)  		BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock));  	if (budget < 0) {  		if (verb >= 2)  			BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  		fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (wfact > 100)  	wfact = 100;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (wfact > 100)  	wfact = 100;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: wfact = 100;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: budgetInit = (Int32)nblock * ((wfact - 1) / 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (verb >= 3)  	BZLibCommon.VPrintf ("      {0} work' {1} block' ratio {2:f}\n"' budgetInit - budget' nblock' (float)(budgetInit - budget) / (float)(nblock == 0 ? 1 : nblock));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (budget < 0) {  	if (verb >= 2)  		BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  	fallbackSort (ref s.arr1' ref s.arr2' ref ftab' nblock' verb);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: if (verb >= 2)  	BZLibCommon.VPrintf ("    too repetitive; using fallback" + " sorting algorithm\n");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BlockSort,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\blocksort.cs,BZ2_blockSort,The following statement contains a magic number: BZLibCommon.AssertH (s.origPtr != -1' 1003);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ_GET_FAST,The following statement contains a magic number: s.tPos >>= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ_GET_FAST,The following statement contains a magic number: s.tPos >>= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ_GET_FAST_C,The following statement contains a magic number: c_tPos >>= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ_GET_FAST_C,The following statement contains a magic number: c_tPos >>= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,SET_LL4,The following statement contains a magic number: if (((i) & 0x1) == 0)  	s.ll4 [(i) >> 1] = (byte)(((s.ll4 [i >> 1]) & 0xf0) | (n));  else  	s.ll4 [(i) >> 1] = (byte)((s.ll4 [(i) >> 1] & 0x0f) | ((n) << 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,SET_LL4,The following statement contains a magic number: s.ll4 [(i) >> 1] = (byte)((s.ll4 [(i) >> 1] & 0x0f) | ((n) << 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,GET_LL4,The following statement contains a magic number: return (UInt32)((((Int32)(s.ll4 [i / 2])) >> ((Int32)((i * 4) & 0x4)) & 0xF));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,GET_LL4,The following statement contains a magic number: return (UInt32)((((Int32)(s.ll4 [i / 2])) >> ((Int32)((i * 4) & 0x4)) & 0xF));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,SET_LL,The following statement contains a magic number: SET_LL4 (ref s' i' n >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,GET_LL,The following statement contains a magic number: return (((UInt32)s.ll16 [i]) | (GET_LL4 (ref s' i) << 16));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: if (strm == null || blockSize100k < 1 || blockSize100k > 9 || workFactor < 0 || workFactor > 250)  	return BZReturnValue.BZ_PARAM_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: if (strm == null || blockSize100k < 1 || blockSize100k > 9 || workFactor < 0 || workFactor > 250)  	return BZReturnValue.BZ_PARAM_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: if (workFactor == 0)  	workFactor = 30;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: workFactor = 30;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: n = 100000 * blockSize100k;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: s.ftab = new UInt32[65537];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: s.nblockMAX = 100000 * blockSize100k - 19;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompressInit,The following statement contains a magic number: s.nblockMAX = 100000 * blockSize100k - 19;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompressInit,The following statement contains a magic number: if (verbosity < 0 || verbosity > 4)  	return BZReturnValue.BZ_PARAM_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: while (true) {  	if (s.state == BZDecompressionState.BZ_X_IDLE)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	if (s.state == BZDecompressionState.BZ_X_OUTPUT) {  		if (s.smallDecompress)  			unRLE_obuf_to_output_SMALL (ref s);  		else  			unRLE_obuf_to_output_FAST (ref s);  		if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  			CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  			if (s.verbosity >= 2)  				BZLibCommon.VPrintf ("]");  			// Xceed Extensions   			//if (s.calculatedBlockCRC != s.storedBlockCRC)  			if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  			s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  			s.state = BZDecompressionState.BZ_X_BLKHDR_1;  		}  		else {  			return BZReturnValue.BZ_OK;  		}  	}  	if (s.state >= BZDecompressionState.BZ_X_MAGIC_1) {  		BZReturnValue r = Decompress.BZ2_decompress (ref s);  		if (r == BZReturnValue.BZ_STREAM_END) {  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC);  			// Xceed Extensions   			//if (s.calculatedCombinedCRC != s.storedCombinedCRC)  			if (s.bSmallSig == 0 && s.calculatedCombinedCRC != s.storedCombinedCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			return r;  		}  		if (s.state != BZDecompressionState.BZ_X_OUTPUT)  			return r;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: while (true) {  	if (s.state == BZDecompressionState.BZ_X_IDLE)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	if (s.state == BZDecompressionState.BZ_X_OUTPUT) {  		if (s.smallDecompress)  			unRLE_obuf_to_output_SMALL (ref s);  		else  			unRLE_obuf_to_output_FAST (ref s);  		if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  			CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  			if (s.verbosity >= 2)  				BZLibCommon.VPrintf ("]");  			// Xceed Extensions   			//if (s.calculatedBlockCRC != s.storedBlockCRC)  			if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  			s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  			s.state = BZDecompressionState.BZ_X_BLKHDR_1;  		}  		else {  			return BZReturnValue.BZ_OK;  		}  	}  	if (s.state >= BZDecompressionState.BZ_X_MAGIC_1) {  		BZReturnValue r = Decompress.BZ2_decompress (ref s);  		if (r == BZReturnValue.BZ_STREAM_END) {  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC);  			// Xceed Extensions   			//if (s.calculatedCombinedCRC != s.storedCombinedCRC)  			if (s.bSmallSig == 0 && s.calculatedCombinedCRC != s.storedCombinedCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			return r;  		}  		if (s.state != BZDecompressionState.BZ_X_OUTPUT)  			return r;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: while (true) {  	if (s.state == BZDecompressionState.BZ_X_IDLE)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	if (s.state == BZDecompressionState.BZ_X_OUTPUT) {  		if (s.smallDecompress)  			unRLE_obuf_to_output_SMALL (ref s);  		else  			unRLE_obuf_to_output_FAST (ref s);  		if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  			CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  			if (s.verbosity >= 2)  				BZLibCommon.VPrintf ("]");  			// Xceed Extensions   			//if (s.calculatedBlockCRC != s.storedBlockCRC)  			if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  			s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  			s.state = BZDecompressionState.BZ_X_BLKHDR_1;  		}  		else {  			return BZReturnValue.BZ_OK;  		}  	}  	if (s.state >= BZDecompressionState.BZ_X_MAGIC_1) {  		BZReturnValue r = Decompress.BZ2_decompress (ref s);  		if (r == BZReturnValue.BZ_STREAM_END) {  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC);  			// Xceed Extensions   			//if (s.calculatedCombinedCRC != s.storedCombinedCRC)  			if (s.bSmallSig == 0 && s.calculatedCombinedCRC != s.storedCombinedCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			return r;  		}  		if (s.state != BZDecompressionState.BZ_X_OUTPUT)  			return r;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: while (true) {  	if (s.state == BZDecompressionState.BZ_X_IDLE)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	if (s.state == BZDecompressionState.BZ_X_OUTPUT) {  		if (s.smallDecompress)  			unRLE_obuf_to_output_SMALL (ref s);  		else  			unRLE_obuf_to_output_FAST (ref s);  		if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  			CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  			if (s.verbosity >= 2)  				BZLibCommon.VPrintf ("]");  			// Xceed Extensions   			//if (s.calculatedBlockCRC != s.storedBlockCRC)  			if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  			s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  			s.state = BZDecompressionState.BZ_X_BLKHDR_1;  		}  		else {  			return BZReturnValue.BZ_OK;  		}  	}  	if (s.state >= BZDecompressionState.BZ_X_MAGIC_1) {  		BZReturnValue r = Decompress.BZ2_decompress (ref s);  		if (r == BZReturnValue.BZ_STREAM_END) {  			if (s.verbosity >= 3)  				BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC);  			// Xceed Extensions   			//if (s.calculatedCombinedCRC != s.storedCombinedCRC)  			if (s.bSmallSig == 0 && s.calculatedCombinedCRC != s.storedCombinedCRC)  				return BZReturnValue.BZ_DATA_ERROR;  			return r;  		}  		if (s.state != BZDecompressionState.BZ_X_OUTPUT)  			return r;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.state == BZDecompressionState.BZ_X_OUTPUT) {  	if (s.smallDecompress)  		unRLE_obuf_to_output_SMALL (ref s);  	else  		unRLE_obuf_to_output_FAST (ref s);  	if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  		CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  		if (s.verbosity >= 3)  			BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  		if (s.verbosity >= 2)  			BZLibCommon.VPrintf ("]");  		// Xceed Extensions   		//if (s.calculatedBlockCRC != s.storedBlockCRC)  		if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  			return BZReturnValue.BZ_DATA_ERROR;  		s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  		s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  		s.state = BZDecompressionState.BZ_X_BLKHDR_1;  	}  	else {  		return BZReturnValue.BZ_OK;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.state == BZDecompressionState.BZ_X_OUTPUT) {  	if (s.smallDecompress)  		unRLE_obuf_to_output_SMALL (ref s);  	else  		unRLE_obuf_to_output_FAST (ref s);  	if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  		CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  		if (s.verbosity >= 3)  			BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  		if (s.verbosity >= 2)  			BZLibCommon.VPrintf ("]");  		// Xceed Extensions   		//if (s.calculatedBlockCRC != s.storedBlockCRC)  		if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  			return BZReturnValue.BZ_DATA_ERROR;  		s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  		s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  		s.state = BZDecompressionState.BZ_X_BLKHDR_1;  	}  	else {  		return BZReturnValue.BZ_OK;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.state == BZDecompressionState.BZ_X_OUTPUT) {  	if (s.smallDecompress)  		unRLE_obuf_to_output_SMALL (ref s);  	else  		unRLE_obuf_to_output_FAST (ref s);  	if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  		CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  		if (s.verbosity >= 3)  			BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  		if (s.verbosity >= 2)  			BZLibCommon.VPrintf ("]");  		// Xceed Extensions   		//if (s.calculatedBlockCRC != s.storedBlockCRC)  		if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  			return BZReturnValue.BZ_DATA_ERROR;  		s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  		s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  		s.state = BZDecompressionState.BZ_X_BLKHDR_1;  	}  	else {  		return BZReturnValue.BZ_OK;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  	CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  	if (s.verbosity >= 3)  		BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  	if (s.verbosity >= 2)  		BZLibCommon.VPrintf ("]");  	// Xceed Extensions   	//if (s.calculatedBlockCRC != s.storedBlockCRC)  	if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  		return BZReturnValue.BZ_DATA_ERROR;  	s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  	s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  	s.state = BZDecompressionState.BZ_X_BLKHDR_1;  }  else {  	return BZReturnValue.BZ_OK;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  	CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  	if (s.verbosity >= 3)  		BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  	if (s.verbosity >= 2)  		BZLibCommon.VPrintf ("]");  	// Xceed Extensions   	//if (s.calculatedBlockCRC != s.storedBlockCRC)  	if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  		return BZReturnValue.BZ_DATA_ERROR;  	s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  	s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  	s.state = BZDecompressionState.BZ_X_BLKHDR_1;  }  else {  	return BZReturnValue.BZ_OK;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.nblock_used == s.save_nblock + 1 && s.state_out_len == 0) {  	CRCTable.BZ_FINALISE_CRC (ref s.calculatedBlockCRC);  	if (s.verbosity >= 3)  		BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  	if (s.verbosity >= 2)  		BZLibCommon.VPrintf ("]");  	// Xceed Extensions   	//if (s.calculatedBlockCRC != s.storedBlockCRC)  	if (s.bSmallSig == 0 && s.calculatedBlockCRC != s.storedBlockCRC)  		return BZReturnValue.BZ_DATA_ERROR;  	s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  	s.calculatedCombinedCRC ^= s.calculatedBlockCRC;  	s.state = BZDecompressionState.BZ_X_BLKHDR_1;  }  else {  	return BZReturnValue.BZ_OK;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf (" {0x{0:x}' 0x{1:x}}"' s.storedBlockCRC' s.calculatedBlockCRC);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.verbosity >= 2)  	BZLibCommon.VPrintf ("]");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: s.calculatedCombinedCRC = (s.calculatedCombinedCRC << 1) | (s.calculatedCombinedCRC >> 31);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.state >= BZDecompressionState.BZ_X_MAGIC_1) {  	BZReturnValue r = Decompress.BZ2_decompress (ref s);  	if (r == BZReturnValue.BZ_STREAM_END) {  		if (s.verbosity >= 3)  			BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC);  		// Xceed Extensions   		//if (s.calculatedCombinedCRC != s.storedCombinedCRC)  		if (s.bSmallSig == 0 && s.calculatedCombinedCRC != s.storedCombinedCRC)  			return BZReturnValue.BZ_DATA_ERROR;  		return r;  	}  	if (s.state != BZDecompressionState.BZ_X_OUTPUT)  		return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (r == BZReturnValue.BZ_STREAM_END) {  	if (s.verbosity >= 3)  		BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC);  	// Xceed Extensions   	//if (s.calculatedCombinedCRC != s.storedCombinedCRC)  	if (s.bSmallSig == 0 && s.calculatedCombinedCRC != s.storedCombinedCRC)  		return BZReturnValue.BZ_DATA_ERROR;  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzDecompress,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("\n    combined CRCs: stored = 0x{0:x}' computed = 0x{1:x}"' s.storedCombinedCRC' s.calculatedCombinedCRC);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The following statement contains a magic number: if (dest == null || source == null || blockSize100k < 1 || blockSize100k > 9 || verbosity < 0 || verbosity > 4 || workFactor < 0 || workFactor > 250)  	return BZReturnValue.BZ_PARAM_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The following statement contains a magic number: if (dest == null || source == null || blockSize100k < 1 || blockSize100k > 9 || verbosity < 0 || verbosity > 4 || workFactor < 0 || workFactor > 250)  	return BZReturnValue.BZ_PARAM_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The following statement contains a magic number: if (dest == null || source == null || blockSize100k < 1 || blockSize100k > 9 || verbosity < 0 || verbosity > 4 || workFactor < 0 || workFactor > 250)  	return BZReturnValue.BZ_PARAM_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The following statement contains a magic number: if (workFactor == 0)  	workFactor = 30;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffCompress,The following statement contains a magic number: workFactor = 30;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzBuffToBuffDecompress,The following statement contains a magic number: if (dest == null || source == null || verbosity < 0 || verbosity > 4)  	return BZReturnValue.BZ_PARAM_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,prepare_new_block,The following statement contains a magic number: for (i = 0; i < 256; i++)  	s.inUse [i] = false;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,init_RL,The following statement contains a magic number: s.state_in_ch = 256;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,isempty_RL,The following statement contains a magic number: if (s.state_in_ch < 256 && s.state_in_len > 0)  	return false;  else  	return true;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,add_pair_to_block,The following statement contains a magic number: switch (s.state_in_len) {  case 1:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 2:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 3:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  default:  	s.inUse [s.state_in_len - 4] = true;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' ((byte)(s.state_in_len - 4)));  	s.nblock++;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,add_pair_to_block,The following statement contains a magic number: switch (s.state_in_len) {  case 1:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 2:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 3:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  default:  	s.inUse [s.state_in_len - 4] = true;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' ((byte)(s.state_in_len - 4)));  	s.nblock++;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,add_pair_to_block,The following statement contains a magic number: switch (s.state_in_len) {  case 1:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 2:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 3:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  default:  	s.inUse [s.state_in_len - 4] = true;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' ((byte)(s.state_in_len - 4)));  	s.nblock++;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,add_pair_to_block,The following statement contains a magic number: switch (s.state_in_len) {  case 1:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 2:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  case 3:  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	break;  default:  	s.inUse [s.state_in_len - 4] = true;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' (byte)ch);  	s.nblock++;  	s.block.WriteByte (s.nblock' ((byte)(s.state_in_len - 4)));  	s.nblock++;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,add_pair_to_block,The following statement contains a magic number: s.inUse [s.state_in_len - 4] = true;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,add_pair_to_block,The following statement contains a magic number: s.block.WriteByte (s.nblock' ((byte)(s.state_in_len - 4)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,flush_RL,The following statement contains a magic number: if (s.state_in_ch < 256)  	add_pair_to_block (ref s);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,ADD_CHAR_TO_BLOCK,The following statement contains a magic number: if (zchh != zs.state_in_ch && zs.state_in_len == 1) {  	byte ch = (byte)(zs.state_in_ch);  	CRCTable.BZ_UPDATE_CRC (ref zs.blockCRC' ch);  	zs.inUse [zs.state_in_ch] = true;  	zs.block.WriteByte (zs.nblock' (byte)ch);  	zs.nblock++;  	zs.state_in_ch = zchh;  }  else//-- general' uncommon cases --  if (zchh != zs.state_in_ch || zs.state_in_len == 255) {  	if (zs.state_in_ch < 256)  		add_pair_to_block (ref zs);  	zs.state_in_ch = zchh;  	zs.state_in_len = 1;  }  else {  	zs.state_in_len++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,ADD_CHAR_TO_BLOCK,The following statement contains a magic number: if (zchh != zs.state_in_ch && zs.state_in_len == 1) {  	byte ch = (byte)(zs.state_in_ch);  	CRCTable.BZ_UPDATE_CRC (ref zs.blockCRC' ch);  	zs.inUse [zs.state_in_ch] = true;  	zs.block.WriteByte (zs.nblock' (byte)ch);  	zs.nblock++;  	zs.state_in_ch = zchh;  }  else//-- general' uncommon cases --  if (zchh != zs.state_in_ch || zs.state_in_len == 255) {  	if (zs.state_in_ch < 256)  		add_pair_to_block (ref zs);  	zs.state_in_ch = zchh;  	zs.state_in_len = 1;  }  else {  	zs.state_in_len++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,ADD_CHAR_TO_BLOCK,The following statement contains a magic number: if (zchh != zs.state_in_ch || zs.state_in_len == 255) {  	if (zs.state_in_ch < 256)  		add_pair_to_block (ref zs);  	zs.state_in_ch = zchh;  	zs.state_in_len = 1;  }  else {  	zs.state_in_len++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,ADD_CHAR_TO_BLOCK,The following statement contains a magic number: if (zchh != zs.state_in_ch || zs.state_in_len == 255) {  	if (zs.state_in_ch < 256)  		add_pair_to_block (ref zs);  	zs.state_in_ch = zchh;  	zs.state_in_len = 1;  }  else {  	zs.state_in_len++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,ADD_CHAR_TO_BLOCK,The following statement contains a magic number: if (zs.state_in_ch < 256)  	add_pair_to_block (ref zs);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	// restore   	UInt32 c_calculatedBlockCRC = s.calculatedBlockCRC;  	byte c_state_out_ch = s.state_out_ch;  	Int32 c_state_out_len = s.state_out_len;  	Int32 c_nblock_used = s.nblock_used;  	Int32 c_k0 = s.k0;  	UInt32[] c_tt = s.tt;  	UInt32 c_tPos = s.tPos;  	byte[] cs_next_out = s.strm.next_out;  	UInt32 cs_next_out_index = s.strm.next_out_index;  	uint cs_avail_out = s.strm.avail_out;  	// end restore   	UInt32 avail_out_INIT = cs_avail_out;  	Int32 s_save_nblockPP = s.save_nblock + 1;  	UInt64 total_out_old;  	while (true) {  		// try to finish existing run   		if (c_state_out_len > 0) {  			while (true) {  				if (cs_avail_out == 0)  					goto return_notr;  				if (c_state_out_len == 1)  					break;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				c_state_out_len--;  				cs_next_out_index++;  				cs_avail_out--;  			}  			//					s_state_out_len_eq_one:  			{  				if (cs_avail_out == 0) {  					c_state_out_len = 1;  					goto return_notr;  				}  				;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				cs_next_out_index++;  				cs_avail_out--;  			}  		}  		s_state_out_len_eq_one:  		// can a new run be started?   		if (c_nblock_used == s_save_nblockPP) {  			c_state_out_len = 0;  			goto return_notr;  		}  		;  		c_state_out_ch = (byte)c_k0;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  			if (k1 != c_k0) {  				c_k0 = k1;  			}  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  			goto s_state_out_len_eq_one;  		}  		c_state_out_len = 2;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		c_state_out_len = 3;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		c_state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  		c_nblock_used++;  	}  	return_notr:  	total_out_old = s.strm.total_out;  	s.strm.total_out += (avail_out_INIT - cs_avail_out);  	// save   	s.calculatedBlockCRC = c_calculatedBlockCRC;  	s.state_out_ch = c_state_out_ch;  	s.state_out_len = c_state_out_len;  	s.nblock_used = c_nblock_used;  	s.k0 = c_k0;  	s.tt = c_tt;  	s.tPos = c_tPos;  	s.strm.next_out_index = cs_next_out_index;  	s.strm.avail_out = cs_avail_out;  	// end save   }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	// restore   	UInt32 c_calculatedBlockCRC = s.calculatedBlockCRC;  	byte c_state_out_ch = s.state_out_ch;  	Int32 c_state_out_len = s.state_out_len;  	Int32 c_nblock_used = s.nblock_used;  	Int32 c_k0 = s.k0;  	UInt32[] c_tt = s.tt;  	UInt32 c_tPos = s.tPos;  	byte[] cs_next_out = s.strm.next_out;  	UInt32 cs_next_out_index = s.strm.next_out_index;  	uint cs_avail_out = s.strm.avail_out;  	// end restore   	UInt32 avail_out_INIT = cs_avail_out;  	Int32 s_save_nblockPP = s.save_nblock + 1;  	UInt64 total_out_old;  	while (true) {  		// try to finish existing run   		if (c_state_out_len > 0) {  			while (true) {  				if (cs_avail_out == 0)  					goto return_notr;  				if (c_state_out_len == 1)  					break;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				c_state_out_len--;  				cs_next_out_index++;  				cs_avail_out--;  			}  			//					s_state_out_len_eq_one:  			{  				if (cs_avail_out == 0) {  					c_state_out_len = 1;  					goto return_notr;  				}  				;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				cs_next_out_index++;  				cs_avail_out--;  			}  		}  		s_state_out_len_eq_one:  		// can a new run be started?   		if (c_nblock_used == s_save_nblockPP) {  			c_state_out_len = 0;  			goto return_notr;  		}  		;  		c_state_out_ch = (byte)c_k0;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  			if (k1 != c_k0) {  				c_k0 = k1;  			}  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  			goto s_state_out_len_eq_one;  		}  		c_state_out_len = 2;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		c_state_out_len = 3;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		c_state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  		c_nblock_used++;  	}  	return_notr:  	total_out_old = s.strm.total_out;  	s.strm.total_out += (avail_out_INIT - cs_avail_out);  	// save   	s.calculatedBlockCRC = c_calculatedBlockCRC;  	s.state_out_ch = c_state_out_ch;  	s.state_out_len = c_state_out_len;  	s.nblock_used = c_nblock_used;  	s.k0 = c_k0;  	s.tt = c_tt;  	s.tPos = c_tPos;  	s.strm.next_out_index = cs_next_out_index;  	s.strm.avail_out = cs_avail_out;  	// end save   }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	// restore   	UInt32 c_calculatedBlockCRC = s.calculatedBlockCRC;  	byte c_state_out_ch = s.state_out_ch;  	Int32 c_state_out_len = s.state_out_len;  	Int32 c_nblock_used = s.nblock_used;  	Int32 c_k0 = s.k0;  	UInt32[] c_tt = s.tt;  	UInt32 c_tPos = s.tPos;  	byte[] cs_next_out = s.strm.next_out;  	UInt32 cs_next_out_index = s.strm.next_out_index;  	uint cs_avail_out = s.strm.avail_out;  	// end restore   	UInt32 avail_out_INIT = cs_avail_out;  	Int32 s_save_nblockPP = s.save_nblock + 1;  	UInt64 total_out_old;  	while (true) {  		// try to finish existing run   		if (c_state_out_len > 0) {  			while (true) {  				if (cs_avail_out == 0)  					goto return_notr;  				if (c_state_out_len == 1)  					break;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				c_state_out_len--;  				cs_next_out_index++;  				cs_avail_out--;  			}  			//					s_state_out_len_eq_one:  			{  				if (cs_avail_out == 0) {  					c_state_out_len = 1;  					goto return_notr;  				}  				;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				cs_next_out_index++;  				cs_avail_out--;  			}  		}  		s_state_out_len_eq_one:  		// can a new run be started?   		if (c_nblock_used == s_save_nblockPP) {  			c_state_out_len = 0;  			goto return_notr;  		}  		;  		c_state_out_ch = (byte)c_k0;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  			if (k1 != c_k0) {  				c_k0 = k1;  			}  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  			goto s_state_out_len_eq_one;  		}  		c_state_out_len = 2;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		c_state_out_len = 3;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		c_state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  		c_nblock_used++;  	}  	return_notr:  	total_out_old = s.strm.total_out;  	s.strm.total_out += (avail_out_INIT - cs_avail_out);  	// save   	s.calculatedBlockCRC = c_calculatedBlockCRC;  	s.state_out_ch = c_state_out_ch;  	s.state_out_len = c_state_out_len;  	s.nblock_used = c_nblock_used;  	s.k0 = c_k0;  	s.tt = c_tt;  	s.tPos = c_tPos;  	s.strm.next_out_index = cs_next_out_index;  	s.strm.avail_out = cs_avail_out;  	// end save   }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	// restore   	UInt32 c_calculatedBlockCRC = s.calculatedBlockCRC;  	byte c_state_out_ch = s.state_out_ch;  	Int32 c_state_out_len = s.state_out_len;  	Int32 c_nblock_used = s.nblock_used;  	Int32 c_k0 = s.k0;  	UInt32[] c_tt = s.tt;  	UInt32 c_tPos = s.tPos;  	byte[] cs_next_out = s.strm.next_out;  	UInt32 cs_next_out_index = s.strm.next_out_index;  	uint cs_avail_out = s.strm.avail_out;  	// end restore   	UInt32 avail_out_INIT = cs_avail_out;  	Int32 s_save_nblockPP = s.save_nblock + 1;  	UInt64 total_out_old;  	while (true) {  		// try to finish existing run   		if (c_state_out_len > 0) {  			while (true) {  				if (cs_avail_out == 0)  					goto return_notr;  				if (c_state_out_len == 1)  					break;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				c_state_out_len--;  				cs_next_out_index++;  				cs_avail_out--;  			}  			//					s_state_out_len_eq_one:  			{  				if (cs_avail_out == 0) {  					c_state_out_len = 1;  					goto return_notr;  				}  				;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				cs_next_out_index++;  				cs_avail_out--;  			}  		}  		s_state_out_len_eq_one:  		// can a new run be started?   		if (c_nblock_used == s_save_nblockPP) {  			c_state_out_len = 0;  			goto return_notr;  		}  		;  		c_state_out_ch = (byte)c_k0;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  			if (k1 != c_k0) {  				c_k0 = k1;  			}  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  			goto s_state_out_len_eq_one;  		}  		c_state_out_len = 2;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		c_state_out_len = 3;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		c_state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  		c_nblock_used++;  	}  	return_notr:  	total_out_old = s.strm.total_out;  	s.strm.total_out += (avail_out_INIT - cs_avail_out);  	// save   	s.calculatedBlockCRC = c_calculatedBlockCRC;  	s.state_out_ch = c_state_out_ch;  	s.state_out_len = c_state_out_len;  	s.nblock_used = c_nblock_used;  	s.k0 = c_k0;  	s.tt = c_tt;  	s.tPos = c_tPos;  	s.strm.next_out_index = cs_next_out_index;  	s.strm.avail_out = cs_avail_out;  	// end save   }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	// restore   	UInt32 c_calculatedBlockCRC = s.calculatedBlockCRC;  	byte c_state_out_ch = s.state_out_ch;  	Int32 c_state_out_len = s.state_out_len;  	Int32 c_nblock_used = s.nblock_used;  	Int32 c_k0 = s.k0;  	UInt32[] c_tt = s.tt;  	UInt32 c_tPos = s.tPos;  	byte[] cs_next_out = s.strm.next_out;  	UInt32 cs_next_out_index = s.strm.next_out_index;  	uint cs_avail_out = s.strm.avail_out;  	// end restore   	UInt32 avail_out_INIT = cs_avail_out;  	Int32 s_save_nblockPP = s.save_nblock + 1;  	UInt64 total_out_old;  	while (true) {  		// try to finish existing run   		if (c_state_out_len > 0) {  			while (true) {  				if (cs_avail_out == 0)  					goto return_notr;  				if (c_state_out_len == 1)  					break;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				c_state_out_len--;  				cs_next_out_index++;  				cs_avail_out--;  			}  			//					s_state_out_len_eq_one:  			{  				if (cs_avail_out == 0) {  					c_state_out_len = 1;  					goto return_notr;  				}  				;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				cs_next_out_index++;  				cs_avail_out--;  			}  		}  		s_state_out_len_eq_one:  		// can a new run be started?   		if (c_nblock_used == s_save_nblockPP) {  			c_state_out_len = 0;  			goto return_notr;  		}  		;  		c_state_out_ch = (byte)c_k0;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  			if (k1 != c_k0) {  				c_k0 = k1;  			}  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  			goto s_state_out_len_eq_one;  		}  		c_state_out_len = 2;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		c_state_out_len = 3;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		c_state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  		c_nblock_used++;  	}  	return_notr:  	total_out_old = s.strm.total_out;  	s.strm.total_out += (avail_out_INIT - cs_avail_out);  	// save   	s.calculatedBlockCRC = c_calculatedBlockCRC;  	s.state_out_ch = c_state_out_ch;  	s.state_out_len = c_state_out_len;  	s.nblock_used = c_nblock_used;  	s.k0 = c_k0;  	s.tt = c_tt;  	s.tPos = c_tPos;  	s.strm.next_out_index = cs_next_out_index;  	s.strm.avail_out = cs_avail_out;  	// end save   }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	// restore   	UInt32 c_calculatedBlockCRC = s.calculatedBlockCRC;  	byte c_state_out_ch = s.state_out_ch;  	Int32 c_state_out_len = s.state_out_len;  	Int32 c_nblock_used = s.nblock_used;  	Int32 c_k0 = s.k0;  	UInt32[] c_tt = s.tt;  	UInt32 c_tPos = s.tPos;  	byte[] cs_next_out = s.strm.next_out;  	UInt32 cs_next_out_index = s.strm.next_out_index;  	uint cs_avail_out = s.strm.avail_out;  	// end restore   	UInt32 avail_out_INIT = cs_avail_out;  	Int32 s_save_nblockPP = s.save_nblock + 1;  	UInt64 total_out_old;  	while (true) {  		// try to finish existing run   		if (c_state_out_len > 0) {  			while (true) {  				if (cs_avail_out == 0)  					goto return_notr;  				if (c_state_out_len == 1)  					break;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				c_state_out_len--;  				cs_next_out_index++;  				cs_avail_out--;  			}  			//					s_state_out_len_eq_one:  			{  				if (cs_avail_out == 0) {  					c_state_out_len = 1;  					goto return_notr;  				}  				;  				cs_next_out [cs_next_out_index] = c_state_out_ch;  				CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  				cs_next_out_index++;  				cs_avail_out--;  			}  		}  		s_state_out_len_eq_one:  		// can a new run be started?   		if (c_nblock_used == s_save_nblockPP) {  			c_state_out_len = 0;  			goto return_notr;  		}  		;  		c_state_out_ch = (byte)c_k0;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  			if (k1 != c_k0) {  				c_k0 = k1;  			}  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  			goto s_state_out_len_eq_one;  		}  		c_state_out_len = 2;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		c_state_out_len = 3;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		if (c_nblock_used == s_save_nblockPP)  			continue;  		if (k1 != c_k0) {  			c_k0 = k1;  			continue;  		}  		;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  		c_nblock_used++;  		c_state_out_len = ((Int32)k1) + 4;  		BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  		c_nblock_used++;  	}  	return_notr:  	total_out_old = s.strm.total_out;  	s.strm.total_out += (avail_out_INIT - cs_avail_out);  	// save   	s.calculatedBlockCRC = c_calculatedBlockCRC;  	s.state_out_ch = c_state_out_ch;  	s.state_out_len = c_state_out_len;  	s.nblock_used = c_nblock_used;  	s.k0 = c_k0;  	s.tt = c_tt;  	s.tPos = c_tPos;  	s.strm.next_out_index = cs_next_out_index;  	s.strm.avail_out = cs_avail_out;  	// end save   }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_FAST (ref s' ref s.k0);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_FAST (ref s' ref s.k0);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_FAST (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_FAST (ref s' ref s.k0);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: s.state_out_len = 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: s.state_out_len = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: s.state_out_len = ((Int32)k1) + 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: while (true) {  	// try to finish existing run   	if (c_state_out_len > 0) {  		while (true) {  			if (cs_avail_out == 0)  				goto return_notr;  			if (c_state_out_len == 1)  				break;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			c_state_out_len--;  			cs_next_out_index++;  			cs_avail_out--;  		}  		//					s_state_out_len_eq_one:  		{  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  		}  	}  	s_state_out_len_eq_one:  	// can a new run be started?   	if (c_nblock_used == s_save_nblockPP) {  		c_state_out_len = 0;  		goto return_notr;  	}  	;  	c_state_out_ch = (byte)c_k0;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  		if (k1 != c_k0) {  			c_k0 = k1;  		}  		if (cs_avail_out == 0) {  			c_state_out_len = 1;  			goto return_notr;  		}  		;  		cs_next_out [cs_next_out_index] = c_state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  		cs_next_out_index++;  		cs_avail_out--;  		goto s_state_out_len_eq_one;  	}  	c_state_out_len = 2;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (c_nblock_used == s_save_nblockPP)  		continue;  	if (k1 != c_k0) {  		c_k0 = k1;  		continue;  	}  	;  	c_state_out_len = 3;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (c_nblock_used == s_save_nblockPP)  		continue;  	if (k1 != c_k0) {  		c_k0 = k1;  		continue;  	}  	;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	c_state_out_len = ((Int32)k1) + 4;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  	c_nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: while (true) {  	// try to finish existing run   	if (c_state_out_len > 0) {  		while (true) {  			if (cs_avail_out == 0)  				goto return_notr;  			if (c_state_out_len == 1)  				break;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			c_state_out_len--;  			cs_next_out_index++;  			cs_avail_out--;  		}  		//					s_state_out_len_eq_one:  		{  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  		}  	}  	s_state_out_len_eq_one:  	// can a new run be started?   	if (c_nblock_used == s_save_nblockPP) {  		c_state_out_len = 0;  		goto return_notr;  	}  	;  	c_state_out_ch = (byte)c_k0;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  		if (k1 != c_k0) {  			c_k0 = k1;  		}  		if (cs_avail_out == 0) {  			c_state_out_len = 1;  			goto return_notr;  		}  		;  		cs_next_out [cs_next_out_index] = c_state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  		cs_next_out_index++;  		cs_avail_out--;  		goto s_state_out_len_eq_one;  	}  	c_state_out_len = 2;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (c_nblock_used == s_save_nblockPP)  		continue;  	if (k1 != c_k0) {  		c_k0 = k1;  		continue;  	}  	;  	c_state_out_len = 3;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (c_nblock_used == s_save_nblockPP)  		continue;  	if (k1 != c_k0) {  		c_k0 = k1;  		continue;  	}  	;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	c_state_out_len = ((Int32)k1) + 4;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  	c_nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: while (true) {  	// try to finish existing run   	if (c_state_out_len > 0) {  		while (true) {  			if (cs_avail_out == 0)  				goto return_notr;  			if (c_state_out_len == 1)  				break;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			c_state_out_len--;  			cs_next_out_index++;  			cs_avail_out--;  		}  		//					s_state_out_len_eq_one:  		{  			if (cs_avail_out == 0) {  				c_state_out_len = 1;  				goto return_notr;  			}  			;  			cs_next_out [cs_next_out_index] = c_state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  			cs_next_out_index++;  			cs_avail_out--;  		}  	}  	s_state_out_len_eq_one:  	// can a new run be started?   	if (c_nblock_used == s_save_nblockPP) {  		c_state_out_len = 0;  		goto return_notr;  	}  	;  	c_state_out_ch = (byte)c_k0;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (k1 != c_k0 || c_nblock_used == s_save_nblockPP) {  		if (k1 != c_k0) {  			c_k0 = k1;  		}  		if (cs_avail_out == 0) {  			c_state_out_len = 1;  			goto return_notr;  		}  		;  		cs_next_out [cs_next_out_index] = c_state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref c_calculatedBlockCRC' c_state_out_ch);  		cs_next_out_index++;  		cs_avail_out--;  		goto s_state_out_len_eq_one;  	}  	c_state_out_len = 2;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (c_nblock_used == s_save_nblockPP)  		continue;  	if (k1 != c_k0) {  		c_k0 = k1;  		continue;  	}  	;  	c_state_out_len = 3;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	if (c_nblock_used == s_save_nblockPP)  		continue;  	if (k1 != c_k0) {  		c_k0 = k1;  		continue;  	}  	;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref k1);  	c_nblock_used++;  	c_state_out_len = ((Int32)k1) + 4;  	BZ_GET_FAST_C (ref c_tt' ref c_tPos' ref c_k0);  	c_nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: c_state_out_len = 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: c_state_out_len = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_FAST,The following statement contains a magic number: c_state_out_len = ((Int32)k1) + 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_indexIntoF,The following statement contains a magic number: na = 256;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: if (s.blockRandomised != 0) {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  		s.nblock_used++;  	}  }  else {  	while (true) {  		// try to finish existing run   		while (true) {  			if (s.strm.avail_out == 0)  				return;  			if (s.state_out_len == 0)  				break;  			s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  			CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  			s.state_out_len--;  			s.strm.next_out_index++;  			s.strm.avail_out--;  			s.strm.total_out++;  		}  		// can a new run be started?   		if (s.nblock_used == s.save_nblock + 1)  			return;  		s.state_out_len = 1;  		s.state_out_ch = (byte)s.k0;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 2;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		s.state_out_len = 3;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		if (s.nblock_used == s.save_nblock + 1)  			continue;  		if (k1 != s.k0) {  			s.k0 = k1;  			continue;  		}  		;  		BZ_GET_SMALL (ref s' ref k1);  		s.nblock_used++;  		s.state_out_len = ((Int32)k1) + 4;  		BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_SMALL (ref s' ref s.k0);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_SMALL (ref s' ref s.k0);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_SMALL (ref s' ref k1);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	k1 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_SMALL (ref s' ref s.k0);  	RandTable.BZ_RAND_UPD_MASK (ref s);  	s.k0 ^= (byte)RandTable.BZ_RAND_MASK (ref s);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: s.state_out_len = 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: s.state_out_len = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: s.state_out_len = ((Int32)k1) + 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_SMALL (ref s' ref s.k0);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_SMALL (ref s' ref s.k0);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: while (true) {  	// try to finish existing run   	while (true) {  		if (s.strm.avail_out == 0)  			return;  		if (s.state_out_len == 0)  			break;  		s.strm.next_out [s.strm.next_out_index] = s.state_out_ch;  		CRCTable.BZ_UPDATE_CRC (ref s.calculatedBlockCRC' s.state_out_ch);  		s.state_out_len--;  		s.strm.next_out_index++;  		s.strm.avail_out--;  		s.strm.total_out++;  	}  	// can a new run be started?   	if (s.nblock_used == s.save_nblock + 1)  		return;  	s.state_out_len = 1;  	s.state_out_ch = (byte)s.k0;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 2;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	s.state_out_len = 3;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	if (s.nblock_used == s.save_nblock + 1)  		continue;  	if (k1 != s.k0) {  		s.k0 = k1;  		continue;  	}  	;  	BZ_GET_SMALL (ref s' ref k1);  	s.nblock_used++;  	s.state_out_len = ((Int32)k1) + 4;  	BZ_GET_SMALL (ref s' ref s.k0);  	s.nblock_used++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: s.state_out_len = 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: s.state_out_len = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The following statement contains a magic number: s.state_out_len = ((Int32)k1) + 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsFinishWrite,The following statement contains a magic number: while (s.bsLive > 0) {  	s.zbits.WriteByte ((Int32)(s.zbits_index + s.numZ)' (byte)(s.bsBuff >> 24));  	s.numZ++;  	s.bsBuff <<= 8;  	s.bsLive -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsFinishWrite,The following statement contains a magic number: while (s.bsLive > 0) {  	s.zbits.WriteByte ((Int32)(s.zbits_index + s.numZ)' (byte)(s.bsBuff >> 24));  	s.numZ++;  	s.bsBuff <<= 8;  	s.bsLive -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsFinishWrite,The following statement contains a magic number: while (s.bsLive > 0) {  	s.zbits.WriteByte ((Int32)(s.zbits_index + s.numZ)' (byte)(s.bsBuff >> 24));  	s.numZ++;  	s.bsBuff <<= 8;  	s.bsLive -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsFinishWrite,The following statement contains a magic number: s.zbits.WriteByte ((Int32)(s.zbits_index + s.numZ)' (byte)(s.bsBuff >> 24));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsFinishWrite,The following statement contains a magic number: s.bsBuff <<= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsFinishWrite,The following statement contains a magic number: s.bsLive -= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsNEEDW,The following statement contains a magic number: while (s.bsLive >= 8) {  	s.zbits.WriteByte (s.zbits_index + s.numZ' (byte)(s.bsBuff >> 24));  	s.numZ++;  	s.bsBuff <<= 8;  	s.bsLive -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsNEEDW,The following statement contains a magic number: while (s.bsLive >= 8) {  	s.zbits.WriteByte (s.zbits_index + s.numZ' (byte)(s.bsBuff >> 24));  	s.numZ++;  	s.bsBuff <<= 8;  	s.bsLive -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsNEEDW,The following statement contains a magic number: while (s.bsLive >= 8) {  	s.zbits.WriteByte (s.zbits_index + s.numZ' (byte)(s.bsBuff >> 24));  	s.numZ++;  	s.bsBuff <<= 8;  	s.bsLive -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsNEEDW,The following statement contains a magic number: while (s.bsLive >= 8) {  	s.zbits.WriteByte (s.zbits_index + s.numZ' (byte)(s.bsBuff >> 24));  	s.numZ++;  	s.bsBuff <<= 8;  	s.bsLive -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsNEEDW,The following statement contains a magic number: s.zbits.WriteByte (s.zbits_index + s.numZ' (byte)(s.bsBuff >> 24));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsNEEDW,The following statement contains a magic number: s.bsBuff <<= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsNEEDW,The following statement contains a magic number: s.bsLive -= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsW,The following statement contains a magic number: s.bsBuff |= (UInt32)(v << (32 - s.bsLive - n));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUInt32,The following statement contains a magic number: bsW (ref s' 8' (u >> 24) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUInt32,The following statement contains a magic number: bsW (ref s' 8' (u >> 24) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUInt32,The following statement contains a magic number: bsW (ref s' 8' (u >> 16) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUInt32,The following statement contains a magic number: bsW (ref s' 8' (u >> 16) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUInt32,The following statement contains a magic number: bsW (ref s' 8' (u >> 8) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUInt32,The following statement contains a magic number: bsW (ref s' 8' (u >> 8) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUInt32,The following statement contains a magic number: bsW (ref s' 8' u & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,bsPutUChar,The following statement contains a magic number: bsW (ref s' 8' c);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,makeMaps_e,The following statement contains a magic number: for (i = 0; i < 256; i++)  	if (s.inUse [i]) {  		s.unseqToSeq [i] = (byte)s.nInUse;  		s.nInUse++;  	}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: for (i = 0; i < s.nblock; i++) {  	byte ll_i;  	BZLibCommon.AssertD (wr <= i' "generateMTFValues(1)");  	j = (Int32)ptr [i] - 1;  	if (j < 0)  		j += (Int32)s.nblock;  	ll_i = s.unseqToSeq [block.ReadByte (j)];  	BZLibCommon.AssertD (ll_i < s.nInUse' "generateMTFValues(2a)");  	if (yy [0] == ll_i) {  		zPend++;  	}  	else {  		if (zPend > 0) {  			zPend--;  			while (true) {  				if ((zPend & 1) != 0) {  					mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  					wr++;  					s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  				}  				else {  					mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  					wr++;  					s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  				}  				if (zPend < 2)  					break;  				zPend = (zPend - 2) / 2;  			}  			;  			zPend = 0;  		}  		{  			byte rtmp;  			byte ryy_j_index;  			byte rll_i;  			rtmp = yy [1];  			yy [1] = yy [0];  			ryy_j_index = 1;  			//  ryy_j = &(yy[1]);  			rll_i = ll_i;  			while (rll_i != rtmp) {  				byte rtmp2;  				ryy_j_index++;  				rtmp2 = rtmp;  				rtmp = yy [ryy_j_index];  				yy [ryy_j_index] = rtmp2;  			}  			;  			yy [0] = rtmp;  			j = ryy_j_index;  			mtfv.WriteUInt16 (wr' (UInt16)(j + 1));  			wr++;  			s.mtfFreq [j + 1]++;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: for (i = 0; i < s.nblock; i++) {  	byte ll_i;  	BZLibCommon.AssertD (wr <= i' "generateMTFValues(1)");  	j = (Int32)ptr [i] - 1;  	if (j < 0)  		j += (Int32)s.nblock;  	ll_i = s.unseqToSeq [block.ReadByte (j)];  	BZLibCommon.AssertD (ll_i < s.nInUse' "generateMTFValues(2a)");  	if (yy [0] == ll_i) {  		zPend++;  	}  	else {  		if (zPend > 0) {  			zPend--;  			while (true) {  				if ((zPend & 1) != 0) {  					mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  					wr++;  					s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  				}  				else {  					mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  					wr++;  					s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  				}  				if (zPend < 2)  					break;  				zPend = (zPend - 2) / 2;  			}  			;  			zPend = 0;  		}  		{  			byte rtmp;  			byte ryy_j_index;  			byte rll_i;  			rtmp = yy [1];  			yy [1] = yy [0];  			ryy_j_index = 1;  			//  ryy_j = &(yy[1]);  			rll_i = ll_i;  			while (rll_i != rtmp) {  				byte rtmp2;  				ryy_j_index++;  				rtmp2 = rtmp;  				rtmp = yy [ryy_j_index];  				yy [ryy_j_index] = rtmp2;  			}  			;  			yy [0] = rtmp;  			j = ryy_j_index;  			mtfv.WriteUInt16 (wr' (UInt16)(j + 1));  			wr++;  			s.mtfFreq [j + 1]++;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: for (i = 0; i < s.nblock; i++) {  	byte ll_i;  	BZLibCommon.AssertD (wr <= i' "generateMTFValues(1)");  	j = (Int32)ptr [i] - 1;  	if (j < 0)  		j += (Int32)s.nblock;  	ll_i = s.unseqToSeq [block.ReadByte (j)];  	BZLibCommon.AssertD (ll_i < s.nInUse' "generateMTFValues(2a)");  	if (yy [0] == ll_i) {  		zPend++;  	}  	else {  		if (zPend > 0) {  			zPend--;  			while (true) {  				if ((zPend & 1) != 0) {  					mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  					wr++;  					s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  				}  				else {  					mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  					wr++;  					s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  				}  				if (zPend < 2)  					break;  				zPend = (zPend - 2) / 2;  			}  			;  			zPend = 0;  		}  		{  			byte rtmp;  			byte ryy_j_index;  			byte rll_i;  			rtmp = yy [1];  			yy [1] = yy [0];  			ryy_j_index = 1;  			//  ryy_j = &(yy[1]);  			rll_i = ll_i;  			while (rll_i != rtmp) {  				byte rtmp2;  				ryy_j_index++;  				rtmp2 = rtmp;  				rtmp = yy [ryy_j_index];  				yy [ryy_j_index] = rtmp2;  			}  			;  			yy [0] = rtmp;  			j = ryy_j_index;  			mtfv.WriteUInt16 (wr' (UInt16)(j + 1));  			wr++;  			s.mtfFreq [j + 1]++;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (yy [0] == ll_i) {  	zPend++;  }  else {  	if (zPend > 0) {  		zPend--;  		while (true) {  			if ((zPend & 1) != 0) {  				mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  				wr++;  				s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  			}  			else {  				mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  				wr++;  				s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  			}  			if (zPend < 2)  				break;  			zPend = (zPend - 2) / 2;  		}  		;  		zPend = 0;  	}  	{  		byte rtmp;  		byte ryy_j_index;  		byte rll_i;  		rtmp = yy [1];  		yy [1] = yy [0];  		ryy_j_index = 1;  		//  ryy_j = &(yy[1]);  		rll_i = ll_i;  		while (rll_i != rtmp) {  			byte rtmp2;  			ryy_j_index++;  			rtmp2 = rtmp;  			rtmp = yy [ryy_j_index];  			yy [ryy_j_index] = rtmp2;  		}  		;  		yy [0] = rtmp;  		j = ryy_j_index;  		mtfv.WriteUInt16 (wr' (UInt16)(j + 1));  		wr++;  		s.mtfFreq [j + 1]++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (yy [0] == ll_i) {  	zPend++;  }  else {  	if (zPend > 0) {  		zPend--;  		while (true) {  			if ((zPend & 1) != 0) {  				mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  				wr++;  				s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  			}  			else {  				mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  				wr++;  				s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  			}  			if (zPend < 2)  				break;  			zPend = (zPend - 2) / 2;  		}  		;  		zPend = 0;  	}  	{  		byte rtmp;  		byte ryy_j_index;  		byte rll_i;  		rtmp = yy [1];  		yy [1] = yy [0];  		ryy_j_index = 1;  		//  ryy_j = &(yy[1]);  		rll_i = ll_i;  		while (rll_i != rtmp) {  			byte rtmp2;  			ryy_j_index++;  			rtmp2 = rtmp;  			rtmp = yy [ryy_j_index];  			yy [ryy_j_index] = rtmp2;  		}  		;  		yy [0] = rtmp;  		j = ryy_j_index;  		mtfv.WriteUInt16 (wr' (UInt16)(j + 1));  		wr++;  		s.mtfFreq [j + 1]++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (yy [0] == ll_i) {  	zPend++;  }  else {  	if (zPend > 0) {  		zPend--;  		while (true) {  			if ((zPend & 1) != 0) {  				mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  				wr++;  				s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  			}  			else {  				mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  				wr++;  				s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  			}  			if (zPend < 2)  				break;  			zPend = (zPend - 2) / 2;  		}  		;  		zPend = 0;  	}  	{  		byte rtmp;  		byte ryy_j_index;  		byte rll_i;  		rtmp = yy [1];  		yy [1] = yy [0];  		ryy_j_index = 1;  		//  ryy_j = &(yy[1]);  		rll_i = ll_i;  		while (rll_i != rtmp) {  			byte rtmp2;  			ryy_j_index++;  			rtmp2 = rtmp;  			rtmp = yy [ryy_j_index];  			yy [ryy_j_index] = rtmp2;  		}  		;  		yy [0] = rtmp;  		j = ryy_j_index;  		mtfv.WriteUInt16 (wr' (UInt16)(j + 1));  		wr++;  		s.mtfFreq [j + 1]++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		if ((zPend & 1) != 0) {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  		}  		else {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  		}  		if (zPend < 2)  			break;  		zPend = (zPend - 2) / 2;  	}  	;  	zPend = 0;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		if ((zPend & 1) != 0) {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  		}  		else {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  		}  		if (zPend < 2)  			break;  		zPend = (zPend - 2) / 2;  	}  	;  	zPend = 0;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		if ((zPend & 1) != 0) {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  		}  		else {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  		}  		if (zPend < 2)  			break;  		zPend = (zPend - 2) / 2;  	}  	;  	zPend = 0;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: while (true) {  	if ((zPend & 1) != 0) {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  	}  	else {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  	}  	if (zPend < 2)  		break;  	zPend = (zPend - 2) / 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: while (true) {  	if ((zPend & 1) != 0) {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  	}  	else {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  	}  	if (zPend < 2)  		break;  	zPend = (zPend - 2) / 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: while (true) {  	if ((zPend & 1) != 0) {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  	}  	else {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  	}  	if (zPend < 2)  		break;  	zPend = (zPend - 2) / 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend < 2)  	break;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		if ((zPend & 1) != 0) {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  		}  		else {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  		}  		if (zPend < 2)  			break;  		zPend = (zPend - 2) / 2;  	}  	;  	zPend = 0;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		if ((zPend & 1) != 0) {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  		}  		else {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  		}  		if (zPend < 2)  			break;  		zPend = (zPend - 2) / 2;  	}  	;  	zPend = 0;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0) {  	zPend--;  	while (true) {  		if ((zPend & 1) != 0) {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  		}  		else {  			mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  			wr++;  			s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  		}  		if (zPend < 2)  			break;  		zPend = (zPend - 2) / 2;  	}  	;  	zPend = 0;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: while (true) {  	if ((zPend & 1) != 0) {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  	}  	else {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  	}  	if (zPend < 2)  		break;  	zPend = (zPend - 2) / 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: while (true) {  	if ((zPend & 1) != 0) {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  	}  	else {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  	}  	if (zPend < 2)  		break;  	zPend = (zPend - 2) / 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: while (true) {  	if ((zPend & 1) != 0) {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNB);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNB]++;  	}  	else {  		mtfv.WriteUInt16 (wr' BZLib.BZConstants.BZ_RUNA);  		wr++;  		s.mtfFreq [BZLib.BZConstants.BZ_RUNA]++;  	}  	if (zPend < 2)  		break;  	zPend = (zPend - 2) / 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: if (zPend < 2)  	break;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) / 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("      {0} in block' {1} after MTF & 1-2 coding' " + "{2}+2 syms in use\n"' s.nblock' s.nMTF' s.nInUse);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: alphaSize = s.nInUse + 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (s.nMTF > 0' 3001);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 200)  	nGroups = 2;  else if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: nGroups = 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 600)  	nGroups = 3;  else if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: nGroups = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 1200)  	nGroups = 4;  else if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: nGroups = 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.nMTF < 2400)  	nGroups = 5;  else  	nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: nGroups = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: nGroups = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (nPart > 0) {  	tFreq = remF / nPart;  	ge = gs - 1;  	aFreq = 0;  	while (aFreq < tFreq && ge < alphaSize - 1) {  		ge++;  		aFreq += s.mtfFreq [ge];  	}  	if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  		aFreq -= s.mtfFreq [ge];  		ge--;  	}  	if (s.verbosity >= 3)  		BZLibCommon.VPrintf ("      initial group {0}' [{1} .. {2}]' " + "has {3} syms ({4:f})\n"' nPart' gs' ge' aFreq' (100.0 * (float)aFreq) / (float)(s.nMTF));  	for (v = 0; v < alphaSize; v++)  		if (v >= gs && v <= ge)  			s.len [nPart - 1] [v] = BZ_LESSER_ICOST;  		else  			s.len [nPart - 1] [v] = BZ_GREATER_ICOST;  	nPart--;  	gs = ge + 1;  	remF -= aFreq;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (nPart > 0) {  	tFreq = remF / nPart;  	ge = gs - 1;  	aFreq = 0;  	while (aFreq < tFreq && ge < alphaSize - 1) {  		ge++;  		aFreq += s.mtfFreq [ge];  	}  	if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  		aFreq -= s.mtfFreq [ge];  		ge--;  	}  	if (s.verbosity >= 3)  		BZLibCommon.VPrintf ("      initial group {0}' [{1} .. {2}]' " + "has {3} syms ({4:f})\n"' nPart' gs' ge' aFreq' (100.0 * (float)aFreq) / (float)(s.nMTF));  	for (v = 0; v < alphaSize; v++)  		if (v >= gs && v <= ge)  			s.len [nPart - 1] [v] = BZ_LESSER_ICOST;  		else  			s.len [nPart - 1] [v] = BZ_GREATER_ICOST;  	nPart--;  	gs = ge + 1;  	remF -= aFreq;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (nPart > 0) {  	tFreq = remF / nPart;  	ge = gs - 1;  	aFreq = 0;  	while (aFreq < tFreq && ge < alphaSize - 1) {  		ge++;  		aFreq += s.mtfFreq [ge];  	}  	if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  		aFreq -= s.mtfFreq [ge];  		ge--;  	}  	if (s.verbosity >= 3)  		BZLibCommon.VPrintf ("      initial group {0}' [{1} .. {2}]' " + "has {3} syms ({4:f})\n"' nPart' gs' ge' aFreq' (100.0 * (float)aFreq) / (float)(s.nMTF));  	for (v = 0; v < alphaSize; v++)  		if (v >= gs && v <= ge)  			s.len [nPart - 1] [v] = BZ_LESSER_ICOST;  		else  			s.len [nPart - 1] [v] = BZ_GREATER_ICOST;  	nPart--;  	gs = ge + 1;  	remF -= aFreq;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  	aFreq -= s.mtfFreq [ge];  	ge--;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("      initial group {0}' [{1} .. {2}]' " + "has {3} syms ({4:f})\n"' nPart' gs' ge' aFreq' (100.0 * (float)aFreq) / (float)(s.nMTF));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("      initial group {0}' [{1} .. {2}]' " + "has {3} syms ({4:f})\n"' nPart' gs' ge' aFreq' (100.0 * (float)aFreq) / (float)(s.nMTF));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.VPrintf ("      initial group {0}' [{1} .. {2}]' " + "has {3} syms ({4:f})\n"' nPart' gs' ge' aFreq' (100.0 * (float)aFreq) / (float)(s.nMTF));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZLib.BZConstants.BZ_N_ITERS; iter++) {  	for (t = 0; t < nGroups; t++)  		fave [t] = 0;  	for (t = 0; t < nGroups; t++)  		for (v = 0; v < alphaSize; v++)  			s.rfreq [t] [v] = 0;  	/*--- 				  Set up an auxiliary length table which is used to fast-track 			  the common case (nGroups == 6).  				---*/if (nGroups == 6) {  		for (v = 0; v < alphaSize; v++) {  			s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  			s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  			s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  		}  	}  	nSelectors = 0;  	totc = 0;  	gs = 0;  	while (true) {  		/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  			break;  		ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  		if (ge >= s.nMTF)  			ge = s.nMTF - 1;  		/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  			cost [t] = 0;  		if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  			UInt16 icv;  			cost01 = cost23 = cost45 = 0;  			for (int nn = 0; nn < 50; nn++) {  				icv = mtfv.ReadUInt16 (gs + (nn));  				cost01 += s.len_pack [icv] [0];  				cost23 += s.len_pack [icv] [1];  				cost45 += s.len_pack [icv] [2];  			}  			cost [0] = (UInt16)(cost01 & 0xffff);  			cost [1] = (UInt16)(cost01 >> 16);  			cost [2] = (UInt16)(cost23 & 0xffff);  			cost [3] = (UInt16)(cost23 >> 16);  			cost [4] = (UInt16)(cost45 & 0xffff);  			cost [5] = (UInt16)(cost45 >> 16);  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  				UInt16 icv = mtfv.ReadUInt16 (i);  				for (t = 0; t < nGroups; t++)  					cost [t] += s.len [t] [icv];  			}  		}  		/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  		bt = -1;  		for (t = 0; t < nGroups; t++)  			if (cost [t] < bc) {  				bc = cost [t];  				bt = t;  			}  		;  		totc += bc;  		fave [bt]++;  		s.selector [nSelectors] = (byte)bt;  		nSelectors++;  		/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  			/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  				s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  			}  		}  		else {  			/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  				s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  		}  		gs = ge + 1;  	}  	if (s.verbosity >= 3) {  		BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  		for (t = 0; t < nGroups; t++)  			BZLibCommon.VPrintf ("{0} "' fave [t]);  		BZLibCommon.VPrintf ("\n");  	}  	/*-- 				  Recompute the tables based on the accumulated frequencies. 				--*/for (t = 0; t < nGroups; t++)  		s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6) {  	for (v = 0; v < alphaSize; v++) {  		s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  		s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  		s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (v = 0; v < alphaSize; v++) {  	s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  	s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  	s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [0] = (UInt32)((s.len [1] [v] << 16) | s.len [0] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [1] = (UInt32)((s.len [3] [v] << 16) | s.len [2] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.len_pack [v] [2] = (UInt32)((s.len [5] [v] << 16) | s.len [4] [v]);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	/*--- Set group start & end marks. --*/if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	/*--  					   Calculate the cost of this group as coded 					   by each of the coding tables. 					--*/for (t = 0; t < nGroups; t++)  		cost [t] = 0;  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  		UInt16 icv;  		cost01 = cost23 = cost45 = 0;  		for (int nn = 0; nn < 50; nn++) {  			icv = mtfv.ReadUInt16 (gs + (nn));  			cost01 += s.len_pack [icv] [0];  			cost23 += s.len_pack [icv] [1];  			cost45 += s.len_pack [icv] [2];  		}  		cost [0] = (UInt16)(cost01 & 0xffff);  		cost [1] = (UInt16)(cost01 >> 16);  		cost [2] = (UInt16)(cost23 & 0xffff);  		cost [3] = (UInt16)(cost23 >> 16);  		cost [4] = (UInt16)(cost45 & 0xffff);  		cost [5] = (UInt16)(cost45 >> 16);  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			UInt16 icv = mtfv.ReadUInt16 (i);  			for (t = 0; t < nGroups; t++)  				cost [t] += s.len [t] [icv];  		}  	}  	/*--  					   Find the coding table which is best for this group' 					   and record its identity in the selector table. 					--*/bc = 999999999;  	bt = -1;  	for (t = 0; t < nGroups; t++)  		if (cost [t] < bc) {  			bc = cost [t];  			bt = t;  		}  	;  	totc += bc;  	fave [bt]++;  	s.selector [nSelectors] = (byte)bt;  	nSelectors++;  	/*--  					   Increment the symbol frequencies for the selected table. 					 --*/if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  			s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  			s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  	}  	gs = ge + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt32 cost01' cost23' cost45;  	UInt16 icv;  	cost01 = cost23 = cost45 = 0;  	for (int nn = 0; nn < 50; nn++) {  		icv = mtfv.ReadUInt16 (gs + (nn));  		cost01 += s.len_pack [icv] [0];  		cost23 += s.len_pack [icv] [1];  		cost45 += s.len_pack [icv] [2];  	}  	cost [0] = (UInt16)(cost01 & 0xffff);  	cost [1] = (UInt16)(cost01 >> 16);  	cost [2] = (UInt16)(cost23 & 0xffff);  	cost [3] = (UInt16)(cost23 >> 16);  	cost [4] = (UInt16)(cost45 & 0xffff);  	cost [5] = (UInt16)(cost45 >> 16);  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		UInt16 icv = mtfv.ReadUInt16 (i);  		for (t = 0; t < nGroups; t++)  			cost [t] += s.len [t] [icv];  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (int nn = 0; nn < 50; nn++) {  	icv = mtfv.ReadUInt16 (gs + (nn));  	cost01 += s.len_pack [icv] [0];  	cost23 += s.len_pack [icv] [1];  	cost45 += s.len_pack [icv] [2];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (int nn = 0; nn < 50; nn++) {  	icv = mtfv.ReadUInt16 (gs + (nn));  	cost01 += s.len_pack [icv] [0];  	cost23 += s.len_pack [icv] [1];  	cost45 += s.len_pack [icv] [2];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost45 += s.len_pack [icv] [2];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost [1] = (UInt16)(cost01 >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost [2] = (UInt16)(cost23 & 0xffff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost [3] = (UInt16)(cost23 >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost [3] = (UInt16)(cost23 >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost [4] = (UInt16)(cost45 & 0xffff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost [5] = (UInt16)(cost45 >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: cost [5] = (UInt16)(cost45 >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bc = 999999999;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  		s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  	}  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  		s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  		s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  	}  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  		s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/for (int yy = 0; yy < 50; yy++) {  		s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  	}  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++)  		s.rfreq [bt] [mtfv.ReadUInt16 (i)]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (int yy = 0; yy < 50; yy++) {  	s.rfreq [bt] [mtfv.ReadUInt16 (gs + (yy))]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3) {  	BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  	for (t = 0; t < nGroups; t++)  		BZLibCommon.VPrintf ("{0} "' fave [t]);  	BZLibCommon.VPrintf ("\n");  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3) {  	BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  	for (t = 0; t < nGroups; t++)  		BZLibCommon.VPrintf ("{0} "' fave [t]);  	BZLibCommon.VPrintf ("\n");  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.VPrintf ("      pass {0}: size is {1}' grp uses are "' iter + 1' totc / 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++)  	s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: s.huffmanTable.BZ2_hbMakeCodeLengths (ref (s.len)' ref (s.rfreq)' alphaSize' 20' t);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (nGroups < 8' 3002);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (nGroups < 8' 3002);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (nSelectors < 32768 && nSelectors <= (2 + (900000 / BZLib.BZConstants.BZ_G_SIZE))' 3003);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (nSelectors < 32768 && nSelectors <= (2 + (900000 / BZLib.BZConstants.BZ_G_SIZE))' 3003);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (nSelectors < 32768 && nSelectors <= (2 + (900000 / BZLib.BZConstants.BZ_G_SIZE))' 3003);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (nSelectors < 32768 && nSelectors <= (2 + (900000 / BZLib.BZConstants.BZ_G_SIZE))' 3003);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	minLen = 32;  	maxLen = 0;  	for (i = 0; i < alphaSize; i++) {  		if (s.len [t] [i] > maxLen)  			maxLen = s.len [t] [i];  		if (s.len [t] [i] < minLen)  			minLen = s.len [t] [i];  	}  	BZLibCommon.AssertH (!(maxLen > 20)' 3004);  	BZLibCommon.AssertH (!(minLen < 1)' 3005);  	Huffman.BZ2_hbAssignCodes (ref s.code' ref s.len' minLen' maxLen' alphaSize' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	minLen = 32;  	maxLen = 0;  	for (i = 0; i < alphaSize; i++) {  		if (s.len [t] [i] > maxLen)  			maxLen = s.len [t] [i];  		if (s.len [t] [i] < minLen)  			minLen = s.len [t] [i];  	}  	BZLibCommon.AssertH (!(maxLen > 20)' 3004);  	BZLibCommon.AssertH (!(minLen < 1)' 3005);  	Huffman.BZ2_hbAssignCodes (ref s.code' ref s.len' minLen' maxLen' alphaSize' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	minLen = 32;  	maxLen = 0;  	for (i = 0; i < alphaSize; i++) {  		if (s.len [t] [i] > maxLen)  			maxLen = s.len [t] [i];  		if (s.len [t] [i] < minLen)  			minLen = s.len [t] [i];  	}  	BZLibCommon.AssertH (!(maxLen > 20)' 3004);  	BZLibCommon.AssertH (!(minLen < 1)' 3005);  	Huffman.BZ2_hbAssignCodes (ref s.code' ref s.len' minLen' maxLen' alphaSize' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	minLen = 32;  	maxLen = 0;  	for (i = 0; i < alphaSize; i++) {  		if (s.len [t] [i] > maxLen)  			maxLen = s.len [t] [i];  		if (s.len [t] [i] < minLen)  			minLen = s.len [t] [i];  	}  	BZLibCommon.AssertH (!(maxLen > 20)' 3004);  	BZLibCommon.AssertH (!(minLen < 1)' 3005);  	Huffman.BZ2_hbAssignCodes (ref s.code' ref s.len' minLen' maxLen' alphaSize' t);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: minLen = 32;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (!(maxLen > 20)' 3004);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (!(maxLen > 20)' 3004);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (!(minLen < 1)' 3005);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < 16; i++) {  	inUse16 [i] = false;  	for (j = 0; j < 16; j++)  		if (s.inUse [i * 16 + j])  			inUse16 [i] = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < 16; i++) {  	inUse16 [i] = false;  	for (j = 0; j < 16; j++)  		if (s.inUse [i * 16 + j])  			inUse16 [i] = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < 16; i++) {  	inUse16 [i] = false;  	for (j = 0; j < 16; j++)  		if (s.inUse [i * 16 + j])  			inUse16 [i] = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (j = 0; j < 16; j++)  	if (s.inUse [i * 16 + j])  		inUse16 [i] = true;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (j = 0; j < 16; j++)  	if (s.inUse [i * 16 + j])  		inUse16 [i] = true;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.inUse [i * 16 + j])  	inUse16 [i] = true;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < 16; i++)  	if (inUse16 [i])  		bsW (ref s' 1' 1);  	else  		bsW (ref s' 1' 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < 16; i++)  	if (inUse16 [i])  		for (j = 0; j < 16; j++) {  			if (s.inUse [i * 16 + j])  				bsW (ref s' 1' 1);  			else  				bsW (ref s' 1' 0);  		}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < 16; i++)  	if (inUse16 [i])  		for (j = 0; j < 16; j++) {  			if (s.inUse [i * 16 + j])  				bsW (ref s' 1' 1);  			else  				bsW (ref s' 1' 0);  		}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < 16; i++)  	if (inUse16 [i])  		for (j = 0; j < 16; j++) {  			if (s.inUse [i * 16 + j])  				bsW (ref s' 1' 1);  			else  				bsW (ref s' 1' 0);  		}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (inUse16 [i])  	for (j = 0; j < 16; j++) {  		if (s.inUse [i * 16 + j])  			bsW (ref s' 1' 1);  		else  			bsW (ref s' 1' 0);  	}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (inUse16 [i])  	for (j = 0; j < 16; j++) {  		if (s.inUse [i * 16 + j])  			bsW (ref s' 1' 1);  		else  			bsW (ref s' 1' 0);  	}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (j = 0; j < 16; j++) {  	if (s.inUse [i * 16 + j])  		bsW (ref s' 1' 1);  	else  		bsW (ref s' 1' 0);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (j = 0; j < 16; j++) {  	if (s.inUse [i * 16 + j])  		bsW (ref s' 1' 1);  	else  		bsW (ref s' 1' 0);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.inUse [i * 16 + j])  	bsW (ref s' 1' 1);  else  	bsW (ref s' 1' 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("      bytes: mapping {0}' "' s.numZ - nBytes);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bsW (ref s' 3' (UInt32)nGroups);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bsW (ref s' 15' (UInt32)nSelectors);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("selectors {0}' "' s.numZ - nBytes);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	Int32 curr = s.len [t] [0];  	bsW (ref s' 5' (UInt32)curr);  	for (i = 0; i < alphaSize; i++) {  		while (curr < s.len [t] [i]) {  			bsW (ref s' 2' 2);  			curr++;  			/* 10 */}  		;  		while (curr > s.len [t] [i]) {  			bsW (ref s' 2' 3);  			curr--;  			/* 11 */}  		;  		bsW (ref s' 1' 0);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	Int32 curr = s.len [t] [0];  	bsW (ref s' 5' (UInt32)curr);  	for (i = 0; i < alphaSize; i++) {  		while (curr < s.len [t] [i]) {  			bsW (ref s' 2' 2);  			curr++;  			/* 10 */}  		;  		while (curr > s.len [t] [i]) {  			bsW (ref s' 2' 3);  			curr--;  			/* 11 */}  		;  		bsW (ref s' 1' 0);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	Int32 curr = s.len [t] [0];  	bsW (ref s' 5' (UInt32)curr);  	for (i = 0; i < alphaSize; i++) {  		while (curr < s.len [t] [i]) {  			bsW (ref s' 2' 2);  			curr++;  			/* 10 */}  		;  		while (curr > s.len [t] [i]) {  			bsW (ref s' 2' 3);  			curr--;  			/* 11 */}  		;  		bsW (ref s' 1' 0);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	Int32 curr = s.len [t] [0];  	bsW (ref s' 5' (UInt32)curr);  	for (i = 0; i < alphaSize; i++) {  		while (curr < s.len [t] [i]) {  			bsW (ref s' 2' 2);  			curr++;  			/* 10 */}  		;  		while (curr > s.len [t] [i]) {  			bsW (ref s' 2' 3);  			curr--;  			/* 11 */}  		;  		bsW (ref s' 1' 0);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	Int32 curr = s.len [t] [0];  	bsW (ref s' 5' (UInt32)curr);  	for (i = 0; i < alphaSize; i++) {  		while (curr < s.len [t] [i]) {  			bsW (ref s' 2' 2);  			curr++;  			/* 10 */}  		;  		while (curr > s.len [t] [i]) {  			bsW (ref s' 2' 3);  			curr--;  			/* 11 */}  		;  		bsW (ref s' 1' 0);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bsW (ref s' 5' (UInt32)curr);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < alphaSize; i++) {  	while (curr < s.len [t] [i]) {  		bsW (ref s' 2' 2);  		curr++;  		/* 10 */}  	;  	while (curr > s.len [t] [i]) {  		bsW (ref s' 2' 3);  		curr--;  		/* 11 */}  	;  	bsW (ref s' 1' 0);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < alphaSize; i++) {  	while (curr < s.len [t] [i]) {  		bsW (ref s' 2' 2);  		curr++;  		/* 10 */}  	;  	while (curr > s.len [t] [i]) {  		bsW (ref s' 2' 3);  		curr--;  		/* 11 */}  	;  	bsW (ref s' 1' 0);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < alphaSize; i++) {  	while (curr < s.len [t] [i]) {  		bsW (ref s' 2' 2);  		curr++;  		/* 10 */}  	;  	while (curr > s.len [t] [i]) {  		bsW (ref s' 2' 3);  		curr--;  		/* 11 */}  	;  	bsW (ref s' 1' 0);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (i = 0; i < alphaSize; i++) {  	while (curr < s.len [t] [i]) {  		bsW (ref s' 2' 2);  		curr++;  		/* 10 */}  	;  	while (curr > s.len [t] [i]) {  		bsW (ref s' 2' 3);  		curr--;  		/* 11 */}  	;  	bsW (ref s' 1' 0);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (curr < s.len [t] [i]) {  	bsW (ref s' 2' 2);  	curr++;  	/* 10 */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (curr < s.len [t] [i]) {  	bsW (ref s' 2' 2);  	curr++;  	/* 10 */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bsW (ref s' 2' 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bsW (ref s' 2' 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (curr > s.len [t] [i]) {  	bsW (ref s' 2' 3);  	curr--;  	/* 11 */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (curr > s.len [t] [i]) {  	bsW (ref s' 2' 3);  	curr--;  	/* 11 */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bsW (ref s' 2' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: bsW (ref s' 2' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("code lengths {0}' "' s.numZ - nBytes);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	BZLibCommon.AssertH (s.selector [selCtr] < nGroups' 3006);  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt16 mtfv_i;  		//UChar* s_len_sel_selCtr = &(s.len[s.selector[selCtr]][0]);  		//Int32* s_code_sel_selCtr = &(s.code[s.selector[selCtr]][0]);  		Int32 s_len_sel_selCtr_indexer = 0;  		Int32 s_code_sel_selCtr_indexer = 0;  		for (int nn = 0; nn < 50; nn++) {  			mtfv_i = mtfv.ReadUInt16 (gs + (nn));  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]);  		}  	}  	gs = ge + 1;  	selCtr++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	BZLibCommon.AssertH (s.selector [selCtr] < nGroups' 3006);  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt16 mtfv_i;  		//UChar* s_len_sel_selCtr = &(s.len[s.selector[selCtr]][0]);  		//Int32* s_code_sel_selCtr = &(s.code[s.selector[selCtr]][0]);  		Int32 s_len_sel_selCtr_indexer = 0;  		Int32 s_code_sel_selCtr_indexer = 0;  		for (int nn = 0; nn < 50; nn++) {  			mtfv_i = mtfv.ReadUInt16 (gs + (nn));  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]);  		}  	}  	gs = ge + 1;  	selCtr++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	BZLibCommon.AssertH (s.selector [selCtr] < nGroups' 3006);  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt16 mtfv_i;  		//UChar* s_len_sel_selCtr = &(s.len[s.selector[selCtr]][0]);  		//Int32* s_code_sel_selCtr = &(s.code[s.selector[selCtr]][0]);  		Int32 s_len_sel_selCtr_indexer = 0;  		Int32 s_code_sel_selCtr_indexer = 0;  		for (int nn = 0; nn < 50; nn++) {  			mtfv_i = mtfv.ReadUInt16 (gs + (nn));  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]);  		}  	}  	gs = ge + 1;  	selCtr++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: while (true) {  	if (gs >= s.nMTF)  		break;  	ge = gs + BZLib.BZConstants.BZ_G_SIZE - 1;  	if (ge >= s.nMTF)  		ge = s.nMTF - 1;  	BZLibCommon.AssertH (s.selector [selCtr] < nGroups' 3006);  	if (nGroups == 6 && 50 == ge - gs + 1) {  		/*--- fast track the common case ---*/UInt16 mtfv_i;  		//UChar* s_len_sel_selCtr = &(s.len[s.selector[selCtr]][0]);  		//Int32* s_code_sel_selCtr = &(s.code[s.selector[selCtr]][0]);  		Int32 s_len_sel_selCtr_indexer = 0;  		Int32 s_code_sel_selCtr_indexer = 0;  		for (int nn = 0; nn < 50; nn++) {  			mtfv_i = mtfv.ReadUInt16 (gs + (nn));  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  		}  	}  	else {  		/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  			bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]);  		}  	}  	gs = ge + 1;  	selCtr++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (s.selector [selCtr] < nGroups' 3006);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt16 mtfv_i;  	//UChar* s_len_sel_selCtr = &(s.len[s.selector[selCtr]][0]);  	//Int32* s_code_sel_selCtr = &(s.code[s.selector[selCtr]][0]);  	Int32 s_len_sel_selCtr_indexer = 0;  	Int32 s_code_sel_selCtr_indexer = 0;  	for (int nn = 0; nn < 50; nn++) {  		mtfv_i = mtfv.ReadUInt16 (gs + (nn));  		bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  	}  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt16 mtfv_i;  	//UChar* s_len_sel_selCtr = &(s.len[s.selector[selCtr]][0]);  	//Int32* s_code_sel_selCtr = &(s.code[s.selector[selCtr]][0]);  	Int32 s_len_sel_selCtr_indexer = 0;  	Int32 s_code_sel_selCtr_indexer = 0;  	for (int nn = 0; nn < 50; nn++) {  		mtfv_i = mtfv.ReadUInt16 (gs + (nn));  		bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  	}  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (nGroups == 6 && 50 == ge - gs + 1) {  	/*--- fast track the common case ---*/UInt16 mtfv_i;  	//UChar* s_len_sel_selCtr = &(s.len[s.selector[selCtr]][0]);  	//Int32* s_code_sel_selCtr = &(s.code[s.selector[selCtr]][0]);  	Int32 s_len_sel_selCtr_indexer = 0;  	Int32 s_code_sel_selCtr_indexer = 0;  	for (int nn = 0; nn < 50; nn++) {  		mtfv_i = mtfv.ReadUInt16 (gs + (nn));  		bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  	}  }  else {  	/*--- slow version which correctly handles all situations ---*/for (i = gs; i <= ge; i++) {  		bsW (ref s' s.len [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]' (UInt32)s.code [s.selector [selCtr]] [mtfv.ReadUInt16 (i)]);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: for (int nn = 0; nn < 50; nn++) {  	mtfv_i = mtfv.ReadUInt16 (gs + (nn));  	bsW (ref s' s.len [s.selector [selCtr]] [mtfv_i + s_len_sel_selCtr_indexer]' (UInt32)s.code [s.selector [selCtr]] [mtfv_i + s_code_sel_selCtr_indexer]);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: BZLibCommon.AssertH (selCtr == nSelectors' 3007);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,sendMTFValues,The following statement contains a magic number: if (s.verbosity >= 3)  	BZLibCommon.VPrintf ("codes {0}\n"' s.numZ - nBytes);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: if (s.nblock > 0) {  	BZ_FINALISE_CRC (ref s.blockCRC);  	s.combinedCRC = (s.combinedCRC << 1) | (s.combinedCRC >> 31);  	s.combinedCRC ^= s.blockCRC;  	if (s.blockNo > 1)  		s.numZ = 0;  	if (s.verbosity >= 2)  		BZLibCommon.VPrintf ("    block {0}: crc = 0x{1:x}' " + "combined CRC = 0x{2:x}' size = {3}\n"' s.blockNo' s.blockCRC' s.combinedCRC' s.nblock);  	BlockSort.BZ2_blockSort (ref s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: if (s.nblock > 0) {  	BZ_FINALISE_CRC (ref s.blockCRC);  	s.combinedCRC = (s.combinedCRC << 1) | (s.combinedCRC >> 31);  	s.combinedCRC ^= s.blockCRC;  	if (s.blockNo > 1)  		s.numZ = 0;  	if (s.verbosity >= 2)  		BZLibCommon.VPrintf ("    block {0}: crc = 0x{1:x}' " + "combined CRC = 0x{2:x}' size = {3}\n"' s.blockNo' s.blockCRC' s.combinedCRC' s.nblock);  	BlockSort.BZ2_blockSort (ref s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: s.combinedCRC = (s.combinedCRC << 1) | (s.combinedCRC >> 31);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: if (s.verbosity >= 2)  	BZLibCommon.VPrintf ("    block {0}: crc = 0x{1:x}' " + "combined CRC = 0x{2:x}' size = {3}\n"' s.blockNo' s.blockCRC' s.combinedCRC' s.nblock);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: if (s.nblock > 0) {  	bsPutUChar (ref s' 0x31);  	/* Xceed Extensions */if (s.bSmallSig == 0) {  		bsPutUChar (ref s' 0x41);  		bsPutUChar (ref s' 0x59);  		bsPutUChar (ref s' 0x26);  		bsPutUChar (ref s' 0x53);  		bsPutUChar (ref s' 0x59);  		/*-- Now the block's CRC' so it is in a known place. --*/bsPutUInt32 (ref s' s.blockCRC);  	}  	/*--  				   Now a single bit indicating (non-)randomisation.  				   As of version 0.9.5' we use a better sorting algorithm 				   which makes randomisation unnecessary.  So always set 				   the randomised bit to 'no'.  Of course' the decoder 				   still needs to be able to handle randomised blocks 				   so as to maintain backwards compatibility with 				   older versions of bzip2. 				--*/bsW (ref s' 1' 0);  	bsW (ref s' 24' (UInt32)s.origPtr);  	generateMTFValues (ref s);  	sendMTFValues (ref s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: bsW (ref s' 24' (UInt32)s.origPtr);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: if (is_last_block) {  	bsPutUChar (ref s' 0x17);  	/* Xceed Extensions */if (s.bSmallSig == 0) {  		bsPutUChar (ref s' 0x72);  		bsPutUChar (ref s' 0x45);  		bsPutUChar (ref s' 0x38);  		bsPutUChar (ref s' 0x50);  		bsPutUChar (ref s' 0x90);  		bsPutUInt32 (ref s' s.combinedCRC);  		if (s.verbosity >= 2)  			BZLibCommon.VPrintf ("    final combined CRC = 0x{0:x}\n   "' s.combinedCRC);  	}  	bsFinishWrite (ref s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: if (s.bSmallSig == 0) {  	bsPutUChar (ref s' 0x72);  	bsPutUChar (ref s' 0x45);  	bsPutUChar (ref s' 0x38);  	bsPutUChar (ref s' 0x50);  	bsPutUChar (ref s' 0x90);  	bsPutUInt32 (ref s' s.combinedCRC);  	if (s.verbosity >= 2)  		BZLibCommon.VPrintf ("    final combined CRC = 0x{0:x}\n   "' s.combinedCRC);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,BZ2_compressBlock,The following statement contains a magic number: if (s.verbosity >= 2)  	BZLibCommon.VPrintf ("    final combined CRC = 0x{0:x}\n   "' s.combinedCRC);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,CRCTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\crctable.cs,BZ_UPDATE_CRC,The following statement contains a magic number: crcVar = (crcVar << 8) ^ BZ2_crc32Table [(crcVar >> 24) ^ (cha)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,CRCTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\crctable.cs,BZ_UPDATE_CRC,The following statement contains a magic number: crcVar = (crcVar << 8) ^ BZ2_crc32Table [(crcVar >> 24) ^ (cha)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadUInt16,The following statement contains a magic number: iIndex *= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadUInt32,The following statement contains a magic number: iIndex *= 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt16,The following statement contains a magic number: iIndex *= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt16,The following statement contains a magic number: m_streamData [iIndex] = (byte)((valueUInt16 >> 8) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt32,The following statement contains a magic number: iIndex *= 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt32,The following statement contains a magic number: m_streamData [iIndex + 3] = (byte)(valueUInt32 & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt32,The following statement contains a magic number: m_streamData [iIndex + 2] = (byte)((valueUInt32 >> 8) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamByte,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt32,The following statement contains a magic number: m_streamData [iIndex + 2] = (byte)((valueUInt32 >> 8) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt16,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: iIndex /= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt16,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadUInt32,The following statement contains a magic number: iIndex *= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt16,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: iIndex /= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt16,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: if (iIndex % 1 == 0)  	m_streamData [iIndex] = valueByte;  else  	m_streamData [iIndex] = (UInt16)(valueByte << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt16,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex] = (UInt16)(valueByte << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt16,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt32,The following statement contains a magic number: iIndex *= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt16,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt32,The following statement contains a magic number: m_streamData [iIndex] = (UInt16)((valueUInt32 >> 16) & 0xffff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  	break;  case 1:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  	break;  case 2:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  	break;  default:  	bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: bRes = (byte)(m_streamData [iIndex >> 2] & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: bRes = (byte)((m_streamData [iIndex >> 2] >> 8) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: bRes = (byte)((m_streamData [iIndex >> 2] >> 16) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadByte,The following statement contains a magic number: bRes = (byte)((m_streamData [iIndex >> 2] >> 24) & 0xff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadUInt16,The following statement contains a magic number: switch (iIndex % 2) {  case 0:  	iRes = (UInt16)((m_streamData [(iIndex >> 1)]) & 0x0000ffff);  	break;  default:  	iRes = (UInt16)((m_streamData [(iIndex >> 1)] >> 16) & 0x0000ffff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadUInt16,The following statement contains a magic number: switch (iIndex % 2) {  case 0:  	iRes = (UInt16)((m_streamData [(iIndex >> 1)]) & 0x0000ffff);  	break;  default:  	iRes = (UInt16)((m_streamData [(iIndex >> 1)] >> 16) & 0x0000ffff);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,ReadUInt16,The following statement contains a magic number: iRes = (UInt16)((m_streamData [(iIndex >> 1)] >> 16) & 0x0000ffff);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: switch (iIndex % 4) {  case 0:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  	break;  case 1:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  	break;  case 2:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  	break;  default:  	m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffffff00) | (UInt32)valueByte;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xffff00ff) | ((UInt32)valueByte << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0xff00ffff) | ((UInt32)valueByte << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteByte,The following statement contains a magic number: m_streamData [iIndex >> 2] = (m_streamData [iIndex >> 2] & 0x00ffffff) | ((UInt32)valueByte << 24);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt16,The following statement contains a magic number: switch (iIndex % 2) {  case 0:  	m_streamData [(iIndex >> 1)] = (m_streamData [iIndex >> 1] & 0xffff0000) | (UInt32)valueUInt16;  	break;  default:  	m_streamData [(iIndex >> 1)] = (m_streamData [iIndex >> 1] & 0x0000ffff) | ((UInt32)valueUInt16 << 16);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt16,The following statement contains a magic number: switch (iIndex % 2) {  case 0:  	m_streamData [(iIndex >> 1)] = (m_streamData [iIndex >> 1] & 0xffff0000) | (UInt32)valueUInt16;  	break;  default:  	m_streamData [(iIndex >> 1)] = (m_streamData [iIndex >> 1] & 0x0000ffff) | ((UInt32)valueUInt16 << 16);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,DataStreamUInt32,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\DataStream.cs,WriteUInt16,The following statement contains a magic number: m_streamData [(iIndex >> 1)] = (m_streamData [iIndex >> 1] & 0x0000ffff) | ((UInt32)valueUInt16 << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (!GET_BITS (vars' BZLib.BZDecompressionState.BZ_X_MAGIC_4' ref s.blockSize100k' 8' ref s))  	goto save_state_and_return;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.smallDecompress) {  	s.ll16 = new UInt16[s.blockSize100k * 100000];  	s.ll4 = new byte[((1 + s.blockSize100k * 100000) >> 1)];  	if (s.ll16 == null || s.ll4 == null) {  		vars.retVal = BZLib.BZReturnValue.BZ_MEM_ERROR;  		goto save_state_and_return;  	}  }  else {  	s.tt = new UInt32[s.blockSize100k * 100000];  	if (s.tt == null) {  		vars.retVal = BZLib.BZReturnValue.BZ_MEM_ERROR;  		goto save_state_and_return;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.smallDecompress) {  	s.ll16 = new UInt16[s.blockSize100k * 100000];  	s.ll4 = new byte[((1 + s.blockSize100k * 100000) >> 1)];  	if (s.ll16 == null || s.ll4 == null) {  		vars.retVal = BZLib.BZReturnValue.BZ_MEM_ERROR;  		goto save_state_and_return;  	}  }  else {  	s.tt = new UInt32[s.blockSize100k * 100000];  	if (s.tt == null) {  		vars.retVal = BZLib.BZReturnValue.BZ_MEM_ERROR;  		goto save_state_and_return;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.smallDecompress) {  	s.ll16 = new UInt16[s.blockSize100k * 100000];  	s.ll4 = new byte[((1 + s.blockSize100k * 100000) >> 1)];  	if (s.ll16 == null || s.ll4 == null) {  		vars.retVal = BZLib.BZReturnValue.BZ_MEM_ERROR;  		goto save_state_and_return;  	}  }  else {  	s.tt = new UInt32[s.blockSize100k * 100000];  	if (s.tt == null) {  		vars.retVal = BZLib.BZReturnValue.BZ_MEM_ERROR;  		goto save_state_and_return;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.ll16 = new UInt16[s.blockSize100k * 100000];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.ll4 = new byte[((1 + s.blockSize100k * 100000) >> 1)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.tt = new UInt32[s.blockSize100k * 100000];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.verbosity >= 2)  	BZLibCommon.VPrintf ("\n    [{0}: huff+mtf "' s.currBlockNo);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedBlockCRC = (s.storedBlockCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedBlockCRC = (s.storedBlockCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedBlockCRC = (s.storedBlockCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedBlockCRC = (s.storedBlockCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.origPtr = (s.origPtr << 8) | ((Int32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.origPtr = (s.origPtr << 8) | ((Int32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.origPtr = (s.origPtr << 8) | ((Int32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.origPtr > 10 + 100000 * s.blockSize100k) {  	vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  	goto save_state_and_return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.origPtr > 10 + 100000 * s.blockSize100k) {  	vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  	goto save_state_and_return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i < 16; i++) {  	if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_1) {  		i = s.save_i;  		forceLabel = BZLib.BZDecompressionState.None;  	}  	if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_1' ref uc' ref s))  		goto save_state_and_return;  	if (uc == 1)  		s.inUse16 [i] = true;  	else  		s.inUse16 [i] = false;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i < 256; i++)  	s.inUse [i] = false;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i < 16; i++) {  	if (s.inUse16 [i] || forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  		for (j = 0; j < 16; j++) {  			if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  				i = s.save_i;  				j = s.save_j;  				forceLabel = BZLib.BZDecompressionState.None;  			}  			if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_2' ref uc' ref s))  				goto save_state_and_return;  			if (uc == 1)  				s.inUse [i * 16 + j] = true;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i < 16; i++) {  	if (s.inUse16 [i] || forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  		for (j = 0; j < 16; j++) {  			if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  				i = s.save_i;  				j = s.save_j;  				forceLabel = BZLib.BZDecompressionState.None;  			}  			if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_2' ref uc' ref s))  				goto save_state_and_return;  			if (uc == 1)  				s.inUse [i * 16 + j] = true;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i < 16; i++) {  	if (s.inUse16 [i] || forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  		for (j = 0; j < 16; j++) {  			if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  				i = s.save_i;  				j = s.save_j;  				forceLabel = BZLib.BZDecompressionState.None;  			}  			if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_2' ref uc' ref s))  				goto save_state_and_return;  			if (uc == 1)  				s.inUse [i * 16 + j] = true;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.inUse16 [i] || forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  	for (j = 0; j < 16; j++) {  		if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  			i = s.save_i;  			j = s.save_j;  			forceLabel = BZLib.BZDecompressionState.None;  		}  		if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_2' ref uc' ref s))  			goto save_state_and_return;  		if (uc == 1)  			s.inUse [i * 16 + j] = true;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.inUse16 [i] || forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  	for (j = 0; j < 16; j++) {  		if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  			i = s.save_i;  			j = s.save_j;  			forceLabel = BZLib.BZDecompressionState.None;  		}  		if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_2' ref uc' ref s))  			goto save_state_and_return;  		if (uc == 1)  			s.inUse [i * 16 + j] = true;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (j = 0; j < 16; j++) {  	if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  		i = s.save_i;  		j = s.save_j;  		forceLabel = BZLib.BZDecompressionState.None;  	}  	if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_2' ref uc' ref s))  		goto save_state_and_return;  	if (uc == 1)  		s.inUse [i * 16 + j] = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (j = 0; j < 16; j++) {  	if (forceLabel == BZLib.BZDecompressionState.BZ_X_MAPPING_2) {  		i = s.save_i;  		j = s.save_j;  		forceLabel = BZLib.BZDecompressionState.None;  	}  	if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_MAPPING_2' ref uc' ref s))  		goto save_state_and_return;  	if (uc == 1)  		s.inUse [i * 16 + j] = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (uc == 1)  	s.inUse [i * 16 + j] = true;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.inUse [i * 16 + j] = true;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: alphaSize = s.nInUse + 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (!GET_BITS (vars' BZLib.BZDecompressionState.BZ_X_SELECTOR_1' ref nGroups' 3' ref s))  	goto save_state_and_return;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nGroups < 2 || nGroups > 6) {  	vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  	goto save_state_and_return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nGroups < 2 || nGroups > 6) {  	vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  	goto save_state_and_return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (!GET_BITS (vars' BZLib.BZDecompressionState.BZ_X_SELECTOR_2' ref vars.nSelectors' 15' ref s))  	goto save_state_and_return;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	if (forceLabel == BZLib.BZDecompressionState.BZ_X_CODING_1) {  		t = s.save_t;  		forceLabel = BZLib.BZDecompressionState.None;  	}  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (!GET_BITS (vars' BZLib.BZDecompressionState.BZ_X_CODING_1' ref curr' 5' ref s))  			goto save_state_and_return;  	}  	for (i = 0; i < alphaSize; i++) {  		while (true) {  			if (forceLabel != BZLib.BZDecompressionState.BZ_X_CODING_3) {  				if (curr < 1 || curr > 20) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				if (forceLabel == BZLib.BZDecompressionState.BZ_X_CODING_2) {  					t = s.save_t;  					i = s.save_i;  					forceLabel = BZLib.BZDecompressionState.None;  				}  				if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_2' ref uc' ref s))  					goto save_state_and_return;  				if (uc == 0)  					break;  			}  			else {  				t = s.save_t;  				i = s.save_i;  				forceLabel = BZLib.BZDecompressionState.None;  			}  			if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_3' ref uc' ref s))  				goto save_state_and_return;  			if (uc == 0)  				curr++;  			else  				curr--;  		}  		s.len [t] [i] = (byte)curr;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	if (forceLabel == BZLib.BZDecompressionState.BZ_X_CODING_1) {  		t = s.save_t;  		forceLabel = BZLib.BZDecompressionState.None;  	}  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (!GET_BITS (vars' BZLib.BZDecompressionState.BZ_X_CODING_1' ref curr' 5' ref s))  			goto save_state_and_return;  	}  	for (i = 0; i < alphaSize; i++) {  		while (true) {  			if (forceLabel != BZLib.BZDecompressionState.BZ_X_CODING_3) {  				if (curr < 1 || curr > 20) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				if (forceLabel == BZLib.BZDecompressionState.BZ_X_CODING_2) {  					t = s.save_t;  					i = s.save_i;  					forceLabel = BZLib.BZDecompressionState.None;  				}  				if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_2' ref uc' ref s))  					goto save_state_and_return;  				if (uc == 0)  					break;  			}  			else {  				t = s.save_t;  				i = s.save_i;  				forceLabel = BZLib.BZDecompressionState.None;  			}  			if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_3' ref uc' ref s))  				goto save_state_and_return;  			if (uc == 0)  				curr++;  			else  				curr--;  		}  		s.len [t] [i] = (byte)curr;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (!GET_BITS (vars' BZLib.BZDecompressionState.BZ_X_CODING_1' ref curr' 5' ref s))  		goto save_state_and_return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (!GET_BITS (vars' BZLib.BZDecompressionState.BZ_X_CODING_1' ref curr' 5' ref s))  	goto save_state_and_return;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i < alphaSize; i++) {  	while (true) {  		if (forceLabel != BZLib.BZDecompressionState.BZ_X_CODING_3) {  			if (curr < 1 || curr > 20) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			if (forceLabel == BZLib.BZDecompressionState.BZ_X_CODING_2) {  				t = s.save_t;  				i = s.save_i;  				forceLabel = BZLib.BZDecompressionState.None;  			}  			if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_2' ref uc' ref s))  				goto save_state_and_return;  			if (uc == 0)  				break;  		}  		else {  			t = s.save_t;  			i = s.save_i;  			forceLabel = BZLib.BZDecompressionState.None;  		}  		if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_3' ref uc' ref s))  			goto save_state_and_return;  		if (uc == 0)  			curr++;  		else  			curr--;  	}  	s.len [t] [i] = (byte)curr;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_CODING_3) {  		if (curr < 1 || curr > 20) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		if (forceLabel == BZLib.BZDecompressionState.BZ_X_CODING_2) {  			t = s.save_t;  			i = s.save_i;  			forceLabel = BZLib.BZDecompressionState.None;  		}  		if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_2' ref uc' ref s))  			goto save_state_and_return;  		if (uc == 0)  			break;  	}  	else {  		t = s.save_t;  		i = s.save_i;  		forceLabel = BZLib.BZDecompressionState.None;  	}  	if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_3' ref uc' ref s))  		goto save_state_and_return;  	if (uc == 0)  		curr++;  	else  		curr--;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_CODING_3) {  	if (curr < 1 || curr > 20) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	if (forceLabel == BZLib.BZDecompressionState.BZ_X_CODING_2) {  		t = s.save_t;  		i = s.save_i;  		forceLabel = BZLib.BZDecompressionState.None;  	}  	if (!GET_BIT (vars' BZLib.BZDecompressionState.BZ_X_CODING_2' ref uc' ref s))  		goto save_state_and_return;  	if (uc == 0)  		break;  }  else {  	t = s.save_t;  	i = s.save_i;  	forceLabel = BZLib.BZDecompressionState.None;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (curr < 1 || curr > 20) {  	vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  	goto save_state_and_return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (t = 0; t < nGroups; t++) {  	minLen = 32;  	maxLen = 0;  	for (i = 0; i < alphaSize; i++) {  		if (s.len [t] [i] > maxLen)  			maxLen = s.len [t] [i];  		if (s.len [t] [i] < minLen)  			minLen = s.len [t] [i];  	}  	Huffman.BZ2_hbCreateDecodeTables (ref s.limit [t]' ref s.m_base [t]' ref s.perm [t]' ref s.len [t]' minLen' maxLen' alphaSize);  	s.minLens [t] = minLen;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: minLen = 32;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: nblockMAX = 100000 * s.blockSize100k;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i <= 255; i++)  	s.unzftab [i] = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  	for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  		s.mtfa [kk] = (byte)(ii * (Int32)BZLib.BZConstants.MTFL_SIZE + jj);  		kk--;  	}  	s.mtfbase [ii] = kk + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (true) {  	if (nextSym == EOB)  		break;  	if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			es = -1;  			N = 1;  		}  		do {  			if (forceLabel == BZLib.BZDecompressionState.None) {  				if (nextSym == BZLib.BZConstants.BZ_RUNA)  					es = es + (0 + 1) * N;  				else if (nextSym == BZLib.BZConstants.BZ_RUNB)  					es = es + (1 + 1) * N;  				N = N * 2;  			}  			if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  				goto save_state_and_return;  			}  			;  		}  		while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  		es++;  		uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  		s.unzftab [uc] += es;  		if (s.smallDecompress) {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.ll16 [nblock] = (UInt16)uc;  				nblock++;  				es--;  			}  		}  		else {  			while (es > 0) {  				if (nblock >= nblockMAX) {  					vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  					goto save_state_and_return;  				}  				s.tt [nblock] = (UInt32)uc;  				nblock++;  				es--;  			}  			;  		}  		continue;  	}  	else {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			/*-- uc = MTF ( nextSym-1 ) --*/{  				Int32 ii' jj' kk' pp' lno' off;  				UInt32 nn;  				nn = (UInt32)(nextSym - 1);  				if (nn < BZLib.BZConstants.MTFL_SIZE) {  					/* avoid general-case expense */pp = s.mtfbase [0];  					uc = s.mtfa [pp + nn];  					while (nn > 3) {  						Int32 z = (Int32)(pp + nn);  						s.mtfa [(z)] = s.mtfa [(z) - 1];  						s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  						s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  						s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  						nn -= 4;  					}  					while (nn > 0) {  						s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  						nn--;  					}  					;  					s.mtfa [pp] = uc;  				}  				else {  					/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  					off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  					pp = s.mtfbase [lno] + off;  					uc = s.mtfa [pp];  					while (pp > s.mtfbase [lno]) {  						s.mtfa [pp] = s.mtfa [pp - 1];  						pp--;  					}  					;  					s.mtfbase [lno]++;  					while (lno > 0) {  						s.mtfbase [lno]--;  						s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  						lno--;  					}  					s.mtfbase [0]--;  					s.mtfa [s.mtfbase [0]] = uc;  					if (s.mtfbase [0] == 0) {  						kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  						for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  							for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  								s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  								kk--;  							}  							s.mtfbase [ii] = kk + 1;  						}  					}  				}  			/*-- end uc = MTF ( nextSym-1 ) --*/}  			s.unzftab [s.seqToUnseq [uc]]++;  			if (s.smallDecompress)  				s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  			else  				s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  			nblock++;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		continue;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel != BZLib.BZDecompressionState.BZ_X_MTF_5 && (nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB) || (forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_3 || forceLabel == BZLib.BZDecompressionState.BZ_X_MTF_4)) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		es = -1;  		N = 1;  	}  	do {  		if (forceLabel == BZLib.BZDecompressionState.None) {  			if (nextSym == BZLib.BZConstants.BZ_RUNA)  				es = es + (0 + 1) * N;  			else if (nextSym == BZLib.BZConstants.BZ_RUNB)  				es = es + (1 + 1) * N;  			N = N * 2;  		}  		if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  			goto save_state_and_return;  		}  		;  	}  	while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  	es++;  	uc = s.seqToUnseq [s.mtfa [s.mtfbase [0]]];  	s.unzftab [uc] += es;  	if (s.smallDecompress) {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.ll16 [nblock] = (UInt16)uc;  			nblock++;  			es--;  		}  	}  	else {  		while (es > 0) {  			if (nblock >= nblockMAX) {  				vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  				goto save_state_and_return;  			}  			s.tt [nblock] = (UInt32)uc;  			nblock++;  			es--;  		}  		;  	}  	continue;  }  else {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nblock >= nblockMAX) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			goto save_state_and_return;  		}  		/*-- uc = MTF ( nextSym-1 ) --*/{  			Int32 ii' jj' kk' pp' lno' off;  			UInt32 nn;  			nn = (UInt32)(nextSym - 1);  			if (nn < BZLib.BZConstants.MTFL_SIZE) {  				/* avoid general-case expense */pp = s.mtfbase [0];  				uc = s.mtfa [pp + nn];  				while (nn > 3) {  					Int32 z = (Int32)(pp + nn);  					s.mtfa [(z)] = s.mtfa [(z) - 1];  					s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  					s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  					s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  					nn -= 4;  				}  				while (nn > 0) {  					s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  					nn--;  				}  				;  				s.mtfa [pp] = uc;  			}  			else {  				/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  				off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  				pp = s.mtfbase [lno] + off;  				uc = s.mtfa [pp];  				while (pp > s.mtfbase [lno]) {  					s.mtfa [pp] = s.mtfa [pp - 1];  					pp--;  				}  				;  				s.mtfbase [lno]++;  				while (lno > 0) {  					s.mtfbase [lno]--;  					s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  					lno--;  				}  				s.mtfbase [0]--;  				s.mtfa [s.mtfbase [0]] = uc;  				if (s.mtfbase [0] == 0) {  					kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  					for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  						for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  							s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  							kk--;  						}  						s.mtfbase [ii] = kk + 1;  					}  				}  			}  		/*-- end uc = MTF ( nextSym-1 ) --*/}  		s.unzftab [s.seqToUnseq [uc]]++;  		if (s.smallDecompress)  			s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  		else  			s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  		nblock++;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_5' BZLib.BZDecompressionState.BZ_X_MTF_6' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	continue;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: do {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (nextSym == BZLib.BZConstants.BZ_RUNA)  			es = es + (0 + 1) * N;  		else if (nextSym == BZLib.BZConstants.BZ_RUNB)  			es = es + (1 + 1) * N;  		N = N * 2;  	}  	if (!GET_MTF_VAL (vars' ref forceLabel' BZLib.BZDecompressionState.BZ_X_MTF_3' BZLib.BZDecompressionState.BZ_X_MTF_4' ref nextSym' ref s)) {  		goto save_state_and_return;  	}  	;  }  while ((nextSym == BZLib.BZConstants.BZ_RUNA || nextSym == BZLib.BZConstants.BZ_RUNB));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nextSym == BZLib.BZConstants.BZ_RUNA)  		es = es + (0 + 1) * N;  	else if (nextSym == BZLib.BZConstants.BZ_RUNB)  		es = es + (1 + 1) * N;  	N = N * 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: N = N * 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (nblock >= nblockMAX) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		goto save_state_and_return;  	}  	/*-- uc = MTF ( nextSym-1 ) --*/{  		Int32 ii' jj' kk' pp' lno' off;  		UInt32 nn;  		nn = (UInt32)(nextSym - 1);  		if (nn < BZLib.BZConstants.MTFL_SIZE) {  			/* avoid general-case expense */pp = s.mtfbase [0];  			uc = s.mtfa [pp + nn];  			while (nn > 3) {  				Int32 z = (Int32)(pp + nn);  				s.mtfa [(z)] = s.mtfa [(z) - 1];  				s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  				s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  				s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  				nn -= 4;  			}  			while (nn > 0) {  				s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  				nn--;  			}  			;  			s.mtfa [pp] = uc;  		}  		else {  			/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  			off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  			pp = s.mtfbase [lno] + off;  			uc = s.mtfa [pp];  			while (pp > s.mtfbase [lno]) {  				s.mtfa [pp] = s.mtfa [pp - 1];  				pp--;  			}  			;  			s.mtfbase [lno]++;  			while (lno > 0) {  				s.mtfbase [lno]--;  				s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  				lno--;  			}  			s.mtfbase [0]--;  			s.mtfa [s.mtfbase [0]] = uc;  			if (s.mtfbase [0] == 0) {  				kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  				for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  					for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  						s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  						kk--;  					}  					s.mtfbase [ii] = kk + 1;  				}  			}  		}  	/*-- end uc = MTF ( nextSym-1 ) --*/}  	s.unzftab [s.seqToUnseq [uc]]++;  	if (s.smallDecompress)  		s.ll16 [nblock] = (UInt16)(s.seqToUnseq [uc]);  	else  		s.tt [nblock] = (UInt32)(s.seqToUnseq [uc]);  	nblock++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (nn < BZLib.BZConstants.MTFL_SIZE) {  	/* avoid general-case expense */pp = s.mtfbase [0];  	uc = s.mtfa [pp + nn];  	while (nn > 3) {  		Int32 z = (Int32)(pp + nn);  		s.mtfa [(z)] = s.mtfa [(z) - 1];  		s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  		s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  		s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  		nn -= 4;  	}  	while (nn > 0) {  		s.mtfa [(pp + nn)] = s.mtfa [(pp + nn) - 1];  		nn--;  	}  	;  	s.mtfa [pp] = uc;  }  else {  	/* general case */lno = (Int32)(nn / BZLib.BZConstants.MTFL_SIZE);  	off = (Int32)(nn % BZLib.BZConstants.MTFL_SIZE);  	pp = s.mtfbase [lno] + off;  	uc = s.mtfa [pp];  	while (pp > s.mtfbase [lno]) {  		s.mtfa [pp] = s.mtfa [pp - 1];  		pp--;  	}  	;  	s.mtfbase [lno]++;  	while (lno > 0) {  		s.mtfbase [lno]--;  		s.mtfa [s.mtfbase [lno]] = s.mtfa [s.mtfbase [lno - 1] + (Int32)BZLib.BZConstants.MTFL_SIZE - 1];  		lno--;  	}  	s.mtfbase [0]--;  	s.mtfa [s.mtfbase [0]] = uc;  	if (s.mtfbase [0] == 0) {  		kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  		for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  			for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  				s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  				kk--;  			}  			s.mtfbase [ii] = kk + 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (nn > 3) {  	Int32 z = (Int32)(pp + nn);  	s.mtfa [(z)] = s.mtfa [(z) - 1];  	s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  	s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  	s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  	nn -= 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (nn > 3) {  	Int32 z = (Int32)(pp + nn);  	s.mtfa [(z)] = s.mtfa [(z) - 1];  	s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  	s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  	s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  	nn -= 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (nn > 3) {  	Int32 z = (Int32)(pp + nn);  	s.mtfa [(z)] = s.mtfa [(z) - 1];  	s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  	s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  	s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  	nn -= 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (nn > 3) {  	Int32 z = (Int32)(pp + nn);  	s.mtfa [(z)] = s.mtfa [(z) - 1];  	s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  	s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  	s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  	nn -= 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (nn > 3) {  	Int32 z = (Int32)(pp + nn);  	s.mtfa [(z)] = s.mtfa [(z) - 1];  	s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  	s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  	s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  	nn -= 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (nn > 3) {  	Int32 z = (Int32)(pp + nn);  	s.mtfa [(z)] = s.mtfa [(z) - 1];  	s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  	s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  	s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  	nn -= 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: while (nn > 3) {  	Int32 z = (Int32)(pp + nn);  	s.mtfa [(z)] = s.mtfa [(z) - 1];  	s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  	s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  	s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  	nn -= 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.mtfa [(z) - 1] = s.mtfa [(z) - 2];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.mtfa [(z) - 2] = s.mtfa [(z) - 3];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.mtfa [(z) - 3] = s.mtfa [(z) - 4];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: nn -= 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.mtfbase [0] == 0) {  	kk = (Int32)BZLib.BZConstants.MTFA_SIZE - 1;  	for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  		for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  			s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  			kk--;  		}  		s.mtfbase [ii] = kk + 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1; ii >= 0; ii--) {  	for (jj = (Int32)BZLib.BZConstants.MTFL_SIZE - 1; jj >= 0; jj--) {  		s.mtfa [kk] = s.mtfa [s.mtfbase [ii] + jj];  		kk--;  	}  	s.mtfbase [ii] = kk + 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: ii = 256 / (Int32)BZLib.BZConstants.MTFL_SIZE - 1
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.verbosity >= 2)  	BZLibCommon.VPrintf ("rt+rld");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 1; i <= 256; i++)  	s.cftab [i] = s.unzftab [i - 1];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 1; i <= 256; i++)  	s.cftab [i] += s.cftab [i - 1];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.smallDecompress) {  	/*-- Make a copy of cftab' used in generation of T --*/for (i = 0; i <= 256; i++)  		s.cftabCopy [i] = s.cftab [i];  	/*-- compute the T vector --*/for (i = 0; i < nblock; i++) {  		uc = (byte)(s.ll16 [i]);  		BZLib.SET_LL (ref s' i' s.cftabCopy [uc]);  		s.cftabCopy [uc]++;  	}  	/*-- Compute T^(-1) by pointer reversal on T --*/i = s.origPtr;  	j = (Int32)BZLib.GET_LL (ref s' (UInt32)i);  	do {  		Int32 tmp = (Int32)BZLib.GET_LL (ref s' (UInt32)j);  		BZLib.SET_LL (ref s' j' i);  		i = j;  		j = tmp;  	}  	while (i != s.origPtr);  	s.tPos = (UInt32)s.origPtr;  	s.nblock_used = 0;  	if (s.blockRandomised != 0) {  		RandTable.BZ_RAND_INIT_MASK (ref s);  		BZLib.BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	}  	else {  		BZLib.BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  else {  	/*-- compute the T^(-1) vector --*/for (i = 0; i < nblock; i++) {  		uc = (byte)(s.tt [i] & 0xff);  		s.tt [s.cftab [uc]] |= (UInt32)(i << 8);  		s.cftab [uc]++;  	}  	s.tPos = s.tt [s.origPtr] >> 8;  	s.nblock_used = 0;  	if (s.blockRandomised != 0) {  		RandTable.BZ_RAND_INIT_MASK (ref s);  		BZLib.BZ_GET_FAST (ref s' ref s.k0);  		s.nblock_used++;  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	}  	else {  		BZLib.BZ_GET_FAST (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.smallDecompress) {  	/*-- Make a copy of cftab' used in generation of T --*/for (i = 0; i <= 256; i++)  		s.cftabCopy [i] = s.cftab [i];  	/*-- compute the T vector --*/for (i = 0; i < nblock; i++) {  		uc = (byte)(s.ll16 [i]);  		BZLib.SET_LL (ref s' i' s.cftabCopy [uc]);  		s.cftabCopy [uc]++;  	}  	/*-- Compute T^(-1) by pointer reversal on T --*/i = s.origPtr;  	j = (Int32)BZLib.GET_LL (ref s' (UInt32)i);  	do {  		Int32 tmp = (Int32)BZLib.GET_LL (ref s' (UInt32)j);  		BZLib.SET_LL (ref s' j' i);  		i = j;  		j = tmp;  	}  	while (i != s.origPtr);  	s.tPos = (UInt32)s.origPtr;  	s.nblock_used = 0;  	if (s.blockRandomised != 0) {  		RandTable.BZ_RAND_INIT_MASK (ref s);  		BZLib.BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	}  	else {  		BZLib.BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  else {  	/*-- compute the T^(-1) vector --*/for (i = 0; i < nblock; i++) {  		uc = (byte)(s.tt [i] & 0xff);  		s.tt [s.cftab [uc]] |= (UInt32)(i << 8);  		s.cftab [uc]++;  	}  	s.tPos = s.tt [s.origPtr] >> 8;  	s.nblock_used = 0;  	if (s.blockRandomised != 0) {  		RandTable.BZ_RAND_INIT_MASK (ref s);  		BZLib.BZ_GET_FAST (ref s' ref s.k0);  		s.nblock_used++;  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	}  	else {  		BZLib.BZ_GET_FAST (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: if (s.smallDecompress) {  	/*-- Make a copy of cftab' used in generation of T --*/for (i = 0; i <= 256; i++)  		s.cftabCopy [i] = s.cftab [i];  	/*-- compute the T vector --*/for (i = 0; i < nblock; i++) {  		uc = (byte)(s.ll16 [i]);  		BZLib.SET_LL (ref s' i' s.cftabCopy [uc]);  		s.cftabCopy [uc]++;  	}  	/*-- Compute T^(-1) by pointer reversal on T --*/i = s.origPtr;  	j = (Int32)BZLib.GET_LL (ref s' (UInt32)i);  	do {  		Int32 tmp = (Int32)BZLib.GET_LL (ref s' (UInt32)j);  		BZLib.SET_LL (ref s' j' i);  		i = j;  		j = tmp;  	}  	while (i != s.origPtr);  	s.tPos = (UInt32)s.origPtr;  	s.nblock_used = 0;  	if (s.blockRandomised != 0) {  		RandTable.BZ_RAND_INIT_MASK (ref s);  		BZLib.BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	}  	else {  		BZLib.BZ_GET_SMALL (ref s' ref s.k0);  		s.nblock_used++;  	}  }  else {  	/*-- compute the T^(-1) vector --*/for (i = 0; i < nblock; i++) {  		uc = (byte)(s.tt [i] & 0xff);  		s.tt [s.cftab [uc]] |= (UInt32)(i << 8);  		s.cftab [uc]++;  	}  	s.tPos = s.tt [s.origPtr] >> 8;  	s.nblock_used = 0;  	if (s.blockRandomised != 0) {  		RandTable.BZ_RAND_INIT_MASK (ref s);  		BZLib.BZ_GET_FAST (ref s' ref s.k0);  		s.nblock_used++;  		RandTable.BZ_RAND_UPD_MASK (ref s);  		s.k0 ^= RandTable.BZ_RAND_MASK (ref s);  	}  	else {  		BZLib.BZ_GET_FAST (ref s' ref s.k0);  		s.nblock_used++;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i <= 256; i++)  	s.cftabCopy [i] = s.cftab [i];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: for (i = 0; i < nblock; i++) {  	uc = (byte)(s.tt [i] & 0xff);  	s.tt [s.cftab [uc]] |= (UInt32)(i << 8);  	s.cftab [uc]++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.tt [s.cftab [uc]] |= (UInt32)(i << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.tPos = s.tt [s.origPtr] >> 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedCombinedCRC = (s.storedCombinedCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedCombinedCRC = (s.storedCombinedCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedCombinedCRC = (s.storedCombinedCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,BZ2_decompress,The following statement contains a magic number: s.storedCombinedCRC = (s.storedCombinedCRC << 8) | ((UInt32)uc);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,makeMaps_d,The following statement contains a magic number: for (i = 0; i < 256; i++)  	if (s.inUse [i]) {  		s.seqToUnseq [s.nInUse] = (byte)i;  		s.nInUse++;  	}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_BITS,The following statement contains a magic number: while (true) {  	if (s.bsLive >= nnn) {  		vvv = (Int32)((s.bsBuff >> (s.bsLive - nnn)) & ((1 << nnn) - 1));  		s.bsLive -= nnn;  		break;  	}  	if (s.strm.avail_in == 0) {  		vars.retVal = BZLib.BZReturnValue.BZ_OK;  		return false;  	}  	s.bsBuff = (s.bsBuff << 8) | ((UInt32)(s.strm.next_in [s.strm.next_in_index]));  	s.bsLive += 8;  	s.strm.next_in_index++;  	s.strm.avail_in--;  	s.strm.total_in++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_BITS,The following statement contains a magic number: while (true) {  	if (s.bsLive >= nnn) {  		vvv = (Int32)((s.bsBuff >> (s.bsLive - nnn)) & ((1 << nnn) - 1));  		s.bsLive -= nnn;  		break;  	}  	if (s.strm.avail_in == 0) {  		vars.retVal = BZLib.BZReturnValue.BZ_OK;  		return false;  	}  	s.bsBuff = (s.bsBuff << 8) | ((UInt32)(s.strm.next_in [s.strm.next_in_index]));  	s.bsLive += 8;  	s.strm.next_in_index++;  	s.strm.avail_in--;  	s.strm.total_in++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_BITS,The following statement contains a magic number: s.bsBuff = (s.bsBuff << 8) | ((UInt32)(s.strm.next_in [s.strm.next_in_index]));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_BITS,The following statement contains a magic number: s.bsLive += 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_MTF_VAL,The following statement contains a magic number: while (true) {  	if (forceLabel == BZLib.BZDecompressionState.None) {  		if (vars.zn > 20/* the longest code */) {  			vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  			return false;  			//goto save_state_and_return;  		}  		if (vars.zvec <= vars.gLimit [vars.zn])  			break;  		vars.zn++;  	}  	if (forceLabel == BZLib.BZDecompressionState.None || forceLabel == label2) {  		forceLabel = BZLib.BZDecompressionState.None;  		if (!GET_BITS (vars' label2' ref vars.zj' 1' ref s))  			return false;  		vars.zvec = (vars.zvec << 1) | vars.zj;  	}  	else {  		return false;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_MTF_VAL,The following statement contains a magic number: if (forceLabel == BZLib.BZDecompressionState.None) {  	if (vars.zn > 20/* the longest code */) {  		vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  		return false;  		//goto save_state_and_return;  	}  	if (vars.zvec <= vars.gLimit [vars.zn])  		break;  	vars.zn++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Decompress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\decompress.cs,GET_MTF_VAL,The following statement contains a magic number: if (vars.zn > 20/* the longest code */) {  	vars.retVal = BZLib.BZReturnValue.BZ_DATA_ERROR;  	return false;  	//goto save_state_and_return;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: for (i = 0; i < alphaSize; i++)  	weight [i + 1] = (freq [t] [i] == 0 ? 1 : freq [t] [i]) << 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: weight [i + 1] = (freq [t] [i] == 0 ? 1 : freq [t] [i]) << 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: while (true) {  	nNodes = alphaSize;  	nHeap = 0;  	heap [0] = 0;  	weight [0] = 0;  	parent [0] = -2;  	for (i = 1; i <= alphaSize; i++) {  		parent [i] = -1;  		nHeap++;  		heap [nHeap] = i;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  	while (nHeap > 1) {  		n1 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		n2 = heap [1];  		heap [1] = heap [nHeap];  		nHeap--;  		DOWNHEAP (1);  		nNodes++;  		parent [n1] = parent [n2] = nNodes;  		weight [nNodes] = ADDWEIGHTS (weight [n1]' weight [n2]);  		parent [nNodes] = -1;  		nHeap++;  		heap [nHeap] = nNodes;  		UPHEAP (nHeap);  	}  	BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  	tooLong = false;  	for (i = 1; i <= alphaSize; i++) {  		j = 0;  		k = i;  		while (parent [k] >= 0) {  			k = parent [k];  			j++;  		}  		len [t] [i - 1] = (byte)j;  		if (j > maxLen)  			tooLong = true;  	}  	if (!tooLong)  		break;  	for (i = 1; i < alphaSize; i++) {  		j = weight [i] >> 8;  		j = 1 + (j / 2);  		weight [i] = j << 8;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: parent [0] = -2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: BZLibCommon.AssertH (nHeap < (BZ_MAX_ALPHA_SIZE + 2)' 2001);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: BZLibCommon.AssertH (nNodes < (BZ_MAX_ALPHA_SIZE * 2)' 2002);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: for (i = 1; i < alphaSize; i++) {  	j = weight [i] >> 8;  	j = 1 + (j / 2);  	weight [i] = j << 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: for (i = 1; i < alphaSize; i++) {  	j = weight [i] >> 8;  	j = 1 + (j / 2);  	weight [i] = j << 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: for (i = 1; i < alphaSize; i++) {  	j = weight [i] >> 8;  	j = 1 + (j / 2);  	weight [i] = j << 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: j = weight [i] >> 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: j = 1 + (j / 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,HuffmanTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Huffman.cs,BZ2_hbMakeCodeLengths,The following statement contains a magic number: weight [i] = j << 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,RandTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\randtable.cs,BZ_RAND_UPD_MASK,The following statement contains a magic number: if (s.rNToGo == 0) {  	s.rNToGo = BZ2_rNums [s.rTPos];  	s.rTPos++;  	if (s.rTPos == 512)  		s.rTPos = 0;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,RandTable,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\randtable.cs,BZ_RAND_UPD_MASK,The following statement contains a magic number: if (s.rTPos == 512)  	s.rTPos = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = b & 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = k & 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid stored block lengths";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "too many length or distance symbols";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "too many length or distance symbols";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "too many length or distance symbols";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (14' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: s.blens [border [s.index++]] = b & 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 19)  	s.blens [border [s.index++]] = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: s.bb = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: j = c == 18 ? 11u : 3u;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	s.blens = null;  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid bit length repeat";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	s.blens = null;  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid bit length repeat";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	s.blens = null;  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid bit length repeat";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: c = c == 16 ? s.blens [i - 1] : 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: bl = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: bd = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,NEEDBITS,The following statement contains a magic number: while (k < j) {  	if (n != 0) {  		r = ReturnCode.Z_OK;  	}  	else {  		r = LEAVE (b' k' n' p' q' s' z' r);  		return false;  	}  	b |= (uint)NEXTBYTE (ref n' ref p' z) << (int)k;  	k += 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,NEEDBITS,The following statement contains a magic number: k += 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,GRABBITS,The following statement contains a magic number: while (k < j) {  	unchecked {  		b |= ((uint)NEXTBYTE (ref n' ref p' z)) << (int)k;  	}  	k += 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,GRABBITS,The following statement contains a magic number: k += 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,UNGRAB,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,UNGRAB,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,UNGRAB,The following statement contains a magic number: k -= c << 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: maxlen = 258;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (m >= maxlen && n >= 10) {  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  	InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (r != ReturnCode.Z_OK) {  		c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  		break;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* length */ {  	c._get = e & 15;  	c.len = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.LENEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* length */ {  	c._get = e & 15;  	c.len = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.LENEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: c._get = e & 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 64) == 0)/* next table */ {  	c.need = e;  	unchecked {  		c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  	}  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 32) != 0)/* end of block */ {  	c.mode = inflate_codes_mode.WASH;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* distance */ {  	c._get = e & 15;  	c.dist = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.DISTEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* distance */ {  	c._get = e & 15;  	c.dist = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.DISTEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: c._get = e & 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 64) == 0)/* next table */ {  	c.need = e;  	unchecked {  		c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  	}  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (k > 7)/* return unused byte' if any */ {  	System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  	k -= 8;  	n++;  	p--;  	/* can always return one */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (k > 7)/* return unused byte' if any */ {  	System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  	k -= 8;  	n++;  	p--;  	/* can always return one */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (k > 7)/* return unused byte' if any */ {  	System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  	k -= 8;  	n++;  	p--;  	/* can always return one */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: k -= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: maxlen = 258;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits to add to distance base */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* do the copy */m -= c;  		r = /*unchecked(*/(int)q - (int)d/*)*/;  		if (r < 0)/* wrap if needed */ {  			do {  				r += /*unchecked(*/(int)s.end/*)*/;  				/* force index in window */}  			while (r < 0);  			/* covers invalid distances */e = s.end - (uint)r;  			if (c > e) {  				c -= e;  				/* wrapped copy */do {  					s.window [q++] = s.window [r++];  				}  				while ((--e) != 0);  				r = 0;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		e = tp [tp_ndx + t].exop;  	}  	else {  		z.msg = "invalid distance code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits to add to distance base */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* do the copy */m -= c;  		r = /*unchecked(*/(int)q - (int)d/*)*/;  		if (r < 0)/* wrap if needed */ {  			do {  				r += /*unchecked(*/(int)s.end/*)*/;  				/* force index in window */}  			while (r < 0);  			/* covers invalid distances */e = s.end - (uint)r;  			if (c > e) {  				c -= e;  				/* wrapped copy */do {  					s.window [q++] = s.window [r++];  				}  				while ((--e) != 0);  				r = 0;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		e = tp [tp_ndx + t].exop;  	}  	else {  		z.msg = "invalid distance code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits to add to distance base */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* do the copy */m -= c;  		r = /*unchecked(*/(int)q - (int)d/*)*/;  		if (r < 0)/* wrap if needed */ {  			do {  				r += /*unchecked(*/(int)s.end/*)*/;  				/* force index in window */}  			while (r < 0);  			/* covers invalid distances */e = s.end - (uint)r;  			if (c > e) {  				c -= e;  				/* wrapped copy */do {  					s.window [q++] = s.window [r++];  				}  				while ((--e) != 0);  				r = 0;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		e = tp [tp_ndx + t].exop;  	}  	else {  		z.msg = "invalid distance code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits to add to distance base */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* do the copy */m -= c;  	r = /*unchecked(*/(int)q - (int)d/*)*/;  	if (r < 0)/* wrap if needed */ {  		do {  			r += /*unchecked(*/(int)s.end/*)*/;  			/* force index in window */}  		while (r < 0);  		/* covers invalid distances */e = s.end - (uint)r;  		if (c > e) {  			c -= e;  			/* wrapped copy */do {  				s.window [q++] = s.window [r++];  			}  			while ((--e) != 0);  			r = 0;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  	}  	else/* normal copy */ {  		s.window [q++] = s.window [r++];  		c--;  		s.window [q++] = s.window [r++];  		c--;  		do {  			s.window [q++] = s.window [r++];  		}  		while ((--c) != 0);  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits to add to distance base */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* do the copy */m -= c;  	r = /*unchecked(*/(int)q - (int)d/*)*/;  	if (r < 0)/* wrap if needed */ {  		do {  			r += /*unchecked(*/(int)s.end/*)*/;  			/* force index in window */}  		while (r < 0);  		/* covers invalid distances */e = s.end - (uint)r;  		if (c > e) {  			c -= e;  			/* wrapped copy */do {  				s.window [q++] = s.window [r++];  			}  			while ((--e) != 0);  			r = 0;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  	}  	else/* normal copy */ {  		s.window [q++] = s.window [r++];  		c--;  		s.window [q++] = s.window [r++];  		c--;  		do {  			s.window [q++] = s.window [r++];  		}  		while ((--c) != 0);  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits to add to distance base */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* do the copy */m -= c;  	r = /*unchecked(*/(int)q - (int)d/*)*/;  	if (r < 0)/* wrap if needed */ {  		do {  			r += /*unchecked(*/(int)s.end/*)*/;  			/* force index in window */}  		while (r < 0);  		/* covers invalid distances */e = s.end - (uint)r;  		if (c > e) {  			c -= e;  			/* wrapped copy */do {  				s.window [q++] = s.window [r++];  			}  			while ((--e) != 0);  			r = 0;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  	}  	else/* normal copy */ {  		s.window [q++] = s.window [r++];  		c--;  		s.window [q++] = s.window [r++];  		c--;  		do {  			s.window [q++] = s.window [r++];  		}  		while ((--c) != 0);  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c = new uint[288];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: v = new uint[288];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 144; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 144; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 256; k++)  	c [k] = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 256; k++)  	c [k] = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 280; k++)  	c [k] = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 280; k++)  	c [k] = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 288; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 288; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: fixed_bl = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 30; k++)  	c [k] = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 30; k++)  	c [k] = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: fixed_bd = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The following statement contains a magic number: v = new uint[19];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' ref tb' ref bb' hp' ref hn' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' ref tb' ref bb' hp' ref hn' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The following statement contains a magic number: v = new uint[288];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build (c' 0' nl' 257' cplens' cplext' ref tl' ref bl' hp' ref hn' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != ReturnCode.Z_OK || (bd == 0 && nl > 257)) {  	if (r == ReturnCode.Z_DATA_ERROR)  		z.msg = "oversubscribed distance tree";  	else if (r == ReturnCode.Z_BUF_ERROR) {  		z.msg = "incomplete distance tree";  		r = ReturnCode.Z_DATA_ERROR;  	}  	else if (r != ReturnCode.Z_MEM_ERROR) {  		z.msg = "empty distance tree with lengths";  		r = ReturnCode.Z_DATA_ERROR;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (uint Counter = 0; Counter < 16; Counter++)  	c [Counter] = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: xp = 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = 128 + 64;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = 128 + 64;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,Tree,The following statement contains a magic number: Debug.Assert (static_ltree.Length == (int)XDeflate.Constant.L_CODES + 2' "Array dimension verification failed");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_init,The following statement contains a magic number: s.last_eob_len = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: if (1 + s.last_eob_len + 10 - s.bi_valid < 9) {  	send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  	send_code (s' (int)Constant.END_BLOCK' static_ltree);  	bi_flush (s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: if (1 + s.last_eob_len + 10 - s.bi_valid < 9) {  	send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  	send_code (s' (int)Constant.END_BLOCK' static_ltree);  	bi_flush (s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: if (1 + s.last_eob_len + 10 - s.bi_valid < 9) {  	send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  	send_code (s' (int)Constant.END_BLOCK' static_ltree);  	bi_flush (s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: s.last_eob_len = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,d_code,The following statement contains a magic number: return dist < 256 ? _dist_code [dist] : _dist_code [256 + (dist >> 7)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,d_code,The following statement contains a magic number: return dist < 256 ? _dist_code [dist] : _dist_code [256 + (dist >> 7)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,d_code,The following statement contains a magic number: return dist < 256 ? _dist_code [dist] : _dist_code [256 + (dist >> 7)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,copy_block,The following statement contains a magic number: s.last_eob_len = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,set_data_type,The following statement contains a magic number: while (n < 7)  	bin_freq += s.dyn_ltree [n++].freq_code;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,set_data_type,The following statement contains a magic number: while (n < 128)  	ascii_freq += s.dyn_ltree [n++].freq_code;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,set_data_type,The following statement contains a magic number: s.data_type = (bin_freq > (ascii_freq >> 2) ? DataTypeValue.Z_BINARY : DataTypeValue.Z_ASCII);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (s.opt_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (s.opt_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (s.opt_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (s.static_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (s.static_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (s.static_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = static_lenb = stored_len + 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != null) {  	/* 4: two words for the lengths *//* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                * Otherwise we can't have processed more than WSIZE input bytes since                * the last block flush' because compression would have been                * successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                * transform a block into a stored block.                */_tr_stored_block (s' buf' startindex' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != null) {  	/* 4: two words for the lengths *//* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                * Otherwise we can't have processed more than WSIZE input bytes since                * the last block flush' because compression would have been                * successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                * transform a block into a stored block.                */_tr_stored_block (s' buf' startindex' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != null) {  	/* 4: two words for the lengths *//* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                * Otherwise we can't have processed more than WSIZE input bytes since                * the last block flush' because compression would have been                * successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                * transform a block into a stored block.                */_tr_stored_block (s' buf' startindex' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,_tr_stored_block,The following statement contains a magic number: send_bits (s' ((int)BlockType.STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: s.bi_buf >>= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: s.bi_valid -= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,bi_windup,The following statement contains a magic number: if (s.bi_valid > 8) {  	put_short (s' s.bi_buf);  }  else if (s.bi_valid > 0) {  	put_byte (s' unchecked((byte)s.bi_buf));  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,put_short,The following statement contains a magic number: put_byte (s' unchecked((byte)(w >> 8)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++(s.heap_len)] = (max_code < 2 ? ++max_code : 0);  	tree [node].freq_code = 1;  	s.depth [node] = 0;  	unchecked {  		s.opt_len--;  		if (stree != null)  			s.static_len -= stree [node].dad_len;  	}  	/* node is 0 or 1 so it does not have extra bits */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++(s.heap_len)] = (max_code < 2 ? ++max_code : 0);  	tree [node].freq_code = 1;  	s.depth [node] = 0;  	unchecked {  		s.opt_len--;  		if (stree != null)  			s.static_len -= stree [node].dad_len;  	}  	/* node is 0 or 1 so it does not have extra bits */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap [++(s.heap_len)] = (max_code < 2 ? ++max_code : 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)  	pqdownheap (s' tree' n);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: n = s.heap_len / 2
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: do {  	pqremove (s' tree' ref n);  	/* n = node of least frequency */m = s.heap [(int)Constant.SMALLEST];  	/* m = node of next least frequency */s.heap [--(s.heap_max)] = n;  	/* keep the nodes sorted by frequency */s.heap [--(s.heap_max)] = m;  	/* Create a new node father of n and m */tree [node].freq_code = unchecked((ushort)(tree [n].freq_code + tree [m].freq_code));  	s.depth [node] = (byte)(System.Math.Max (s.depth [n]' s.depth [m]) + 1);  	tree [n].dad_len = tree [m].dad_len = unchecked((ushort)node);  	/* and insert the new node in the heap */s.heap [(int)Constant.SMALLEST] = node++;  	pqdownheap (s' tree' (int)Constant.SMALLEST);  }  while (s.heap_len >= 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = (int)XDeflate.Constant.BL_CODES - 1; max_blindex >= 3; max_blindex--) {  	if (s.bl_tree [bl_order [max_blindex]].dad_len != 0)  		break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: Debug.Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4' "not enough codes");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: Debug.Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4' "not enough codes");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' lcodes - 257' 5);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' lcodes - 257' 5);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' dcodes - 1' 5);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' blcodes - 4' 4);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' blcodes - 4' 4);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++) {  	send_bits (s' s.bl_tree [bl_order [rank]].dad_len' 3);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' s.bl_tree [bl_order [rank]].dad_len' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	/* move one leaf down the tree */s.bl_count [bits + 1] += 2;  	/* move one overflow item as its brother */s.bl_count [max_length]--;  	/* The brother of the overflow item also moves one step up'          * but this does not affect bl_count[max_length]          */overflow -= 2;  }  while (overflow > 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	/* move one leaf down the tree */s.bl_count [bits + 1] += 2;  	/* move one overflow item as its brother */s.bl_count [max_length]--;  	/* The brother of the overflow item also moves one step up'          * but this does not affect bl_count[max_length]          */overflow -= 2;  }  while (overflow > 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count [bits + 1] += 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	s.bl_tree [curlen].freq_code += unchecked((ushort)count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		s.bl_tree [curlen].freq_code++;  	s.bl_tree [(int)Constant.REP_3_6].freq_code++;  }  else if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	s.bl_tree [curlen].freq_code += unchecked((ushort)count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		s.bl_tree [curlen].freq_code++;  	s.bl_tree [(int)Constant.REP_3_6].freq_code++;  }  else if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		s.bl_tree [curlen].freq_code++;  	s.bl_tree [(int)Constant.REP_3_6].freq_code++;  }  else if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: Debug.Assert (count >= 3 && count <= 6' " 3_6?");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: Debug.Assert (count >= 3 && count <= 6' " 3_6?");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 11' 7);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 11' 7);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (level == (int)CompressionLevel.Z_DEFAULT_COMPRESSION)  	level = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: level = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.hash_bits = unchecked((uint)memLevel + 7);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.window = new byte[2 * s.w_size];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.lit_bufsize = unchecked((uint)(1 << (memLevel + 6)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.pending_buf = new byte[s.lit_bufsize * 4];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.pending_buf_size = s.lit_bufsize * 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.l_buf = unchecked((int)((1 + 2) * s.lit_bufsize));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: header |= (level_flags << 6);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.strstart != 0) {  	System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  	putShortMSB (s' strm.adler >> 16);  	putShortMSB (s' strm.adler & 0xffff);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: putShortMSB (s' strm.adler >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: putShortMSB (s' strm.adler >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflateEnd,The following statement contains a magic number: if (status != StreamStatus.INIT_STATE && status != StreamStatus.BUSY_STATE && status != StreamStatus.FINISH_STATE) {  	if (m_adler16 [strm.avail_in % 32] == 0)  		return ReturnCode.Z_INTERNAL_ERROR;  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflateEnd,The following statement contains a magic number: if (m_adler16 [strm.avail_in % 32] == 0)  	return ReturnCode.Z_INTERNAL_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflateParams,The following statement contains a magic number: if (level == (int)CompressionLevel.Z_DEFAULT_COMPRESSION) {  	level = 6;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflateParams,The following statement contains a magic number: level = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflateParams,The following statement contains a magic number: if (level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,lm_init,The following statement contains a magic number: s.window_size = 2 * s.w_size;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,putShortMSB,The following statement contains a magic number: Tree.put_byte (s' unchecked((byte)(b >> 8)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > s.pending_buf_size - 5) {  	max_block_size = s.pending_buf_size - 5;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > s.pending_buf_size - 5) {  	max_block_size = s.pending_buf_size - 5;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_stored,The following statement contains a magic number: max_block_size = s.pending_buf_size - 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: for (; ;) {  	/* Make sure that we always have enough lookahead' except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match' plus MIN_MATCH bytes to insert the          * string following the next match.          */if (s.lookahead < s.min_lookahead) {  		fill_window (s);  		if (s.lookahead < s.min_lookahead && flush == FlushValue.Z_NO_FLUSH) {  			return block_state.need_more;  		}  		if (s.lookahead == 0)  			break;  		/* flush the current block */}  	/* Insert the string window[strstart .. strstart+2] in the          * dictionary' and set hash_head to the head of the hash chain:          */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		INSERT_STRING (s' s.strstart' ref hash_head);  	}  	/* Find the longest match' discarding those <= prev_length.          * At this point we have always match_length < MIN_MATCH          */if (hash_head != 0 && s.strstart - hash_head <= s.max_dist) {  		/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  			s.match_length = longest_match (s' hash_head);  		}  		/* longest_match() sets match_start */}  	if (s.match_length >= (int)Constant.MIN_MATCH) {  		_tr_tally_dist (s' s.strstart - s.match_start' s.match_length - (int)Constant.MIN_MATCH' ref bflush);  		s.lookahead -= s.match_length;  		/* Insert new strings in the hash table only if the match length              * is not too large. This saves time but degrades compression.              */if (s.match_length <= s.max_lazy_match && s.lookahead >= (int)Constant.MIN_MATCH) {  			s.match_length--;  			/* string at strstart already in hash table */do {  				s.strstart++;  				INSERT_STRING (s' s.strstart' ref hash_head);  				/* strstart never exceeds WSIZE-MAX_MATCH' so there are                      * always MIN_MATCH bytes ahead.                      */}  			while (--s.match_length != 0);  			s.strstart++;  		}  		else {  			s.strstart += s.match_length;  			s.match_length = 0;  			s.ins_h = s.window [s.strstart];  			UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  			System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  			/* If lookahead < MIN_MATCH' ins_h is garbage' but it does not                  * matter since it will be recomputed at next deflate call.                  */}  	}  	else {  		/* No match' output a literal byte */_tr_tally_lit (s' s.window [s.strstart]' ref bflush);  		s.lookahead--;  		s.strstart++;  	}  	if (bflush) {  		FLUSH_BLOCK_ONLY (s' false);  		if (s.strm.avail_out == 0) {  			return block_state.need_more;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: if (s.match_length >= (int)Constant.MIN_MATCH) {  	_tr_tally_dist (s' s.strstart - s.match_start' s.match_length - (int)Constant.MIN_MATCH' ref bflush);  	s.lookahead -= s.match_length;  	/* Insert new strings in the hash table only if the match length              * is not too large. This saves time but degrades compression.              */if (s.match_length <= s.max_lazy_match && s.lookahead >= (int)Constant.MIN_MATCH) {  		s.match_length--;  		/* string at strstart already in hash table */do {  			s.strstart++;  			INSERT_STRING (s' s.strstart' ref hash_head);  			/* strstart never exceeds WSIZE-MAX_MATCH' so there are                      * always MIN_MATCH bytes ahead.                      */}  		while (--s.match_length != 0);  		s.strstart++;  	}  	else {  		s.strstart += s.match_length;  		s.match_length = 0;  		s.ins_h = s.window [s.strstart];  		UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  		System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  		/* If lookahead < MIN_MATCH' ins_h is garbage' but it does not                  * matter since it will be recomputed at next deflate call.                  */}  }  else {  	/* No match' output a literal byte */_tr_tally_lit (s' s.window [s.strstart]' ref bflush);  	s.lookahead--;  	s.strstart++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: if (s.match_length <= s.max_lazy_match && s.lookahead >= (int)Constant.MIN_MATCH) {  	s.match_length--;  	/* string at strstart already in hash table */do {  		s.strstart++;  		INSERT_STRING (s' s.strstart' ref hash_head);  		/* strstart never exceeds WSIZE-MAX_MATCH' so there are                      * always MIN_MATCH bytes ahead.                      */}  	while (--s.match_length != 0);  	s.strstart++;  }  else {  	s.strstart += s.match_length;  	s.match_length = 0;  	s.ins_h = s.window [s.strstart];  	UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  	System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  	/* If lookahead < MIN_MATCH' ins_h is garbage' but it does not                  * matter since it will be recomputed at next deflate call.                  */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: for (; ;) {  	/* Make sure that we always have enough lookahead' except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match' plus MIN_MATCH bytes to insert the          * string following the next match.          */if (s.lookahead < s.min_lookahead) {  		fill_window (s);  		if (s.lookahead < s.min_lookahead && flush == FlushValue.Z_NO_FLUSH) {  			return block_state.need_more;  		}  		if (s.lookahead == 0)  			break;  		/* flush the current block */}  	/* Insert the string window[strstart .. strstart+2] in the          * dictionary' and set hash_head to the head of the hash chain:          */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		INSERT_STRING (s' s.strstart' ref hash_head);  	}  	/* Find the longest match' discarding those <= prev_length.          */s.prev_length = s.match_length;  	s.prev_match = s.match_start;  	s.match_length = (int)Constant.MIN_MATCH - 1;  	if (hash_head != 0 && s.prev_length < s.max_lazy_match && unchecked(s.strstart - hash_head) <= s.max_dist) {  		/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  			s.match_length = longest_match (s' hash_head);  		}  		/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  			/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  		}  	}  	/* If there was a match at the previous step and the current          * match is not better' output the previous match:          */if (s.prev_length >= (int)Constant.MIN_MATCH && s.match_length <= s.prev_length) {  		uint max_insert = s.strstart + s.lookahead - (int)Constant.MIN_MATCH;  		/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush);  		/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead' the last two strings are not inserted in              * the hash table.              */s.lookahead -= s.prev_length - 1;  		s.prev_length -= 2;  		do {  			if (++s.strstart <= max_insert) {  				INSERT_STRING (s' s.strstart' ref hash_head);  			}  		}  		while (--s.prev_length != 0);  		s.match_available = 0;  		s.match_length = (int)Constant.MIN_MATCH - 1;  		s.strstart++;  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  			if (s.strm.avail_out == 0)  				return block_state.need_more;  		}  	}  	else if (s.match_available != 0) {  		/* If there was no match at the previous position' output a              * single literal. If there was a match but the current match              * is longer' truncate the previous match to a single literal.              */_tr_tally_lit (s' s.window [s.strstart - 1]' ref bflush);  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  		}  		s.strstart++;  		s.lookahead--;  		if (s.strm.avail_out == 0)  			return block_state.need_more;  	}  	else {  		/* There is no previous match to compare with' wait for              * the next step to decide.              */s.match_available = 1;  		s.strstart++;  		s.lookahead--;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: for (; ;) {  	/* Make sure that we always have enough lookahead' except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match' plus MIN_MATCH bytes to insert the          * string following the next match.          */if (s.lookahead < s.min_lookahead) {  		fill_window (s);  		if (s.lookahead < s.min_lookahead && flush == FlushValue.Z_NO_FLUSH) {  			return block_state.need_more;  		}  		if (s.lookahead == 0)  			break;  		/* flush the current block */}  	/* Insert the string window[strstart .. strstart+2] in the          * dictionary' and set hash_head to the head of the hash chain:          */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		INSERT_STRING (s' s.strstart' ref hash_head);  	}  	/* Find the longest match' discarding those <= prev_length.          */s.prev_length = s.match_length;  	s.prev_match = s.match_start;  	s.match_length = (int)Constant.MIN_MATCH - 1;  	if (hash_head != 0 && s.prev_length < s.max_lazy_match && unchecked(s.strstart - hash_head) <= s.max_dist) {  		/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  			s.match_length = longest_match (s' hash_head);  		}  		/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  			/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  		}  	}  	/* If there was a match at the previous step and the current          * match is not better' output the previous match:          */if (s.prev_length >= (int)Constant.MIN_MATCH && s.match_length <= s.prev_length) {  		uint max_insert = s.strstart + s.lookahead - (int)Constant.MIN_MATCH;  		/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush);  		/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead' the last two strings are not inserted in              * the hash table.              */s.lookahead -= s.prev_length - 1;  		s.prev_length -= 2;  		do {  			if (++s.strstart <= max_insert) {  				INSERT_STRING (s' s.strstart' ref hash_head);  			}  		}  		while (--s.prev_length != 0);  		s.match_available = 0;  		s.match_length = (int)Constant.MIN_MATCH - 1;  		s.strstart++;  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  			if (s.strm.avail_out == 0)  				return block_state.need_more;  		}  	}  	else if (s.match_available != 0) {  		/* If there was no match at the previous position' output a              * single literal. If there was a match but the current match              * is longer' truncate the previous match to a single literal.              */_tr_tally_lit (s' s.window [s.strstart - 1]' ref bflush);  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  		}  		s.strstart++;  		s.lookahead--;  		if (s.strm.avail_out == 0)  			return block_state.need_more;  	}  	else {  		/* There is no previous match to compare with' wait for              * the next step to decide.              */s.match_available = 1;  		s.strstart++;  		s.lookahead--;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: if (hash_head != 0 && s.prev_length < s.max_lazy_match && unchecked(s.strstart - hash_head) <= s.max_dist) {  	/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  		s.match_length = longest_match (s' hash_head);  	}  	/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  		/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  	/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: if (s.prev_length >= (int)Constant.MIN_MATCH && s.match_length <= s.prev_length) {  	uint max_insert = s.strstart + s.lookahead - (int)Constant.MIN_MATCH;  	/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush);  	/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead' the last two strings are not inserted in              * the hash table.              */s.lookahead -= s.prev_length - 1;  	s.prev_length -= 2;  	do {  		if (++s.strstart <= max_insert) {  			INSERT_STRING (s' s.strstart' ref hash_head);  		}  	}  	while (--s.prev_length != 0);  	s.match_available = 0;  	s.match_length = (int)Constant.MIN_MATCH - 1;  	s.strstart++;  	if (bflush) {  		FLUSH_BLOCK_ONLY (s' false);  		if (s.strm.avail_out == 0)  			return block_state.need_more;  	}  }  else if (s.match_available != 0) {  	/* If there was no match at the previous position' output a              * single literal. If there was a match but the current match              * is longer' truncate the previous match to a single literal.              */_tr_tally_lit (s' s.window [s.strstart - 1]' ref bflush);  	if (bflush) {  		FLUSH_BLOCK_ONLY (s' false);  	}  	s.strstart++;  	s.lookahead--;  	if (s.strm.avail_out == 0)  		return block_state.need_more;  }  else {  	/* There is no previous match to compare with' wait for              * the next step to decide.              */s.match_available = 1;  	s.strstart++;  	s.lookahead--;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: s.prev_length -= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: do {  	more = s.window_size - s.lookahead - s.strstart;  	/* Deal with 64K limit: */if (more == 0 && s.strstart == 0 && s.lookahead == 0) {  		more = s.w_size;  	}  	else if (more == unchecked((uint)(-1))) {  		/* Very unlikely' but possible on 16 bit machine if strstart == 0              * and lookahead == 1 (input done one byte at time)              */more--;  		/* If the window is almost full and there is insufficient lookahead'            * move the upper half to the lower one to make room in the upper half.            */}  	else if (s.strstart >= s.w_size + s.max_dist) {  		System.Array.Copy (s.window' unchecked((int)s.w_size)' s.window' 0' unchecked((int)move));  		unchecked {  			s.match_start -= s.w_size;  			s.strstart -= s.w_size;  			/* we now have strstart >= MAX_DIST */s.block_start -= unchecked((int)s.w_size);  		}  		/* Slide the hash table (could be avoided with 32 bit values                at the expense of memory usage). We slide even when level == 0                to keep the hash table consistent if we switch back to level > 0                later. (Using level 0 permanently is not an optimal usage of                zlib' so we don't care about this pathological case.)              */n = s.hash_size;  		p = n;  		do {  			m = s.head [--p];  			s.head [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  		}  		while (--n != 0);  		n = s.w_size;  		p = n;  		do {  			m = s.prev [--p];  			s.prev [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  			/* If n is not on any hash chain' prev[n] is garbage but              * its value will never be used.              */}  		while (--n != 0);  		more += s.w_size;  	}  	if (s.strm.avail_in == 0)  		return;  	/* If there was no sliding:          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&          *    more == window_size - lookahead - strstart          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)          * => more >= window_size - 2*WSIZE + 2          * In the BIG_MEM or MMAP case (not yet supported)'          *   window_size == input_size + MIN_LOOKAHEAD  &&          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.          * Otherwise' window_size == 2*WSIZE so more >= 2.          * If there was sliding' more >= WSIZE. So in all cases' more >= 2.          */System.Diagnostics.Debug.Assert (more >= 2' "more < 2");  	n = unchecked((uint)read_buf (s.strm' s.window' s.strstart + s.lookahead' more));  	s.lookahead += n;  	/* Initialize the hash value now that we have some input: */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		s.ins_h = s.window [s.strstart];  		UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  		System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  	}  	/* If the whole input has less than MIN_MATCH bytes' ins_h is garbage'          * but this is not important since only literal bytes will be emitted.          */}  while (s.lookahead < (int)s.min_lookahead && s.strm.avail_in != 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: do {  	more = s.window_size - s.lookahead - s.strstart;  	/* Deal with 64K limit: */if (more == 0 && s.strstart == 0 && s.lookahead == 0) {  		more = s.w_size;  	}  	else if (more == unchecked((uint)(-1))) {  		/* Very unlikely' but possible on 16 bit machine if strstart == 0              * and lookahead == 1 (input done one byte at time)              */more--;  		/* If the window is almost full and there is insufficient lookahead'            * move the upper half to the lower one to make room in the upper half.            */}  	else if (s.strstart >= s.w_size + s.max_dist) {  		System.Array.Copy (s.window' unchecked((int)s.w_size)' s.window' 0' unchecked((int)move));  		unchecked {  			s.match_start -= s.w_size;  			s.strstart -= s.w_size;  			/* we now have strstart >= MAX_DIST */s.block_start -= unchecked((int)s.w_size);  		}  		/* Slide the hash table (could be avoided with 32 bit values                at the expense of memory usage). We slide even when level == 0                to keep the hash table consistent if we switch back to level > 0                later. (Using level 0 permanently is not an optimal usage of                zlib' so we don't care about this pathological case.)              */n = s.hash_size;  		p = n;  		do {  			m = s.head [--p];  			s.head [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  		}  		while (--n != 0);  		n = s.w_size;  		p = n;  		do {  			m = s.prev [--p];  			s.prev [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  			/* If n is not on any hash chain' prev[n] is garbage but              * its value will never be used.              */}  		while (--n != 0);  		more += s.w_size;  	}  	if (s.strm.avail_in == 0)  		return;  	/* If there was no sliding:          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&          *    more == window_size - lookahead - strstart          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)          * => more >= window_size - 2*WSIZE + 2          * In the BIG_MEM or MMAP case (not yet supported)'          *   window_size == input_size + MIN_LOOKAHEAD  &&          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.          * Otherwise' window_size == 2*WSIZE so more >= 2.          * If there was sliding' more >= WSIZE. So in all cases' more >= 2.          */System.Diagnostics.Debug.Assert (more >= 2' "more < 2");  	n = unchecked((uint)read_buf (s.strm' s.window' s.strstart + s.lookahead' more));  	s.lookahead += n;  	/* Initialize the hash value now that we have some input: */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		s.ins_h = s.window [s.strstart];  		UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  		System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  	}  	/* If the whole input has less than MIN_MATCH bytes' ins_h is garbage'          * but this is not important since only literal bytes will be emitted.          */}  while (s.lookahead < (int)s.min_lookahead && s.strm.avail_in != 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: System.Diagnostics.Debug.Assert (more >= 2' "more < 2");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: if (s.lookahead >= (int)Constant.MIN_MATCH) {  	s.ins_h = s.window [s.strstart];  	UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  	System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,_tr_tally,The following statement contains a magic number: s.pending_buf [s.d_buf + s.last_lit * 2] = unchecked((byte)(dist >> 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,_tr_tally,The following statement contains a magic number: s.pending_buf [s.d_buf + s.last_lit * 2] = unchecked((byte)(dist >> 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,_tr_tally,The following statement contains a magic number: s.pending_buf [s.d_buf + s.last_lit * 2 + 1] = unchecked((byte)(dist & 0xff));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: System.Diagnostics.Debug.Assert (s.hash_bits >= 8 && (s.max_match - 2) % 16 == 0' "Code too clever");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: System.Diagnostics.Debug.Assert (s.hash_bits >= 8 && (s.max_match - 2) % 16 == 0' "Code too clever");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: System.Diagnostics.Debug.Assert (s.hash_bits >= 8 && (s.max_match - 2) % 16 == 0' "Code too clever");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: if (s.prev_length >= s.good_match) {  	chain_length >>= 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: do {  	System.Diagnostics.Debug.Assert (cur_match < s.strstart' "no future");  	match = cur_match;  	/* Skip to next match if the match length cannot increase          * or if the match length is less than 2:          */if (s.window [match + best_len] != scan_end || s.window [match + best_len - 1] != scan_end1 || s.window [match] != s.window [scan] || s.window [++match] != s.window [scan + 1])  		continue;  	/* The check at best_len-1 can be removed because it will be made          * again later. (This heuristic is not always a win.)          * It is not necessary to compare scan[2] and match[2] since they          * are always equal when the other bytes match' given that          * the hash keys are equal and that HASH_BITS >= 8.          */scan += 2;  	match++;  	System.Diagnostics.Debug.Assert (s.window [scan] == s.window [match]' "match[2]?");  	/* We check for insufficient lookahead only every 8th comparison;          * the 256th check will be made at strstart+258.          */do {  	}  	while (s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && scan < strend);  	System.Diagnostics.Debug.Assert (scan <= s.window_size - 1' "wild scan");  	len = unchecked((int)(s.max_match - (strend - scan)));  	scan = strend - s.max_match;  	if (len > best_len) {  		s.match_start = cur_match;  		best_len = len;  		if (len >= nice_match)  			break;  		scan_end1 = s.window [scan + best_len - 1];  		scan_end = s.window [scan + best_len];  	}  }  while ((cur_match = s.prev [cur_match & wmask]) > limit && --chain_length != 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: scan += 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,InflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	InflateEnd (ref z);  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,InflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	InflateEnd (ref z);  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (b != (int)XZLib.Constant.Z_DEFLATED) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "unknown compression method";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if ((z_state.method >> 4) + 8 > z_state.wbits) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "invalid window size";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if ((z_state.method >> 4) + 8 > z_state.wbits) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "invalid window size";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if ((z_state.method >> 4) + 8 > z_state.wbits) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "invalid window size";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (((z_state.method << 8) + b) % 31 != 0) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect header check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (((z_state.method << 8) + b) % 31 != 0) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect header check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (((z_state.method << 8) + b) % 31 != 0) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect header check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (z_state.was != z_state.need) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect data check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: k -= 16;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The following statement contains a magic number: try {  	// If this is the first time we're called  	if (this.m_inputStream == null) {  		// Create a pipe that will act as the input to LZMA  		this.m_inputStream = new CoderInputStream ();  		// Create a memory stream that will receive the decompressed output from LZMA  		this.m_outputStream = new CoderOutputStream (64 * 1024);  		// If we haven't created our encoder  		if (this.m_encoder == null) {  			// Create the encoder  			this.m_encoder = this.CreateCoder ();  		}  		// Start the compress thread  		this.m_compressThread = new Thread (CompressThread);  		this.m_compressThread.Name = "CoderCompress";  		this.m_compressThread.Start ();  	}  	#if !XCEEDCF  	System.Diagnostics.Debug.Assert (this.m_compressThread.IsAlive);  	#endif  	/* Our goal here is to wait for LZMA to process the data we're giving it in this          * pass. As such' we don't need PipeStream.Write() to wait until the other has read          * the data as we have our own signaling system with m_signal UNLESS we're at          * the end of the data or this is the initial read.          *           * We want to wait when we're at the end of data since we need to SignalEndOfData()          * immediately afterwards. */// Unblock LZMA by feeding it data  	this.m_inputStream.Write (buffer' offset' count' true);  	// If we've reached the end of the supplied compressed data  	if (endOfData) {  		// Reflect it in the pipe  		this.m_inputStream.SignalEndOfData (false);  	}  	// Wait until LZMA is stuck without data or is finished  	//this.m_signal.WaitOne();  	// If we've reached the end of the supplied compressed data  	if (endOfData) {  		// Wait for the LZMA thread to exit  		this.m_compressThread.Join ();  		// Clear references to our large objects  		this.m_compressThread = null;  	}  	/* Here' it's safe to manipulate the output stream and other shared data since          * we know that LZMA is stuck waiting for data or has finished the job. */// If an exception has been thrown in the LZMA thread  	if (this.m_exception != null) {  		// Report it  		throw new CompressionException ("LZMA exception. See the InnerException property for details."' this.m_exception);  	}  	lock (this.m_outputStream.SynchronizingObject) {  		if (this.m_outputStream.Length > 0) {  			// Copy the data currently in the output stream to the supplied byte array pointer  			compressed = this.m_outputStream.ToArray ();  			// Truncate the output stream back to empty so we can reuse the space  			this.m_outputStream.SetLength (0);  		}  	}  	return compressed.Length;  }  catch (CompressionException) {  	throw;  }  catch (Exception exception) {  	if (ExceptionFilter.IsPublicException (exception))  		throw;  	throw new CompressionInternalException (exception);  }  
Magic Number,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The following statement contains a magic number: try {  	// If this is the first time we're called  	if (this.m_inputStream == null) {  		// Create a pipe that will act as the input to LZMA  		this.m_inputStream = new CoderInputStream ();  		// Create a memory stream that will receive the decompressed output from LZMA  		this.m_outputStream = new CoderOutputStream (64 * 1024);  		// If we haven't created our encoder  		if (this.m_encoder == null) {  			// Create the encoder  			this.m_encoder = this.CreateCoder ();  		}  		// Start the compress thread  		this.m_compressThread = new Thread (CompressThread);  		this.m_compressThread.Name = "CoderCompress";  		this.m_compressThread.Start ();  	}  	#if !XCEEDCF  	System.Diagnostics.Debug.Assert (this.m_compressThread.IsAlive);  	#endif  	/* Our goal here is to wait for LZMA to process the data we're giving it in this          * pass. As such' we don't need PipeStream.Write() to wait until the other has read          * the data as we have our own signaling system with m_signal UNLESS we're at          * the end of the data or this is the initial read.          *           * We want to wait when we're at the end of data since we need to SignalEndOfData()          * immediately afterwards. */// Unblock LZMA by feeding it data  	this.m_inputStream.Write (buffer' offset' count' true);  	// If we've reached the end of the supplied compressed data  	if (endOfData) {  		// Reflect it in the pipe  		this.m_inputStream.SignalEndOfData (false);  	}  	// Wait until LZMA is stuck without data or is finished  	//this.m_signal.WaitOne();  	// If we've reached the end of the supplied compressed data  	if (endOfData) {  		// Wait for the LZMA thread to exit  		this.m_compressThread.Join ();  		// Clear references to our large objects  		this.m_compressThread = null;  	}  	/* Here' it's safe to manipulate the output stream and other shared data since          * we know that LZMA is stuck waiting for data or has finished the job. */// If an exception has been thrown in the LZMA thread  	if (this.m_exception != null) {  		// Report it  		throw new CompressionException ("LZMA exception. See the InnerException property for details."' this.m_exception);  	}  	lock (this.m_outputStream.SynchronizingObject) {  		if (this.m_outputStream.Length > 0) {  			// Copy the data currently in the output stream to the supplied byte array pointer  			compressed = this.m_outputStream.ToArray ();  			// Truncate the output stream back to empty so we can reuse the space  			this.m_outputStream.SetLength (0);  		}  	}  	return compressed.Length;  }  catch (CompressionException) {  	throw;  }  catch (Exception exception) {  	if (ExceptionFilter.IsPublicException (exception))  		throw;  	throw new CompressionInternalException (exception);  }  
Magic Number,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The following statement contains a magic number: if (this.m_inputStream == null) {  	// Create a pipe that will act as the input to LZMA  	this.m_inputStream = new CoderInputStream ();  	// Create a memory stream that will receive the decompressed output from LZMA  	this.m_outputStream = new CoderOutputStream (64 * 1024);  	// If we haven't created our encoder  	if (this.m_encoder == null) {  		// Create the encoder  		this.m_encoder = this.CreateCoder ();  	}  	// Start the compress thread  	this.m_compressThread = new Thread (CompressThread);  	this.m_compressThread.Name = "CoderCompress";  	this.m_compressThread.Start ();  }  
Magic Number,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The following statement contains a magic number: if (this.m_inputStream == null) {  	// Create a pipe that will act as the input to LZMA  	this.m_inputStream = new CoderInputStream ();  	// Create a memory stream that will receive the decompressed output from LZMA  	this.m_outputStream = new CoderOutputStream (64 * 1024);  	// If we haven't created our encoder  	if (this.m_encoder == null) {  		// Create the encoder  		this.m_encoder = this.CreateCoder ();  	}  	// Start the compress thread  	this.m_compressThread = new Thread (CompressThread);  	this.m_compressThread.Name = "CoderCompress";  	this.m_compressThread.Start ();  }  
Magic Number,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The following statement contains a magic number: this.m_outputStream = new CoderOutputStream (64 * 1024);  
Magic Number,Xceed.Compression.Coder,CoderCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderCompressor.cs,Compress,The following statement contains a magic number: this.m_outputStream = new CoderOutputStream (64 * 1024);  
Magic Number,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The following statement contains a magic number: try {  	// If this is the first time we're called  	if (this.m_inputStream == null) {  		// Create a pipe that will act as the input to the decompressor  		this.m_inputStream = new CoderInputStream ();  		#if DEBUG  		this.m_inputStream.Compress = false;  		#endif  		// Create a memory stream that will receive the decompressed output from the decompressor  		this.m_outputStream = new CoderOutputStream (64 * 1024);  		// If the decoder hasn't been created yet  		if (this.m_decoder == null) {  			// Create the decoder  			this.m_decoder = this.CreateDecoder ();  		}  		// Start the decompression thread  		this.m_decompressThread = new Thread (DecompressThread);  		this.m_decompressThread.Name = "CoderDecompress";  		this.m_decompressThread.Start ();  	}  	#if !XCEEDCF  	System.Diagnostics.Debug.Assert (this.m_decompressThread.IsAlive);  	#endif  	lock (this.m_outputStream.SynchronizingObject) {  		// Increment our supplied data counter  		this.m_suppliedSize += (ulong)count;  	}  	// If the decompressor still wants to process data  	if (!m_endOfData) {  		// If we have data or we know more data will come later  		if (count > 0 || !endOfData) {  			// Supply the data to the decompressor thread' waiting for it to be consumed  			this.m_inputStream.Write (buffer' offset' count' true);  		}  		// If we've been given the very last bytes of the compressed data  		if (endOfData) {  			// Reflect it in the pipe  			this.m_inputStream.SignalEndOfData (false);  		}  	}  	else {  		this.ToString ();  	}  	// If no more data will be supplied or the decompression won't process any more data  	if (endOfData || m_endOfData) {  		// Wait for the decompression thread to exit  		this.m_decompressThread.Join ();  		// Clear references to our large objects  		this.m_decompressThread = null;  	}  	// If an exception has been thrown in the decompressor thread  	if (this.m_exception != null) {  		// Report it  		throw new CompressionException ("Decompression exception. See the InnerException property for details."' this.m_exception);  	}  	lock (this.m_outputStream.SynchronizingObject) {  		// If decompressed data is available  		if (this.m_outputStream.Length > 0) {  			// Copy the data currently in the output stream to the supplied byte array pointer  			decompressed = this.m_outputStream.ToArray ();  			// Truncate the output stream back to empty so we can reuse the space  			this.m_outputStream.SetLength (0);  		}  	}  	// If the decompression thread won't process any more data  	if ((endOfData = this.m_endOfData)) {  		// Calculate the remaining number of bytes  		ulong _remaining = this.m_suppliedSize - this.m_processedSize;  		// If the API can't fit our value  		if (_remaining > int.MaxValue)  			throw new OverflowException ("The remaining data after LZMA compressed data is " + _remaining.ToString () + " bytes' which is larger than an 32-bit integer can take.");  		// Export the number of remaining bytes  		remaining = (int)_remaining;  	}  	else {  		// We don't have remaining data  		remaining = 0;  	}  	return decompressed.Length;  }  catch (CompressionException) {  	throw;  }  catch (Exception exception) {  	if (ExceptionFilter.IsPublicException (exception))  		throw;  	throw new CompressionInternalException (exception);  }  
Magic Number,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The following statement contains a magic number: try {  	// If this is the first time we're called  	if (this.m_inputStream == null) {  		// Create a pipe that will act as the input to the decompressor  		this.m_inputStream = new CoderInputStream ();  		#if DEBUG  		this.m_inputStream.Compress = false;  		#endif  		// Create a memory stream that will receive the decompressed output from the decompressor  		this.m_outputStream = new CoderOutputStream (64 * 1024);  		// If the decoder hasn't been created yet  		if (this.m_decoder == null) {  			// Create the decoder  			this.m_decoder = this.CreateDecoder ();  		}  		// Start the decompression thread  		this.m_decompressThread = new Thread (DecompressThread);  		this.m_decompressThread.Name = "CoderDecompress";  		this.m_decompressThread.Start ();  	}  	#if !XCEEDCF  	System.Diagnostics.Debug.Assert (this.m_decompressThread.IsAlive);  	#endif  	lock (this.m_outputStream.SynchronizingObject) {  		// Increment our supplied data counter  		this.m_suppliedSize += (ulong)count;  	}  	// If the decompressor still wants to process data  	if (!m_endOfData) {  		// If we have data or we know more data will come later  		if (count > 0 || !endOfData) {  			// Supply the data to the decompressor thread' waiting for it to be consumed  			this.m_inputStream.Write (buffer' offset' count' true);  		}  		// If we've been given the very last bytes of the compressed data  		if (endOfData) {  			// Reflect it in the pipe  			this.m_inputStream.SignalEndOfData (false);  		}  	}  	else {  		this.ToString ();  	}  	// If no more data will be supplied or the decompression won't process any more data  	if (endOfData || m_endOfData) {  		// Wait for the decompression thread to exit  		this.m_decompressThread.Join ();  		// Clear references to our large objects  		this.m_decompressThread = null;  	}  	// If an exception has been thrown in the decompressor thread  	if (this.m_exception != null) {  		// Report it  		throw new CompressionException ("Decompression exception. See the InnerException property for details."' this.m_exception);  	}  	lock (this.m_outputStream.SynchronizingObject) {  		// If decompressed data is available  		if (this.m_outputStream.Length > 0) {  			// Copy the data currently in the output stream to the supplied byte array pointer  			decompressed = this.m_outputStream.ToArray ();  			// Truncate the output stream back to empty so we can reuse the space  			this.m_outputStream.SetLength (0);  		}  	}  	// If the decompression thread won't process any more data  	if ((endOfData = this.m_endOfData)) {  		// Calculate the remaining number of bytes  		ulong _remaining = this.m_suppliedSize - this.m_processedSize;  		// If the API can't fit our value  		if (_remaining > int.MaxValue)  			throw new OverflowException ("The remaining data after LZMA compressed data is " + _remaining.ToString () + " bytes' which is larger than an 32-bit integer can take.");  		// Export the number of remaining bytes  		remaining = (int)_remaining;  	}  	else {  		// We don't have remaining data  		remaining = 0;  	}  	return decompressed.Length;  }  catch (CompressionException) {  	throw;  }  catch (Exception exception) {  	if (ExceptionFilter.IsPublicException (exception))  		throw;  	throw new CompressionInternalException (exception);  }  
Magic Number,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The following statement contains a magic number: if (this.m_inputStream == null) {  	// Create a pipe that will act as the input to the decompressor  	this.m_inputStream = new CoderInputStream ();  	#if DEBUG  	this.m_inputStream.Compress = false;  	#endif  	// Create a memory stream that will receive the decompressed output from the decompressor  	this.m_outputStream = new CoderOutputStream (64 * 1024);  	// If the decoder hasn't been created yet  	if (this.m_decoder == null) {  		// Create the decoder  		this.m_decoder = this.CreateDecoder ();  	}  	// Start the decompression thread  	this.m_decompressThread = new Thread (DecompressThread);  	this.m_decompressThread.Name = "CoderDecompress";  	this.m_decompressThread.Start ();  }  
Magic Number,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The following statement contains a magic number: if (this.m_inputStream == null) {  	// Create a pipe that will act as the input to the decompressor  	this.m_inputStream = new CoderInputStream ();  	#if DEBUG  	this.m_inputStream.Compress = false;  	#endif  	// Create a memory stream that will receive the decompressed output from the decompressor  	this.m_outputStream = new CoderOutputStream (64 * 1024);  	// If the decoder hasn't been created yet  	if (this.m_decoder == null) {  		// Create the decoder  		this.m_decoder = this.CreateDecoder ();  	}  	// Start the decompression thread  	this.m_decompressThread = new Thread (DecompressThread);  	this.m_decompressThread.Name = "CoderDecompress";  	this.m_decompressThread.Start ();  }  
Magic Number,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The following statement contains a magic number: this.m_outputStream = new CoderOutputStream (64 * 1024);  
Magic Number,Xceed.Compression.Coder,CoderDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CoderDecompressor.cs,Decompress,The following statement contains a magic number: this.m_outputStream = new CoderOutputStream (64 * 1024);  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,CompressedStream,The following statement contains a magic number: if ((int)method > 127) {  	m_useZlibHeaders = true;  	method = (CompressionMethod)((int)method - 128);  }  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,CompressedStream,The following statement contains a magic number: if ((int)method > 127) {  	m_useZlibHeaders = true;  	method = (CompressionMethod)((int)method - 128);  }  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,CompressedStream,The following statement contains a magic number: method = (CompressionMethod)((int)method - 128);  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,CompressedStream,The following statement contains a magic number: if ((int)level > 127) {  	useDeflateStore = true;  	level = (CompressionLevel)((int)level - 128);  }  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,CompressedStream,The following statement contains a magic number: if ((int)level > 127) {  	useDeflateStore = true;  	level = (CompressionLevel)((int)level - 128);  }  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,CompressedStream,The following statement contains a magic number: level = (CompressionLevel)((int)level - 128);  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,The following statement contains a magic number: try {  	if (m_decompressor == null) {  		#if !COMPRESSEDSTREAM_MINIMAL  		switch (m_compressionMethod) {  		#if !COMPRESSION_NODEFLATE  		case CompressionMethod.Deflated: {  			m_decompressor = new ManagedDeflateDecompressor (m_useZlibHeaders' m_enforceFormatIntegrity);  			break;  		}  		#endif  		#if !COMPRESSION_NODEFLATE64  		case CompressionMethod.Deflated64: {  			m_decompressor = new ManagedDeflate64Decompressor (m_useZlibHeaders' m_enforceFormatIntegrity);  			break;  		}  		#endif  		#if !COMPRESSION_NOBZIP2  		case CompressionMethod.BZip2: {  			m_decompressor = new ManagedBZip2Decompressor ();  			break;  		}  		#endif  		#if !COMPRESSION_NOBWT  		case CompressionMethod.BWT: {  			m_decompressor = new ManagedBZip2Decompressor ((char)1);  			break;  		}  		#endif  		#if !COMPRESSION_NOPPMD  		case CompressionMethod.PPMd:  			this.m_decompressor = SetupPPMdDecompression (this.m_stream);  			break;  		#endif  		#if !COMPRESSION_NOLZMA  		case CompressionMethod.LZMA:  			this.m_decompressor = DecompressorFactory.CreateLzmaDecompressor ();  			break;  		#endif  		default:  			System.Diagnostics.Debug.Assert (false' "Unknown CompressionMethod in delayed initialization");  			throw new CompressionInternalException ("Unknown CompressionMethod value");  		}  		#else  		          throw new CompressionInternalException( "Decompressor not initialized" );           #endif  	}  	int totalRead = 0;  	do {  		if (m_decompressedCount > 0) {  			int decompBytesRead = (count > m_decompressedCount) ? (m_decompressedCount) : (count);  			if (decompBytesRead > 0) {  				Buffer.BlockCopy (m_decompressed' m_decompressedOffset' buffer' offset' decompBytesRead);  				m_decompressedOffset += decompBytesRead;  				m_decompressedCount -= decompBytesRead;  				offset += decompBytesRead;  				count -= decompBytesRead;  				totalRead += decompBytesRead;  				if (m_decompressedCount == 0) {  					m_decompressed = null;  					m_decompressedOffset = 0;  				}  			}  		}  		else if (m_decompressedCount == 0) {  			// No data was provided by decompressor' result m_decompressed buffer  			m_decompressed = null;  		}  		if ((count == 0) || m_endOfData)  			break;  		// If we get here' it's because we have emptied m_decompressed.  		System.Diagnostics.Debug.Assert (m_decompressed == null);  		System.Diagnostics.Debug.Assert (m_decompressedCount == 0);  		// Read data if required  		if (m_compressedCount == 0) {  			m_compressedOffset = 0;  			m_compressedReadCount = m_compressedCount = m_stream.Read (m_compressed' 0' m_compressed.Length);  			m_endOfData = (m_compressedCount == 0);  		}  		// Decompress' but in smaller blocks to avoid decompressing 32kb to gigs!  		// Make sure to call decompressor even if no more compressed data to provide.  		int toDecompress = (m_compressedCount > 1024) ? (1024) : (m_compressedCount);  		int remaining = 0;  		m_decompressedCount = m_decompressor.Decompress (m_compressed' m_compressedOffset' toDecompress' ref m_endOfData' out m_decompressed' out remaining);  		// If we've reached the end of the compressed data  		if (m_endOfData) {  			// Calculate the negative offset inside the last buffer we read where the data ends  			m_remainingOffset = m_compressedOffset + toDecompress - remaining;  			m_remainingOffset = m_remainingOffset - m_compressedReadCount;  		}  		/*           if( remaining > 0 )           {             System.Diagnostics.Debug.Assert( m_endOfData' "Bytes can remain only when in end-of-data condition." );              m_remainingBytes = new byte[ remaining ];              Buffer.BlockCopy( m_compressed' m_compressedOffset + toDecompress - remaining' m_remainingBytes' 0' remaining );           }           */m_compressedOffset += toDecompress;  		m_compressedCount -= toDecompress;  	}  	while (true);  	return totalRead;  }  catch (IOException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,The following statement contains a magic number: try {  	if (m_decompressor == null) {  		#if !COMPRESSEDSTREAM_MINIMAL  		switch (m_compressionMethod) {  		#if !COMPRESSION_NODEFLATE  		case CompressionMethod.Deflated: {  			m_decompressor = new ManagedDeflateDecompressor (m_useZlibHeaders' m_enforceFormatIntegrity);  			break;  		}  		#endif  		#if !COMPRESSION_NODEFLATE64  		case CompressionMethod.Deflated64: {  			m_decompressor = new ManagedDeflate64Decompressor (m_useZlibHeaders' m_enforceFormatIntegrity);  			break;  		}  		#endif  		#if !COMPRESSION_NOBZIP2  		case CompressionMethod.BZip2: {  			m_decompressor = new ManagedBZip2Decompressor ();  			break;  		}  		#endif  		#if !COMPRESSION_NOBWT  		case CompressionMethod.BWT: {  			m_decompressor = new ManagedBZip2Decompressor ((char)1);  			break;  		}  		#endif  		#if !COMPRESSION_NOPPMD  		case CompressionMethod.PPMd:  			this.m_decompressor = SetupPPMdDecompression (this.m_stream);  			break;  		#endif  		#if !COMPRESSION_NOLZMA  		case CompressionMethod.LZMA:  			this.m_decompressor = DecompressorFactory.CreateLzmaDecompressor ();  			break;  		#endif  		default:  			System.Diagnostics.Debug.Assert (false' "Unknown CompressionMethod in delayed initialization");  			throw new CompressionInternalException ("Unknown CompressionMethod value");  		}  		#else  		          throw new CompressionInternalException( "Decompressor not initialized" );           #endif  	}  	int totalRead = 0;  	do {  		if (m_decompressedCount > 0) {  			int decompBytesRead = (count > m_decompressedCount) ? (m_decompressedCount) : (count);  			if (decompBytesRead > 0) {  				Buffer.BlockCopy (m_decompressed' m_decompressedOffset' buffer' offset' decompBytesRead);  				m_decompressedOffset += decompBytesRead;  				m_decompressedCount -= decompBytesRead;  				offset += decompBytesRead;  				count -= decompBytesRead;  				totalRead += decompBytesRead;  				if (m_decompressedCount == 0) {  					m_decompressed = null;  					m_decompressedOffset = 0;  				}  			}  		}  		else if (m_decompressedCount == 0) {  			// No data was provided by decompressor' result m_decompressed buffer  			m_decompressed = null;  		}  		if ((count == 0) || m_endOfData)  			break;  		// If we get here' it's because we have emptied m_decompressed.  		System.Diagnostics.Debug.Assert (m_decompressed == null);  		System.Diagnostics.Debug.Assert (m_decompressedCount == 0);  		// Read data if required  		if (m_compressedCount == 0) {  			m_compressedOffset = 0;  			m_compressedReadCount = m_compressedCount = m_stream.Read (m_compressed' 0' m_compressed.Length);  			m_endOfData = (m_compressedCount == 0);  		}  		// Decompress' but in smaller blocks to avoid decompressing 32kb to gigs!  		// Make sure to call decompressor even if no more compressed data to provide.  		int toDecompress = (m_compressedCount > 1024) ? (1024) : (m_compressedCount);  		int remaining = 0;  		m_decompressedCount = m_decompressor.Decompress (m_compressed' m_compressedOffset' toDecompress' ref m_endOfData' out m_decompressed' out remaining);  		// If we've reached the end of the compressed data  		if (m_endOfData) {  			// Calculate the negative offset inside the last buffer we read where the data ends  			m_remainingOffset = m_compressedOffset + toDecompress - remaining;  			m_remainingOffset = m_remainingOffset - m_compressedReadCount;  		}  		/*           if( remaining > 0 )           {             System.Diagnostics.Debug.Assert( m_endOfData' "Bytes can remain only when in end-of-data condition." );              m_remainingBytes = new byte[ remaining ];              Buffer.BlockCopy( m_compressed' m_compressedOffset + toDecompress - remaining' m_remainingBytes' 0' remaining );           }           */m_compressedOffset += toDecompress;  		m_compressedCount -= toDecompress;  	}  	while (true);  	return totalRead;  }  catch (IOException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,The following statement contains a magic number: do {  	if (m_decompressedCount > 0) {  		int decompBytesRead = (count > m_decompressedCount) ? (m_decompressedCount) : (count);  		if (decompBytesRead > 0) {  			Buffer.BlockCopy (m_decompressed' m_decompressedOffset' buffer' offset' decompBytesRead);  			m_decompressedOffset += decompBytesRead;  			m_decompressedCount -= decompBytesRead;  			offset += decompBytesRead;  			count -= decompBytesRead;  			totalRead += decompBytesRead;  			if (m_decompressedCount == 0) {  				m_decompressed = null;  				m_decompressedOffset = 0;  			}  		}  	}  	else if (m_decompressedCount == 0) {  		// No data was provided by decompressor' result m_decompressed buffer  		m_decompressed = null;  	}  	if ((count == 0) || m_endOfData)  		break;  	// If we get here' it's because we have emptied m_decompressed.  	System.Diagnostics.Debug.Assert (m_decompressed == null);  	System.Diagnostics.Debug.Assert (m_decompressedCount == 0);  	// Read data if required  	if (m_compressedCount == 0) {  		m_compressedOffset = 0;  		m_compressedReadCount = m_compressedCount = m_stream.Read (m_compressed' 0' m_compressed.Length);  		m_endOfData = (m_compressedCount == 0);  	}  	// Decompress' but in smaller blocks to avoid decompressing 32kb to gigs!  	// Make sure to call decompressor even if no more compressed data to provide.  	int toDecompress = (m_compressedCount > 1024) ? (1024) : (m_compressedCount);  	int remaining = 0;  	m_decompressedCount = m_decompressor.Decompress (m_compressed' m_compressedOffset' toDecompress' ref m_endOfData' out m_decompressed' out remaining);  	// If we've reached the end of the compressed data  	if (m_endOfData) {  		// Calculate the negative offset inside the last buffer we read where the data ends  		m_remainingOffset = m_compressedOffset + toDecompress - remaining;  		m_remainingOffset = m_remainingOffset - m_compressedReadCount;  	}  	/*           if( remaining > 0 )           {             System.Diagnostics.Debug.Assert( m_endOfData' "Bytes can remain only when in end-of-data condition." );              m_remainingBytes = new byte[ remaining ];              Buffer.BlockCopy( m_compressed' m_compressedOffset + toDecompress - remaining' m_remainingBytes' 0' remaining );           }           */m_compressedOffset += toDecompress;  	m_compressedCount -= toDecompress;  }  while (true);  
Magic Number,Xceed.Compression,CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\CompressedStream.cs,Read,The following statement contains a magic number: do {  	if (m_decompressedCount > 0) {  		int decompBytesRead = (count > m_decompressedCount) ? (m_decompressedCount) : (count);  		if (decompBytesRead > 0) {  			Buffer.BlockCopy (m_decompressed' m_decompressedOffset' buffer' offset' decompBytesRead);  			m_decompressedOffset += decompBytesRead;  			m_decompressedCount -= decompBytesRead;  			offset += decompBytesRead;  			count -= decompBytesRead;  			totalRead += decompBytesRead;  			if (m_decompressedCount == 0) {  				m_decompressed = null;  				m_decompressedOffset = 0;  			}  		}  	}  	else if (m_decompressedCount == 0) {  		// No data was provided by decompressor' result m_decompressed buffer  		m_decompressed = null;  	}  	if ((count == 0) || m_endOfData)  		break;  	// If we get here' it's because we have emptied m_decompressed.  	System.Diagnostics.Debug.Assert (m_decompressed == null);  	System.Diagnostics.Debug.Assert (m_decompressedCount == 0);  	// Read data if required  	if (m_compressedCount == 0) {  		m_compressedOffset = 0;  		m_compressedReadCount = m_compressedCount = m_stream.Read (m_compressed' 0' m_compressed.Length);  		m_endOfData = (m_compressedCount == 0);  	}  	// Decompress' but in smaller blocks to avoid decompressing 32kb to gigs!  	// Make sure to call decompressor even if no more compressed data to provide.  	int toDecompress = (m_compressedCount > 1024) ? (1024) : (m_compressedCount);  	int remaining = 0;  	m_decompressedCount = m_decompressor.Decompress (m_compressed' m_compressedOffset' toDecompress' ref m_endOfData' out m_decompressed' out remaining);  	// If we've reached the end of the compressed data  	if (m_endOfData) {  		// Calculate the negative offset inside the last buffer we read where the data ends  		m_remainingOffset = m_compressedOffset + toDecompress - remaining;  		m_remainingOffset = m_remainingOffset - m_compressedReadCount;  	}  	/*           if( remaining > 0 )           {             System.Diagnostics.Debug.Assert( m_endOfData' "Bytes can remain only when in end-of-data condition." );              m_remainingBytes = new byte[ remaining ];              Buffer.BlockCopy( m_compressed' m_compressedOffset + toDecompress - remaining' m_remainingBytes' 0' remaining );           }           */m_compressedOffset += toDecompress;  	m_compressedCount -= toDecompress;  }  while (true);  
Magic Number,Xceed.Compression,ManagedLzmaCompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaCompressorUnsafe.cs,OnCoding,The following statement contains a magic number: if (this.m_headerType == LZMAHeaderType.Zip) {  	/* LZMA Version Information 2 bytes          * This field identifies which version of           * the LZMA SDK was used to compress a file.  The first byte will           * store the major version number of the LZMA SDK and the second           * byte will store the minor number. */outputStream.WriteByte (9);  	outputStream.WriteByte (20);  	/* LZMA Properties Size 2 bytes          * This field defines the size of the remaining           * property data.  Typically this size should be determined by the           * version of the SDK.  This size field is included as a convenience          * and to help avoid any ambiguity should it arise in the future due          * to changes in this compression algorithm.          *           * It is possible that this layout may be          * changed by the author over time.  The data layout in version 9.20           * of the LZMA SDK defines a 5 byte array. */ushort propertiesSize = LzmaPropertiesSize;  	outputStream.Write (BitConverter.GetBytes (propertiesSize)' 0' 2);  }  
Magic Number,Xceed.Compression,ManagedLzmaCompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaCompressorUnsafe.cs,OnCoding,The following statement contains a magic number: if (this.m_headerType == LZMAHeaderType.Zip) {  	/* LZMA Version Information 2 bytes          * This field identifies which version of           * the LZMA SDK was used to compress a file.  The first byte will           * store the major version number of the LZMA SDK and the second           * byte will store the minor number. */outputStream.WriteByte (9);  	outputStream.WriteByte (20);  	/* LZMA Properties Size 2 bytes          * This field defines the size of the remaining           * property data.  Typically this size should be determined by the           * version of the SDK.  This size field is included as a convenience          * and to help avoid any ambiguity should it arise in the future due          * to changes in this compression algorithm.          *           * It is possible that this layout may be          * changed by the author over time.  The data layout in version 9.20           * of the LZMA SDK defines a 5 byte array. */ushort propertiesSize = LzmaPropertiesSize;  	outputStream.Write (BitConverter.GetBytes (propertiesSize)' 0' 2);  }  
Magic Number,Xceed.Compression,ManagedLzmaCompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaCompressorUnsafe.cs,OnCoding,The following statement contains a magic number: if (this.m_headerType == LZMAHeaderType.Zip) {  	/* LZMA Version Information 2 bytes          * This field identifies which version of           * the LZMA SDK was used to compress a file.  The first byte will           * store the major version number of the LZMA SDK and the second           * byte will store the minor number. */outputStream.WriteByte (9);  	outputStream.WriteByte (20);  	/* LZMA Properties Size 2 bytes          * This field defines the size of the remaining           * property data.  Typically this size should be determined by the           * version of the SDK.  This size field is included as a convenience          * and to help avoid any ambiguity should it arise in the future due          * to changes in this compression algorithm.          *           * It is possible that this layout may be          * changed by the author over time.  The data layout in version 9.20           * of the LZMA SDK defines a 5 byte array. */ushort propertiesSize = LzmaPropertiesSize;  	outputStream.Write (BitConverter.GetBytes (propertiesSize)' 0' 2);  }  
Magic Number,Xceed.Compression,ManagedLzmaCompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaCompressorUnsafe.cs,OnCoding,The following statement contains a magic number: outputStream.WriteByte (9);  
Magic Number,Xceed.Compression,ManagedLzmaCompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaCompressorUnsafe.cs,OnCoding,The following statement contains a magic number: outputStream.WriteByte (20);  
Magic Number,Xceed.Compression,ManagedLzmaCompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaCompressorUnsafe.cs,OnCoding,The following statement contains a magic number: outputStream.Write (BitConverter.GetBytes (propertiesSize)' 0' 2);  
Magic Number,Xceed.Compression,ManagedLzmaDecompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaDecompressorUnsafe.cs,OnDecoding,The following statement contains a magic number: if (this.m_headerType == LZMAHeaderType.Zip) {  	data = new byte[LzmaZipHeaderSize];  	/* LZMA Version Information 2 bytes          * This field identifies which version of           * the LZMA SDK was used to compress a file.  The first byte will           * store the major version number of the LZMA SDK and the second           * byte will store the minor number. *//* LZMA Properties Size 2 bytes          * This field defines the size of the remaining           * property data.  Typically this size should be determined by the           * version of the SDK.  This size field is included as a convenience          * and to help avoid any ambiguity should it arise in the future due          * to changes in this compression algorithm.          *           * It is possible that this layout may be          * changed by the author over time.  The data layout in version 9.20           * of the LZMA SDK defines a 5 byte array. */length = this.Read (inputStream' data' 0' LzmaZipHeaderSize);  	System.Diagnostics.Debug.Assert (length == LzmaZipHeaderSize);  	suppliedDataCount += LzmaZipHeaderSize;  	byte majorVersion = data [0];  	byte minorVersion = data [1];  	propertiesSize = BitConverter.ToUInt16 (data' 2);  	// If the LZMA version is higher than 9.x  	if (majorVersion > 9) {  		// We don't know about that version  		throw new NotSupportedException (String.Format ("LZMA version {0}.{1} is not supported."' majorVersion' minorVersion));  	}  }  else {  	propertiesSize = LzmaPropertiesSize;  }  
Magic Number,Xceed.Compression,ManagedLzmaDecompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaDecompressorUnsafe.cs,OnDecoding,The following statement contains a magic number: if (this.m_headerType == LZMAHeaderType.Zip) {  	data = new byte[LzmaZipHeaderSize];  	/* LZMA Version Information 2 bytes          * This field identifies which version of           * the LZMA SDK was used to compress a file.  The first byte will           * store the major version number of the LZMA SDK and the second           * byte will store the minor number. *//* LZMA Properties Size 2 bytes          * This field defines the size of the remaining           * property data.  Typically this size should be determined by the           * version of the SDK.  This size field is included as a convenience          * and to help avoid any ambiguity should it arise in the future due          * to changes in this compression algorithm.          *           * It is possible that this layout may be          * changed by the author over time.  The data layout in version 9.20           * of the LZMA SDK defines a 5 byte array. */length = this.Read (inputStream' data' 0' LzmaZipHeaderSize);  	System.Diagnostics.Debug.Assert (length == LzmaZipHeaderSize);  	suppliedDataCount += LzmaZipHeaderSize;  	byte majorVersion = data [0];  	byte minorVersion = data [1];  	propertiesSize = BitConverter.ToUInt16 (data' 2);  	// If the LZMA version is higher than 9.x  	if (majorVersion > 9) {  		// We don't know about that version  		throw new NotSupportedException (String.Format ("LZMA version {0}.{1} is not supported."' majorVersion' minorVersion));  	}  }  else {  	propertiesSize = LzmaPropertiesSize;  }  
Magic Number,Xceed.Compression,ManagedLzmaDecompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaDecompressorUnsafe.cs,OnDecoding,The following statement contains a magic number: propertiesSize = BitConverter.ToUInt16 (data' 2);  
Magic Number,Xceed.Compression,ManagedLzmaDecompressorUnsafe,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedLzmaDecompressorUnsafe.cs,OnDecoding,The following statement contains a magic number: if (majorVersion > 9) {  	// We don't know about that version  	throw new NotSupportedException (String.Format ("LZMA version {0}.{1} is not supported."' majorVersion' minorVersion));  }  
Magic Number,Xceed.Compression,ManagedPPMdDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdDecompressor.cs,ReadPPMdZipHeader,The following statement contains a magic number: allocatorSize = value >> 4;  
Magic Number,Xceed.Compression,ManagedPPMdDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdDecompressor.cs,ReadPPMdZipHeader,The following statement contains a magic number: allocatorSize = ((value << 4) | allocatorSize) + 1;  
Magic Number,Xceed.Compression,ManagedPPMdDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdDecompressor.cs,ReadPPMdZipHeader,The following statement contains a magic number: method = (Xceed.Compression.PPMd.ModelRestorationMethod)(value >> 4);  
Magic Number,Xceed.Compression,ManagedPPMdCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdCompressor.cs,WritePPMdZipHeader,The following statement contains a magic number: value = (byte)(allocatorSize << 4 | modelOrder);  
Magic Number,Xceed.Compression,ManagedPPMdCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdCompressor.cs,WritePPMdZipHeader,The following statement contains a magic number: value = (byte)((byte)method << 4 | allocatorSize >> 4);  
Magic Number,Xceed.Compression,ManagedPPMdCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedPPMdCompressor.cs,WritePPMdZipHeader,The following statement contains a magic number: value = (byte)((byte)method << 4 | allocatorSize >> 4);  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_bzstream.next_in = buffer;  		m_bzstream.next_in_index = unchecked((uint)offset);  		m_bzstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_bzstream.next_in = null;  		m_bzstream.next_in_index = 0;  		m_bzstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	ulong currentTotalOut = m_bzstream.total_out;  	BZLib.BZReturnValue bzipRet = BZLib.BZReturnValue.BZ_FINISH_OK;  	if (endOfData) {  		do {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			if (m_compressionBuffer.Length < OutSize) {  				byte[] newBuffer = new Byte[OutSize];  				m_compressionBuffer.CopyTo (newBuffer' 0);  				m_compressionBuffer = newBuffer;  			}  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  		}  		while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  		if (bzipRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			// normal termination   			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		}  		else if (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK) {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Out of compressor buffer");  		}  		else {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	else {  		BZLib.BZActions compressAction = BZLib.BZActions.BZ_RUN;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			compressAction = BZLib.BZActions.BZ_FLUSH;  		}  		do {  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  			if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  				OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  				if (m_compressionBuffer.Length < OutSize) {  					byte[] newBuffer = new Byte[OutSize];  					m_compressionBuffer.CopyTo (newBuffer' 0);  					m_compressionBuffer = newBuffer;  				}  			}  		}  		while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  		if (bzipRet == BZLib.BZReturnValue.BZ_RUN_OK || bzipRet == BZLib.BZReturnValue.BZ_FLUSH_OK) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return (int)OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_bzstream.next_in = buffer;  		m_bzstream.next_in_index = unchecked((uint)offset);  		m_bzstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_bzstream.next_in = null;  		m_bzstream.next_in_index = 0;  		m_bzstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	ulong currentTotalOut = m_bzstream.total_out;  	BZLib.BZReturnValue bzipRet = BZLib.BZReturnValue.BZ_FINISH_OK;  	if (endOfData) {  		do {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			if (m_compressionBuffer.Length < OutSize) {  				byte[] newBuffer = new Byte[OutSize];  				m_compressionBuffer.CopyTo (newBuffer' 0);  				m_compressionBuffer = newBuffer;  			}  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  		}  		while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  		if (bzipRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			// normal termination   			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		}  		else if (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK) {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Out of compressor buffer");  		}  		else {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	else {  		BZLib.BZActions compressAction = BZLib.BZActions.BZ_RUN;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			compressAction = BZLib.BZActions.BZ_FLUSH;  		}  		do {  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  			if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  				OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  				if (m_compressionBuffer.Length < OutSize) {  					byte[] newBuffer = new Byte[OutSize];  					m_compressionBuffer.CopyTo (newBuffer' 0);  					m_compressionBuffer = newBuffer;  				}  			}  		}  		while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  		if (bzipRet == BZLib.BZReturnValue.BZ_RUN_OK || bzipRet == BZLib.BZReturnValue.BZ_FLUSH_OK) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return (int)OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_bzstream.next_in = buffer;  		m_bzstream.next_in_index = unchecked((uint)offset);  		m_bzstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_bzstream.next_in = null;  		m_bzstream.next_in_index = 0;  		m_bzstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	ulong currentTotalOut = m_bzstream.total_out;  	BZLib.BZReturnValue bzipRet = BZLib.BZReturnValue.BZ_FINISH_OK;  	if (endOfData) {  		do {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			if (m_compressionBuffer.Length < OutSize) {  				byte[] newBuffer = new Byte[OutSize];  				m_compressionBuffer.CopyTo (newBuffer' 0);  				m_compressionBuffer = newBuffer;  			}  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  		}  		while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  		if (bzipRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			// normal termination   			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		}  		else if (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK) {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Out of compressor buffer");  		}  		else {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	else {  		BZLib.BZActions compressAction = BZLib.BZActions.BZ_RUN;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			compressAction = BZLib.BZActions.BZ_FLUSH;  		}  		do {  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  			if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  				OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  				if (m_compressionBuffer.Length < OutSize) {  					byte[] newBuffer = new Byte[OutSize];  					m_compressionBuffer.CopyTo (newBuffer' 0);  					m_compressionBuffer = newBuffer;  				}  			}  		}  		while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  		if (bzipRet == BZLib.BZReturnValue.BZ_RUN_OK || bzipRet == BZLib.BZReturnValue.BZ_FLUSH_OK) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return (int)OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_bzstream.next_in = buffer;  		m_bzstream.next_in_index = unchecked((uint)offset);  		m_bzstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_bzstream.next_in = null;  		m_bzstream.next_in_index = 0;  		m_bzstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	ulong currentTotalOut = m_bzstream.total_out;  	BZLib.BZReturnValue bzipRet = BZLib.BZReturnValue.BZ_FINISH_OK;  	if (endOfData) {  		do {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			if (m_compressionBuffer.Length < OutSize) {  				byte[] newBuffer = new Byte[OutSize];  				m_compressionBuffer.CopyTo (newBuffer' 0);  				m_compressionBuffer = newBuffer;  			}  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  		}  		while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  		if (bzipRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			// normal termination   			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		}  		else if (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK) {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Out of compressor buffer");  		}  		else {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	else {  		BZLib.BZActions compressAction = BZLib.BZActions.BZ_RUN;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			compressAction = BZLib.BZActions.BZ_FLUSH;  		}  		do {  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  			if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  				OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  				if (m_compressionBuffer.Length < OutSize) {  					byte[] newBuffer = new Byte[OutSize];  					m_compressionBuffer.CopyTo (newBuffer' 0);  					m_compressionBuffer = newBuffer;  				}  			}  		}  		while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  		if (bzipRet == BZLib.BZReturnValue.BZ_RUN_OK || bzipRet == BZLib.BZReturnValue.BZ_FLUSH_OK) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return (int)OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_bzstream.next_in = buffer;  		m_bzstream.next_in_index = unchecked((uint)offset);  		m_bzstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_bzstream.next_in = null;  		m_bzstream.next_in_index = 0;  		m_bzstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	ulong currentTotalOut = m_bzstream.total_out;  	BZLib.BZReturnValue bzipRet = BZLib.BZReturnValue.BZ_FINISH_OK;  	if (endOfData) {  		do {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			if (m_compressionBuffer.Length < OutSize) {  				byte[] newBuffer = new Byte[OutSize];  				m_compressionBuffer.CopyTo (newBuffer' 0);  				m_compressionBuffer = newBuffer;  			}  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  		}  		while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  		if (bzipRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			// normal termination   			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		}  		else if (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK) {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Out of compressor buffer");  		}  		else {  			BZLib.BZ2_bzCompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	else {  		BZLib.BZActions compressAction = BZLib.BZActions.BZ_RUN;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			compressAction = BZLib.BZActions.BZ_FLUSH;  		}  		do {  			m_bzstream.next_out = m_compressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  			if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  				OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  				if (m_compressionBuffer.Length < OutSize) {  					byte[] newBuffer = new Byte[OutSize];  					m_compressionBuffer.CopyTo (newBuffer' 0);  					m_compressionBuffer = newBuffer;  				}  			}  		}  		while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  		if (bzipRet == BZLib.BZReturnValue.BZ_RUN_OK || bzipRet == BZLib.BZReturnValue.BZ_FLUSH_OK) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return (int)OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: if (count > 0) {  	OutSize = count + count / 9 + 12;  	m_bzstream.next_in = buffer;  	m_bzstream.next_in_index = unchecked((uint)offset);  	m_bzstream.avail_in = unchecked((uint)count);  }  else {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	m_bzstream.next_in = null;  	m_bzstream.next_in_index = 0;  	m_bzstream.avail_in = 0;  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: if (count > 0) {  	OutSize = count + count / 9 + 12;  	m_bzstream.next_in = buffer;  	m_bzstream.next_in_index = unchecked((uint)offset);  	m_bzstream.avail_in = unchecked((uint)count);  }  else {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	m_bzstream.next_in = null;  	m_bzstream.next_in_index = 0;  	m_bzstream.avail_in = 0;  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: if (count > 0) {  	OutSize = count + count / 9 + 12;  	m_bzstream.next_in = buffer;  	m_bzstream.next_in_index = unchecked((uint)offset);  	m_bzstream.avail_in = unchecked((uint)count);  }  else {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	m_bzstream.next_in = null;  	m_bzstream.next_in_index = 0;  	m_bzstream.avail_in = 0;  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: OutSize = count + count / 9 + 12;  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: OutSize = count + count / 9 + 12;  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: if (endOfData) {  	do {  		OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  		if (m_compressionBuffer.Length < OutSize) {  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  		}  		m_bzstream.next_out = m_compressionBuffer;  		m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  		m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  		bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  	}  	while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  	if (bzipRet == BZLib.BZReturnValue.BZ_STREAM_END) {  		// normal termination   		OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		BZLib.BZ2_bzCompressEnd (ref m_bzstream);  	}  	else if (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK) {  		BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		throw new CompressionException ("BZIP2: Out of compressor buffer");  	}  	else {  		BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		throw new CompressionException ("BZIP2: Expected end of stream not found");  	}  }  else {  	BZLib.BZActions compressAction = BZLib.BZActions.BZ_RUN;  	m_flushCalled = false;  	if (count == 0) {  		m_flushCalled = true;  		compressAction = BZLib.BZActions.BZ_FLUSH;  	}  	do {  		m_bzstream.next_out = m_compressionBuffer;  		m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  		m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  		bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  		if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			if (m_compressionBuffer.Length < OutSize) {  				byte[] newBuffer = new Byte[OutSize];  				m_compressionBuffer.CopyTo (newBuffer' 0);  				m_compressionBuffer = newBuffer;  			}  		}  	}  	while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  	if (bzipRet == BZLib.BZReturnValue.BZ_RUN_OK || bzipRet == BZLib.BZReturnValue.BZ_FLUSH_OK) {  		OutSize = (int)(m_bzstream.total_out - currentTotalOut);  	}  	else {  		throw new CompressionException ("BZIP2: Expected end of stream not found");  	}  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: if (endOfData) {  	do {  		OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  		if (m_compressionBuffer.Length < OutSize) {  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  		}  		m_bzstream.next_out = m_compressionBuffer;  		m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  		m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  		bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  	}  	while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  	if (bzipRet == BZLib.BZReturnValue.BZ_STREAM_END) {  		// normal termination   		OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		BZLib.BZ2_bzCompressEnd (ref m_bzstream);  	}  	else if (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK) {  		BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		throw new CompressionException ("BZIP2: Out of compressor buffer");  	}  	else {  		BZLib.BZ2_bzCompressEnd (ref m_bzstream);  		throw new CompressionException ("BZIP2: Expected end of stream not found");  	}  }  else {  	BZLib.BZActions compressAction = BZLib.BZActions.BZ_RUN;  	m_flushCalled = false;  	if (count == 0) {  		m_flushCalled = true;  		compressAction = BZLib.BZActions.BZ_FLUSH;  	}  	do {  		m_bzstream.next_out = m_compressionBuffer;  		m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  		m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  		bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  		if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			if (m_compressionBuffer.Length < OutSize) {  				byte[] newBuffer = new Byte[OutSize];  				m_compressionBuffer.CopyTo (newBuffer' 0);  				m_compressionBuffer = newBuffer;  			}  		}  	}  	while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  	if (bzipRet == BZLib.BZReturnValue.BZ_RUN_OK || bzipRet == BZLib.BZReturnValue.BZ_FLUSH_OK) {  		OutSize = (int)(m_bzstream.total_out - currentTotalOut);  	}  	else {  		throw new CompressionException ("BZIP2: Expected end of stream not found");  	}  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: do {  	OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  	if (m_compressionBuffer.Length < OutSize) {  		byte[] newBuffer = new Byte[OutSize];  		m_compressionBuffer.CopyTo (newBuffer' 0);  		m_compressionBuffer = newBuffer;  	}  	m_bzstream.next_out = m_compressionBuffer;  	m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  	m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  	bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' BZLib.BZActions.BZ_FINISH);  }  while (bzipRet == BZLib.BZReturnValue.BZ_FINISH_OK);  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: do {  	m_bzstream.next_out = m_compressionBuffer;  	m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  	m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  	bzipRet = BZLib.BZ2_bzCompress (ref m_bzstream' compressAction);  	if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  		OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  		if (m_compressionBuffer.Length < OutSize) {  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  		}  	}  }  while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0) || BZLib.BZReturnValue.BZ_FLUSH_OK == bzipRet);  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: if ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in != 0)) {  	OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  	if (m_compressionBuffer.Length < OutSize) {  		byte[] newBuffer = new Byte[OutSize];  		m_compressionBuffer.CopyTo (newBuffer' 0);  		m_compressionBuffer = newBuffer;  	}  }  
Magic Number,Xceed.Compression,ManagedBZip2Compressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Compressor.cs,Compress,The following statement contains a magic number: OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The following statement contains a magic number: try {  	OutSize = count * 2;  	m_bzstream.next_in = buffer;  	m_bzstream.next_in_index = unchecked((uint)offset);  	m_bzstream.avail_in = unchecked((uint)count);  	if (count == 0) {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	}  	if (m_decompressionBuffer == null || m_decompressionBuffer.Length < OutSize) {  		m_decompressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_decompressionBuffer.Length;  	}  	m_bzstream.next_out = m_decompressionBuffer;  	m_bzstream.next_out_index = 0;  	m_bzstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_bzstream.total_out;  	if (endOfData) {  		byte[] TempNextIn = new byte[count + 1];  		if (count > 0)  			System.Array.Copy (buffer' offset' TempNextIn' 0' count);  		m_bzstream.next_in = TempNextIn;  		m_bzstream.next_in_index = 0;  		m_bzstream.avail_in = unchecked((uint)count + 1);  		BZLib.BZReturnValue BZRet = BZLib.BZ2_bzDecompress (ref m_bzstream);  		while ((BZRet == BZLib.BZReturnValue.BZ_OK) || (BZRet == BZLib.BZReturnValue.BZ_OUTBUFF_FULL)) {  			m_bzstream.next_out = m_decompressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			ulong totalOut = m_bzstream.total_out;  			BZRet = BZLib.BZ2_bzDecompress (ref m_bzstream);  			if (totalOut == m_bzstream.total_out) {  				BZRet = BZLib.BZReturnValue.BZ_STREAM_END;  			}  			else if (m_bzstream.avail_in != 0) {  				// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  				// After that' we increment by 0x8000000 (128 megs).  				OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  				byte[] newBuffer = new Byte[OutSize];  				m_decompressionBuffer.CopyTo (newBuffer' 0);  				m_decompressionBuffer = newBuffer;  			}  		}  		// Undo added extra byte  		//                    m_bzstream.avail_in--;  		if (BZRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			BZLib.BZ2_bzDecompressEnd (ref m_bzstream);  		}  		else {  			BZLib.BZ2_bzDecompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	else {  		BZLib.BZReturnValue BZRet;  		do {  			m_bzstream.next_out = m_decompressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			BZRet = BZLib.BZ2_bzDecompress (ref m_bzstream);  			if (m_bzstream.avail_in != 0) {  				// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  				// After that' we increment by 0x8000000 (128 megs).  				OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  				byte[] newBuffer = new Byte[OutSize];  				m_decompressionBuffer.CopyTo (newBuffer' 0);  				m_decompressionBuffer = newBuffer;  			}  		}  		while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in > 0) && BZRet == BZLib.BZReturnValue.BZ_OK);  		if (BZRet == BZLib.BZReturnValue.BZ_OK) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		}  		else if (BZRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			endOfData = true;  		}  		else {  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	if (OutSize > 0) {  		decompressed = m_decompressionBuffer;  	}  	else {  		decompressed = null;  	}  	remaining = (int)m_bzstream.avail_in;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The following statement contains a magic number: try {  	OutSize = count * 2;  	m_bzstream.next_in = buffer;  	m_bzstream.next_in_index = unchecked((uint)offset);  	m_bzstream.avail_in = unchecked((uint)count);  	if (count == 0) {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	}  	if (m_decompressionBuffer == null || m_decompressionBuffer.Length < OutSize) {  		m_decompressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_decompressionBuffer.Length;  	}  	m_bzstream.next_out = m_decompressionBuffer;  	m_bzstream.next_out_index = 0;  	m_bzstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_bzstream.total_out;  	if (endOfData) {  		byte[] TempNextIn = new byte[count + 1];  		if (count > 0)  			System.Array.Copy (buffer' offset' TempNextIn' 0' count);  		m_bzstream.next_in = TempNextIn;  		m_bzstream.next_in_index = 0;  		m_bzstream.avail_in = unchecked((uint)count + 1);  		BZLib.BZReturnValue BZRet = BZLib.BZ2_bzDecompress (ref m_bzstream);  		while ((BZRet == BZLib.BZReturnValue.BZ_OK) || (BZRet == BZLib.BZReturnValue.BZ_OUTBUFF_FULL)) {  			m_bzstream.next_out = m_decompressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			ulong totalOut = m_bzstream.total_out;  			BZRet = BZLib.BZ2_bzDecompress (ref m_bzstream);  			if (totalOut == m_bzstream.total_out) {  				BZRet = BZLib.BZReturnValue.BZ_STREAM_END;  			}  			else if (m_bzstream.avail_in != 0) {  				// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  				// After that' we increment by 0x8000000 (128 megs).  				OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  				byte[] newBuffer = new Byte[OutSize];  				m_decompressionBuffer.CopyTo (newBuffer' 0);  				m_decompressionBuffer = newBuffer;  			}  		}  		// Undo added extra byte  		//                    m_bzstream.avail_in--;  		if (BZRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			BZLib.BZ2_bzDecompressEnd (ref m_bzstream);  		}  		else {  			BZLib.BZ2_bzDecompressEnd (ref m_bzstream);  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	else {  		BZLib.BZReturnValue BZRet;  		do {  			m_bzstream.next_out = m_decompressionBuffer;  			m_bzstream.next_out_index = (uint)(m_bzstream.total_out - currentTotalOut);  			m_bzstream.avail_out = (uint)OutSize - (uint)(m_bzstream.total_out - currentTotalOut);  			BZRet = BZLib.BZ2_bzDecompress (ref m_bzstream);  			if (m_bzstream.avail_in != 0) {  				// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  				// After that' we increment by 0x8000000 (128 megs).  				OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  				byte[] newBuffer = new Byte[OutSize];  				m_decompressionBuffer.CopyTo (newBuffer' 0);  				m_decompressionBuffer = newBuffer;  			}  		}  		while ((m_bzstream.avail_out == 0) && (m_bzstream.avail_in > 0) && BZRet == BZLib.BZReturnValue.BZ_OK);  		if (BZRet == BZLib.BZReturnValue.BZ_OK) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  		}  		else if (BZRet == BZLib.BZReturnValue.BZ_STREAM_END) {  			OutSize = (int)(m_bzstream.total_out - currentTotalOut);  			endOfData = true;  		}  		else {  			throw new CompressionException ("BZIP2: Expected end of stream not found");  		}  	}  	if (OutSize > 0) {  		decompressed = m_decompressionBuffer;  	}  	else {  		decompressed = null;  	}  	remaining = (int)m_bzstream.avail_in;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The following statement contains a magic number: OutSize = count * 2;  
Magic Number,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The following statement contains a magic number: if (count == 0) {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  }  
Magic Number,Xceed.Compression,ManagedBZip2Decompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedBZip2Decompressor.cs,Decompress,The following statement contains a magic number: OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,ManagedDeflateCompressor,The following statement contains a magic number: try {  	m_zstream = new CompressionEngine.Managed.z_stream_s ();  	int windowBits = (useZlibHeaders ? this.MaxWindowBits : -this.MaxWindowBits);  	if (XZLib.DeflateInit2 (m_zstream' compressionLevel' this.Method' windowBits' 8' CompressionStrategy.Z_DEFAULT_STRATEGY) != ReturnCode.Z_OK) {  		string message = String.Format ("Unable to initialize the managed deflate compression engine. Method: {0}. Level: {1}. MaxWindowBits: {2}."' this.Method' compressionLevel' windowBits);  		throw new CompressionException (message);  	}  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,ManagedDeflateCompressor,The following statement contains a magic number: if (XZLib.DeflateInit2 (m_zstream' compressionLevel' this.Method' windowBits' 8' CompressionStrategy.Z_DEFAULT_STRATEGY) != ReturnCode.Z_OK) {  	string message = String.Format ("Unable to initialize the managed deflate compression engine. Method: {0}. Level: {1}. MaxWindowBits: {2}."' this.Method' compressionLevel' windowBits);  	throw new CompressionException (message);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// Deflate doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_zstream.next_in = buffer;  		m_zstream.next_in_index = unchecked((uint)offset);  		m_zstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_zstream.next_in = null;  		m_zstream.next_in_index = 0;  		m_zstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	m_zstream.next_out = m_compressionBuffer;  	m_zstream.next_out_index = 0;  	m_zstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_zstream.total_out;  	if (endOfData) {  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		while (deflateRet == ReturnCode.Z_OK) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		}  		if (deflateRet == ReturnCode.Z_STREAM_END) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	else {  		FlushValue Flush = FlushValue.Z_NO_FLUSH;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			Flush = FlushValue.Z_SYNC_FLUSH;  		}  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' Flush);  		while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' Flush);  		}  		if (deflateRet == ReturnCode.Z_OK) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// Deflate doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_zstream.next_in = buffer;  		m_zstream.next_in_index = unchecked((uint)offset);  		m_zstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_zstream.next_in = null;  		m_zstream.next_in_index = 0;  		m_zstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	m_zstream.next_out = m_compressionBuffer;  	m_zstream.next_out_index = 0;  	m_zstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_zstream.total_out;  	if (endOfData) {  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		while (deflateRet == ReturnCode.Z_OK) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		}  		if (deflateRet == ReturnCode.Z_STREAM_END) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	else {  		FlushValue Flush = FlushValue.Z_NO_FLUSH;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			Flush = FlushValue.Z_SYNC_FLUSH;  		}  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' Flush);  		while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' Flush);  		}  		if (deflateRet == ReturnCode.Z_OK) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// Deflate doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_zstream.next_in = buffer;  		m_zstream.next_in_index = unchecked((uint)offset);  		m_zstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_zstream.next_in = null;  		m_zstream.next_in_index = 0;  		m_zstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	m_zstream.next_out = m_compressionBuffer;  	m_zstream.next_out_index = 0;  	m_zstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_zstream.total_out;  	if (endOfData) {  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		while (deflateRet == ReturnCode.Z_OK) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		}  		if (deflateRet == ReturnCode.Z_STREAM_END) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	else {  		FlushValue Flush = FlushValue.Z_NO_FLUSH;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			Flush = FlushValue.Z_SYNC_FLUSH;  		}  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' Flush);  		while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' Flush);  		}  		if (deflateRet == ReturnCode.Z_OK) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// Deflate doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_zstream.next_in = buffer;  		m_zstream.next_in_index = unchecked((uint)offset);  		m_zstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_zstream.next_in = null;  		m_zstream.next_in_index = 0;  		m_zstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	m_zstream.next_out = m_compressionBuffer;  	m_zstream.next_out_index = 0;  	m_zstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_zstream.total_out;  	if (endOfData) {  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		while (deflateRet == ReturnCode.Z_OK) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		}  		if (deflateRet == ReturnCode.Z_STREAM_END) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	else {  		FlushValue Flush = FlushValue.Z_NO_FLUSH;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			Flush = FlushValue.Z_SYNC_FLUSH;  		}  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' Flush);  		while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' Flush);  		}  		if (deflateRet == ReturnCode.Z_OK) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: try {  	int OutSize = 0;  	if ((count == 0) && (m_flushCalled) && (!endOfData)) {  		// Deflate doesn't support duplicate consecutive flushes  		compressed = new byte[0];  		return 0;  	}  	if (count > 0) {  		OutSize = count + count / 9 + 12;  		m_zstream.next_in = buffer;  		m_zstream.next_in_index = unchecked((uint)offset);  		m_zstream.avail_in = unchecked((uint)count);  	}  	else {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  		m_zstream.next_in = null;  		m_zstream.next_in_index = 0;  		m_zstream.avail_in = 0;  	}  	if (m_compressionBuffer == null || m_compressionBuffer.Length < OutSize) {  		m_compressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_compressionBuffer.Length;  	}  	m_zstream.next_out = m_compressionBuffer;  	m_zstream.next_out_index = 0;  	m_zstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_zstream.total_out;  	if (endOfData) {  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		while (deflateRet == ReturnCode.Z_OK) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  		}  		if (deflateRet == ReturnCode.Z_STREAM_END) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	else {  		FlushValue Flush = FlushValue.Z_NO_FLUSH;  		m_flushCalled = false;  		if (count == 0) {  			m_flushCalled = true;  			Flush = FlushValue.Z_SYNC_FLUSH;  		}  		ReturnCode deflateRet = XZLib.Deflate (m_zstream' Flush);  		while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  			OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  			byte[] newBuffer = new Byte[OutSize];  			m_compressionBuffer.CopyTo (newBuffer' 0);  			m_compressionBuffer = newBuffer;  			m_zstream.next_out = m_compressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			deflateRet = XZLib.Deflate (m_zstream' Flush);  		}  		if (deflateRet == ReturnCode.Z_OK) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	compressed = m_compressionBuffer;  	return OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: if (count > 0) {  	OutSize = count + count / 9 + 12;  	m_zstream.next_in = buffer;  	m_zstream.next_in_index = unchecked((uint)offset);  	m_zstream.avail_in = unchecked((uint)count);  }  else {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	m_zstream.next_in = null;  	m_zstream.next_in_index = 0;  	m_zstream.avail_in = 0;  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: if (count > 0) {  	OutSize = count + count / 9 + 12;  	m_zstream.next_in = buffer;  	m_zstream.next_in_index = unchecked((uint)offset);  	m_zstream.avail_in = unchecked((uint)count);  }  else {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	m_zstream.next_in = null;  	m_zstream.next_in_index = 0;  	m_zstream.avail_in = 0;  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: if (count > 0) {  	OutSize = count + count / 9 + 12;  	m_zstream.next_in = buffer;  	m_zstream.next_in_index = unchecked((uint)offset);  	m_zstream.avail_in = unchecked((uint)count);  }  else {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	m_zstream.next_in = null;  	m_zstream.next_in_index = 0;  	m_zstream.avail_in = 0;  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: OutSize = count + count / 9 + 12;  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: OutSize = count + count / 9 + 12;  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: if (endOfData) {  	ReturnCode deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  	while (deflateRet == ReturnCode.Z_OK) {  		OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  		byte[] newBuffer = new Byte[OutSize];  		m_compressionBuffer.CopyTo (newBuffer' 0);  		m_compressionBuffer = newBuffer;  		m_zstream.next_out = m_compressionBuffer;  		m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  		m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  		deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  	}  	if (deflateRet == ReturnCode.Z_STREAM_END) {  		OutSize = (int)(m_zstream.total_out - currentTotalOut);  	}  	else {  		throw new CompressionException ("Expected end of stream not found");  	}  }  else {  	FlushValue Flush = FlushValue.Z_NO_FLUSH;  	m_flushCalled = false;  	if (count == 0) {  		m_flushCalled = true;  		Flush = FlushValue.Z_SYNC_FLUSH;  	}  	ReturnCode deflateRet = XZLib.Deflate (m_zstream' Flush);  	while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  		OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  		byte[] newBuffer = new Byte[OutSize];  		m_compressionBuffer.CopyTo (newBuffer' 0);  		m_compressionBuffer = newBuffer;  		m_zstream.next_out = m_compressionBuffer;  		m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  		m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  		deflateRet = XZLib.Deflate (m_zstream' Flush);  	}  	if (deflateRet == ReturnCode.Z_OK) {  		OutSize = (int)(m_zstream.total_out - currentTotalOut);  	}  	else {  		throw new CompressionException ("Expected end of stream not found");  	}  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: if (endOfData) {  	ReturnCode deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  	while (deflateRet == ReturnCode.Z_OK) {  		OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  		byte[] newBuffer = new Byte[OutSize];  		m_compressionBuffer.CopyTo (newBuffer' 0);  		m_compressionBuffer = newBuffer;  		m_zstream.next_out = m_compressionBuffer;  		m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  		m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  		deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  	}  	if (deflateRet == ReturnCode.Z_STREAM_END) {  		OutSize = (int)(m_zstream.total_out - currentTotalOut);  	}  	else {  		throw new CompressionException ("Expected end of stream not found");  	}  }  else {  	FlushValue Flush = FlushValue.Z_NO_FLUSH;  	m_flushCalled = false;  	if (count == 0) {  		m_flushCalled = true;  		Flush = FlushValue.Z_SYNC_FLUSH;  	}  	ReturnCode deflateRet = XZLib.Deflate (m_zstream' Flush);  	while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  		OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  		byte[] newBuffer = new Byte[OutSize];  		m_compressionBuffer.CopyTo (newBuffer' 0);  		m_compressionBuffer = newBuffer;  		m_zstream.next_out = m_compressionBuffer;  		m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  		m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  		deflateRet = XZLib.Deflate (m_zstream' Flush);  	}  	if (deflateRet == ReturnCode.Z_OK) {  		OutSize = (int)(m_zstream.total_out - currentTotalOut);  	}  	else {  		throw new CompressionException ("Expected end of stream not found");  	}  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: while (deflateRet == ReturnCode.Z_OK) {  	OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  	byte[] newBuffer = new Byte[OutSize];  	m_compressionBuffer.CopyTo (newBuffer' 0);  	m_compressionBuffer = newBuffer;  	m_zstream.next_out = m_compressionBuffer;  	m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  	m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  	deflateRet = XZLib.Deflate (m_zstream' FlushValue.Z_FINISH);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  	OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  	byte[] newBuffer = new Byte[OutSize];  	m_compressionBuffer.CopyTo (newBuffer' 0);  	m_compressionBuffer = newBuffer;  	m_zstream.next_out = m_compressionBuffer;  	m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  	m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  	deflateRet = XZLib.Deflate (m_zstream' Flush);  }  
Magic Number,Xceed.Compression,ManagedDeflateCompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateCompressor.cs,Compress,The following statement contains a magic number: OutSize += MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,The following statement contains a magic number: try {  	int OutSize = count * 2;  	m_zstream.next_in = buffer;  	m_zstream.next_in_index = unchecked((uint)offset);  	m_zstream.avail_in = unchecked((uint)count);  	if (count == 0) {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	}  	if (m_decompressionBuffer == null || m_decompressionBuffer.Length < OutSize) {  		m_decompressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_decompressionBuffer.Length;  	}  	m_zstream.next_out = m_decompressionBuffer;  	m_zstream.next_out_index = 0;  	m_zstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_zstream.total_out;  	if (endOfData) {  		// inflate() requires a dummy extra byte at the end of the compressed data...  		byte[] TempNextIn = new byte[count + 1];  		if (count > 0)  			System.Array.Copy (buffer' offset' TempNextIn' 0' count);  		m_zstream.next_in = TempNextIn;  		m_zstream.next_in_index = 0;  		m_zstream.avail_in = unchecked((uint)count + 1);  		ReturnCode InflateRet = XZLib.Inflate (ref m_zstream' FlushValue.Z_FINISH);  		while ((InflateRet == ReturnCode.Z_OK) || (InflateRet == ReturnCode.Z_BUF_ERROR)) {  			// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  			// After that' we increment by 0x8000000 (128 megs).  			OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  			byte[] newBuffer = new Byte[OutSize];  			m_decompressionBuffer.CopyTo (newBuffer' 0);  			m_decompressionBuffer = newBuffer;  			m_zstream.next_out = m_decompressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			ulong totalOut = m_zstream.total_out;  			InflateRet = XZLib.Inflate (ref m_zstream' FlushValue.Z_FINISH);  			if (totalOut == m_zstream.total_out) {  				InflateRet = ReturnCode.Z_DATA_ERROR;  			}  		}  		if (m_zstream.avail_in > 0) {  			// Undo added extra byte  			m_zstream.avail_in--;  		}  		if (InflateRet == ReturnCode.Z_STREAM_END || !this.m_enforceFormatIntegrity) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	else {  		FlushValue Flush = FlushValue.Z_NO_FLUSH;  		if (count == 0) {  			Flush = FlushValue.Z_SYNC_FLUSH;  		}  		ReturnCode InflateRet = XZLib.Inflate (ref m_zstream' Flush);  		while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  			// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  			// After that' we increment by 0x8000000 (128 megs).  			OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  			byte[] newBuffer = new Byte[OutSize];  			m_decompressionBuffer.CopyTo (newBuffer' 0);  			m_decompressionBuffer = newBuffer;  			m_zstream.next_out = m_decompressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			InflateRet = XZLib.Inflate (ref m_zstream' Flush);  		}  		if (InflateRet == ReturnCode.Z_OK) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else if (InflateRet == ReturnCode.Z_STREAM_END) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  			endOfData = true;  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	decompressed = m_decompressionBuffer;  	remaining = (int)m_zstream.avail_in;  	return OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,The following statement contains a magic number: try {  	int OutSize = count * 2;  	m_zstream.next_in = buffer;  	m_zstream.next_in_index = unchecked((uint)offset);  	m_zstream.avail_in = unchecked((uint)count);  	if (count == 0) {  		OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  	}  	if (m_decompressionBuffer == null || m_decompressionBuffer.Length < OutSize) {  		m_decompressionBuffer = new byte[OutSize];  	}  	else {  		OutSize = m_decompressionBuffer.Length;  	}  	m_zstream.next_out = m_decompressionBuffer;  	m_zstream.next_out_index = 0;  	m_zstream.avail_out = (uint)OutSize;  	ulong currentTotalOut = m_zstream.total_out;  	if (endOfData) {  		// inflate() requires a dummy extra byte at the end of the compressed data...  		byte[] TempNextIn = new byte[count + 1];  		if (count > 0)  			System.Array.Copy (buffer' offset' TempNextIn' 0' count);  		m_zstream.next_in = TempNextIn;  		m_zstream.next_in_index = 0;  		m_zstream.avail_in = unchecked((uint)count + 1);  		ReturnCode InflateRet = XZLib.Inflate (ref m_zstream' FlushValue.Z_FINISH);  		while ((InflateRet == ReturnCode.Z_OK) || (InflateRet == ReturnCode.Z_BUF_ERROR)) {  			// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  			// After that' we increment by 0x8000000 (128 megs).  			OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  			byte[] newBuffer = new Byte[OutSize];  			m_decompressionBuffer.CopyTo (newBuffer' 0);  			m_decompressionBuffer = newBuffer;  			m_zstream.next_out = m_decompressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			ulong totalOut = m_zstream.total_out;  			InflateRet = XZLib.Inflate (ref m_zstream' FlushValue.Z_FINISH);  			if (totalOut == m_zstream.total_out) {  				InflateRet = ReturnCode.Z_DATA_ERROR;  			}  		}  		if (m_zstream.avail_in > 0) {  			// Undo added extra byte  			m_zstream.avail_in--;  		}  		if (InflateRet == ReturnCode.Z_STREAM_END || !this.m_enforceFormatIntegrity) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	else {  		FlushValue Flush = FlushValue.Z_NO_FLUSH;  		if (count == 0) {  			Flush = FlushValue.Z_SYNC_FLUSH;  		}  		ReturnCode InflateRet = XZLib.Inflate (ref m_zstream' Flush);  		while ((m_zstream.avail_out == 0) && (m_zstream.avail_in != 0)) {  			// Up to 0x10000000 (256 megs)' we increment the size by doubling it.  			// After that' we increment by 0x8000000 (128 megs).  			OutSize += (OutSize < 0x10000000 ? OutSize : 0x8000000);  			byte[] newBuffer = new Byte[OutSize];  			m_decompressionBuffer.CopyTo (newBuffer' 0);  			m_decompressionBuffer = newBuffer;  			m_zstream.next_out = m_decompressionBuffer;  			m_zstream.next_out_index = (uint)(m_zstream.total_out - currentTotalOut);  			m_zstream.avail_out = (uint)OutSize - (uint)(m_zstream.total_out - currentTotalOut);  			InflateRet = XZLib.Inflate (ref m_zstream' Flush);  		}  		if (InflateRet == ReturnCode.Z_OK) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  		}  		else if (InflateRet == ReturnCode.Z_STREAM_END) {  			OutSize = (int)(m_zstream.total_out - currentTotalOut);  			endOfData = true;  		}  		else {  			throw new CompressionException ("Expected end of stream not found");  		}  	}  	decompressed = m_decompressionBuffer;  	remaining = (int)m_zstream.avail_in;  	return OutSize;  }  catch (CompressionException) {  	throw;  }  catch (Exception except) {  	if (ExceptionFilter.IsPublicException (except))  		throw;  	throw new CompressionInternalException (except);  }  
Magic Number,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,The following statement contains a magic number: if (count == 0) {  	OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  }  
Magic Number,Xceed.Compression,ManagedDeflateDecompressor,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\ManagedDeflateDecompressor.cs,Decompress,The following statement contains a magic number: OutSize = MAX_COMPRESSION_BUFFER_SIZE * 2;  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_propertyIDs = new UInt32[]//new NCoderPropID[]   {  	1'  	// NCoderPropID.kDictionarySize'  	5'  	// NCoderPropID.kPosStateBits'  	6'  	// NCoderPropID.kLitContextBits'  	7'  	// NCoderPropID.kLitPosBits'  	12'  	// NCoderPropID.kAlgorithm'  	8'  	// NCoderPropID.kNumFastBytes'  	9'  	// NCoderPropID.kMatchFinder'  	14'  // NCoderPropID.kEndMarker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_propertyIDs = new UInt32[]//new NCoderPropID[]   {  	1'  	// NCoderPropID.kDictionarySize'  	5'  	// NCoderPropID.kPosStateBits'  	6'  	// NCoderPropID.kLitContextBits'  	7'  	// NCoderPropID.kLitPosBits'  	12'  	// NCoderPropID.kAlgorithm'  	8'  	// NCoderPropID.kNumFastBytes'  	9'  	// NCoderPropID.kMatchFinder'  	14'  // NCoderPropID.kEndMarker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_propertyIDs = new UInt32[]//new NCoderPropID[]   {  	1'  	// NCoderPropID.kDictionarySize'  	5'  	// NCoderPropID.kPosStateBits'  	6'  	// NCoderPropID.kLitContextBits'  	7'  	// NCoderPropID.kLitPosBits'  	12'  	// NCoderPropID.kAlgorithm'  	8'  	// NCoderPropID.kNumFastBytes'  	9'  	// NCoderPropID.kMatchFinder'  	14'  // NCoderPropID.kEndMarker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_propertyIDs = new UInt32[]//new NCoderPropID[]   {  	1'  	// NCoderPropID.kDictionarySize'  	5'  	// NCoderPropID.kPosStateBits'  	6'  	// NCoderPropID.kLitContextBits'  	7'  	// NCoderPropID.kLitPosBits'  	12'  	// NCoderPropID.kAlgorithm'  	8'  	// NCoderPropID.kNumFastBytes'  	9'  	// NCoderPropID.kMatchFinder'  	14'  // NCoderPropID.kEndMarker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_propertyIDs = new UInt32[]//new NCoderPropID[]   {  	1'  	// NCoderPropID.kDictionarySize'  	5'  	// NCoderPropID.kPosStateBits'  	6'  	// NCoderPropID.kLitContextBits'  	7'  	// NCoderPropID.kLitPosBits'  	12'  	// NCoderPropID.kAlgorithm'  	8'  	// NCoderPropID.kNumFastBytes'  	9'  	// NCoderPropID.kMatchFinder'  	14'  // NCoderPropID.kEndMarker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_propertyIDs = new UInt32[]//new NCoderPropID[]   {  	1'  	// NCoderPropID.kDictionarySize'  	5'  	// NCoderPropID.kPosStateBits'  	6'  	// NCoderPropID.kLitContextBits'  	7'  	// NCoderPropID.kLitPosBits'  	12'  	// NCoderPropID.kAlgorithm'  	8'  	// NCoderPropID.kNumFastBytes'  	9'  	// NCoderPropID.kMatchFinder'  	14'  // NCoderPropID.kEndMarker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_propertyIDs = new UInt32[]//new NCoderPropID[]   {  	1'  	// NCoderPropID.kDictionarySize'  	5'  	// NCoderPropID.kPosStateBits'  	6'  	// NCoderPropID.kLitContextBits'  	7'  	// NCoderPropID.kLitPosBits'  	12'  	// NCoderPropID.kAlgorithm'  	8'  	// NCoderPropID.kNumFastBytes'  	9'  	// NCoderPropID.kMatchFinder'  	14'  // NCoderPropID.kEndMarker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_properties = new object[] {  	(UInt32)(1 << 23)'  	// set dictionary - [0' 29]' default: 23 (8MB)  	(UInt32)2'  	// set number of pos bits - [0' 4]' default: 2  	(UInt32)3'  	// set number of literal context bits - [0' 8]' 3 for normal files' 0 for 32-bit data  	(UInt32)0'  	// set number of literal pos bits - [0' 4]' 0 for normal files' 2 for 32-bit data  	(UInt32)2'  	(UInt32)128'  	// set number of fast bytes - [5' 273]' default: 128  	"bt4"'  	// set Match Finder: [bt2' bt4]' default: bt4  	true'  // write End Of Stream marker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_properties = new object[] {  	(UInt32)(1 << 23)'  	// set dictionary - [0' 29]' default: 23 (8MB)  	(UInt32)2'  	// set number of pos bits - [0' 4]' default: 2  	(UInt32)3'  	// set number of literal context bits - [0' 8]' 3 for normal files' 0 for 32-bit data  	(UInt32)0'  	// set number of literal pos bits - [0' 4]' 0 for normal files' 2 for 32-bit data  	(UInt32)2'  	(UInt32)128'  	// set number of fast bytes - [5' 273]' default: 128  	"bt4"'  	// set Match Finder: [bt2' bt4]' default: bt4  	true'  // write End Of Stream marker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_properties = new object[] {  	(UInt32)(1 << 23)'  	// set dictionary - [0' 29]' default: 23 (8MB)  	(UInt32)2'  	// set number of pos bits - [0' 4]' default: 2  	(UInt32)3'  	// set number of literal context bits - [0' 8]' 3 for normal files' 0 for 32-bit data  	(UInt32)0'  	// set number of literal pos bits - [0' 4]' 0 for normal files' 2 for 32-bit data  	(UInt32)2'  	(UInt32)128'  	// set number of fast bytes - [5' 273]' default: 128  	"bt4"'  	// set Match Finder: [bt2' bt4]' default: bt4  	true'  // write End Of Stream marker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_properties = new object[] {  	(UInt32)(1 << 23)'  	// set dictionary - [0' 29]' default: 23 (8MB)  	(UInt32)2'  	// set number of pos bits - [0' 4]' default: 2  	(UInt32)3'  	// set number of literal context bits - [0' 8]' 3 for normal files' 0 for 32-bit data  	(UInt32)0'  	// set number of literal pos bits - [0' 4]' 0 for normal files' 2 for 32-bit data  	(UInt32)2'  	(UInt32)128'  	// set number of fast bytes - [5' 273]' default: 128  	"bt4"'  	// set Match Finder: [bt2' bt4]' default: bt4  	true'  // write End Of Stream marker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,LZMAOptions,The following statement contains a magic number: this.m_properties = new object[] {  	(UInt32)(1 << 23)'  	// set dictionary - [0' 29]' default: 23 (8MB)  	(UInt32)2'  	// set number of pos bits - [0' 4]' default: 2  	(UInt32)3'  	// set number of literal context bits - [0' 8]' 3 for normal files' 0 for 32-bit data  	(UInt32)0'  	// set number of literal pos bits - [0' 4]' 0 for normal files' 2 for 32-bit data  	(UInt32)2'  	(UInt32)128'  	// set number of fast bytes - [5' 273]' default: 128  	"bt4"'  	// set Match Finder: [bt2' bt4]' default: bt4  	true'  // write End Of Stream marker  };  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.DictionarySize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 24) : (1 << 25)));  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.DictionarySize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 24) : (1 << 25)));  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.DictionarySize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 24) : (1 << 25)));  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.DictionarySize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 24) : (1 << 25)));  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.DictionarySize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 24) : (1 << 25)));  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.DictionarySize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 24) : (1 << 25)));  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.NumFastBytes = level < 7 ? 32 : 64;  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.NumFastBytes = level < 7 ? 32 : 64;  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.NumFastBytes = level < 7 ? 32 : 64;  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.NumLiteralContextBits = 3;  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.NumPositionBits = 2;  
Magic Number,Xceed.Compression.LZMA,LZMAOptions,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\LZMAOptions.cs,SetTemplate,The following statement contains a magic number: this.MatchFinder = level < 5 ? MatchFinder.bt2 : MatchFinder.bt4;  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: for (unitCount++; index < N1 + N2; index++' unitCount += 2)  	indexToUnits [index] = (byte)unitCount;  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: unitCount += 2
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: for (unitCount++; index < N1 + N2 + N3; index++' unitCount += 3)  	indexToUnits [index] = (byte)unitCount;  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: unitCount += 3
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: for (unitCount++; index < N1 + N2 + N3 + N4; index++' unitCount += 4)  	indexToUnits [index] = (byte)unitCount;  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: unitCount += 4
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: unitsToIndex = new byte[128];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,Allocator,The following statement contains a magic number: for (unitCount = index = 0; unitCount < 128; unitCount++) {  	index += (uint)((indexToUnits [index] < unitCount + 1) ? 1 : 0);  	unitsToIndex [unitCount] = (byte)index;  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,MoveUnitsUp,The following statement contains a magic number: if (oldPointer > BaseUnit + 16 * 1024 || oldPointer > MemoryNodes [index].Next)  	return oldPointer;  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,MoveUnitsUp,The following statement contains a magic number: if (oldPointer > BaseUnit + 16 * 1024 || oldPointer > MemoryNodes [index].Next)  	return oldPointer;  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: while (memoryNode.Available) {  	memoryNode0 = memoryNode.Remove ();  	uint unitCount = memoryNode0.UnitCount;  	if (unitCount != 0) {  		for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  			MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  		uint index = unitsToIndex [unitCount - 1];  		if (indexToUnits [index] != unitCount) {  			uint unitCountDifference = unitCount - indexToUnits [--index];  			MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  		}  		MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  	}  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: while (memoryNode.Available) {  	memoryNode0 = memoryNode.Remove ();  	uint unitCount = memoryNode0.UnitCount;  	if (unitCount != 0) {  		for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  			MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  		uint index = unitsToIndex [unitCount - 1];  		if (indexToUnits [index] != unitCount) {  			uint unitCountDifference = unitCount - indexToUnits [--index];  			MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  		}  		MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  	}  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: while (memoryNode.Available) {  	memoryNode0 = memoryNode.Remove ();  	uint unitCount = memoryNode0.UnitCount;  	if (unitCount != 0) {  		for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  			MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  		uint index = unitsToIndex [unitCount - 1];  		if (indexToUnits [index] != unitCount) {  			uint unitCountDifference = unitCount - indexToUnits [--index];  			MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  		}  		MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  	}  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: while (memoryNode.Available) {  	memoryNode0 = memoryNode.Remove ();  	uint unitCount = memoryNode0.UnitCount;  	if (unitCount != 0) {  		for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  			MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  		uint index = unitsToIndex [unitCount - 1];  		if (indexToUnits [index] != unitCount) {  			uint unitCountDifference = unitCount - indexToUnits [--index];  			MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  		}  		MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  	}  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: if (unitCount != 0) {  	for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  		MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  	uint index = unitsToIndex [unitCount - 1];  	if (indexToUnits [index] != unitCount) {  		uint unitCountDifference = unitCount - indexToUnits [--index];  		MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  	}  	MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: if (unitCount != 0) {  	for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  		MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  	uint index = unitsToIndex [unitCount - 1];  	if (indexToUnits [index] != unitCount) {  		uint unitCountDifference = unitCount - indexToUnits [--index];  		MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  	}  	MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: if (unitCount != 0) {  	for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  		MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  	uint index = unitsToIndex [unitCount - 1];  	if (indexToUnits [index] != unitCount) {  		uint unitCountDifference = unitCount - indexToUnits [--index];  		MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  	}  	MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: if (unitCount != 0) {  	for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  		MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  	uint index = unitsToIndex [unitCount - 1];  	if (indexToUnits [index] != unitCount) {  		uint unitCountDifference = unitCount - indexToUnits [--index];  		MemoryNodes [unitCountDifference - 1].Insert (memoryNode0 + (unitCount - unitCountDifference)' unitCountDifference);  	}  	MemoryNodes [index].Insert (memoryNode0' indexToUnits [index]);  }  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  	MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  	MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  	MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: for (; unitCount > 128; unitCount -= 128' memoryNode0 += 128)  	MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: unitCount -= 128
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: memoryNode0 += 128
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: MemoryNodes [IndexCount - 1].Insert (memoryNode0' 128);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,GlueFreeBlocks,The following statement contains a magic number: GlueCount = 1 << 13;  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: do {  	target [0] = source [0];  	target [1] = source [1];  	target [2] = source [2];  	target [3] = source [3];  	target [4] = source [4];  	target [5] = source [5];  	target [6] = source [6];  	target [7] = source [7];  	target [8] = source [8];  	target [9] = source [9];  	target [10] = source [10];  	target [11] = source [11];  	target += UnitSize;  	source += UnitSize;  }  while (--unitCount != 0);  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [2] = source [2];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [2] = source [2];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [3] = source [3];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [3] = source [3];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [4] = source [4];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [4] = source [4];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [5] = source [5];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [5] = source [5];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [6] = source [6];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [6] = source [6];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [7] = source [7];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [7] = source [7];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [8] = source [8];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [8] = source [8];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [9] = source [9];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [9] = source [9];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [10] = source [10];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [10] = source [10];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [11] = source [11];  
Magic Number,Xceed.Compression.PPMd,Allocator,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Allocator.cs,CopyUnits,The following statement contains a magic number: target [11] = source [11];  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: while ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true)) {  	stream.WriteByte ((byte)(low >> 24));  	range <<= 8;  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: while ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true)) {  	stream.WriteByte ((byte)(low >> 24));  	range <<= 8;  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: while ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true)) {  	stream.WriteByte ((byte)(low >> 24));  	range <<= 8;  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: stream.WriteByte ((byte)(low >> 24));  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: range <<= 8;  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderNormalize,The following statement contains a magic number: low <<= 8;  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderFlush,The following statement contains a magic number: for (uint index = 0; index < 4; index++) {  	byte value = (byte)(low >> 24);  	stream.WriteByte (value);  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderFlush,The following statement contains a magic number: for (uint index = 0; index < 4; index++) {  	byte value = (byte)(low >> 24);  	stream.WriteByte (value);  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderFlush,The following statement contains a magic number: for (uint index = 0; index < 4; index++) {  	byte value = (byte)(low >> 24);  	stream.WriteByte (value);  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeEncoderFlush,The following statement contains a magic number: low <<= 8;  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderInitialize,The following statement contains a magic number: for (RangeDecoderInitializeIndex = 0; RangeDecoderInitializeIndex < 4; RangeDecoderInitializeIndex++) {  	int value = stream.ReadByte ();  	if (value < 0) {  		return false;  	}  	code = (code << 8) | (byte)value;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderInitialize,The following statement contains a magic number: for (RangeDecoderInitializeIndex = 0; RangeDecoderInitializeIndex < 4; RangeDecoderInitializeIndex++) {  	int value = stream.ReadByte ();  	if (value < 0) {  		return false;  	}  	code = (code << 8) | (byte)value;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderInitialize,The following statement contains a magic number: code = (code << 8) | (byte)value;  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: while (resume || ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true))) {  	resume = false;  	int value = stream.ReadByte ();  	if (value < 0) {  		return false;  	}  	code = (code << 8) | (byte)value;  	range <<= 8;  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: while (resume || ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true))) {  	resume = false;  	int value = stream.ReadByte ();  	if (value < 0) {  		return false;  	}  	code = (code << 8) | (byte)value;  	range <<= 8;  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: while (resume || ((low ^ (low + range)) < RangeTop || range < RangeBottom && ((range = (uint)-low & (RangeBottom - 1)) != 0 || true))) {  	resume = false;  	int value = stream.ReadByte ();  	if (value < 0) {  		return false;  	}  	code = (code << 8) | (byte)value;  	range <<= 8;  	low <<= 8;  }  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: code = (code << 8) | (byte)value;  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: range <<= 8;  
Magic Number,Xceed.Compression.PPMd,Coder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Coder.cs,RangeDecoderNormalize,The following statement contains a magic number: low <<= 8;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Dispose,The following statement contains a magic number: if (Allocator != null) {  	if (disposing) {  		Coder = null;  		Memory = null;  		maximumContext.Memory = null;  		foundState.Memory = null;  		decodeStates = null;  		// Release the managed resources  		Allocator.Stop ();  		// Force the garbage collector to reclaim PPMd's memory  		#if !SILVERLIGHT && !XCEEDCF  		GC.Collect (2' GCCollectionMode.Forced);  		#else  		          GC.Collect();           #endif  	}  	// Release the native unmanaged resources  	// Clear references  	Allocator = null;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Dispose,The following statement contains a magic number: if (disposing) {  	Coder = null;  	Memory = null;  	maximumContext.Memory = null;  	foundState.Memory = null;  	decodeStates = null;  	// Release the managed resources  	Allocator.Stop ();  	// Force the garbage collector to reclaim PPMd's memory  	#if !SILVERLIGHT && !XCEEDCF  	GC.Collect (2' GCCollectionMode.Forced);  	#else  	          GC.Collect();           #endif  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Dispose,The following statement contains a magic number: GC.Collect (2' GCCollectionMode.Forced);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex [0] = 2 * 0;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex [1] = 2 * 1;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 2; index < 11; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 2;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 2; index < 11; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 2;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 2; index < 11; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 2;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 2; index < 11; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 2;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex [index] = 2 * 2;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex [index] = 2 * 2;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 11; index < 256; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 3;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 11; index < 256; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 3;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 11; index < 256; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 3;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = 11; index < 256; index++)  	numberStatisticsToBinarySummaryIndex [index] = 2 * 3;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex [index] = 2 * 3;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: numberStatisticsToBinarySummaryIndex [index] = 2 * 3;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index = UpperFrequency; index < 260; index++) {  	probabilities [index] = (byte)probability;  	count--;  	if (count == 0) {  		step++;  		count = step;  		probability++;  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: see2Contexts = new See2Context[24' 32];  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: see2Contexts = new See2Context[24' 32];  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index1 = 0; index1 < 24; index1++)  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [index1' index2] = new See2Context ();  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index1 = 0; index1 < 24; index1++)  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [index1' index2] = new See2Context ();  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: for (int index2 = 0; index2 < 32; index2++)  	see2Contexts [index1' index2] = new See2Context ();  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: emptySee2Context.Shift = (byte)((Signature >> 16) & 0x000000ff);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,Model,The following statement contains a magic number: emptySee2Context.Count = (byte)(Signature >> 24);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: if (modelOrder < 2) {  	orderFall = this.modelOrder;  	for (PpmContext context = maximumContext; context.Suffix != PpmContext.Zero; context = context.Suffix)  		orderFall--;  	return;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: initialRunLength = -((modelOrder < 12) ? modelOrder : 12) - 1;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: initialRunLength = -((modelOrder < 12) ? modelOrder : 12) - 1;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: maximumContext.NumberStatistics = 255;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: maximumContext.SummaryFrequency = (ushort)(maximumContext.NumberStatistics + 2);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: maximumContext.Statistics = Allocator.AllocateUnits (256 / 2);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: maximumContext.Statistics = Allocator.AllocateUnits (256 / 2);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index = 0; index < 256; index++) {  	PpmState state = maximumContext.Statistics [index];  	state.Symbol = (byte)index;  	state.Frequency = 1;  	state.Successor = PpmContext.Zero;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index1 = 0; probability < 25; probability++) {  	while (probabilities [index1] == probability)  		index1++;  	for (int index2 = 0; index2 < 8; index2++)  		binarySummary [probability' index2] = (ushort)(BinaryScale - InitialBinaryEscapes [index2] / (index1 + 1));  	for (int index2 = 8; index2 < 64; index2 += 8)  		for (int index3 = 0; index3 < 8; index3++)  			binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index1 = 0; probability < 25; probability++) {  	while (probabilities [index1] == probability)  		index1++;  	for (int index2 = 0; index2 < 8; index2++)  		binarySummary [probability' index2] = (ushort)(BinaryScale - InitialBinaryEscapes [index2] / (index1 + 1));  	for (int index2 = 8; index2 < 64; index2 += 8)  		for (int index3 = 0; index3 < 8; index3++)  			binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index1 = 0; probability < 25; probability++) {  	while (probabilities [index1] == probability)  		index1++;  	for (int index2 = 0; index2 < 8; index2++)  		binarySummary [probability' index2] = (ushort)(BinaryScale - InitialBinaryEscapes [index2] / (index1 + 1));  	for (int index2 = 8; index2 < 64; index2 += 8)  		for (int index3 = 0; index3 < 8; index3++)  			binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index1 = 0; probability < 25; probability++) {  	while (probabilities [index1] == probability)  		index1++;  	for (int index2 = 0; index2 < 8; index2++)  		binarySummary [probability' index2] = (ushort)(BinaryScale - InitialBinaryEscapes [index2] / (index1 + 1));  	for (int index2 = 8; index2 < 64; index2 += 8)  		for (int index3 = 0; index3 < 8; index3++)  			binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index1 = 0; probability < 25; probability++) {  	while (probabilities [index1] == probability)  		index1++;  	for (int index2 = 0; index2 < 8; index2++)  		binarySummary [probability' index2] = (ushort)(BinaryScale - InitialBinaryEscapes [index2] / (index1 + 1));  	for (int index2 = 8; index2 < 64; index2 += 8)  		for (int index3 = 0; index3 < 8; index3++)  			binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index1 = 0; probability < 25; probability++) {  	while (probabilities [index1] == probability)  		index1++;  	for (int index2 = 0; index2 < 8; index2++)  		binarySummary [probability' index2] = (ushort)(BinaryScale - InitialBinaryEscapes [index2] / (index1 + 1));  	for (int index2 = 8; index2 < 64; index2 += 8)  		for (int index3 = 0; index3 < 8; index3++)  			binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 0; index2 < 8; index2++)  	binarySummary [probability' index2] = (ushort)(BinaryScale - InitialBinaryEscapes [index2] / (index1 + 1));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 8; index2 < 64; index2 += 8)  	for (int index3 = 0; index3 < 8; index3++)  		binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 8; index2 < 64; index2 += 8)  	for (int index3 = 0; index3 < 8; index3++)  		binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 8; index2 < 64; index2 += 8)  	for (int index3 = 0; index3 < 8; index3++)  		binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 8; index2 < 64; index2 += 8)  	for (int index3 = 0; index3 < 8; index3++)  		binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: index2 += 8
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index3 = 0; index3 < 8; index3++)  	binarySummary [probability' index2 + index3] = binarySummary [probability' index3];  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (uint index1 = 0; probability < 24; probability++) {  	while (probabilities [index1 + 3] == probability + 3)  		index1++;  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [probability' index2].Initialize (2 * index1 + 5);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (uint index1 = 0; probability < 24; probability++) {  	while (probabilities [index1 + 3] == probability + 3)  		index1++;  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [probability' index2].Initialize (2 * index1 + 5);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (uint index1 = 0; probability < 24; probability++) {  	while (probabilities [index1 + 3] == probability + 3)  		index1++;  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [probability' index2].Initialize (2 * index1 + 5);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (uint index1 = 0; probability < 24; probability++) {  	while (probabilities [index1 + 3] == probability + 3)  		index1++;  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [probability' index2].Initialize (2 * index1 + 5);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (uint index1 = 0; probability < 24; probability++) {  	while (probabilities [index1 + 3] == probability + 3)  		index1++;  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [probability' index2].Initialize (2 * index1 + 5);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (uint index1 = 0; probability < 24; probability++) {  	while (probabilities [index1 + 3] == probability + 3)  		index1++;  	for (int index2 = 0; index2 < 32; index2++)  		see2Contexts [probability' index2].Initialize (2 * index1 + 5);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: while (probabilities [index1 + 3] == probability + 3)  	index1++;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: while (probabilities [index1 + 3] == probability + 3)  	index1++;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 0; index2 < 32; index2++)  	see2Contexts [probability' index2].Initialize (2 * index1 + 5);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 0; index2 < 32; index2++)  	see2Contexts [probability' index2].Initialize (2 * index1 + 5);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: for (int index2 = 0; index2 < 32; index2++)  	see2Contexts [probability' index2].Initialize (2 * index1 + 5);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: see2Contexts [probability' index2].Initialize (2 * index1 + 5);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,StartModel,The following statement contains a magic number: see2Contexts [probability' index2].Initialize (2 * index1 + 5);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if ((foundStateFrequency < MaximumFrequency / 4) && (context != PpmContext.Zero)) {  	if (context.NumberStatistics != 0) {  		state = context.Statistics;  		if (state.Symbol != foundStateSymbol) {  			do {  				symbol = state [1].Symbol;  				state++;  			}  			while (symbol != foundStateSymbol);  			if (state [0].Frequency >= state [-1].Frequency) {  				Swap (state [0]' state [-1]);  				state--;  			}  		}  		cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  		state.Frequency += (byte)cf;  		context.SummaryFrequency += (byte)cf;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if ((foundStateFrequency < MaximumFrequency / 4) && (context != PpmContext.Zero)) {  	if (context.NumberStatistics != 0) {  		state = context.Statistics;  		if (state.Symbol != foundStateSymbol) {  			do {  				symbol = state [1].Symbol;  				state++;  			}  			while (symbol != foundStateSymbol);  			if (state [0].Frequency >= state [-1].Frequency) {  				Swap (state [0]' state [-1]);  				state--;  			}  		}  		cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  		state.Frequency += (byte)cf;  		context.SummaryFrequency += (byte)cf;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if ((foundStateFrequency < MaximumFrequency / 4) && (context != PpmContext.Zero)) {  	if (context.NumberStatistics != 0) {  		state = context.Statistics;  		if (state.Symbol != foundStateSymbol) {  			do {  				symbol = state [1].Symbol;  				state++;  			}  			while (symbol != foundStateSymbol);  			if (state [0].Frequency >= state [-1].Frequency) {  				Swap (state [0]' state [-1]);  				state--;  			}  		}  		cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  		state.Frequency += (byte)cf;  		context.SummaryFrequency += (byte)cf;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if ((foundStateFrequency < MaximumFrequency / 4) && (context != PpmContext.Zero)) {  	if (context.NumberStatistics != 0) {  		state = context.Statistics;  		if (state.Symbol != foundStateSymbol) {  			do {  				symbol = state [1].Symbol;  				state++;  			}  			while (symbol != foundStateSymbol);  			if (state [0].Frequency >= state [-1].Frequency) {  				Swap (state [0]' state [-1]);  				state--;  			}  		}  		cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  		state.Frequency += (byte)cf;  		context.SummaryFrequency += (byte)cf;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != foundStateSymbol) {  		do {  			symbol = state [1].Symbol;  			state++;  		}  		while (symbol != foundStateSymbol);  		if (state [0].Frequency >= state [-1].Frequency) {  			Swap (state [0]' state [-1]);  			state--;  		}  	}  	cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  	state.Frequency += (byte)cf;  	context.SummaryFrequency += (byte)cf;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != foundStateSymbol) {  		do {  			symbol = state [1].Symbol;  			state++;  		}  		while (symbol != foundStateSymbol);  		if (state [0].Frequency >= state [-1].Frequency) {  			Swap (state [0]' state [-1]);  			state--;  		}  	}  	cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  	state.Frequency += (byte)cf;  	context.SummaryFrequency += (byte)cf;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != foundStateSymbol) {  		do {  			symbol = state [1].Symbol;  			state++;  		}  		while (symbol != foundStateSymbol);  		if (state [0].Frequency >= state [-1].Frequency) {  			Swap (state [0]' state [-1]);  			state--;  		}  	}  	cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  	state.Frequency += (byte)cf;  	context.SummaryFrequency += (byte)cf;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	ns1 = currentContext.NumberStatistics;  	if (ns1 != 0) {  		if ((ns1 & 1) != 0) {  			state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  			if (state == PpmState.Zero)  				goto RestartModel;  			currentContext.Statistics = state;  		}  		currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  	}  	else {  		state = Allocator.AllocateUnits (1);  		if (state == PpmState.Zero)  			goto RestartModel;  		Copy (state' currentContext.FirstState);  		currentContext.Statistics = state;  		if (state.Frequency < MaximumFrequency / 4 - 1)  			state.Frequency += state.Frequency;  		else  			state.Frequency = (byte)(MaximumFrequency - 4);  		currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  	}  	cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  	sf = s0 + currentContext.SummaryFrequency;  	if (cf < 6 * sf) {  		cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += 4;  	}  	else {  		cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  		currentContext.SummaryFrequency += (ushort)cf;  	}  	state = currentContext.Statistics + (++currentContext.NumberStatistics);  	state.Successor = Successor;  	state.Symbol = foundStateSymbol;  	state.Frequency = (byte)cf;  	currentContext.Flags |= flag;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (ns1 != 0) {  	if ((ns1 & 1) != 0) {  		state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  		if (state == PpmState.Zero)  			goto RestartModel;  		currentContext.Statistics = state;  	}  	currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  }  else {  	state = Allocator.AllocateUnits (1);  	if (state == PpmState.Zero)  		goto RestartModel;  	Copy (state' currentContext.FirstState);  	currentContext.Statistics = state;  	if (state.Frequency < MaximumFrequency / 4 - 1)  		state.Frequency += state.Frequency;  	else  		state.Frequency = (byte)(MaximumFrequency - 4);  	currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (ns1 != 0) {  	if ((ns1 & 1) != 0) {  		state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  		if (state == PpmState.Zero)  			goto RestartModel;  		currentContext.Statistics = state;  	}  	currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  }  else {  	state = Allocator.AllocateUnits (1);  	if (state == PpmState.Zero)  		goto RestartModel;  	Copy (state' currentContext.FirstState);  	currentContext.Statistics = state;  	if (state.Frequency < MaximumFrequency / 4 - 1)  		state.Frequency += state.Frequency;  	else  		state.Frequency = (byte)(MaximumFrequency - 4);  	currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (ns1 != 0) {  	if ((ns1 & 1) != 0) {  		state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  		if (state == PpmState.Zero)  			goto RestartModel;  		currentContext.Statistics = state;  	}  	currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  }  else {  	state = Allocator.AllocateUnits (1);  	if (state == PpmState.Zero)  		goto RestartModel;  	Copy (state' currentContext.FirstState);  	currentContext.Statistics = state;  	if (state.Frequency < MaximumFrequency / 4 - 1)  		state.Frequency += state.Frequency;  	else  		state.Frequency = (byte)(MaximumFrequency - 4);  	currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (ns1 != 0) {  	if ((ns1 & 1) != 0) {  		state = Allocator.ExpandUnits (currentContext.Statistics' (ns1 + 1) >> 1);  		if (state == PpmState.Zero)  			goto RestartModel;  		currentContext.Statistics = state;  	}  	currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  }  else {  	state = Allocator.AllocateUnits (1);  	if (state == PpmState.Zero)  		goto RestartModel;  	Copy (state' currentContext.FirstState);  	currentContext.Statistics = state;  	if (state.Frequency < MaximumFrequency / 4 - 1)  		state.Frequency += state.Frequency;  	else  		state.Frequency = (byte)(MaximumFrequency - 4);  	currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: currentContext.SummaryFrequency += (ushort)((3 * ns1 + 1 < numberStatistics) ? 1 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (state.Frequency < MaximumFrequency / 4 - 1)  	state.Frequency += state.Frequency;  else  	state.Frequency = (byte)(MaximumFrequency - 4);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (state.Frequency < MaximumFrequency / 4 - 1)  	state.Frequency += state.Frequency;  else  	state.Frequency = (byte)(MaximumFrequency - 4);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: state.Frequency = (byte)(MaximumFrequency - 4);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: currentContext.SummaryFrequency = (ushort)(state.Frequency + initialEscape + ((numberStatistics > 2) ? 1 : 0));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(2 * foundStateFrequency * (currentContext.SummaryFrequency + 6));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (cf < 6 * sf) {  	cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += 4;  }  else {  	cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += (ushort)cf;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (cf < 6 * sf) {  	cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += 4;  }  else {  	cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += (ushort)cf;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (cf < 6 * sf) {  	cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += 4;  }  else {  	cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += (ushort)cf;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (cf < 6 * sf) {  	cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += 4;  }  else {  	cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += (ushort)cf;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (cf < 6 * sf) {  	cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += 4;  }  else {  	cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += (ushort)cf;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (cf < 6 * sf) {  	cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += 4;  }  else {  	cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += (ushort)cf;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: if (cf < 6 * sf) {  	cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += 4;  }  else {  	cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  	currentContext.SummaryFrequency += (ushort)cf;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(1 + ((cf > sf) ? 1 : 0) + ((cf >= 4 * sf) ? 1 : 0));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: currentContext.SummaryFrequency += 4;  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,UpdateModel,The following statement contains a magic number: cf = (uint)(4 + ((cf > 9 * sf) ? 1 : 0) + ((cf > 12 * sf) ? 1 : 0) + ((cf > 15 * sf) ? 1 : 0));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: do {  	if (gotoLoopEntry) {  		gotoLoopEntry = false;  		goto LoopEntry;  	}  	context = context.Suffix;  	if (context.NumberStatistics != 0) {  		byte temporary;  		state = context.Statistics;  		if (state.Symbol != symbol) {  			do {  				temporary = state [1].Symbol;  				state++;  			}  			while (temporary != symbol);  		}  		temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 1 : 0);  		state.Frequency += temporary;  		context.SummaryFrequency += temporary;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)(((context.Suffix.NumberStatistics == 0) ? 1 : 0) & ((state.Frequency < 24) ? 1 : 0));  	}  	LoopEntry:  	if (state.Successor != upBranch) {  		context = state.Successor;  		break;  	}  	states [stateIndex++] = state;  }  while (context.Suffix != PpmContext.Zero);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: do {  	if (gotoLoopEntry) {  		gotoLoopEntry = false;  		goto LoopEntry;  	}  	context = context.Suffix;  	if (context.NumberStatistics != 0) {  		byte temporary;  		state = context.Statistics;  		if (state.Symbol != symbol) {  			do {  				temporary = state [1].Symbol;  				state++;  			}  			while (temporary != symbol);  		}  		temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 1 : 0);  		state.Frequency += temporary;  		context.SummaryFrequency += temporary;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)(((context.Suffix.NumberStatistics == 0) ? 1 : 0) & ((state.Frequency < 24) ? 1 : 0));  	}  	LoopEntry:  	if (state.Successor != upBranch) {  		context = state.Successor;  		break;  	}  	states [stateIndex++] = state;  }  while (context.Suffix != PpmContext.Zero);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	byte temporary;  	state = context.Statistics;  	if (state.Symbol != symbol) {  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 1 : 0);  	state.Frequency += temporary;  	context.SummaryFrequency += temporary;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)(((context.Suffix.NumberStatistics == 0) ? 1 : 0) & ((state.Frequency < 24) ? 1 : 0));  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	byte temporary;  	state = context.Statistics;  	if (state.Symbol != symbol) {  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 1 : 0);  	state.Frequency += temporary;  	context.SummaryFrequency += temporary;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)(((context.Suffix.NumberStatistics == 0) ? 1 : 0) & ((state.Frequency < 24) ? 1 : 0));  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 1 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: state.Frequency += (byte)(((context.Suffix.NumberStatistics == 0) ? 1 : 0) & ((state.Frequency < 24) ? 1 : 0));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != symbol) {  		byte temporary;  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	uint cf = (uint)(state.Frequency - 1);  	uint s0 = (uint)(context.SummaryFrequency - context.NumberStatistics - cf);  	localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  }  else {  	localFrequency = context.FirstStateFrequency;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != symbol) {  		byte temporary;  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	uint cf = (uint)(state.Frequency - 1);  	uint s0 = (uint)(context.SummaryFrequency - context.NumberStatistics - cf);  	localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  }  else {  	localFrequency = context.FirstStateFrequency;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != symbol) {  		byte temporary;  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	uint cf = (uint)(state.Frequency - 1);  	uint s0 = (uint)(context.SummaryFrequency - context.NumberStatistics - cf);  	localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  }  else {  	localFrequency = context.FirstStateFrequency;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != symbol) {  		byte temporary;  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	uint cf = (uint)(state.Frequency - 1);  	uint s0 = (uint)(context.SummaryFrequency - context.NumberStatistics - cf);  	localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  }  else {  	localFrequency = context.FirstStateFrequency;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,CreateSuccessors,The following statement contains a magic number: localFrequency = (byte)(1 + ((2 * cf <= s0) ? (uint)((5 * cf > s0) ? 1 : 0) : ((cf + 2 * s0 - 3) / s0)));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: while (true) {  	if (gotoLoopEntry) {  		gotoLoopEntry = false;  		goto LoopEntry;  	}  	if (context.Suffix == PpmContext.Zero) {  		if (method > ModelRestorationMethod.Freeze) {  			do {  				states [--stateIndex].Successor = context;  			}  			while (stateIndex != 0);  			Allocator.Text = Allocator.Heap + 1;  			orderFall = 1;  		}  		return context;  	}  	context = context.Suffix;  	if (context.NumberStatistics != 0) {  		state = context.Statistics;  		if (state.Symbol != symbol) {  			do {  				temporary = state [1].Symbol;  				state++;  			}  			while (temporary != symbol);  		}  		temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  		state.Frequency += temporary;  		context.SummaryFrequency += temporary;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  	}  	LoopEntry:  	if (state.Successor != PpmContext.Zero)  		break;  	states [stateIndex++] = state;  	state.Successor = UpBranch;  	orderFall++;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: while (true) {  	if (gotoLoopEntry) {  		gotoLoopEntry = false;  		goto LoopEntry;  	}  	if (context.Suffix == PpmContext.Zero) {  		if (method > ModelRestorationMethod.Freeze) {  			do {  				states [--stateIndex].Successor = context;  			}  			while (stateIndex != 0);  			Allocator.Text = Allocator.Heap + 1;  			orderFall = 1;  		}  		return context;  	}  	context = context.Suffix;  	if (context.NumberStatistics != 0) {  		state = context.Statistics;  		if (state.Symbol != symbol) {  			do {  				temporary = state [1].Symbol;  				state++;  			}  			while (temporary != symbol);  		}  		temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  		state.Frequency += temporary;  		context.SummaryFrequency += temporary;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  	}  	LoopEntry:  	if (state.Successor != PpmContext.Zero)  		break;  	states [stateIndex++] = state;  	state.Successor = UpBranch;  	orderFall++;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: while (true) {  	if (gotoLoopEntry) {  		gotoLoopEntry = false;  		goto LoopEntry;  	}  	if (context.Suffix == PpmContext.Zero) {  		if (method > ModelRestorationMethod.Freeze) {  			do {  				states [--stateIndex].Successor = context;  			}  			while (stateIndex != 0);  			Allocator.Text = Allocator.Heap + 1;  			orderFall = 1;  		}  		return context;  	}  	context = context.Suffix;  	if (context.NumberStatistics != 0) {  		state = context.Statistics;  		if (state.Symbol != symbol) {  			do {  				temporary = state [1].Symbol;  				state++;  			}  			while (temporary != symbol);  		}  		temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  		state.Frequency += temporary;  		context.SummaryFrequency += temporary;  	}  	else {  		state = context.FirstState;  		state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  	}  	LoopEntry:  	if (state.Successor != PpmContext.Zero)  		break;  	states [stateIndex++] = state;  	state.Successor = UpBranch;  	orderFall++;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != symbol) {  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  	state.Frequency += temporary;  	context.SummaryFrequency += temporary;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != symbol) {  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  	state.Frequency += temporary;  	context.SummaryFrequency += temporary;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: if (context.NumberStatistics != 0) {  	state = context.Statistics;  	if (state.Symbol != symbol) {  		do {  			temporary = state [1].Symbol;  			state++;  		}  		while (temporary != symbol);  	}  	temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  	state.Frequency += temporary;  	context.SummaryFrequency += temporary;  }  else {  	state = context.FirstState;  	state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: temporary = (byte)((state.Frequency < MaximumFrequency - 9) ? 2 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,ReduceOrder,The following statement contains a magic number: state.Frequency += (byte)((state.Frequency < 32) ? 1 : 0);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: for (currentContext = maximumContext; currentContext != context; currentContext = currentContext.Suffix) {  	if (--(currentContext.NumberStatistics) == 0) {  		currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00));  		PpmState state = currentContext.Statistics;  		Copy (currentContext.FirstState' state);  		Allocator.SpecialFreeUnits (state);  		currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  	}  	else {  		currentContext.Refresh ((uint)((currentContext.NumberStatistics + 3) >> 1)' false);  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: for (currentContext = maximumContext; currentContext != context; currentContext = currentContext.Suffix) {  	if (--(currentContext.NumberStatistics) == 0) {  		currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00));  		PpmState state = currentContext.Statistics;  		Copy (currentContext.FirstState' state);  		Allocator.SpecialFreeUnits (state);  		currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  	}  	else {  		currentContext.Refresh ((uint)((currentContext.NumberStatistics + 3) >> 1)' false);  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: for (currentContext = maximumContext; currentContext != context; currentContext = currentContext.Suffix) {  	if (--(currentContext.NumberStatistics) == 0) {  		currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00));  		PpmState state = currentContext.Statistics;  		Copy (currentContext.FirstState' state);  		Allocator.SpecialFreeUnits (state);  		currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  	}  	else {  		currentContext.Refresh ((uint)((currentContext.NumberStatistics + 3) >> 1)' false);  	}  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (--(currentContext.NumberStatistics) == 0) {  	currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00));  	PpmState state = currentContext.Statistics;  	Copy (currentContext.FirstState' state);  	Allocator.SpecialFreeUnits (state);  	currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  }  else {  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 3) >> 1)' false);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (--(currentContext.NumberStatistics) == 0) {  	currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00));  	PpmState state = currentContext.Statistics;  	Copy (currentContext.FirstState' state);  	Allocator.SpecialFreeUnits (state);  	currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  }  else {  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 3) >> 1)' false);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (--(currentContext.NumberStatistics) == 0) {  	currentContext.Flags = (byte)((currentContext.Flags & 0x10) + ((currentContext.Statistics.Symbol >= 0x40) ? 0x08 : 0x00));  	PpmState state = currentContext.Statistics;  	Copy (currentContext.FirstState' state);  	Allocator.SpecialFreeUnits (state);  	currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  }  else {  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 3) >> 1)' false);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: currentContext.FirstStateFrequency = (byte)((currentContext.FirstStateFrequency + 11) >> 3);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: currentContext.Refresh ((uint)((currentContext.NumberStatistics + 3) >> 1)' false);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	if (currentContext.NumberStatistics == 0)  		currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  	else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  		currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	if (currentContext.NumberStatistics == 0)  		currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  	else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  		currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	if (currentContext.NumberStatistics == 0)  		currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  	else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  		currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: for (; currentContext != minimumContext; currentContext = currentContext.Suffix) {  	if (currentContext.NumberStatistics == 0)  		currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  	else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  		currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (currentContext.NumberStatistics == 0)  	currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (currentContext.NumberStatistics == 0)  	currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (currentContext.NumberStatistics == 0)  	currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (currentContext.NumberStatistics == 0)  	currentContext.FirstStateFrequency -= (byte)(currentContext.FirstStateFrequency >> 1);  else if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if ((currentContext.SummaryFrequency += 4) > 128 + 4 * currentContext.NumberStatistics)  	currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: currentContext.Refresh ((uint)((currentContext.NumberStatistics + 2) >> 1)' true);  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (method > ModelRestorationMethod.Freeze) {  	maximumContext = foundStateSuccessor;  	Allocator.GlueCount += (uint)(((Allocator.MemoryNodes [1].Stamp & 1) == 0) ? 1 : 0);  }  else if (method == ModelRestorationMethod.Freeze) {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	maximumContext.RemoveBinaryContexts (0);  	method = (ModelRestorationMethod)(method + 1);  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  else if (method == ModelRestorationMethod.Restart || Allocator.GetMemoryUsed () < (Allocator.AllocatorSize >> 1)) {  	StartModel (modelOrder' method);  	escapeCount = 0;  }  else {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	do {  		maximumContext.CutOff (0);  		Allocator.ExpandText ();  	}  	while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (method > ModelRestorationMethod.Freeze) {  	maximumContext = foundStateSuccessor;  	Allocator.GlueCount += (uint)(((Allocator.MemoryNodes [1].Stamp & 1) == 0) ? 1 : 0);  }  else if (method == ModelRestorationMethod.Freeze) {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	maximumContext.RemoveBinaryContexts (0);  	method = (ModelRestorationMethod)(method + 1);  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  else if (method == ModelRestorationMethod.Restart || Allocator.GetMemoryUsed () < (Allocator.AllocatorSize >> 1)) {  	StartModel (modelOrder' method);  	escapeCount = 0;  }  else {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	do {  		maximumContext.CutOff (0);  		Allocator.ExpandText ();  	}  	while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (method == ModelRestorationMethod.Freeze) {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	maximumContext.RemoveBinaryContexts (0);  	method = (ModelRestorationMethod)(method + 1);  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  else if (method == ModelRestorationMethod.Restart || Allocator.GetMemoryUsed () < (Allocator.AllocatorSize >> 1)) {  	StartModel (modelOrder' method);  	escapeCount = 0;  }  else {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	do {  		maximumContext.CutOff (0);  		Allocator.ExpandText ();  	}  	while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (method == ModelRestorationMethod.Freeze) {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	maximumContext.RemoveBinaryContexts (0);  	method = (ModelRestorationMethod)(method + 1);  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  else if (method == ModelRestorationMethod.Restart || Allocator.GetMemoryUsed () < (Allocator.AllocatorSize >> 1)) {  	StartModel (modelOrder' method);  	escapeCount = 0;  }  else {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	do {  		maximumContext.CutOff (0);  		Allocator.ExpandText ();  	}  	while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (method == ModelRestorationMethod.Restart || Allocator.GetMemoryUsed () < (Allocator.AllocatorSize >> 1)) {  	StartModel (modelOrder' method);  	escapeCount = 0;  }  else {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	do {  		maximumContext.CutOff (0);  		Allocator.ExpandText ();  	}  	while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: if (method == ModelRestorationMethod.Restart || Allocator.GetMemoryUsed () < (Allocator.AllocatorSize >> 1)) {  	StartModel (modelOrder' method);  	escapeCount = 0;  }  else {  	while (maximumContext.Suffix != PpmContext.Zero)  		maximumContext = maximumContext.Suffix;  	do {  		maximumContext.CutOff (0);  		Allocator.ExpandText ();  	}  	while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  	Allocator.GlueCount = 0;  	orderFall = modelOrder;  }  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: do {  	maximumContext.CutOff (0);  	Allocator.ExpandText ();  }  while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  
Magic Number,Xceed.Compression.PPMd,Model,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\Model.cs,RestoreModel,The following statement contains a magic number: do {  	maximumContext.CutOff (0);  	Allocator.ExpandText ();  }  while (Allocator.GetMemoryUsed () > 3 * (Allocator.AllocatorSize >> 2));  
Magic Number,Xceed.Compression.PPMd,See2Context,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\See2Context.cs,Initialize,The following statement contains a magic number: Shift = PeriodBitCount - 4;  
Magic Number,Xceed.Compression.PPMd,See2Context,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\See2Context.cs,Initialize,The following statement contains a magic number: Count = 7;  
Magic Number,Xceed.Compression.PPMd,See2Context,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\See2Context.cs,Update,The following statement contains a magic number: if (Shift < PeriodBitCount && --Count == 0) {  	Summary += Summary;  	Count = (byte)(3 << Shift++);  }  
Magic Number,Xceed.Compression.PPMd,See2Context,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\PPMd\See2Context.cs,Update,The following statement contains a magic number: Count = (byte)(3 << Shift++);  
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,unRLE_obuf_to_output_SMALL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4' 23)' (70' 89))
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,Compress,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\Compress.cs,generateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 70)' (96' 115))
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 43)' (17' 45))
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XZLib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Missing Default,Xceed.Compression.CompressionEngine.Managed,BZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\BZip2\BZLib.cs,BZ2_bzCompress,The following switch statement is missing a default case: switch (s.mode) {  case BZCompressionMode.BZ_M_IDLE:  	return BZReturnValue.BZ_SEQUENCE_ERROR;  case BZCompressionMode.BZ_M_RUNNING:  	if (action == BZActions.BZ_RUN) {  		progress = handle_compress (ref strm);  		return progress ? BZReturnValue.BZ_RUN_OK : BZReturnValue.BZ_PARAM_ERROR;  	}  	else if (action == BZActions.BZ_FLUSH) {  		s.avail_in_expect = strm.avail_in;  		s.mode = BZCompressionMode.BZ_M_FLUSHING;  		goto preswitch;  	}  	else if (action == BZActions.BZ_FINISH) {  		s.avail_in_expect = strm.avail_in;  		s.mode = BZCompressionMode.BZ_M_FINISHING;  		goto preswitch;  	}  	else  		return BZReturnValue.BZ_PARAM_ERROR;  case BZCompressionMode.BZ_M_FLUSHING:  	if (action != BZActions.BZ_FLUSH)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	if (s.avail_in_expect != s.strm.avail_in)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	progress = handle_compress (ref strm);  	if (progress && // need this to avoid error flushing  	(s.avail_in_expect > 0 || !isempty_RL (ref s) || s.state_out_pos < s.numZ))  		return BZReturnValue.BZ_FLUSH_OK;  	s.mode = BZCompressionMode.BZ_M_RUNNING;  	return BZReturnValue.BZ_RUN_OK;  case BZCompressionMode.BZ_M_FINISHING:  	if (action != BZActions.BZ_FINISH)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	if (s.avail_in_expect != s.strm.avail_in)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	progress = handle_compress (ref strm);  	if (!progress)  		return BZReturnValue.BZ_SEQUENCE_ERROR;  	if (s.avail_in_expect > 0 || !isempty_RL (ref s) || s.state_out_pos < s.numZ)  		return BZReturnValue.BZ_FINISH_OK;  	s.mode = BZCompressionMode.BZ_M_IDLE;  	return BZReturnValue.BZ_STREAM_END;  }  
Missing Default,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following switch statement is missing a default case: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Missing Default,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\XZLib\XDeflate.cs,deflate,The following switch statement is missing a default case: switch (configuration_table [s.level].func) {  case Compress_func.deflate_stored:  	bstate = deflate_stored (s' flush);  	break;  case Compress_func.deflate_fast:  	bstate = deflate_fast (s' flush);  	break;  case Compress_func.deflate_slow:  	bstate = deflate_slow (s' flush);  	break;  }  
Missing Default,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Blueprint\Utils\Streams\CombinedStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin:  	this.Position = offset;  	break;  case SeekOrigin.End:  	this.Position = this.Length + offset;  	break;  case SeekOrigin.Current:  	this.Position += offset;  	break;  }  
