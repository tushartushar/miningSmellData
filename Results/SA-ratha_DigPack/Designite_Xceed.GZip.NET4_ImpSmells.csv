Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The method has 140 lines of code.
Long Method,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The method has 106 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,OpenWrite,The method has 162 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,Update,The method has 146 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The method has 212 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The method has 263 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The method has 187 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The method has 142 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The method has 156 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The method has 116 lines of code.
Long Method,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The method has 151 lines of code.
Complex Method,Xceed.GZip,GZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZippedFile.cs,GZippedFile,Cyclomatic complexity of the method is 8
Complex Method,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,Cyclomatic complexity of the method is 23
Complex Method,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,Cyclomatic complexity of the method is 11
Complex Method,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,Cyclomatic complexity of the method is 9
Complex Method,Xceed.GZip,QuickGZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\QuickGZip.cs,GZip,Cyclomatic complexity of the method is 10
Complex Method,Xceed.GZip,QuickGZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\QuickGZip.cs,Ungzip,Cyclomatic complexity of the method is 10
Complex Method,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,Cyclomatic complexity of the method is 12
Complex Method,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,Cyclomatic complexity of the method is 12
Complex Method,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,OpenRead,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,OpenWrite,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,Update,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,UpdateItems,Cyclomatic complexity of the method is 15
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,Cyclomatic complexity of the method is 40
Complex Method,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,AddItem,Cyclomatic complexity of the method is 29
Complex Method,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Utils.Storage,StorageKeyComparer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageKeyComparer.cs,Compare,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,Cyclomatic complexity of the method is 96
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,Cyclomatic complexity of the method is 87
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,Cyclomatic complexity of the method is 18
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,Cyclomatic complexity of the method is 27
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_stored,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,fill_window,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,Cyclomatic complexity of the method is 97
Long Parameter List,Xceed.GZip,GZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorage.cs,ReadItem,The method has 5 parameters.
Long Parameter List,Xceed.GZip,QuickGZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\QuickGZip.cs,GZip,The method has 6 parameters.
Long Parameter List,Xceed.GZip,QuickGZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\QuickGZip.cs,Ungzip,The method has 7 parameters.
Long Parameter List,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The method has 5 parameters.
Long Parameter List,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The method has 6 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,ReadItem,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,OnItemRead,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,LOAD,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,UPDATE,The method has 7 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,NEEDBITS,The method has 9 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,GRABBITS,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,UNGRAB,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,LEAVE,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,FLUSH,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The method has 8 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The method has 9 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The method has 11 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,copy_block,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_stored_block,The method has 5 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The method has 6 parameters.
Long Parameter List,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,DeflateInit2,The method has 6 parameters.
Long Identifier,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the parameter preservedPathDestinationFolder is 30.
Long Statement,Xceed.GZip,GZipStorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageHandler.cs,GetRootItemToken,The length of the statement  "	return new GZipStorageItemHandlerToken (this.GetItem (Path.DirectorySeparatorChar.ToString ()' false) as GZipStorageItemHandler); " is 129.
Long Statement,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The length of the statement  "		System.Diagnostics.Debug.Assert (count > 0' "The loop above is always running at least once' thus should have incremented count."); " is 131.
Long Statement,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The length of the statement  "		System.Diagnostics.Debug.Assert (count > 0' "The loop above is always running at least once' thus should have incremented count."); " is 131.
Long Statement,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The length of the statement  "	System.Diagnostics.Debug.Assert (m_compressionMethod == 8' "Hardcoded compression method for now. Should become parameter."); " is 125.
Long Statement,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The length of the statement  "	GZipFlags dynamicFlags = ((this.HasComment) ? GZipFlags.HasComment : GZipFlags.None) | ((this.HasExtraHeader) ? GZipFlags.HasExtraHeader : GZipFlags.None); " is 155.
Long Statement,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,CalculateHeaderSize,The length of the statement  "	m_calculatedSize = 10 + ((this.HasExtraHeader) ? (m_extraHeader.Length + 2) : (0)) + ((this.HasFilename) ? (m_filenameSize) : (0)) + ((this.HasComment) ? (m_commentSize) : (0)) + ((this.HasHeaderChecksum) ? (2) : (0)); " is 218.
Long Statement,Xceed.GZip,GZipStorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItemHandler.cs,OnCreated,The length of the statement  "		throw new FileSystemNotSupportedException ("Cannot create more than one GZippedFile in a GZipArchive when GZipArchive.AllowMultipleFiles is false."' null); " is 155.
Long Statement,Xceed.GZip,GZipStorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItemHandler.cs,OnPreparingReadStream,The length of the statement  "	System.Diagnostics.Debug.Assert ((this.Size != -1) || (this.GZipItem.Crc32 == 0)' "When the size is unknown' the expected checksum should always be zero."); " is 156.
Long Statement,Xceed.GZip,GZipStorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItemHandler.cs,OnPreparingReadStream,The length of the statement  "	ChecksumStream checksumStream = new ChecksumStream (compressedStream' ChecksumType.CRC32' unchecked((int)this.GZipItem.Crc32)); " is 127.
Long Statement,Xceed.GZip,QuickGZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\QuickGZip.cs,OnByteProgression,The length of the statement  "	byteProgressionCallback (e.CurrentItem.FullName' e.CurrentFileBytes.Processed' e.CurrentFileBytes.Total' e.CurrentFileBytes.Percent' e.AllFilesBytes.Processed' e.AllFilesBytes.Total' e.AllFilesBytes.Percent' userParams); " is 220.
Long Statement,Xceed.GZip,QuickGZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\QuickGZip.cs,OnItemProgression,The length of the statement  "	itemProgressionCallback (e.CurrentItem.FullName' e.AllItems.Processed' e.AllItems.Total' e.AllItems.Percent' ref abort' userParams); " is 132.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The length of the statement  "				throw new FileSystemIOException ("The parent folder full name is too long for item : " + fileParentFolderPath' null' exception); " is 128.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The length of the statement  "			if ((fileParentFolderPath == Path.DirectorySeparatorChar.ToString ()) || (fileParentFolderPath == Path.AltDirectorySeparatorChar.ToString ())) { " is 144.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,The length of the statement  "			if (!fileParentFolderPath.EndsWith (Path.DirectorySeparatorChar.ToString ()) && !fileParentFolderPath.EndsWith (Path.AltDirectorySeparatorChar.ToString ())) { " is 158.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,The length of the statement  "			if (fileParentFolderPath == Path.DirectorySeparatorChar.ToString () || fileParentFolderPath == Path.AltDirectorySeparatorChar.ToString ()) { " is 140.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "			throw new FileSystemIOException ("The parent folder full name is too long for item : " + fileSystemItem.FullName' null' exception); " is 131.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "				throw new FileSystemIOException ("The parent's full name is too long for item : " + fileSystemItem.FullName' null' exception); " is 126.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "			// If in current folder' no root path specified or sourceFolderPath is a root path' use the destination folder directly. " is 120.
Long Statement,Xceed.Utils.Exceptions,ExceptionFilter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Exceptions\ExceptionFilter.cs,IsPublicException,The length of the statement  "	exception is OutOfMemoryException || exception is System.Security.SecurityException || exception is UnauthorizedAccessException || exception is System.IO.PathTooLongException || exception is ArgumentException || exception is System.Reflection.TargetInvocationException); " is 270.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,SetBatchUpdateable,The length of the statement  "		MethodInfo getBatchUpdateableInfo = item.GetType ().GetProperty ("BatchUpdateable"' BindingFlags.NonPublic | BindingFlags.Instance).GetGetMethod (true); " is 152.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,DoAddWriteReference,The length of the statement  "           * one file' this will fail. But we're ready for this with the try/catch. */m_writingFile = m_matchingFile.ParentFolder.GetFile (m_originalName); " is 144.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,DoReleaseWriteReference,The length of the statement  "					throw new FileSystemIOException ("Though the changes may have been committed' the temporary file could not be deleted."' m_writingFile' except); " is 144.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,DoReleaseWriteReference,The length of the statement  "			throw new FileSystemIOException ("The temporary file could not be copied over its destination file."' m_writingFile' except); " is 125.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,AddWriteReference,The length of the statement  "		System.Diagnostics.Debug.Assert (m_writingRef == 1' "The current implementation does not support opening a file more than once for writing."); " is 142.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "		System.Diagnostics.Debug.Assert (m_writingRef == 1' "The current implementation does not support opening a file more than once for writing."); " is 142.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "								throw new FileSystemIOException ("Could not delete the temporary file while reverting changes."' m_writingFile' except); " is 120.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "								throw new FileSystemIOException ("Could not delete the temporary file while reverting changes. The original file could not be renamed to its original name."' m_writingFile' except); " is 181.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,OpenRead,The length of the statement  "					throw new FileSystemInternalException ("A non-seekable stream was open on a file' with a position already behind the target offset."); " is 134.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,The length of the statement  "                 * won't be able to be updated since we never know on which disk a footer is located */m_canUpdateInPlace &= /*item.AllowsUpdateInPlace &&*/(!this.IsSplitOrSpanned && !this.IsSplittingOrSpanning); " is 195.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,The length of the statement  "				m_canUpdateInPlace = m_canUpdateInPlace && ((location.HeaderSize == 0) || (location.HeaderSize == item.CurrentHeaderSize)); " is 123.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,OpenWrite,The length of the statement  "				System.Diagnostics.Debug.Fail ("OpenWrite should always write at the end of the file. The cached offset should match the end of the last item."); " is 145.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,UpdateItems,The length of the statement  "			System.Diagnostics.Debug.Fail ("This should not happen as we made sure this storage did not require an ending header and did not have invalid items."); " is 151.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The length of the statement  "				bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove); " is 132.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,BuildAddItemException,The length of the statement  "		message = String.Format ("{0} {1}\nItem: '{2}'. at {3}. Nearest item is {4}/{5}' '{6}' {{{7}}} at {8}."' message' section' item.FullName' item.Location' nearestIndex' this.m_items.Count' nearest.FullName' nearest.GetType ().Name' nearest.Location); " is 248.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,BuildAddItemException,The length of the statement  "		message = String.Format ("{0} {1}\nItem: '{2}'. at {3}. Nearest item not found. {4} total."' message' section' item.FullName' item.Location' this.m_items.Count); " is 161.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,GetItem,The length of the statement  "		System.Diagnostics.Debug.Assert (!itemHandler.IsRootFolder' "The root item should have been found by m_itemHandlers.Contains above."); " is 134.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,RenameItem,The length of the statement  "	System.Diagnostics.Debug.Assert (m_itemHandlers.ContainsKey (currentFullName)' "The itemHandler must not have been renamed yet."); " is 130.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,ReleaseReference,The length of the statement  "               decisions on whether to refresh or not later. *//* PERFORMANCE NOTE: I'd like to avoid making yet another call to Exists as it may" is 130.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageItemHandler.cs,AddChild,The length of the statement  "		System.Diagnostics.Debug.Assert (current.m_children.Count == child.m_children.Count' "A folder being replaced must be addressed by caller."); " is 141.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameChild,The length of the statement  "	System.Diagnostics.Debug.Assert (m_children.ContainsKey (currentFullName)' "The StorageHandler.GetItem mechanism should have populated item's children."); " is 154.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameChild,The length of the statement  "			string message = String.Format ("RenameChild() is attempting to replace an existing child <{0}> of state '{1}' with " + "another item. The existing child should either be not in the list or be unassigned or " + "have been discarded."' newFullName' state); " is 255.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameTo,The length of the statement  "		SortedList<string' StorageItemHandler> children = new SortedList<string' StorageItemHandler> (m_children' StringComparer.OrdinalIgnoreCase); " is 140.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,NotifyStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\NotifyStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("size"' size' "The size can be -1 for up to end-of-stream copy' or a value greater than 0."); " is 142.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,Seek,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("origin"' origin' "The seek origin is not a valid SeekOrigin member."); " is 120.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,The length of the statement  "		throw new ArgumentOutOfRangeException ("count"' "The count parameter exceeds the buffer's remaining length after offset."); " is 123.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The length of the statement  "	/* TODO: Store 'currentLength' and supply it to EndWrite() *///long currentLength = ( m_innerStream.CanSeek && m_length != -1 ) ? m_innerStream.Length : 0; " is 155.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,CheckInnerStream,The length of the statement  "			throw new IOException ("The inner stream of the WindowStream has been accessed directly' preventing the WindowStream from working properly."); " is 142.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "	/* bytes to end of window or read pointer */// The "t" variable was used for both a temp storage of values and return codes. " is 124.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "	/* copy input/output information to locals (UPDATE macro restores) */LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s); " is 123.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "			/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE); " is 135.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The length of the statement  "				returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z); " is 147.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The length of the statement  "	/* copy input/output information to locals (UPDATE macro restores) */InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s); " is 132.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The length of the statement  "	/* copy source pointer *//* load input' output' bit values */InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s); " is 124.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The length of the statement  "		/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z); " is 130.
Long Statement,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The length of the statement  "	/* Return Z_BUF_ERROR if we were given an incomplete table */return (y != 0 && g != 1) ? ReturnCode.Z_BUF_ERROR : ReturnCode.Z_OK; " is 130.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The length of the statement  "	/* index of last bit length code of non zero freq *//* Build the Huffman trees unless a stored block is forced */if (s.level > 0) { " is 131.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_tree,The length of the statement  "		/* Create a new node father of n and m */tree [node].freq_code = unchecked((ushort)(tree [n].freq_code + tree [m].freq_code)); " is 126.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_bl_tree,The length of the statement  "	/* index of last bit length code of non zero freq *//* Determine the bit length frequencies for literal and distance trees */scan_tree (s' s.dyn_ltree' s.l_desc.max_code); " is 171.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_bl_tree,The length of the statement  "	/* Update opt_len to include the bit length tree and counts */s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4)); " is 128.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The length of the statement  "			dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff))); " is 125.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The length of the statement  "			/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow"); " is 173.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The length of the statement  "	Debug.Assert (lcodes <= (int)XDeflate.Constant.L_CODES && dcodes <= (int)XDeflate.Constant.D_CODES && blcodes <= (int)XDeflate.Constant.BL_CODES' "too many codes"); " is 164.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,pqdownheap,The length of the statement  "		/* Set j to the smallest of the two sons: */if (j < s.heap_len && smaller (tree' s.heap [j + 1]' s.heap [j]' s.depth)) { " is 120.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,gen_codes,The length of the statement  "         */Debug.Assert (code + bl_count [(int)XDeflate.Constant.MAX_BITS] - 1 == (1 << (int)XDeflate.Constant.MAX_BITS) - 1' "inconsistent bit counts"); " is 144.
Long Statement,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,smaller,The length of the statement  "	return (tree [n].freq_code < tree [m].freq_code || (tree [n].freq_code == tree [m].freq_code && depth [n] <= depth [m])); " is 121.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The length of the statement  "	if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) { " is 239.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The length of the statement  "	if (strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (s.status == StreamStatus.FINISH_STATE && flush != FlushValue.Z_FINISH)) { " is 151.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The length of the statement  "	/* User must not provide more input after the first FINISH: */if (s.status == StreamStatus.FINISH_STATE && strm.avail_in != 0) { " is 128.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The length of the statement  "	/* Start a new block or continue the current one. */if (strm.avail_in != 0 || s.lookahead != 0 || (flush != FlushValue.Z_NO_FLUSH && s.status != StreamStatus.FINISH_STATE)) { " is 174.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_stored,The length of the statement  "			/* strstart == 0 is possible when wraparound on 16-bit machine *///System.Diagnostics.Debug.Assert( false' "The lines inside this \"if\" were never tested" ); " is 158.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_fast,The length of the statement  "	/* set if current block must be flushed */System.Diagnostics.Debug.Assert (s.method != (int)XZLib.Constant.Z_DEFLATED64); " is 121.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The length of the statement  "	/* set if current block must be flushed */System.Diagnostics.Debug.Assert (s.method != (int)XZLib.Constant.Z_DEFLATED64); " is 121.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The length of the statement  "			/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) { " is 215.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The length of the statement  "			/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush); " is 157.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,_tr_tally,The length of the statement  "		/* dist = match distance - 1 */System.Diagnostics.Debug.Assert (dist < s.max_dist && lc <= (s.max_match - (uint)Constant.MIN_MATCH) && Tree.d_code (dist) < (int)Constant.D_CODES' "_tr_tally: bad match"); " is 203.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The length of the statement  "         */if (s.window [match + best_len] != scan_end || s.window [match + best_len - 1] != scan_end1 || s.window [match] != s.window [scan] || s.window [++match] != s.window [scan + 1]) " is 178.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The length of the statement  "		while (s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && scan < strend); " is 366.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,FLUSH_BLOCK_ONLY,The length of the statement  "	Tree._tr_flush_block (s' (s.block_start >= 0 ? s.window : null)' s.block_start' unchecked((uint)(s.strstart - s.block_start))' eof); " is 132.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,InflateInit,The length of the statement  "	/* create inflate_blocks state */if ((((internal_state)z.state).blocks = InfBlock.inflate_blocks_new (ref z' ((internal_state)z.state).nowrap == 0' (uint)1 << w)) == null) { " is 173.
Long Statement,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,DeflateInit,The length of the statement  "	return XZLib.DeflateInit2 (strm' level' (int)Constant.Z_DEFLATED' (int)Constant.MAX_WBITS' (int)Constant.DEF_MEM_LEVEL' CompressionStrategy.Z_DEFAULT_STRATEGY); " is 160.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The conditional expression  "memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The conditional expression  "strm == null || strm.state == null || flush > FlushValue.Z_FINISH || flush < 0"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (s.status == StreamStatus.FINISH_STATE && flush != FlushValue.Z_FINISH)"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || s.lookahead != 0 || (flush != FlushValue.Z_NO_FLUSH && s.status != StreamStatus.FINISH_STATE)"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflateParams,The conditional expression  "level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The conditional expression  "s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The conditional expression  "s.window [match + best_len] != scan_end || s.window [match + best_len - 1] != scan_end1 || s.window [match] != s.window [scan] || s.window [++match] != s.window [scan + 1]"  is complex.
Complex Conditional,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The conditional expression  "s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && scan < strend"  is complex.
Virtual Method Call from Constructor,Xceed.GZip,GZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZippedFile.cs,GZippedFile,The constructor "GZippedFile" calls a virtual method "CreateSession".
Virtual Method Call from Constructor,Xceed.GZip,GZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZippedFile.cs,GZippedFile,The constructor "GZippedFile" calls a virtual method "CreateSession".
Virtual Method Call from Constructor,Xceed.GZip,GZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZippedFolder.cs,GZippedFolder,The constructor "GZippedFolder" calls a virtual method "CreateSession".
Empty Catch Block,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,SetBatchUpdateable,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,OpenWriteStorageFile,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,ReleaseReference,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,The method has an empty catch block.
Magic Number,Xceed.GZip,GZipStorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageHandler.cs,GetStorageHandler,The following statement contains a magic number: lock (mg_handlers.SyncRoot) {  	// Check if already in list and return reference.  	if (mg_handlers.Contains (gzipFile)) {  		WeakReference weakHandler = mg_handlers [gzipFile] as WeakReference;  		if (weakHandler == null) {  			System.Diagnostics.Debug.Fail ("The WeakReference's Target can become null' but the ref itself shouldn't.");  			// Clean up!  			mg_handlers.Remove (gzipFile);  		}  		else {  			handler = weakHandler.Target as GZipStorageHandler;  			if (handler == null) {  				// Clean up!  				mg_handlers.Remove (gzipFile);  			}  		}  	}  	if (handler == null) {  		if (mg_lastCleanupCount + 50 < mg_handlers.Count) {  			CleanStorageHandlers ();  		}  		// GZipStorageHandler not found' add it to the list in a weak reference  		handler = new GZipStorageHandler (session' gzipFile);  		mg_handlers.Add (gzipFile' new WeakReference (handler));  	}  }  
Magic Number,Xceed.GZip,GZipStorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageHandler.cs,GetStorageHandler,The following statement contains a magic number: if (handler == null) {  	if (mg_lastCleanupCount + 50 < mg_handlers.Count) {  		CleanStorageHandlers ();  	}  	// GZipStorageHandler not found' add it to the list in a weak reference  	handler = new GZipStorageHandler (session' gzipFile);  	mg_handlers.Add (gzipFile' new WeakReference (handler));  }  
Magic Number,Xceed.GZip,GZipStorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageHandler.cs,GetStorageHandler,The following statement contains a magic number: if (mg_lastCleanupCount + 50 < mg_handlers.Count) {  	CleanStorageHandlers ();  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if (fixedHeader.Length >= 2) {  	if (BitConverter.ToUInt16 (fixedHeader' 0) != Signature)  		throw new InvalidGZipStructureException ("A GZIP signature was not found where one was expected.");  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if (fixedHeader.Length != 10)  	throw new FileSystemIOException ("Incomplete GZIP header. Premature end of stream reached.");  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: size += 10;  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: m_compressionMethod = fixedHeader [2];  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: m_flags = (GZipFlags)fixedHeader [3];  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: m_modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: m_extraFlags = (GZipExtraFlags)fixedHeader [8];  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: m_operatingSystem = (GZipOperatingSystem)fixedHeader [9];  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if ((m_flags & GZipFlags.HasExtraHeader) == GZipFlags.HasExtraHeader) {  	ushort extraHeaderLen = reader.ReadUInt16 ();  	m_extraHeader = reader.ReadBytes (extraHeaderLen);  	if (m_extraHeader.Length != extraHeaderLen)  		throw new FileSystemIOException ("Incomplete GZIP header. Premature end of stream reached.");  	size += extraHeaderLen;  	if (headerCRC) {  		calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (extraHeaderLen)' 0' 2' calculatedCRC);  		calculatedCRC = ChecksumStream.CalculateCrc32 (m_extraHeader' 0' m_extraHeader.Length' calculatedCRC);  	}  }  else {  	m_extraHeader = null;  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if (headerCRC) {  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (extraHeaderLen)' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (m_extraHeader' 0' m_extraHeader.Length' calculatedCRC);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (extraHeaderLen)' 0' 2' calculatedCRC);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if ((m_flags & GZipFlags.HasFilename) == GZipFlags.HasFilename) {  	// Though the filename field as no size limit' we consider 2k  	// to be the maximum acceptable filename length.  	byte[] filename = new byte[2048];  	int count = 0;  	do {  		if (count == filename.Length)  			throw new FileSystemNotSupportedException ("Filename too long or invalid."' null);  		if ((filename [count++] = reader.ReadByte ()) == 0)  			break;  	}  	while (true);  	size += count;  	m_filenameSize = count;  	if (headerCRC) {  		calculatedCRC = ChecksumStream.CalculateCrc32 (filename' 0' count' calculatedCRC);  	}  	System.Diagnostics.Debug.Assert (count > 0' "The loop above is always running at least once' thus should have incremented count.");  	// Do not include the terminating null-char in the translation.  	m_fullName = LatinEncoder.GetString (filename' 0' count - 1);  	// There should be no separator char.  	if (m_fullName.IndexOfAny (new char[] {  		Path.DirectorySeparatorChar'  		Path.AltDirectorySeparatorChar  	}) != -1) {  		System.Diagnostics.Debug.Fail ("A filename in the GZIP archive contains a path.");  		// This method supports both slash and backslash.  		m_fullName = Path.GetFileName (m_fullName);  	}  	// We keep name with the leading separator' for performance.  	m_fullName = Path.DirectorySeparatorChar.ToString () + m_fullName;  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if ((m_flags & GZipFlags.HasComment) == GZipFlags.HasComment) {  	// Though the comment field has no size limit' we consider 64k   	// to be the maximum acceptable comment.  	byte[] comment = new byte[65536];  	int count = 0;  	do {  		if (count == comment.Length)  			throw new FileSystemNotSupportedException ("Comment too long or invalid."' null);  		if ((comment [count++] = reader.ReadByte ()) == 0)  			break;  	}  	while (true);  	size += count;  	m_commentSize = count;  	if (headerCRC) {  		calculatedCRC = ChecksumStream.CalculateCrc32 (comment' 0' count' calculatedCRC);  	}  	System.Diagnostics.Debug.Assert (count > 0' "The loop above is always running at least once' thus should have incremented count.");  	// Do not include the terminating null-char in the translation.  	m_comment = LatinEncoder.GetString (comment' 0' count - 1);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if (headerCRC) {  	ushort readCRC = reader.ReadUInt16 ();  	ushort lowCRC = unchecked((ushort)(calculatedCRC & 0xffff));  	size += 2;  	if (readCRC != lowCRC) {  		// Some other products actually folded the high and low parts or the CRC32  		// to form the CRC16. We support this when reading.  		ushort foldedCRC = unchecked((ushort)((calculatedCRC >> 16) | (calculatedCRC & 0xffff)));  		if (readCRC != foldedCRC)  			throw new InvalidGZipStructureException ("The header's reported checksum differs from the calculated checksum.");  	}  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if (headerCRC) {  	ushort readCRC = reader.ReadUInt16 ();  	ushort lowCRC = unchecked((ushort)(calculatedCRC & 0xffff));  	size += 2;  	if (readCRC != lowCRC) {  		// Some other products actually folded the high and low parts or the CRC32  		// to form the CRC16. We support this when reading.  		ushort foldedCRC = unchecked((ushort)((calculatedCRC >> 16) | (calculatedCRC & 0xffff)));  		if (readCRC != foldedCRC)  			throw new InvalidGZipStructureException ("The header's reported checksum differs from the calculated checksum.");  	}  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: size += 2;  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if (readCRC != lowCRC) {  	// Some other products actually folded the high and low parts or the CRC32  	// to form the CRC16. We support this when reading.  	ushort foldedCRC = unchecked((ushort)((calculatedCRC >> 16) | (calculatedCRC & 0xffff)));  	if (readCRC != foldedCRC)  		throw new InvalidGZipStructureException ("The header's reported checksum differs from the calculated checksum.");  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,ReadHeader,The following statement contains a magic number: if (m_compressionMethod != 8)  	throw new FileSystemNotSupportedException ("Unsupported compression method."' null);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: System.Diagnostics.Debug.Assert (m_compressionMethod == 8' "Hardcoded compression method for now. Should become parameter.");  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: try {  	state.next_out = new byte[32768];  	state.next_in = new byte[8];  	do {  		if (state.avail_in == 0) {  			int read = source.Read (state.next_in' 0' state.next_in.Length);  			if (read == 0)  				throw new FileSystemIOException ("Unexpected end of stream reached before reading all the compressed data.");  			state.next_in_index = 0;  			state.avail_in = unchecked((uint)read);  		}  		// We forget about any uncompressed data every loop.  		state.avail_out = unchecked((uint)state.next_out.Length);  		state.next_out_index = 0;  		ReturnCode code = XZLib.Inflate (ref state' FlushValue.Z_NO_FLUSH);  		if (code == ReturnCode.Z_STREAM_END)  			break;  		if (code != ReturnCode.Z_OK)  			throw new FileSystemIOException ("An error occurred while decompressing the data.");  	}  	while (true);  	if (state.avail_in + state.next_in_index != 8)  		throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  	byte[] footer = new byte[8];  	int footerCount = 0;  	if (state.avail_in > 0) {  		#if ( XCEEDCF )  		          Array.Copy( state.next_in' ( int )state.next_in_index' footer' 0' ( int )state.avail_in ); #else  		Array.Copy (state.next_in' state.next_in_index' footer' 0' state.avail_in);  		#endif  		footerCount = unchecked((int)state.avail_in);  	}  	while (footerCount < footer.Length) {  		int read = source.Read (footer' footerCount' footer.Length - footerCount);  		if (read == 0)  			throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  		footerCount += read;  	}  	m_crc32 = BitConverter.ToUInt32 (footer' 0);  	m_size = (long)BitConverter.ToUInt32 (footer' 4);  	return unchecked((long)state.total_in + footer.Length);  }  finally {  	XZLib.InflateEnd (ref state);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: try {  	state.next_out = new byte[32768];  	state.next_in = new byte[8];  	do {  		if (state.avail_in == 0) {  			int read = source.Read (state.next_in' 0' state.next_in.Length);  			if (read == 0)  				throw new FileSystemIOException ("Unexpected end of stream reached before reading all the compressed data.");  			state.next_in_index = 0;  			state.avail_in = unchecked((uint)read);  		}  		// We forget about any uncompressed data every loop.  		state.avail_out = unchecked((uint)state.next_out.Length);  		state.next_out_index = 0;  		ReturnCode code = XZLib.Inflate (ref state' FlushValue.Z_NO_FLUSH);  		if (code == ReturnCode.Z_STREAM_END)  			break;  		if (code != ReturnCode.Z_OK)  			throw new FileSystemIOException ("An error occurred while decompressing the data.");  	}  	while (true);  	if (state.avail_in + state.next_in_index != 8)  		throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  	byte[] footer = new byte[8];  	int footerCount = 0;  	if (state.avail_in > 0) {  		#if ( XCEEDCF )  		          Array.Copy( state.next_in' ( int )state.next_in_index' footer' 0' ( int )state.avail_in ); #else  		Array.Copy (state.next_in' state.next_in_index' footer' 0' state.avail_in);  		#endif  		footerCount = unchecked((int)state.avail_in);  	}  	while (footerCount < footer.Length) {  		int read = source.Read (footer' footerCount' footer.Length - footerCount);  		if (read == 0)  			throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  		footerCount += read;  	}  	m_crc32 = BitConverter.ToUInt32 (footer' 0);  	m_size = (long)BitConverter.ToUInt32 (footer' 4);  	return unchecked((long)state.total_in + footer.Length);  }  finally {  	XZLib.InflateEnd (ref state);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: try {  	state.next_out = new byte[32768];  	state.next_in = new byte[8];  	do {  		if (state.avail_in == 0) {  			int read = source.Read (state.next_in' 0' state.next_in.Length);  			if (read == 0)  				throw new FileSystemIOException ("Unexpected end of stream reached before reading all the compressed data.");  			state.next_in_index = 0;  			state.avail_in = unchecked((uint)read);  		}  		// We forget about any uncompressed data every loop.  		state.avail_out = unchecked((uint)state.next_out.Length);  		state.next_out_index = 0;  		ReturnCode code = XZLib.Inflate (ref state' FlushValue.Z_NO_FLUSH);  		if (code == ReturnCode.Z_STREAM_END)  			break;  		if (code != ReturnCode.Z_OK)  			throw new FileSystemIOException ("An error occurred while decompressing the data.");  	}  	while (true);  	if (state.avail_in + state.next_in_index != 8)  		throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  	byte[] footer = new byte[8];  	int footerCount = 0;  	if (state.avail_in > 0) {  		#if ( XCEEDCF )  		          Array.Copy( state.next_in' ( int )state.next_in_index' footer' 0' ( int )state.avail_in ); #else  		Array.Copy (state.next_in' state.next_in_index' footer' 0' state.avail_in);  		#endif  		footerCount = unchecked((int)state.avail_in);  	}  	while (footerCount < footer.Length) {  		int read = source.Read (footer' footerCount' footer.Length - footerCount);  		if (read == 0)  			throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  		footerCount += read;  	}  	m_crc32 = BitConverter.ToUInt32 (footer' 0);  	m_size = (long)BitConverter.ToUInt32 (footer' 4);  	return unchecked((long)state.total_in + footer.Length);  }  finally {  	XZLib.InflateEnd (ref state);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: try {  	state.next_out = new byte[32768];  	state.next_in = new byte[8];  	do {  		if (state.avail_in == 0) {  			int read = source.Read (state.next_in' 0' state.next_in.Length);  			if (read == 0)  				throw new FileSystemIOException ("Unexpected end of stream reached before reading all the compressed data.");  			state.next_in_index = 0;  			state.avail_in = unchecked((uint)read);  		}  		// We forget about any uncompressed data every loop.  		state.avail_out = unchecked((uint)state.next_out.Length);  		state.next_out_index = 0;  		ReturnCode code = XZLib.Inflate (ref state' FlushValue.Z_NO_FLUSH);  		if (code == ReturnCode.Z_STREAM_END)  			break;  		if (code != ReturnCode.Z_OK)  			throw new FileSystemIOException ("An error occurred while decompressing the data.");  	}  	while (true);  	if (state.avail_in + state.next_in_index != 8)  		throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  	byte[] footer = new byte[8];  	int footerCount = 0;  	if (state.avail_in > 0) {  		#if ( XCEEDCF )  		          Array.Copy( state.next_in' ( int )state.next_in_index' footer' 0' ( int )state.avail_in ); #else  		Array.Copy (state.next_in' state.next_in_index' footer' 0' state.avail_in);  		#endif  		footerCount = unchecked((int)state.avail_in);  	}  	while (footerCount < footer.Length) {  		int read = source.Read (footer' footerCount' footer.Length - footerCount);  		if (read == 0)  			throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  		footerCount += read;  	}  	m_crc32 = BitConverter.ToUInt32 (footer' 0);  	m_size = (long)BitConverter.ToUInt32 (footer' 4);  	return unchecked((long)state.total_in + footer.Length);  }  finally {  	XZLib.InflateEnd (ref state);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: try {  	state.next_out = new byte[32768];  	state.next_in = new byte[8];  	do {  		if (state.avail_in == 0) {  			int read = source.Read (state.next_in' 0' state.next_in.Length);  			if (read == 0)  				throw new FileSystemIOException ("Unexpected end of stream reached before reading all the compressed data.");  			state.next_in_index = 0;  			state.avail_in = unchecked((uint)read);  		}  		// We forget about any uncompressed data every loop.  		state.avail_out = unchecked((uint)state.next_out.Length);  		state.next_out_index = 0;  		ReturnCode code = XZLib.Inflate (ref state' FlushValue.Z_NO_FLUSH);  		if (code == ReturnCode.Z_STREAM_END)  			break;  		if (code != ReturnCode.Z_OK)  			throw new FileSystemIOException ("An error occurred while decompressing the data.");  	}  	while (true);  	if (state.avail_in + state.next_in_index != 8)  		throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  	byte[] footer = new byte[8];  	int footerCount = 0;  	if (state.avail_in > 0) {  		#if ( XCEEDCF )  		          Array.Copy( state.next_in' ( int )state.next_in_index' footer' 0' ( int )state.avail_in ); #else  		Array.Copy (state.next_in' state.next_in_index' footer' 0' state.avail_in);  		#endif  		footerCount = unchecked((int)state.avail_in);  	}  	while (footerCount < footer.Length) {  		int read = source.Read (footer' footerCount' footer.Length - footerCount);  		if (read == 0)  			throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  		footerCount += read;  	}  	m_crc32 = BitConverter.ToUInt32 (footer' 0);  	m_size = (long)BitConverter.ToUInt32 (footer' 4);  	return unchecked((long)state.total_in + footer.Length);  }  finally {  	XZLib.InflateEnd (ref state);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: state.next_out = new byte[32768];  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: state.next_in = new byte[8];  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: if (state.avail_in + state.next_in_index != 8)  	throw new FileSystemIOException ("Unexpected end of stream reached before reading the GZIP footer.");  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,SkipData,The following statement contains a magic number: m_size = (long)BitConverter.ToUInt32 (footer' 4);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: size += 10;  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (headerCRC) {  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (Signature)' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		m_compressionMethod'  		(byte)m_flags  	}' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (m_modifiedTime)' 0' 4' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		(byte)m_extraFlags'  		(byte)m_operatingSystem  	}' 0' 2' calculatedCRC);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (headerCRC) {  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (Signature)' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		m_compressionMethod'  		(byte)m_flags  	}' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (m_modifiedTime)' 0' 4' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		(byte)m_extraFlags'  		(byte)m_operatingSystem  	}' 0' 2' calculatedCRC);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (headerCRC) {  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (Signature)' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		m_compressionMethod'  		(byte)m_flags  	}' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (m_modifiedTime)' 0' 4' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		(byte)m_extraFlags'  		(byte)m_operatingSystem  	}' 0' 2' calculatedCRC);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (headerCRC) {  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (Signature)' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		m_compressionMethod'  		(byte)m_flags  	}' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (m_modifiedTime)' 0' 4' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  		(byte)m_extraFlags'  		(byte)m_operatingSystem  	}' 0' 2' calculatedCRC);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (Signature)' 0' 2' calculatedCRC);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  	m_compressionMethod'  	(byte)m_flags  }' 0' 2' calculatedCRC);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (m_modifiedTime)' 0' 4' calculatedCRC);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: calculatedCRC = ChecksumStream.CalculateCrc32 (new byte[] {  	(byte)m_extraFlags'  	(byte)m_operatingSystem  }' 0' 2' calculatedCRC);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (this.HasExtraHeader) {  	ushort length = unchecked((ushort)m_extraHeader.Length);  	writer.Write (length);  	writer.Write (m_extraHeader);  	size += length + 2;  	if (headerCRC) {  		calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (length)' 0' 2' calculatedCRC);  		calculatedCRC = ChecksumStream.CalculateCrc32 (m_extraHeader' 0' m_extraHeader.Length' calculatedCRC);  	}  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (this.HasExtraHeader) {  	ushort length = unchecked((ushort)m_extraHeader.Length);  	writer.Write (length);  	writer.Write (m_extraHeader);  	size += length + 2;  	if (headerCRC) {  		calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (length)' 0' 2' calculatedCRC);  		calculatedCRC = ChecksumStream.CalculateCrc32 (m_extraHeader' 0' m_extraHeader.Length' calculatedCRC);  	}  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: size += length + 2;  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (headerCRC) {  	calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (length)' 0' 2' calculatedCRC);  	calculatedCRC = ChecksumStream.CalculateCrc32 (m_extraHeader' 0' m_extraHeader.Length' calculatedCRC);  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: calculatedCRC = ChecksumStream.CalculateCrc32 (BitConverter.GetBytes (length)' 0' 2' calculatedCRC);  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: if (headerCRC) {  	writer.Write (unchecked((ushort)(calculatedCRC & 0xffff)));  	size += 2;  }  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,WriteHeader,The following statement contains a magic number: size += 2;  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,CalculateHeaderSize,The following statement contains a magic number: m_calculatedSize = 10 + ((this.HasExtraHeader) ? (m_extraHeader.Length + 2) : (0)) + ((this.HasFilename) ? (m_filenameSize) : (0)) + ((this.HasComment) ? (m_commentSize) : (0)) + ((this.HasHeaderChecksum) ? (2) : (0));  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,CalculateHeaderSize,The following statement contains a magic number: m_calculatedSize = 10 + ((this.HasExtraHeader) ? (m_extraHeader.Length + 2) : (0)) + ((this.HasFilename) ? (m_filenameSize) : (0)) + ((this.HasComment) ? (m_commentSize) : (0)) + ((this.HasHeaderChecksum) ? (2) : (0));  
Magic Number,Xceed.GZip,GZipStorageItem,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItem.cs,CalculateHeaderSize,The following statement contains a magic number: m_calculatedSize = 10 + ((this.HasExtraHeader) ? (m_extraHeader.Length + 2) : (0)) + ((this.HasFilename) ? (m_filenameSize) : (0)) + ((this.HasComment) ? (m_commentSize) : (0)) + ((this.HasHeaderChecksum) ? (2) : (0));  
Magic Number,Xceed.GZip,GZipStorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\GZipStorageItemHandler.cs,FullNameTooLong,The following statement contains a magic number: return path.Length + name.Length >= 2048;  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)((dateTime.Year - 1980) << 9);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)((dateTime.Year - 1980) << 9);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)(dateTime.Month << 5);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Hour << 11);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Minute << 5);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Second / 2);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToUnixDateTime,The following statement contains a magic number: fileTime /= 10000000;  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Dates\Dates.cs,ToUnixDateTime,The following statement contains a magic number: System.Diagnostics.Debug.Assert ((fileTime >> 32) == 0' "This date is bigger than what can handle a time_t");  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (needsUpdate) {  	// Before changing our offset' we need to seek to our data.  	if (item.Location.DataSize > 0) {  		uint itemDiskNumber = item.Location.DiskNumber;  		if (itemDiskNumber != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  		}  		OnMoveItemsSeekToData (session' sourceStream' item);  	}  	if (spannedDestStream != null)  		item.Location.DiskNumber = spannedDestStream.DiskNumber;  	else  		item.Location.DiskNumber = destStorage.CurrentDiskNumber;  	// Remember current offset  	item.Location.Offset = destStream.Position;  	// Write Header  	item.Location.HeaderSize = item.WriteHeader (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.HeaderSize);  	// Move existing data if present' or write empty data if newly created.  	if (item.Location.DataSize > 0) {  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  	}  	else {  		item.Location.DataSize = item.WriteEmptyData (destStream);  	}  	// Write the footer.  	item.Location.FooterSize = item.WriteFooter (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.FooterSize);  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  	}  	if (session != null)  		OnItemMoved (session' item' destStream);  	// The item is responsible for updating its state.  	System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (needsUpdate) {  	// Before changing our offset' we need to seek to our data.  	if (item.Location.DataSize > 0) {  		uint itemDiskNumber = item.Location.DiskNumber;  		if (itemDiskNumber != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  		}  		OnMoveItemsSeekToData (session' sourceStream' item);  	}  	if (spannedDestStream != null)  		item.Location.DiskNumber = spannedDestStream.DiskNumber;  	else  		item.Location.DiskNumber = destStorage.CurrentDiskNumber;  	// Remember current offset  	item.Location.Offset = destStream.Position;  	// Write Header  	item.Location.HeaderSize = item.WriteHeader (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.HeaderSize);  	// Move existing data if present' or write empty data if newly created.  	if (item.Location.DataSize > 0) {  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  	}  	else {  		item.Location.DataSize = item.WriteEmptyData (destStream);  	}  	// Write the footer.  	item.Location.FooterSize = item.WriteFooter (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.FooterSize);  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  	}  	if (session != null)  		OnItemMoved (session' item' destStream);  	// The item is responsible for updating its state.  	System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.Location.DataSize > 0) {  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  }  else {  	item.Location.DataSize = item.WriteEmptyData (destStream);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.Location.DataSize > 0) {  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  }  else {  	item.Location.DataSize = item.WriteEmptyData (destStream);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  }  else {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  }  else {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageItemHandler.cs,GetNextUniqueFullName,The following statement contains a magic number: if (m_duplicateIndex == 0) {  	string fullName = this.FullName;  	string name = this.Name;  	// First time we get called. We must determine the fixed path  	// and dynamic name pattern.  	int lastSeparator = fullName.LastIndexOf (Path.DirectorySeparatorChar);  	System.Diagnostics.Debug.Assert (lastSeparator != -1' "The FullName must at least be rooted.");  	m_duplicatePath = fullName.Substring (0' lastSeparator + 1);  	string _filename' _extension;  	#if USE_XCEED_UTILS_PATHS  	_filename = Xceed.Utils.Paths.Path.GetFileNameWithoutExtensionSimple (name);  	_extension = Xceed.Utils.Paths.Path.GetExtensionSimple (name);  	#else  	        _filename = Path.GetFileNameWithoutExtension( name );         _extension = Path.GetExtension( name );         #endif  	m_duplicateName = _filename;  	m_duplicateExtension = "{{{0}}}" + _extension;  	// This pair may exceed the limit' but it will get handled below.  	m_duplicateIndex = 2;  }  
Magic Number,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Storage\StorageItemHandler.cs,GetNextUniqueFullName,The following statement contains a magic number: m_duplicateIndex = 2;  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: while (--count >= 0) {  	previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,UniqueCrc32,The following statement contains a magic number: return (uint)(crcTable [(crc ^ input) & 0xff] ^ (crc >> 8));  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: k -= 16;  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,The following statement contains a magic number: if (m_innerStream.CanRead) {  	byte[] buffer = new byte[(skip < 32768 ? skip : 32768)];  	while (skip != 0) {  		// We call our public implementation so it updates our position.  		int read = this.Read (buffer' 0' unchecked((int)(skip < buffer.Length ? skip : buffer.Length)));  		// Have we reached the end of the stream? It's accepted to seek behond  		// the end of the stream.  		if (read == 0)  			break;  		skip -= read;  	}  }  else if (skip != 0) {  	throw new NotSupportedException ("Cannot seek a non-seekable write-only stream.");  }  
Magic Number,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,The following statement contains a magic number: if (m_innerStream.CanRead) {  	byte[] buffer = new byte[(skip < 32768 ? skip : 32768)];  	while (skip != 0) {  		// We call our public implementation so it updates our position.  		int read = this.Read (buffer' 0' unchecked((int)(skip < buffer.Length ? skip : buffer.Length)));  		// Have we reached the end of the stream? It's accepted to seek behond  		// the end of the stream.  		if (read == 0)  			break;  		skip -= read;  	}  }  else if (skip != 0) {  	throw new NotSupportedException ("Cannot seek a non-seekable write-only stream.");  }  
Magic Number,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The following statement contains a magic number: return StreamCopy.Copy (source' dest' size' 8192' null);  
Magic Number,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The following statement contains a magic number: return StreamCopy.Copy (source' dest' size' 8192' onBytesWritten);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (true) {  	switch (s.mode) {  	case inflate_block_mode.TYPE:  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		t = b & 7;  		s.last = t & 1;  		switch (t >> 1) {  		case 0:  			/* stored */DUMPBITS (3' ref b' ref k);  			t = k & 7;  			/* go to byte boundary */DUMPBITS (t' ref b' ref k);  			s.mode = inflate_block_mode.LENS;  			/* get length of stored block */break;  		case 1:  			/* fixed */{  				uint bl = 0;  				uint bd = 0;  				InfTrees.inflate_huft[] tl = null;  				InfTrees.inflate_huft[] td = null;  				InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  				s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  				if (s.codes == null) {  					r = ReturnCode.Z_MEM_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  			}  			DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.CODES;  			break;  		case 2:  			/* dynamic */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.TABLE;  			break;  		case 3:  			/* illegal */DUMPBITS (3' ref b' ref k);  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid block type";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		break;  	case inflate_block_mode.LENS:  		if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		// Check that the block len bits are equal to the len 1's complement that follow  		if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid stored block lengths";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.left = b & 0xffff;  		b = k = 0;  		/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  		break;  	case inflate_block_mode.STORED:  		if (n == 0)  			return LEAVE (b' k' n' p' q' s' z' r);  		{  			if (m == 0) {  				WRAP (ref q' ref m' s);  				if (m == 0) {  					FLUSH (s' z' ref m' ref q' ref r);  					WRAP (ref q' ref m' s);  					if (m == 0) {  						UPDATE (s' z' b' k' n' p' q);  						return inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		t = s.left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		try {  			Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  		}  		catch (ArgumentOutOfRangeException) {  			z.msg = "Out of range exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (ArgumentException) {  			z.msg = "Argument exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		catch (Exception) {  			z.msg = "Unknown exception";  			r = ReturnCode.Z_INTERNAL_ERROR;  			LEAVE (b' k' n' p' q' s' z' r);  		}  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((s.left -= t) != 0)  			break;  		s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  		break;  	case inflate_block_mode.TABLE:  		if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			s.mode = inflate_block_mode.BAD;  			z.msg = "too many length or distance symbols";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		s.blens = new uint[t];  		DUMPBITS (14' ref b' ref k);  		s.index = 0;  		s.mode = inflate_block_mode.BTREE;  		break;  	case inflate_block_mode.BTREE:  		while (s.index < 4 + (s.table >> 10)) {  			if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  				return r;  			}  			s.blens [border [s.index++]] = b & 7;  			DUMPBITS (3' ref b' ref k);  		}  		while (s.index < 19)  			s.blens [border [s.index++]] = 0;  		s.bb = 7;  		returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  			r = returnCode;  			if (r == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.index = 0;  		s.mode = inflate_block_mode.DTREE;  		break;  	case inflate_block_mode.DTREE:  		t = s.table;  		while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  			InfTrees.inflate_huft h = null;  			uint i' j' c;  			t = s.bb;  			if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			h = s.tb [(b & inflate_mask [t])];  			t = h.bits;  			c = h._base;  			if (c < 16) {  				DUMPBITS (t' ref b' ref k);  				s.blens [s.index++] = c;  			}  			else/* c == 16..18 */ {  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11u : 3u;  				if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  					return r;  				DUMPBITS (t' ref b' ref k);  				j += (b & inflate_mask [i]);  				DUMPBITS (i' ref b' ref k);  				i = s.index;  				t = s.table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  					z.msg = "invalid bit length repeat";  					r = ReturnCode.Z_DATA_ERROR;  					return LEAVE (b' k' n' p' q' s' z' r);  				}  				c = c == 16 ? s.blens [i - 1] : 0;  				do {  					s.blens [i++] = c;  				}  				while ((--j) != 0);  				s.index = i;  			}  			t = s.table;  		}  		// end of while  		s.tb = null;  		{  			uint bl;  			uint bd;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfCodes.inflate_codes_state c = null;  			bl = 9;  			/* must be <= 9 for lookahead assumptions */bd = 6;  			/* must be <= 9 for lookahead assumptions */t = s.table;  			returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  			if (returnCode != ReturnCode.Z_OK) {  				if (returnCode == ReturnCode.Z_DATA_ERROR) {  					s.blens = null;  					s.mode = inflate_block_mode.BAD;  				}  				r = returnCode;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			s.codes = c;  		}  		s.blens = null;  		s.mode = inflate_block_mode.CODES;  		break;  	case inflate_block_mode.CODES:  		UPDATE (s' z' b' k' n' p' q);  		if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  			return inflate_flush (s' z' r);  		r = ReturnCode.Z_OK;  		InfCodes.inflate_codes_free (ref s.codes);  		LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (s.last == 0) {  			s.mode = inflate_block_mode.TYPE;  			break;  		}  		s.mode = inflate_block_mode.DRY;  		break;  	case inflate_block_mode.DRY:  		FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.mode = inflate_block_mode.DONE;  		break;  	case inflate_block_mode.DONE:  		r = ReturnCode.Z_STREAM_END;  		return LEAVE (b' k' n' p' q' s' z' r);  	case inflate_block_mode.BAD:  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (s.mode) {  case inflate_block_mode.TYPE:  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	t = b & 7;  	s.last = t & 1;  	switch (t >> 1) {  	case 0:  		/* stored */DUMPBITS (3' ref b' ref k);  		t = k & 7;  		/* go to byte boundary */DUMPBITS (t' ref b' ref k);  		s.mode = inflate_block_mode.LENS;  		/* get length of stored block */break;  	case 1:  		/* fixed */{  			uint bl = 0;  			uint bd = 0;  			InfTrees.inflate_huft[] tl = null;  			InfTrees.inflate_huft[] td = null;  			InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  			s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  			if (s.codes == null) {  				r = ReturnCode.Z_MEM_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  		}  		DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.CODES;  		break;  	case 2:  		/* dynamic */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.TABLE;  		break;  	case 3:  		/* illegal */DUMPBITS (3' ref b' ref k);  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid block type";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	break;  case inflate_block_mode.LENS:  	if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	// Check that the block len bits are equal to the len 1's complement that follow  	if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid stored block lengths";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.left = b & 0xffff;  	b = k = 0;  	/* dump bits */s.mode = (s.left != 0) ? inflate_block_mode.STORED : ((s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE);  	break;  case inflate_block_mode.STORED:  	if (n == 0)  		return LEAVE (b' k' n' p' q' s' z' r);  	{  		if (m == 0) {  			WRAP (ref q' ref m' s);  			if (m == 0) {  				FLUSH (s' z' ref m' ref q' ref r);  				WRAP (ref q' ref m' s);  				if (m == 0) {  					UPDATE (s' z' b' k' n' p' q);  					return inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	t = s.left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	try {  		Array.Copy (z.next_in' (int)p' s.window' (int)q' (int)t);  	}  	catch (ArgumentOutOfRangeException) {  		z.msg = "Out of range exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (ArgumentException) {  		z.msg = "Argument exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	catch (Exception) {  		z.msg = "Unknown exception";  		r = ReturnCode.Z_INTERNAL_ERROR;  		LEAVE (b' k' n' p' q' s' z' r);  	}  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((s.left -= t) != 0)  		break;  	s.mode = (s.last != 0) ? inflate_block_mode.DRY : inflate_block_mode.TYPE;  	break;  case inflate_block_mode.TABLE:  	if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		s.mode = inflate_block_mode.BAD;  		z.msg = "too many length or distance symbols";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	s.blens = new uint[t];  	DUMPBITS (14' ref b' ref k);  	s.index = 0;  	s.mode = inflate_block_mode.BTREE;  	break;  case inflate_block_mode.BTREE:  	while (s.index < 4 + (s.table >> 10)) {  		if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		s.blens [border [s.index++]] = b & 7;  		DUMPBITS (3' ref b' ref k);  	}  	while (s.index < 19)  		s.blens [border [s.index++]] = 0;  	s.bb = 7;  	returnCode = InfTrees.inflate_trees_bits (s.blens' ref s.bb' ref s.tb' s.hufts' z);  	if (returnCode != ReturnCode.Z_OK) {  		System.Diagnostics.Debug.Assert (false' "The lines in this \"if\" were never tested");  		r = returnCode;  		if (r == ReturnCode.Z_DATA_ERROR) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  		}  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.index = 0;  	s.mode = inflate_block_mode.DTREE;  	break;  case inflate_block_mode.DTREE:  	t = s.table;  	while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  		InfTrees.inflate_huft h = null;  		uint i' j' c;  		t = s.bb;  		if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		h = s.tb [(b & inflate_mask [t])];  		t = h.bits;  		c = h._base;  		if (c < 16) {  			DUMPBITS (t' ref b' ref k);  			s.blens [s.index++] = c;  		}  		else/* c == 16..18 */ {  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11u : 3u;  			if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  				return r;  			DUMPBITS (t' ref b' ref k);  			j += (b & inflate_mask [i]);  			DUMPBITS (i' ref b' ref k);  			i = s.index;  			t = s.table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  				z.msg = "invalid bit length repeat";  				r = ReturnCode.Z_DATA_ERROR;  				return LEAVE (b' k' n' p' q' s' z' r);  			}  			c = c == 16 ? s.blens [i - 1] : 0;  			do {  				s.blens [i++] = c;  			}  			while ((--j) != 0);  			s.index = i;  		}  		t = s.table;  	}  	// end of while  	s.tb = null;  	{  		uint bl;  		uint bd;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfCodes.inflate_codes_state c = null;  		bl = 9;  		/* must be <= 9 for lookahead assumptions */bd = 6;  		/* must be <= 9 for lookahead assumptions */t = s.table;  		returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  		if (returnCode != ReturnCode.Z_OK) {  			if (returnCode == ReturnCode.Z_DATA_ERROR) {  				s.blens = null;  				s.mode = inflate_block_mode.BAD;  			}  			r = returnCode;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		if ((c = InfCodes.inflate_codes_new (bl' bd' tl' td)) == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		s.codes = c;  	}  	s.blens = null;  	s.mode = inflate_block_mode.CODES;  	break;  case inflate_block_mode.CODES:  	UPDATE (s' z' b' k' n' p' q);  	if ((r = InfCodes.inflate_codes (s' z' r)) != ReturnCode.Z_STREAM_END)  		return inflate_flush (s' z' r);  	r = ReturnCode.Z_OK;  	InfCodes.inflate_codes_free (ref s.codes);  	LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (s.last == 0) {  		s.mode = inflate_block_mode.TYPE;  		break;  	}  	s.mode = inflate_block_mode.DRY;  	break;  case inflate_block_mode.DRY:  	FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	s.mode = inflate_block_mode.DONE;  	break;  case inflate_block_mode.DONE:  	r = ReturnCode.Z_STREAM_END;  	return LEAVE (b' k' n' p' q' s' z' r);  case inflate_block_mode.BAD:  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = b & 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = k & 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (32' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid stored block lengths";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (14' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "too many length or distance symbols";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "too many length or distance symbols";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	s.mode = inflate_block_mode.BAD;  	z.msg = "too many length or distance symbols";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (14' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 4 + (s.table >> 10)) {  	if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	s.blens [border [s.index++]] = b & 7;  	DUMPBITS (3' ref b' ref k);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (!NEEDBITS (3' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: s.blens [border [s.index++]] = b & 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: DUMPBITS (3' ref b' ref k);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 19)  	s.blens [border [s.index++]] = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: s.bb = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: while (s.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {  	InfTrees.inflate_huft h = null;  	uint i' j' c;  	t = s.bb;  	if (!NEEDBITS (t' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	h = s.tb [(b & inflate_mask [t])];  	t = h.bits;  	c = h._base;  	if (c < 16) {  		DUMPBITS (t' ref b' ref k);  		s.blens [s.index++] = c;  	}  	else/* c == 16..18 */ {  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11u : 3u;  		if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		DUMPBITS (t' ref b' ref k);  		j += (b & inflate_mask [i]);  		DUMPBITS (i' ref b' ref k);  		i = s.index;  		t = s.table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			s.blens = null;  			s.mode = inflate_block_mode.BAD;  			z.msg = "invalid bit length repeat";  			r = ReturnCode.Z_DATA_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  		c = c == 16 ? s.blens [i - 1] : 0;  		do {  			s.blens [i++] = c;  		}  		while ((--j) != 0);  		s.index = i;  	}  	t = s.table;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (c < 16) {  	DUMPBITS (t' ref b' ref k);  	s.blens [s.index++] = c;  }  else/* c == 16..18 */ {  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11u : 3u;  	if (!NEEDBITS (t + i' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	DUMPBITS (t' ref b' ref k);  	j += (b & inflate_mask [i]);  	DUMPBITS (i' ref b' ref k);  	i = s.index;  	t = s.table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		s.blens = null;  		s.mode = inflate_block_mode.BAD;  		z.msg = "invalid bit length repeat";  		r = ReturnCode.Z_DATA_ERROR;  		return LEAVE (b' k' n' p' q' s' z' r);  	}  	c = c == 16 ? s.blens [i - 1] : 0;  	do {  		s.blens [i++] = c;  	}  	while ((--j) != 0);  	s.index = i;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: j = c == 18 ? 11u : 3u;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	s.blens = null;  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid bit length repeat";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	s.blens = null;  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid bit length repeat";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	s.blens = null;  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid bit length repeat";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: c = c == 16 ? s.blens [i - 1] : 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: bl = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: bd = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following statement contains a magic number: returnCode = InfTrees.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' ref s.blens' ref bl' ref bd' ref tl' ref td' ref s.hufts' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,NEEDBITS,The following statement contains a magic number: while (k < j) {  	if (n != 0) {  		r = ReturnCode.Z_OK;  	}  	else {  		r = LEAVE (b' k' n' p' q' s' z' r);  		return false;  	}  	b |= (uint)NEXTBYTE (ref n' ref p' z) << (int)k;  	k += 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,NEEDBITS,The following statement contains a magic number: k += 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,GRABBITS,The following statement contains a magic number: while (k < j) {  	unchecked {  		b |= ((uint)NEXTBYTE (ref n' ref p' z)) << (int)k;  	}  	k += 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,GRABBITS,The following statement contains a magic number: k += 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,UNGRAB,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,UNGRAB,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,UNGRAB,The following statement contains a magic number: k -= c << 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: maxlen = 258;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: while (true) {  	switch (c.mode) {  	/* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  		/* x: set up for LEN */if (m >= maxlen && n >= 10) {  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  			InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  			if (r != ReturnCode.Z_OK) {  				c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  				break;  			}  		}  		c.need = c.lbits;  		c.tree = c.ltree;  		c.tree_ndx = c.ltree_ndx;  		c.mode = inflate_codes_mode.LEN;  		break;  	case inflate_codes_mode.LEN:  		/* i: get length/literal/eob next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if (e == 0)/* literal */ {  			c.lit = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LIT;  			break;  		}  		if ((e & 16) != 0)/* length */ {  			c._get = e & 15;  			c.len = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.LENEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		if ((e & 32) != 0)/* end of block */ {  			c.mode = inflate_codes_mode.WASH;  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid literal/length code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.LENEXT:  		/* i: getting length extra (have base) */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  			return r;  		}  		c.len += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.need = c.dbits;  		c.tree = c.dtree;  		c.tree_ndx = c.dtree_ndx;  		c.mode = inflate_codes_mode.DIST;  		break;  	case inflate_codes_mode.DIST:  		/* i: get distance next */j = c.need;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		unchecked {  			t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  		}  		InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  		e = c.tree [t_index].exop;  		if ((e & 16) != 0)/* distance */ {  			c._get = e & 15;  			c.dist = c.tree [t_index]._base;  			c.mode = inflate_codes_mode.DISTEXT;  			break;  		}  		if ((e & 64) == 0)/* next table */ {  			c.need = e;  			unchecked {  				c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  			}  			break;  		}  		c.mode = inflate_codes_mode.BADCODE;  		/* invalid code */z.msg = "invalid distance code";  		r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.DISTEXT:  		/* i: getting distance extra */j = c._get;  		if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  			return r;  		c.dist += (b & InfBlock.inflate_mask [j]);  		InfBlock.DUMPBITS (j' ref b' ref k);  		c.mode = inflate_codes_mode.COPY;  		break;  	case inflate_codes_mode.COPY:  		/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  		while (f < 0)  			/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  		/* of "if" handles invalid distances */while (c.len != 0) {  			{  				if (m == 0) {  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.FLUSH (s' z' ref m' ref q' ref r);  						InfBlock.WRAP (ref q' ref m' s);  						if (m == 0) {  							InfBlock.UPDATE (s' z' b' k' n' p' q);  							return InfBlock.inflate_flush (s' z' r);  						}  					}  				}  				r = ReturnCode.Z_OK;  			// End of NEEDOUT  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end) {  				f = 0;  			}  			c.len--;  		}  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.LIT:  		/* o: got literal' waiting for output space */{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		}  		// End of NEEDOUT  		s.window [q++] = unchecked((byte)c.lit);  		m--;  		c.mode = inflate_codes_mode.START;  		break;  	case inflate_codes_mode.WASH:  		/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  			System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  			k -= 8;  			n++;  			p--;  			/* can always return one */}  		InfBlock.FLUSH (s' z' ref m' ref q' ref r);  		if (s.read != s.write) {  			return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  		}  		c.mode = inflate_codes_mode.END;  		break;  	case inflate_codes_mode.END:  		r = ReturnCode.Z_STREAM_END;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	case inflate_codes_mode.BADCODE:  		/* x: got error */r = ReturnCode.Z_DATA_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	default:  		r = ReturnCode.Z_STREAM_ERROR;  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: switch (c.mode) {  /* waiting for "i:"=input' "o:"=output' "x:"=nothing */case inflate_codes_mode.START:  	/* x: set up for LEN */if (m >= maxlen && n >= 10) {  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  		InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  		if (r != ReturnCode.Z_OK) {  			c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  			break;  		}  	}  	c.need = c.lbits;  	c.tree = c.ltree;  	c.tree_ndx = c.ltree_ndx;  	c.mode = inflate_codes_mode.LEN;  	break;  case inflate_codes_mode.LEN:  	/* i: get length/literal/eob next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if (e == 0)/* literal */ {  		c.lit = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LIT;  		break;  	}  	if ((e & 16) != 0)/* length */ {  		c._get = e & 15;  		c.len = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.LENEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	if ((e & 32) != 0)/* end of block */ {  		c.mode = inflate_codes_mode.WASH;  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid literal/length code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.LENEXT:  	/* i: getting length extra (have base) */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r)) {  		return r;  	}  	c.len += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.need = c.dbits;  	c.tree = c.dtree;  	c.tree_ndx = c.dtree_ndx;  	c.mode = inflate_codes_mode.DIST;  	break;  case inflate_codes_mode.DIST:  	/* i: get distance next */j = c.need;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	unchecked {  		t_index = (int)(c.tree_ndx + (b & InfBlock.inflate_mask [j]));  	}  	InfBlock.DUMPBITS (c.tree [t_index].bits' ref b' ref k);  	e = c.tree [t_index].exop;  	if ((e & 16) != 0)/* distance */ {  		c._get = e & 15;  		c.dist = c.tree [t_index]._base;  		c.mode = inflate_codes_mode.DISTEXT;  		break;  	}  	if ((e & 64) == 0)/* next table */ {  		c.need = e;  		unchecked {  			c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  		}  		break;  	}  	c.mode = inflate_codes_mode.BADCODE;  	/* invalid code */z.msg = "invalid distance code";  	r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.DISTEXT:  	/* i: getting distance extra */j = c._get;  	if (!InfBlock.NEEDBITS (j' ref k' ref b' ref n' ref p' q' s' z' ref r))  		return r;  	c.dist += (b & InfBlock.inflate_mask [j]);  	InfBlock.DUMPBITS (j' ref b' ref k);  	c.mode = inflate_codes_mode.COPY;  	break;  case inflate_codes_mode.COPY:  	/* o: copying bytes in window' waiting for space */f = /*unchecked(*/(int)q - (int)c.dist/*)*/;  	while (f < 0)  		/* modulo window size-"while" instead */f += /*unchecked(*/(int)s.end/*)*/;  	/* of "if" handles invalid distances */while (c.len != 0) {  		{  			if (m == 0) {  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.FLUSH (s' z' ref m' ref q' ref r);  					InfBlock.WRAP (ref q' ref m' s);  					if (m == 0) {  						InfBlock.UPDATE (s' z' b' k' n' p' q);  						return InfBlock.inflate_flush (s' z' r);  					}  				}  			}  			r = ReturnCode.Z_OK;  		// End of NEEDOUT  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end) {  			f = 0;  		}  		c.len--;  	}  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.LIT:  	/* o: got literal' waiting for output space */{  		if (m == 0) {  			InfBlock.WRAP (ref q' ref m' s);  			if (m == 0) {  				InfBlock.FLUSH (s' z' ref m' ref q' ref r);  				InfBlock.WRAP (ref q' ref m' s);  				if (m == 0) {  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return InfBlock.inflate_flush (s' z' r);  				}  			}  		}  		r = ReturnCode.Z_OK;  	}  	// End of NEEDOUT  	s.window [q++] = unchecked((byte)c.lit);  	m--;  	c.mode = inflate_codes_mode.START;  	break;  case inflate_codes_mode.WASH:  	/* o: got eob' possibly more output */if (k > 7)/* return unused byte' if any */ {  		System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  		k -= 8;  		n++;  		p--;  		/* can always return one */}  	InfBlock.FLUSH (s' z' ref m' ref q' ref r);  	if (s.read != s.write) {  		return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  	}  	c.mode = inflate_codes_mode.END;  	break;  case inflate_codes_mode.END:  	r = ReturnCode.Z_STREAM_END;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  case inflate_codes_mode.BADCODE:  	/* x: got error */r = ReturnCode.Z_DATA_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  default:  	r = ReturnCode.Z_STREAM_ERROR;  	return InfBlock.LEAVE (b' k' n' p' q' s' z' r);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (m >= maxlen && n >= 10) {  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	r = inflate_fast (c.lbits' c.dbits' c.ltree' c.ltree_ndx' c.dtree' c.dtree_ndx' s' z);  	InfBlock.LOAD (ref p' ref n' ref b' ref k' ref q' ref m' z' s);  	if (r != ReturnCode.Z_OK) {  		c.mode = (r == ReturnCode.Z_STREAM_END) ? inflate_codes_mode.WASH : inflate_codes_mode.BADCODE;  		break;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* length */ {  	c._get = e & 15;  	c.len = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.LENEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* length */ {  	c._get = e & 15;  	c.len = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.LENEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: c._get = e & 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 64) == 0)/* next table */ {  	c.need = e;  	unchecked {  		c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  	}  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 32) != 0)/* end of block */ {  	c.mode = inflate_codes_mode.WASH;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* distance */ {  	c._get = e & 15;  	c.dist = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.DISTEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 16) != 0)/* distance */ {  	c._get = e & 15;  	c.dist = c.tree [t_index]._base;  	c.mode = inflate_codes_mode.DISTEXT;  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: c._get = e & 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if ((e & 64) == 0)/* next table */ {  	c.need = e;  	unchecked {  		c.tree_ndx = (uint)t_index + c.tree [t_index]._base;  	}  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (k > 7)/* return unused byte' if any */ {  	System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  	k -= 8;  	n++;  	p--;  	/* can always return one */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (k > 7)/* return unused byte' if any */ {  	System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  	k -= 8;  	n++;  	p--;  	/* can always return one */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: if (k > 7)/* return unused byte' if any */ {  	System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  	k -= 8;  	n++;  	p--;  	/* can always return one */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: System.Diagnostics.Debug.Assert (k < 16' "inflate_codes grabbed too many bytes");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_codes,The following statement contains a magic number: k -= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: maxlen = 258;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	/* assume called with m >= maxlen && n >= 10 *//* get literal/length code */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	t = b & ml;  	tp = tl;  	tp_ndx = tl_ndx;  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		continue;  	}  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits for length */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  			/* max bits for distance code */t = b & md;  			tp = td;  			tp_ndx = td_ndx;  			e = tp [tp_ndx + t].exop;  			do {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				if ((e & 16) != 0) {  					/* get extra bits to add to distance base */e &= 15;  					InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  					/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  					InfBlock.DUMPBITS (e' ref b' ref k);  					/* do the copy */m -= c;  					r = /*unchecked(*/(int)q - (int)d/*)*/;  					if (r < 0)/* wrap if needed */ {  						do {  							r += /*unchecked(*/(int)s.end/*)*/;  							/* force index in window */}  						while (r < 0);  						/* covers invalid distances */e = s.end - (uint)r;  						if (c > e) {  							c -= e;  							/* wrapped copy */do {  								s.window [q++] = s.window [r++];  							}  							while ((--e) != 0);  							r = 0;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  						else/* normal copy */ {  							s.window [q++] = s.window [r++];  							c--;  							s.window [q++] = s.window [r++];  							c--;  							do {  								s.window [q++] = s.window [r++];  							}  							while ((--c) != 0);  						}  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [tp_ndx + t]._base;  					t += (b & InfBlock.inflate_mask [e]);  					e = tp [tp_ndx + t].exop;  				}  				else {  					z.msg = "invalid distance code";  					InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  					InfBlock.UPDATE (s' z' b' k' n' p' q);  					return ReturnCode.Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			if ((e = tp [tp_ndx + t].exop) == 0) {  				InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  				unchecked {  					s.window [q++] = (byte)tp [tp_ndx + t]._base;  				}  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= maxlen && n >= 10);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits for length */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  		/* max bits for distance code */t = b & md;  		tp = td;  		tp_ndx = td_ndx;  		e = tp [tp_ndx + t].exop;  		do {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			if ((e & 16) != 0) {  				/* get extra bits to add to distance base */e &= 15;  				InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  				/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  				InfBlock.DUMPBITS (e' ref b' ref k);  				/* do the copy */m -= c;  				r = /*unchecked(*/(int)q - (int)d/*)*/;  				if (r < 0)/* wrap if needed */ {  					do {  						r += /*unchecked(*/(int)s.end/*)*/;  						/* force index in window */}  					while (r < 0);  					/* covers invalid distances */e = s.end - (uint)r;  					if (c > e) {  						c -= e;  						/* wrapped copy */do {  							s.window [q++] = s.window [r++];  						}  						while ((--e) != 0);  						r = 0;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  					else/* normal copy */ {  						s.window [q++] = s.window [r++];  						c--;  						s.window [q++] = s.window [r++];  						c--;  						do {  							s.window [q++] = s.window [r++];  						}  						while ((--c) != 0);  					}  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [tp_ndx + t]._base;  				t += (b & InfBlock.inflate_mask [e]);  				e = tp [tp_ndx + t].exop;  			}  			else {  				z.msg = "invalid distance code";  				InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  				InfBlock.UPDATE (s' z' b' k' n' p' q);  				return ReturnCode.Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		if ((e = tp [tp_ndx + t].exop) == 0) {  			InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  			unchecked {  				s.window [q++] = (byte)tp [tp_ndx + t]._base;  			}  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits for length */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	c = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* decode distance base of block to copy */InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  	/* max bits for distance code */t = b & md;  	tp = td;  	tp_ndx = td_ndx;  	e = tp [tp_ndx + t].exop;  	do {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		if ((e & 16) != 0) {  			/* get extra bits to add to distance base */e &= 15;  			InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  			/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  			InfBlock.DUMPBITS (e' ref b' ref k);  			/* do the copy */m -= c;  			r = /*unchecked(*/(int)q - (int)d/*)*/;  			if (r < 0)/* wrap if needed */ {  				do {  					r += /*unchecked(*/(int)s.end/*)*/;  					/* force index in window */}  				while (r < 0);  				/* covers invalid distances */e = s.end - (uint)r;  				if (c > e) {  					c -= e;  					/* wrapped copy */do {  						s.window [q++] = s.window [r++];  					}  					while ((--e) != 0);  					r = 0;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  				else/* normal copy */ {  					s.window [q++] = s.window [r++];  					c--;  					s.window [q++] = s.window [r++];  					c--;  					do {  						s.window [q++] = s.window [r++];  					}  					while ((--c) != 0);  				}  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [tp_ndx + t]._base;  			t += (b & InfBlock.inflate_mask [e]);  			e = tp [tp_ndx + t].exop;  		}  		else {  			z.msg = "invalid distance code";  			InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  			InfBlock.UPDATE (s' z' b' k' n' p' q);  			return ReturnCode.Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: InfBlock.GRABBITS (15' ref k' ref b' ref n' ref p' z);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits to add to distance base */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* do the copy */m -= c;  		r = /*unchecked(*/(int)q - (int)d/*)*/;  		if (r < 0)/* wrap if needed */ {  			do {  				r += /*unchecked(*/(int)s.end/*)*/;  				/* force index in window */}  			while (r < 0);  			/* covers invalid distances */e = s.end - (uint)r;  			if (c > e) {  				c -= e;  				/* wrapped copy */do {  					s.window [q++] = s.window [r++];  				}  				while ((--e) != 0);  				r = 0;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		e = tp [tp_ndx + t].exop;  	}  	else {  		z.msg = "invalid distance code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits to add to distance base */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* do the copy */m -= c;  		r = /*unchecked(*/(int)q - (int)d/*)*/;  		if (r < 0)/* wrap if needed */ {  			do {  				r += /*unchecked(*/(int)s.end/*)*/;  				/* force index in window */}  			while (r < 0);  			/* covers invalid distances */e = s.end - (uint)r;  			if (c > e) {  				c -= e;  				/* wrapped copy */do {  					s.window [q++] = s.window [r++];  				}  				while ((--e) != 0);  				r = 0;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		e = tp [tp_ndx + t].exop;  	}  	else {  		z.msg = "invalid distance code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  	if ((e & 16) != 0) {  		/* get extra bits to add to distance base */e &= 15;  		InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  		/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  		InfBlock.DUMPBITS (e' ref b' ref k);  		/* do the copy */m -= c;  		r = /*unchecked(*/(int)q - (int)d/*)*/;  		if (r < 0)/* wrap if needed */ {  			do {  				r += /*unchecked(*/(int)s.end/*)*/;  				/* force index in window */}  			while (r < 0);  			/* covers invalid distances */e = s.end - (uint)r;  			if (c > e) {  				c -= e;  				/* wrapped copy */do {  					s.window [q++] = s.window [r++];  				}  				while ((--e) != 0);  				r = 0;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  			else/* normal copy */ {  				s.window [q++] = s.window [r++];  				c--;  				s.window [q++] = s.window [r++];  				c--;  				do {  					s.window [q++] = s.window [r++];  				}  				while ((--c) != 0);  			}  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [tp_ndx + t]._base;  		t += (b & InfBlock.inflate_mask [e]);  		e = tp [tp_ndx + t].exop;  	}  	else {  		z.msg = "invalid distance code";  		InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  		InfBlock.UPDATE (s' z' b' k' n' p' q);  		return ReturnCode.Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits to add to distance base */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* do the copy */m -= c;  	r = /*unchecked(*/(int)q - (int)d/*)*/;  	if (r < 0)/* wrap if needed */ {  		do {  			r += /*unchecked(*/(int)s.end/*)*/;  			/* force index in window */}  		while (r < 0);  		/* covers invalid distances */e = s.end - (uint)r;  		if (c > e) {  			c -= e;  			/* wrapped copy */do {  				s.window [q++] = s.window [r++];  			}  			while ((--e) != 0);  			r = 0;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  	}  	else/* normal copy */ {  		s.window [q++] = s.window [r++];  		c--;  		s.window [q++] = s.window [r++];  		c--;  		do {  			s.window [q++] = s.window [r++];  		}  		while ((--c) != 0);  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits to add to distance base */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* do the copy */m -= c;  	r = /*unchecked(*/(int)q - (int)d/*)*/;  	if (r < 0)/* wrap if needed */ {  		do {  			r += /*unchecked(*/(int)s.end/*)*/;  			/* force index in window */}  		while (r < 0);  		/* covers invalid distances */e = s.end - (uint)r;  		if (c > e) {  			c -= e;  			/* wrapped copy */do {  				s.window [q++] = s.window [r++];  			}  			while ((--e) != 0);  			r = 0;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  	}  	else/* normal copy */ {  		s.window [q++] = s.window [r++];  		c--;  		s.window [q++] = s.window [r++];  		c--;  		do {  			s.window [q++] = s.window [r++];  		}  		while ((--c) != 0);  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	/* get extra bits to add to distance base */e &= 15;  	InfBlock.GRABBITS (e' ref k' ref b' ref n' ref p' z);  	/* get extra bits (up to 13) */d = tp [tp_ndx + t]._base + (b & InfBlock.inflate_mask [e]);  	InfBlock.DUMPBITS (e' ref b' ref k);  	/* do the copy */m -= c;  	r = /*unchecked(*/(int)q - (int)d/*)*/;  	if (r < 0)/* wrap if needed */ {  		do {  			r += /*unchecked(*/(int)s.end/*)*/;  			/* force index in window */}  		while (r < 0);  		/* covers invalid distances */e = s.end - (uint)r;  		if (c > e) {  			c -= e;  			/* wrapped copy */do {  				s.window [q++] = s.window [r++];  			}  			while ((--e) != 0);  			r = 0;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  		else/* normal copy */ {  			s.window [q++] = s.window [r++];  			c--;  			s.window [q++] = s.window [r++];  			c--;  			do {  				s.window [q++] = s.window [r++];  			}  			while ((--c) != 0);  		}  	}  	else/* normal copy */ {  		s.window [q++] = s.window [r++];  		c--;  		s.window [q++] = s.window [r++];  		c--;  		do {  			s.window [q++] = s.window [r++];  		}  		while ((--c) != 0);  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	e = tp [tp_ndx + t].exop;  }  else {  	z.msg = "invalid distance code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [tp_ndx + t]._base;  	t += (b & InfBlock.inflate_mask [e]);  	if ((e = tp [tp_ndx + t].exop) == 0) {  		InfBlock.DUMPBITS (tp [tp_ndx + t].bits' ref b' ref k);  		unchecked {  			s.window [q++] = (byte)tp [tp_ndx + t]._base;  		}  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfCodes,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	InfBlock.UNGRAB (ref c' ref n' ref k' ref p' z);  	InfBlock.UPDATE (s' z' b' k' n' p' q);  	return ReturnCode.Z_DATA_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: if (!fixed_built) {  	int k = 0;  	/* temporary variable */uint f = 0;  	/* number of hufts used in fixed_mem */uint[] c = null;  	/* length list for huft_build */uint[] v = null;  	/* work area for huft_build *//* allocate memory */c = new uint[288];  	v = new uint[288];  	fixed_mem = new inflate_huft[(int)Constant.FIXEDH];  	/* literal table */for (k = 0; k < 144; k++)  		c [k] = 8;  	for (; k < 256; k++)  		c [k] = 9;  	for (; k < 280; k++)  		c [k] = 7;  	for (; k < 288; k++)  		c [k] = 8;  	fixed_bl = 9;  	huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  	/* distance table */for (k = 0; k < 30; k++)  		c [k] = 5;  	fixed_bd = 5;  	huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  	/* done */fixed_built = true;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c = new uint[288];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: v = new uint[288];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 144; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 144; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 256; k++)  	c [k] = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 256; k++)  	c [k] = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 280; k++)  	c [k] = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 280; k++)  	c [k] = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 288; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (; k < 288; k++)  	c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: fixed_bl = 9;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: huft_build (c' 0' 288' 257' cplens' cplext' ref fixed_tl' ref fixed_bl' fixed_mem' ref f' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 30; k++)  	c [k] = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: for (k = 0; k < 30; k++)  	c [k] = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: c [k] = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: fixed_bd = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_fixed,The following statement contains a magic number: huft_build (c' 0' 30' 0' cpdist' cpdext' ref fixed_td' ref fixed_bd' fixed_mem' ref f' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The following statement contains a magic number: v = new uint[19];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' ref tb' ref bb' hp' ref hn' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' ref tb' ref bb' hp' ref hn' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The following statement contains a magic number: v = new uint[288];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build (c' 0' nl' 257' cplens' cplext' ref tl' ref bl' hp' ref hn' v);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != ReturnCode.Z_OK || (bd == 0 && nl > 257)) {  	if (r == ReturnCode.Z_DATA_ERROR)  		z.msg = "oversubscribed distance tree";  	else if (r == ReturnCode.Z_BUF_ERROR) {  		z.msg = "incomplete distance tree";  		r = ReturnCode.Z_DATA_ERROR;  	}  	else if (r != ReturnCode.Z_MEM_ERROR) {  		z.msg = "empty distance tree with lengths";  		r = ReturnCode.Z_DATA_ERROR;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	return r;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (uint Counter = 0; Counter < 16; Counter++)  	c [Counter] = 0;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: xp = 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a != 0) {  		a--;  		/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  			h++;  			w += l;  			/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  				z = (uint)(g - w);  				z = z > l ? (uint)l : z;  				/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  					/* too few codes for k-w bit table */f -= a + 1;  					/* deduct codes from patterns left */xp = (uint)k;  					if (j < z) {  						while (++j < z)/* try smaller tables up to z bits */ {  							if ((f <<= 1) <= c [++xp])  								break;  							/* enough codes to use up j bits */f -= c [xp];  							/* else deduct codes from patterns */}  					}  				}  				z = (uint)(1 << (int)j);  				/* table entries for j-bit table */}  			/* allocate new table */if (hn + z > (int)Constant.MANY)  				/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  			/* overflow of MANY */u [h] = q = hn;  			hn += z;  			/* connect to last table' if there is one */if (h != 0) {  				x [h] = i;  				/* save pattern for backing up */unchecked {  					r.bits = (byte)l;  					/* bits to dump before this table */r.exop = (byte)j;  					/* bits in this table */}  				j = i >> (w - l);  				unchecked {  					r._base = (uint)(q - u [h - 1] - j);  					/* offset to this table */}  				hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  				/* connect to last table */}  			else {  				t_ndx = q;  			}  		}  		unchecked {  			/* set up table entry in r */r.bits = (byte)(k - w);  			if (p >= n)  				r.exop = 128 + 64;  			/* out of values--invalid code */else if (v [p] < s) {  				r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  				/* 256 is end-of-block */r._base = v [p++];  				/* simple code is just the value */}  			else {  				r.exop = (byte)(e [v [p] - s] + 16 + 64);  				/* non-simple--look up in lists */r._base = d [v [p++] - s];  			}  			/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  			for (j = i >> w; j < z; j += f) {  				hp [q + j] = new InfTrees.inflate_huft (r);  			}  			/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  				i ^= j;  			i ^= j;  			/* backup over finished tables */mask = (uint)(1 << w) - 1;  			/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  				h--;  				/* don't need to update q */w -= l;  				mask = (uint)(1 << w) - 1;  			}  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: while (a != 0) {  	a--;  	/* here i is the Huffman code of length k bits for value *p *//* make tables up to required level */while (k > w + l) {  		h++;  		w += l;  		/* previous table always l bits *//* compute minimum size table less than or equal to l bits */unchecked {  			z = (uint)(g - w);  			z = z > l ? (uint)l : z;  			/* table size upper limit */if ((f = 1u << (int)(j = (uint)(k - w))) > a + 1)/* try a k-w bit table */ {  				/* too few codes for k-w bit table */f -= a + 1;  				/* deduct codes from patterns left */xp = (uint)k;  				if (j < z) {  					while (++j < z)/* try smaller tables up to z bits */ {  						if ((f <<= 1) <= c [++xp])  							break;  						/* enough codes to use up j bits */f -= c [xp];  						/* else deduct codes from patterns */}  				}  			}  			z = (uint)(1 << (int)j);  			/* table entries for j-bit table */}  		/* allocate new table */if (hn + z > (int)Constant.MANY)  			/* (note: doesn't matter for fixed) */return ReturnCode.Z_DATA_ERROR;  		/* overflow of MANY */u [h] = q = hn;  		hn += z;  		/* connect to last table' if there is one */if (h != 0) {  			x [h] = i;  			/* save pattern for backing up */unchecked {  				r.bits = (byte)l;  				/* bits to dump before this table */r.exop = (byte)j;  				/* bits in this table */}  			j = i >> (w - l);  			unchecked {  				r._base = (uint)(q - u [h - 1] - j);  				/* offset to this table */}  			hp [u [h - 1] + j] = new InfTrees.inflate_huft (r);  			/* connect to last table */}  		else {  			t_ndx = q;  		}  	}  	unchecked {  		/* set up table entry in r */r.bits = (byte)(k - w);  		if (p >= n)  			r.exop = 128 + 64;  		/* out of values--invalid code */else if (v [p] < s) {  			r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  			/* 256 is end-of-block */r._base = v [p++];  			/* simple code is just the value */}  		else {  			r.exop = (byte)(e [v [p] - s] + 16 + 64);  			/* non-simple--look up in lists */r._base = d [v [p++] - s];  		}  		/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  		for (j = i >> w; j < z; j += f) {  			hp [q + j] = new InfTrees.inflate_huft (r);  		}  		/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  			i ^= j;  		i ^= j;  		/* backup over finished tables */mask = (uint)(1 << w) - 1;  		/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  			h--;  			/* don't need to update q */w -= l;  			mask = (uint)(1 << w) - 1;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: unchecked {  	/* set up table entry in r */r.bits = (byte)(k - w);  	if (p >= n)  		r.exop = 128 + 64;  	/* out of values--invalid code */else if (v [p] < s) {  		r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  		/* 256 is end-of-block */r._base = v [p++];  		/* simple code is just the value */}  	else {  		r.exop = (byte)(e [v [p] - s] + 16 + 64);  		/* non-simple--look up in lists */r._base = d [v [p++] - s];  	}  	/* fill code-like entries with r */f = (uint)(1 << (int)(k - w));  	for (j = i >> w; j < z; j += f) {  		hp [q + j] = new InfTrees.inflate_huft (r);  	}  	/* backwards increment the k-bit code i */for (j = (uint)1 << (int)(k - 1); (i & j) != 0; j >>= 1)  		i ^= j;  	i ^= j;  	/* backup over finished tables */mask = (uint)(1 << w) - 1;  	/* needed on HP' cc -O bug */while ((i & mask) != x [h]) {  		h--;  		/* don't need to update q */w -= l;  		mask = (uint)(1 << w) - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (p >= n)  	r.exop = 128 + 64;  /* out of values--invalid code */else if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = 128 + 64;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = 128 + 64;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  	/* 256 is end-of-block */r._base = v [p++];  	/* simple code is just the value */}  else {  	r.exop = (byte)(e [v [p] - s] + 16 + 64);  	/* non-simple--look up in lists */r._base = d [v [p++] - s];  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,InfTrees,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfTrees.cs,huft_build,The following statement contains a magic number: r.exop = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,Tree,The following statement contains a magic number: Debug.Assert (static_ltree.Length == (int)XDeflate.Constant.L_CODES + 2' "Array dimension verification failed");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_init,The following statement contains a magic number: s.last_eob_len = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: if (1 + s.last_eob_len + 10 - s.bi_valid < 9) {  	send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  	send_code (s' (int)Constant.END_BLOCK' static_ltree);  	bi_flush (s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: if (1 + s.last_eob_len + 10 - s.bi_valid < 9) {  	send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  	send_code (s' (int)Constant.END_BLOCK' static_ltree);  	bi_flush (s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: if (1 + s.last_eob_len + 10 - s.bi_valid < 9) {  	send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  	send_code (s' (int)Constant.END_BLOCK' static_ltree);  	bi_flush (s);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: send_bits (s' (int)BlockType.STATIC_TREES << 1' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_align,The following statement contains a magic number: s.last_eob_len = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,d_code,The following statement contains a magic number: return dist < 256 ? _dist_code [dist] : _dist_code [256 + (dist >> 7)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,d_code,The following statement contains a magic number: return dist < 256 ? _dist_code [dist] : _dist_code [256 + (dist >> 7)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,d_code,The following statement contains a magic number: return dist < 256 ? _dist_code [dist] : _dist_code [256 + (dist >> 7)];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,copy_block,The following statement contains a magic number: s.last_eob_len = 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,set_data_type,The following statement contains a magic number: while (n < 7)  	bin_freq += s.dyn_ltree [n++].freq_code;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,set_data_type,The following statement contains a magic number: while (n < 128)  	ascii_freq += s.dyn_ltree [n++].freq_code;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,set_data_type,The following statement contains a magic number: s.data_type = (bin_freq > (ascii_freq >> 2) ? DataTypeValue.Z_BINARY : DataTypeValue.Z_ASCII);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (s.level > 0) {  	/* Check if the file is ascii or binary */if (s.data_type == DataTypeValue.Z_UNKNOWN) {  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		set_data_type (s);  	}  	/* Construct the literal and distance trees */build_tree (s' s.l_desc);  	build_tree (s' s.d_desc);  	/* At this point' opt_len and static_len are the total bit lengths of          * the compressed block data' excluding the tree representations.          *//* Build the bit length tree for the above two trees' and get the index          * in bl_order of the last bit length code to send.          */max_blindex = build_bl_tree (s);  	/* Determine the best encoding. Compute first the block length in bytes*/opt_lenb = (s.opt_len + 3 + 7) >> 3;  	static_lenb = (s.static_len + 3 + 7) >> 3;  	if (static_lenb <= opt_lenb) {  		opt_lenb = static_lenb;  	}  }  else {  	Debug.Assert (buf != null' "lost buf");  	opt_lenb = static_lenb = stored_len + 5;  	/* force a stored block */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (s.opt_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (s.opt_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (s.opt_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (s.static_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (s.static_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (s.static_len + 3 + 7) >> 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = static_lenb = stored_len + 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != null) {  	/* 4: two words for the lengths *//* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                * Otherwise we can't have processed more than WSIZE input bytes since                * the last block flush' because compression would have been                * successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                * transform a block into a stored block.                */_tr_stored_block (s' buf' startindex' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != null) {  	/* 4: two words for the lengths *//* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                * Otherwise we can't have processed more than WSIZE input bytes since                * the last block flush' because compression would have been                * successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                * transform a block into a stored block.                */_tr_stored_block (s' buf' startindex' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != null) {  	/* 4: two words for the lengths *//* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                * Otherwise we can't have processed more than WSIZE input bytes since                * the last block flush' because compression would have been                * successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                * transform a block into a stored block.                */_tr_stored_block (s' buf' startindex' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (s' static_ltree' static_dtree);  }  else {  	send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (s' s.l_desc.max_code + 1' s.d_desc.max_code + 1' max_blindex + 1);  	compress_block (s' s.dyn_ltree' s.dyn_dtree);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: send_bits (s' ((int)BlockType.STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_flush_block,The following statement contains a magic number: send_bits (s' ((int)BlockType.DYN_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,_tr_stored_block,The following statement contains a magic number: send_bits (s' ((int)BlockType.STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid == 16) {  	put_short (s' s.bi_buf);  	s.bi_buf = 0;  	s.bi_valid = 0;  }  else if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: if (s.bi_valid >= 8) {  	put_byte (s' unchecked((byte)s.bi_buf));  	s.bi_buf >>= 8;  	s.bi_valid -= 8;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: s.bi_buf >>= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_flush,The following statement contains a magic number: s.bi_valid -= 8;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,bi_windup,The following statement contains a magic number: if (s.bi_valid > 8) {  	put_short (s' s.bi_buf);  }  else if (s.bi_valid > 0) {  	put_byte (s' unchecked((byte)s.bi_buf));  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,put_short,The following statement contains a magic number: put_byte (s' unchecked((byte)(w >> 8)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++(s.heap_len)] = (max_code < 2 ? ++max_code : 0);  	tree [node].freq_code = 1;  	s.depth [node] = 0;  	unchecked {  		s.opt_len--;  		if (stree != null)  			s.static_len -= stree [node].dad_len;  	}  	/* node is 0 or 1 so it does not have extra bits */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++(s.heap_len)] = (max_code < 2 ? ++max_code : 0);  	tree [node].freq_code = 1;  	s.depth [node] = 0;  	unchecked {  		s.opt_len--;  		if (stree != null)  			s.static_len -= stree [node].dad_len;  	}  	/* node is 0 or 1 so it does not have extra bits */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap [++(s.heap_len)] = (max_code < 2 ? ++max_code : 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)  	pqdownheap (s' tree' n);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: n = s.heap_len / 2
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_tree,The following statement contains a magic number: do {  	pqremove (s' tree' ref n);  	/* n = node of least frequency */m = s.heap [(int)Constant.SMALLEST];  	/* m = node of next least frequency */s.heap [--(s.heap_max)] = n;  	/* keep the nodes sorted by frequency */s.heap [--(s.heap_max)] = m;  	/* Create a new node father of n and m */tree [node].freq_code = unchecked((ushort)(tree [n].freq_code + tree [m].freq_code));  	s.depth [node] = (byte)(System.Math.Max (s.depth [n]' s.depth [m]) + 1);  	tree [n].dad_len = tree [m].dad_len = unchecked((ushort)node);  	/* and insert the new node in the heap */s.heap [(int)Constant.SMALLEST] = node++;  	pqdownheap (s' tree' (int)Constant.SMALLEST);  }  while (s.heap_len >= 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = (int)XDeflate.Constant.BL_CODES - 1; max_blindex >= 3; max_blindex--) {  	if (s.bl_tree [bl_order [max_blindex]].dad_len != 0)  		break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,build_bl_tree,The following statement contains a magic number: s.opt_len += unchecked((uint)(3 * (max_blindex + 1) + 5 + 5 + 4));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: if (s.last_lit != 0) {  	do {  		dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  		// XCD Was s.d_buf[ lx ]  		lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  		// XCD Was s.l_buf[ lx++ ]  		if (dist == 0) {  			send_code (s' unchecked((uint)lc)' ltree);  			/* send a literal byte */}  		else {  			/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  			extra = extra_lbits [code];  			baseLen = base_length [code];  			send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  			/* send the length code */if (extra != 0) {  				lc -= baseLen;  				send_bits (s' lc' extra);  				/* send the extra length bits */}  			dist--;  			/* dist is now the match distance - 1 */code = d_code (dist);  			Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  			send_code (s' code' dtree);  			/* send the distance code */extra = extra_dbits [code];  			if (extra != 0) {  				dist -= unchecked((uint)base_dist [code]);  				send_bits (s' unchecked((int)dist)' extra);  				/* send the extra distance bits */}  		}  		/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  	}  	while (lx < s.last_lit);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: do {  	dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  	// XCD Was s.d_buf[ lx ]  	lc = (s.pending_buf [s.l_buf + lx++] & 0xff);  	// XCD Was s.l_buf[ lx++ ]  	if (dist == 0) {  		send_code (s' unchecked((uint)lc)' ltree);  		/* send a literal byte */}  	else {  		/* Here' lc is the match length - MIN_MATCH */code = _length_code [lc];  		extra = extra_lbits [code];  		baseLen = base_length [code];  		send_code (s' code + (int)XDeflate.Constant.LITERALS + 1' ltree);  		/* send the length code */if (extra != 0) {  			lc -= baseLen;  			send_bits (s' lc' extra);  			/* send the extra length bits */}  		dist--;  		/* dist is now the match distance - 1 */code = d_code (dist);  		Debug.Assert (code < (int)XDeflate.Constant.D_CODES' "bad d_code");  		send_code (s' code' dtree);  		/* send the distance code */extra = extra_dbits [code];  		if (extra != 0) {  			dist -= unchecked((uint)base_dist [code]);  			send_bits (s' unchecked((int)dist)' extra);  			/* send the extra distance bits */}  	}  	/* literal or match pair ? *//* Check that the overlay between pending_buf and d_buf+l_buf is ok: */Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  }  while (lx < s.last_lit);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: dist = unchecked((uint)(((s.pending_buf [s.d_buf + lx * 2] << 8) & 0xff00) | (s.pending_buf [s.d_buf + lx * 2 + 1] & 0xff)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,compress_block,The following statement contains a magic number: Debug.Assert (s.pending < s.lit_bufsize + 2 * lx' "pendingBuf overflow");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: Debug.Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4' "not enough codes");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: Debug.Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4' "not enough codes");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' lcodes - 257' 5);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' lcodes - 257' 5);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' dcodes - 1' 5);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' blcodes - 4' 4);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' blcodes - 4' 4);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++) {  	send_bits (s' s.bl_tree [bl_order [rank]].dad_len' 3);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_all_trees,The following statement contains a magic number: send_bits (s' s.bl_tree [bl_order [rank]].dad_len' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	/* move one leaf down the tree */s.bl_count [bits + 1] += 2;  	/* move one overflow item as its brother */s.bl_count [max_length]--;  	/* The brother of the overflow item also moves one step up'          * but this does not affect bl_count[max_length]          */overflow -= 2;  }  while (overflow > 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	/* move one leaf down the tree */s.bl_count [bits + 1] += 2;  	/* move one overflow item as its brother */s.bl_count [max_length]--;  	/* The brother of the overflow item also moves one step up'          * but this does not affect bl_count[max_length]          */overflow -= 2;  }  while (overflow > 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count [bits + 1] += 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		s.bl_tree [curlen].freq_code += unchecked((ushort)count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			s.bl_tree [curlen].freq_code++;  		s.bl_tree [(int)Constant.REP_3_6].freq_code++;  	}  	else if (count <= 10) {  		s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  	}  	else {  		s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	s.bl_tree [curlen].freq_code += unchecked((ushort)count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		s.bl_tree [curlen].freq_code++;  	s.bl_tree [(int)Constant.REP_3_6].freq_code++;  }  else if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	s.bl_tree [curlen].freq_code += unchecked((ushort)count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		s.bl_tree [curlen].freq_code++;  	s.bl_tree [(int)Constant.REP_3_6].freq_code++;  }  else if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		s.bl_tree [curlen].freq_code++;  	s.bl_tree [(int)Constant.REP_3_6].freq_code++;  }  else if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	s.bl_tree [(int)Constant.REPZ_3_10].freq_code++;  }  else {  	s.bl_tree [(int)Constant.REPZ_11_138].freq_code++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,scan_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [n + 1].dad_len;  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (s' unchecked((uint)curlen)' s.bl_tree);  			count--;  		}  		Debug.Assert (count >= 3 && count <= 6' " 3_6?");  		send_code (s' (int)Constant.REP_3_6' s.bl_tree);  		send_bits (s' count - 3' 2);  	}  	else if (count <= 10) {  		send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  		send_bits (s' count - 3' 3);  	}  	else {  		send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  		send_bits (s' count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (s' unchecked((uint)curlen)' s.bl_tree);  		count--;  	}  	Debug.Assert (count >= 3 && count <= 6' " 3_6?");  	send_code (s' (int)Constant.REP_3_6' s.bl_tree);  	send_bits (s' count - 3' 2);  }  else if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: Debug.Assert (count >= 3 && count <= 6' " 3_6?");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: Debug.Assert (count >= 3 && count <= 6' " 3_6?");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 2);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (s' (int)Constant.REPZ_3_10' s.bl_tree);  	send_bits (s' count - 3' 3);  }  else {  	send_code (s' (int)Constant.REPZ_11_138' s.bl_tree);  	send_bits (s' count - 11' 7);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 3' 3);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 11' 7);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: send_bits (s' count - 11' 7);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,Tree,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\Tree.cs,send_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (level == (int)CompressionLevel.Z_DEFAULT_COMPRESSION)  	level = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: level = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: if (memLevel < 1 || memLevel > (int)XZLib.Constant.MAX_MEM_LEVEL || method != (int)XZLib.Constant.Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.hash_bits = unchecked((uint)memLevel + 7);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.window = new byte[2 * s.w_size];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.lit_bufsize = unchecked((uint)(1 << (memLevel + 6)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.pending_buf = new byte[s.lit_bufsize * 4];  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.pending_buf_size = s.lit_bufsize * 4;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,DeflateInit,The following statement contains a magic number: s.l_buf = unchecked((int)((1 + 2) * s.lit_bufsize));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.status == StreamStatus.INIT_STATE) {  	uint header = ((int)XZLib.Constant.Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;  	uint level_flags = unchecked((uint)((s.level - 1) >> 1));  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (s.strstart != 0)  		header |= (int)XZLib.Constant.PRESET_DICT;  	header += 31 - (header % 31);  	s.status = StreamStatus.BUSY_STATE;  	putShortMSB (s' header);  	/* Save the adler32 of the preset dictionary: */if (s.strstart != 0) {  		System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  		putShortMSB (s' strm.adler >> 16);  		putShortMSB (s' strm.adler & 0xffff);  	}  	strm.adler = 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: header |= (level_flags << 6);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: if (s.strstart != 0) {  	System.Diagnostics.Debug.Assert (false' "The lines inside this \"if\" were never tested");  	putShortMSB (s' strm.adler >> 16);  	putShortMSB (s' strm.adler & 0xffff);  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: putShortMSB (s' strm.adler >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following statement contains a magic number: putShortMSB (s' strm.adler >> 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflateEnd,The following statement contains a magic number: if (status != StreamStatus.INIT_STATE && status != StreamStatus.BUSY_STATE && status != StreamStatus.FINISH_STATE) {  	if (m_adler16 [strm.avail_in % 32] == 0)  		return ReturnCode.Z_INTERNAL_ERROR;  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflateEnd,The following statement contains a magic number: if (m_adler16 [strm.avail_in % 32] == 0)  	return ReturnCode.Z_INTERNAL_ERROR;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflateParams,The following statement contains a magic number: if (level == (int)CompressionLevel.Z_DEFAULT_COMPRESSION) {  	level = 6;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflateParams,The following statement contains a magic number: level = 6;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflateParams,The following statement contains a magic number: if (level < 0 || level > 9 || strategy < 0 || strategy > CompressionStrategy.Z_HUFFMAN_ONLY) {  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,lm_init,The following statement contains a magic number: s.window_size = 2 * s.w_size;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,putShortMSB,The following statement contains a magic number: Tree.put_byte (s' unchecked((byte)(b >> 8)));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > s.pending_buf_size - 5) {  	max_block_size = s.pending_buf_size - 5;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > s.pending_buf_size - 5) {  	max_block_size = s.pending_buf_size - 5;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_stored,The following statement contains a magic number: max_block_size = s.pending_buf_size - 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: for (; ;) {  	/* Make sure that we always have enough lookahead' except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match' plus MIN_MATCH bytes to insert the          * string following the next match.          */if (s.lookahead < s.min_lookahead) {  		fill_window (s);  		if (s.lookahead < s.min_lookahead && flush == FlushValue.Z_NO_FLUSH) {  			return block_state.need_more;  		}  		if (s.lookahead == 0)  			break;  		/* flush the current block */}  	/* Insert the string window[strstart .. strstart+2] in the          * dictionary' and set hash_head to the head of the hash chain:          */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		INSERT_STRING (s' s.strstart' ref hash_head);  	}  	/* Find the longest match' discarding those <= prev_length.          * At this point we have always match_length < MIN_MATCH          */if (hash_head != 0 && s.strstart - hash_head <= s.max_dist) {  		/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  			s.match_length = longest_match (s' hash_head);  		}  		/* longest_match() sets match_start */}  	if (s.match_length >= (int)Constant.MIN_MATCH) {  		_tr_tally_dist (s' s.strstart - s.match_start' s.match_length - (int)Constant.MIN_MATCH' ref bflush);  		s.lookahead -= s.match_length;  		/* Insert new strings in the hash table only if the match length              * is not too large. This saves time but degrades compression.              */if (s.match_length <= s.max_lazy_match && s.lookahead >= (int)Constant.MIN_MATCH) {  			s.match_length--;  			/* string at strstart already in hash table */do {  				s.strstart++;  				INSERT_STRING (s' s.strstart' ref hash_head);  				/* strstart never exceeds WSIZE-MAX_MATCH' so there are                      * always MIN_MATCH bytes ahead.                      */}  			while (--s.match_length != 0);  			s.strstart++;  		}  		else {  			s.strstart += s.match_length;  			s.match_length = 0;  			s.ins_h = s.window [s.strstart];  			UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  			System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  			/* If lookahead < MIN_MATCH' ins_h is garbage' but it does not                  * matter since it will be recomputed at next deflate call.                  */}  	}  	else {  		/* No match' output a literal byte */_tr_tally_lit (s' s.window [s.strstart]' ref bflush);  		s.lookahead--;  		s.strstart++;  	}  	if (bflush) {  		FLUSH_BLOCK_ONLY (s' false);  		if (s.strm.avail_out == 0) {  			return block_state.need_more;  		}  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: if (s.match_length >= (int)Constant.MIN_MATCH) {  	_tr_tally_dist (s' s.strstart - s.match_start' s.match_length - (int)Constant.MIN_MATCH' ref bflush);  	s.lookahead -= s.match_length;  	/* Insert new strings in the hash table only if the match length              * is not too large. This saves time but degrades compression.              */if (s.match_length <= s.max_lazy_match && s.lookahead >= (int)Constant.MIN_MATCH) {  		s.match_length--;  		/* string at strstart already in hash table */do {  			s.strstart++;  			INSERT_STRING (s' s.strstart' ref hash_head);  			/* strstart never exceeds WSIZE-MAX_MATCH' so there are                      * always MIN_MATCH bytes ahead.                      */}  		while (--s.match_length != 0);  		s.strstart++;  	}  	else {  		s.strstart += s.match_length;  		s.match_length = 0;  		s.ins_h = s.window [s.strstart];  		UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  		System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  		/* If lookahead < MIN_MATCH' ins_h is garbage' but it does not                  * matter since it will be recomputed at next deflate call.                  */}  }  else {  	/* No match' output a literal byte */_tr_tally_lit (s' s.window [s.strstart]' ref bflush);  	s.lookahead--;  	s.strstart++;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: if (s.match_length <= s.max_lazy_match && s.lookahead >= (int)Constant.MIN_MATCH) {  	s.match_length--;  	/* string at strstart already in hash table */do {  		s.strstart++;  		INSERT_STRING (s' s.strstart' ref hash_head);  		/* strstart never exceeds WSIZE-MAX_MATCH' so there are                      * always MIN_MATCH bytes ahead.                      */}  	while (--s.match_length != 0);  	s.strstart++;  }  else {  	s.strstart += s.match_length;  	s.match_length = 0;  	s.ins_h = s.window [s.strstart];  	UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  	System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  	/* If lookahead < MIN_MATCH' ins_h is garbage' but it does not                  * matter since it will be recomputed at next deflate call.                  */}  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_fast,The following statement contains a magic number: System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: for (; ;) {  	/* Make sure that we always have enough lookahead' except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match' plus MIN_MATCH bytes to insert the          * string following the next match.          */if (s.lookahead < s.min_lookahead) {  		fill_window (s);  		if (s.lookahead < s.min_lookahead && flush == FlushValue.Z_NO_FLUSH) {  			return block_state.need_more;  		}  		if (s.lookahead == 0)  			break;  		/* flush the current block */}  	/* Insert the string window[strstart .. strstart+2] in the          * dictionary' and set hash_head to the head of the hash chain:          */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		INSERT_STRING (s' s.strstart' ref hash_head);  	}  	/* Find the longest match' discarding those <= prev_length.          */s.prev_length = s.match_length;  	s.prev_match = s.match_start;  	s.match_length = (int)Constant.MIN_MATCH - 1;  	if (hash_head != 0 && s.prev_length < s.max_lazy_match && unchecked(s.strstart - hash_head) <= s.max_dist) {  		/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  			s.match_length = longest_match (s' hash_head);  		}  		/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  			/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  		}  	}  	/* If there was a match at the previous step and the current          * match is not better' output the previous match:          */if (s.prev_length >= (int)Constant.MIN_MATCH && s.match_length <= s.prev_length) {  		uint max_insert = s.strstart + s.lookahead - (int)Constant.MIN_MATCH;  		/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush);  		/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead' the last two strings are not inserted in              * the hash table.              */s.lookahead -= s.prev_length - 1;  		s.prev_length -= 2;  		do {  			if (++s.strstart <= max_insert) {  				INSERT_STRING (s' s.strstart' ref hash_head);  			}  		}  		while (--s.prev_length != 0);  		s.match_available = 0;  		s.match_length = (int)Constant.MIN_MATCH - 1;  		s.strstart++;  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  			if (s.strm.avail_out == 0)  				return block_state.need_more;  		}  	}  	else if (s.match_available != 0) {  		/* If there was no match at the previous position' output a              * single literal. If there was a match but the current match              * is longer' truncate the previous match to a single literal.              */_tr_tally_lit (s' s.window [s.strstart - 1]' ref bflush);  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  		}  		s.strstart++;  		s.lookahead--;  		if (s.strm.avail_out == 0)  			return block_state.need_more;  	}  	else {  		/* There is no previous match to compare with' wait for              * the next step to decide.              */s.match_available = 1;  		s.strstart++;  		s.lookahead--;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: for (; ;) {  	/* Make sure that we always have enough lookahead' except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match' plus MIN_MATCH bytes to insert the          * string following the next match.          */if (s.lookahead < s.min_lookahead) {  		fill_window (s);  		if (s.lookahead < s.min_lookahead && flush == FlushValue.Z_NO_FLUSH) {  			return block_state.need_more;  		}  		if (s.lookahead == 0)  			break;  		/* flush the current block */}  	/* Insert the string window[strstart .. strstart+2] in the          * dictionary' and set hash_head to the head of the hash chain:          */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		INSERT_STRING (s' s.strstart' ref hash_head);  	}  	/* Find the longest match' discarding those <= prev_length.          */s.prev_length = s.match_length;  	s.prev_match = s.match_start;  	s.match_length = (int)Constant.MIN_MATCH - 1;  	if (hash_head != 0 && s.prev_length < s.max_lazy_match && unchecked(s.strstart - hash_head) <= s.max_dist) {  		/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  			s.match_length = longest_match (s' hash_head);  		}  		/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  			/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  		}  	}  	/* If there was a match at the previous step and the current          * match is not better' output the previous match:          */if (s.prev_length >= (int)Constant.MIN_MATCH && s.match_length <= s.prev_length) {  		uint max_insert = s.strstart + s.lookahead - (int)Constant.MIN_MATCH;  		/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush);  		/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead' the last two strings are not inserted in              * the hash table.              */s.lookahead -= s.prev_length - 1;  		s.prev_length -= 2;  		do {  			if (++s.strstart <= max_insert) {  				INSERT_STRING (s' s.strstart' ref hash_head);  			}  		}  		while (--s.prev_length != 0);  		s.match_available = 0;  		s.match_length = (int)Constant.MIN_MATCH - 1;  		s.strstart++;  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  			if (s.strm.avail_out == 0)  				return block_state.need_more;  		}  	}  	else if (s.match_available != 0) {  		/* If there was no match at the previous position' output a              * single literal. If there was a match but the current match              * is longer' truncate the previous match to a single literal.              */_tr_tally_lit (s' s.window [s.strstart - 1]' ref bflush);  		if (bflush) {  			FLUSH_BLOCK_ONLY (s' false);  		}  		s.strstart++;  		s.lookahead--;  		if (s.strm.avail_out == 0)  			return block_state.need_more;  	}  	else {  		/* There is no previous match to compare with' wait for              * the next step to decide.              */s.match_available = 1;  		s.strstart++;  		s.lookahead--;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: if (hash_head != 0 && s.prev_length < s.max_lazy_match && unchecked(s.strstart - hash_head) <= s.max_dist) {  	/* To simplify the code' we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */if (s.strategy != CompressionStrategy.Z_HUFFMAN_ONLY) {  		s.match_length = longest_match (s' hash_head);  	}  	/* longest_match() sets match_start */if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  		/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: if (s.match_length <= 5 && (s.strategy == CompressionStrategy.Z_FILTERED || (s.match_length == (int)Constant.MIN_MATCH && s.strstart - s.match_start > (int)Constant.TOO_FAR))) {  	/* If prev_match is also MIN_MATCH' match_start is garbage                  * but we will ignore the current match anyway.                  */s.match_length = (int)Constant.MIN_MATCH - 1;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: if (s.prev_length >= (int)Constant.MIN_MATCH && s.match_length <= s.prev_length) {  	uint max_insert = s.strstart + s.lookahead - (int)Constant.MIN_MATCH;  	/* Do not insert strings in hash table beyond this. */_tr_tally_dist (s' s.strstart - 1 - s.prev_match' s.prev_length - (int)Constant.MIN_MATCH' ref bflush);  	/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead' the last two strings are not inserted in              * the hash table.              */s.lookahead -= s.prev_length - 1;  	s.prev_length -= 2;  	do {  		if (++s.strstart <= max_insert) {  			INSERT_STRING (s' s.strstart' ref hash_head);  		}  	}  	while (--s.prev_length != 0);  	s.match_available = 0;  	s.match_length = (int)Constant.MIN_MATCH - 1;  	s.strstart++;  	if (bflush) {  		FLUSH_BLOCK_ONLY (s' false);  		if (s.strm.avail_out == 0)  			return block_state.need_more;  	}  }  else if (s.match_available != 0) {  	/* If there was no match at the previous position' output a              * single literal. If there was a match but the current match              * is longer' truncate the previous match to a single literal.              */_tr_tally_lit (s' s.window [s.strstart - 1]' ref bflush);  	if (bflush) {  		FLUSH_BLOCK_ONLY (s' false);  	}  	s.strstart++;  	s.lookahead--;  	if (s.strm.avail_out == 0)  		return block_state.need_more;  }  else {  	/* There is no previous match to compare with' wait for              * the next step to decide.              */s.match_available = 1;  	s.strstart++;  	s.lookahead--;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate_slow,The following statement contains a magic number: s.prev_length -= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: do {  	more = s.window_size - s.lookahead - s.strstart;  	/* Deal with 64K limit: */if (more == 0 && s.strstart == 0 && s.lookahead == 0) {  		more = s.w_size;  	}  	else if (more == unchecked((uint)(-1))) {  		/* Very unlikely' but possible on 16 bit machine if strstart == 0              * and lookahead == 1 (input done one byte at time)              */more--;  		/* If the window is almost full and there is insufficient lookahead'            * move the upper half to the lower one to make room in the upper half.            */}  	else if (s.strstart >= s.w_size + s.max_dist) {  		System.Array.Copy (s.window' unchecked((int)s.w_size)' s.window' 0' unchecked((int)move));  		unchecked {  			s.match_start -= s.w_size;  			s.strstart -= s.w_size;  			/* we now have strstart >= MAX_DIST */s.block_start -= unchecked((int)s.w_size);  		}  		/* Slide the hash table (could be avoided with 32 bit values                at the expense of memory usage). We slide even when level == 0                to keep the hash table consistent if we switch back to level > 0                later. (Using level 0 permanently is not an optimal usage of                zlib' so we don't care about this pathological case.)              */n = s.hash_size;  		p = n;  		do {  			m = s.head [--p];  			s.head [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  		}  		while (--n != 0);  		n = s.w_size;  		p = n;  		do {  			m = s.prev [--p];  			s.prev [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  			/* If n is not on any hash chain' prev[n] is garbage but              * its value will never be used.              */}  		while (--n != 0);  		more += s.w_size;  	}  	if (s.strm.avail_in == 0)  		return;  	/* If there was no sliding:          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&          *    more == window_size - lookahead - strstart          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)          * => more >= window_size - 2*WSIZE + 2          * In the BIG_MEM or MMAP case (not yet supported)'          *   window_size == input_size + MIN_LOOKAHEAD  &&          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.          * Otherwise' window_size == 2*WSIZE so more >= 2.          * If there was sliding' more >= WSIZE. So in all cases' more >= 2.          */System.Diagnostics.Debug.Assert (more >= 2' "more < 2");  	n = unchecked((uint)read_buf (s.strm' s.window' s.strstart + s.lookahead' more));  	s.lookahead += n;  	/* Initialize the hash value now that we have some input: */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		s.ins_h = s.window [s.strstart];  		UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  		System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  	}  	/* If the whole input has less than MIN_MATCH bytes' ins_h is garbage'          * but this is not important since only literal bytes will be emitted.          */}  while (s.lookahead < (int)s.min_lookahead && s.strm.avail_in != 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: do {  	more = s.window_size - s.lookahead - s.strstart;  	/* Deal with 64K limit: */if (more == 0 && s.strstart == 0 && s.lookahead == 0) {  		more = s.w_size;  	}  	else if (more == unchecked((uint)(-1))) {  		/* Very unlikely' but possible on 16 bit machine if strstart == 0              * and lookahead == 1 (input done one byte at time)              */more--;  		/* If the window is almost full and there is insufficient lookahead'            * move the upper half to the lower one to make room in the upper half.            */}  	else if (s.strstart >= s.w_size + s.max_dist) {  		System.Array.Copy (s.window' unchecked((int)s.w_size)' s.window' 0' unchecked((int)move));  		unchecked {  			s.match_start -= s.w_size;  			s.strstart -= s.w_size;  			/* we now have strstart >= MAX_DIST */s.block_start -= unchecked((int)s.w_size);  		}  		/* Slide the hash table (could be avoided with 32 bit values                at the expense of memory usage). We slide even when level == 0                to keep the hash table consistent if we switch back to level > 0                later. (Using level 0 permanently is not an optimal usage of                zlib' so we don't care about this pathological case.)              */n = s.hash_size;  		p = n;  		do {  			m = s.head [--p];  			s.head [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  		}  		while (--n != 0);  		n = s.w_size;  		p = n;  		do {  			m = s.prev [--p];  			s.prev [p] = unchecked((ushort)(m >= s.w_size ? m - s.w_size : 0));  			/* If n is not on any hash chain' prev[n] is garbage but              * its value will never be used.              */}  		while (--n != 0);  		more += s.w_size;  	}  	if (s.strm.avail_in == 0)  		return;  	/* If there was no sliding:          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&          *    more == window_size - lookahead - strstart          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)          * => more >= window_size - 2*WSIZE + 2          * In the BIG_MEM or MMAP case (not yet supported)'          *   window_size == input_size + MIN_LOOKAHEAD  &&          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.          * Otherwise' window_size == 2*WSIZE so more >= 2.          * If there was sliding' more >= WSIZE. So in all cases' more >= 2.          */System.Diagnostics.Debug.Assert (more >= 2' "more < 2");  	n = unchecked((uint)read_buf (s.strm' s.window' s.strstart + s.lookahead' more));  	s.lookahead += n;  	/* Initialize the hash value now that we have some input: */if (s.lookahead >= (int)Constant.MIN_MATCH) {  		s.ins_h = s.window [s.strstart];  		UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  		System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  	}  	/* If the whole input has less than MIN_MATCH bytes' ins_h is garbage'          * but this is not important since only literal bytes will be emitted.          */}  while (s.lookahead < (int)s.min_lookahead && s.strm.avail_in != 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: System.Diagnostics.Debug.Assert (more >= 2' "more < 2");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: if (s.lookahead >= (int)Constant.MIN_MATCH) {  	s.ins_h = s.window [s.strstart];  	UPDATE_HASH (s' ref s.ins_h' s.window [s.strstart + 1]);  	System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,fill_window,The following statement contains a magic number: System.Diagnostics.Debug.Assert ((int)Constant.MIN_MATCH == 3' "TO DO : Call UPDATE_HASH() MIN_MATCH-3 more times");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,_tr_tally,The following statement contains a magic number: s.pending_buf [s.d_buf + s.last_lit * 2] = unchecked((byte)(dist >> 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,_tr_tally,The following statement contains a magic number: s.pending_buf [s.d_buf + s.last_lit * 2] = unchecked((byte)(dist >> 8));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,_tr_tally,The following statement contains a magic number: s.pending_buf [s.d_buf + s.last_lit * 2 + 1] = unchecked((byte)(dist & 0xff));  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: System.Diagnostics.Debug.Assert (s.hash_bits >= 8 && (s.max_match - 2) % 16 == 0' "Code too clever");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: System.Diagnostics.Debug.Assert (s.hash_bits >= 8 && (s.max_match - 2) % 16 == 0' "Code too clever");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: System.Diagnostics.Debug.Assert (s.hash_bits >= 8 && (s.max_match - 2) % 16 == 0' "Code too clever");  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: if (s.prev_length >= s.good_match) {  	chain_length >>= 2;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: do {  	System.Diagnostics.Debug.Assert (cur_match < s.strstart' "no future");  	match = cur_match;  	/* Skip to next match if the match length cannot increase          * or if the match length is less than 2:          */if (s.window [match + best_len] != scan_end || s.window [match + best_len - 1] != scan_end1 || s.window [match] != s.window [scan] || s.window [++match] != s.window [scan + 1])  		continue;  	/* The check at best_len-1 can be removed because it will be made          * again later. (This heuristic is not always a win.)          * It is not necessary to compare scan[2] and match[2] since they          * are always equal when the other bytes match' given that          * the hash keys are equal and that HASH_BITS >= 8.          */scan += 2;  	match++;  	System.Diagnostics.Debug.Assert (s.window [scan] == s.window [match]' "match[2]?");  	/* We check for insufficient lookahead only every 8th comparison;          * the 256th check will be made at strstart+258.          */do {  	}  	while (s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && s.window [++scan] == s.window [++match] && scan < strend);  	System.Diagnostics.Debug.Assert (scan <= s.window_size - 1' "wild scan");  	len = unchecked((int)(s.max_match - (strend - scan)));  	scan = strend - s.max_match;  	if (len > best_len) {  		s.match_start = cur_match;  		best_len = len;  		if (len >= nice_match)  			break;  		scan_end1 = s.window [scan + best_len - 1];  		scan_end = s.window [scan + best_len];  	}  }  while ((cur_match = s.prev [cur_match & wmask]) > limit && --chain_length != 0);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,longest_match,The following statement contains a magic number: scan += 2;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,InflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	InflateEnd (ref z);  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,InflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	InflateEnd (ref z);  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: while (true) {  	switch (z_state.mode) {  	case inflate_mode.METHOD:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.method = NEXTBYTE (z);  		b = unchecked((byte)(z_state.method & 0x0f));  		if (b != (int)XZLib.Constant.Z_DEFLATED) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "unknown compression method";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((z_state.method >> 4) + 8 > z_state.wbits) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "invalid window size";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.FLAG;  		break;  	case inflate_mode.FLAG:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		b = NEXTBYTE (z);  		if (((z_state.method << 8) + b) % 31 != 0) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect header check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  			z_state.mode = inflate_mode.BLOCKS;  			break;  		}  		System.Diagnostics.Debug.Assert (false' "The following line was never tested");  		z_state.mode = inflate_mode.DICT4;  		break;  	case inflate_mode.DICT4:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.DICT3;  		break;  	case inflate_mode.DICT3:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.DICT2;  		break;  	case inflate_mode.DICT2:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = (ReturnCode)f;  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.DICT1;  		break;  	case inflate_mode.DICT1:  		System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		z.adler = z_state.need;  		z_state.mode = inflate_mode.DICT0;  		return ReturnCode.Z_NEED_DICT;  	case inflate_mode.DICT0:  		z_state.mode = inflate_mode.BAD;  		z.msg = "need dictionary";  		z_state.marker = 0;  		/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  	case inflate_mode.BLOCKS:  		r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  		if (r == ReturnCode.Z_DATA_ERROR) {  			z_state.mode = inflate_mode.BAD;  			z_state.marker = 0;  			/* can try inflateSync */break;  		}  		if (r == ReturnCode.Z_OK)  			r = unchecked((ReturnCode)f);  		if (r != ReturnCode.Z_STREAM_END)  			return r;  		r = unchecked((ReturnCode)f);  		InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  		if (z_state.nowrap != 0) {  			z_state.mode = inflate_mode.DONE;  			break;  		}  		z_state.mode = inflate_mode.CHECK4;  		break;  	case inflate_mode.CHECK4:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  		z_state.mode = inflate_mode.CHECK3;  		break;  	case inflate_mode.CHECK3:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  		z_state.mode = inflate_mode.CHECK2;  		break;  	case inflate_mode.CHECK2:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  		z_state.mode = inflate_mode.CHECK1;  		break;  	case inflate_mode.CHECK1:  		if (z.avail_in == 0)  			return r;  		r = unchecked((ReturnCode)f);  		z_state.need += NEXTBYTE (z);  		if (z_state.was != z_state.need) {  			z_state.mode = inflate_mode.BAD;  			z.msg = "incorrect data check";  			z_state.marker = 5;  			/* can't try inflateSync */break;  		}  		z_state.mode = inflate_mode.DONE;  		break;  	case inflate_mode.DONE:  		return ReturnCode.Z_STREAM_END;  	case inflate_mode.BAD:  		return ReturnCode.Z_DATA_ERROR;  	default:  		return ReturnCode.Z_STREAM_ERROR;  	}  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: switch (z_state.mode) {  case inflate_mode.METHOD:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.method = NEXTBYTE (z);  	b = unchecked((byte)(z_state.method & 0x0f));  	if (b != (int)XZLib.Constant.Z_DEFLATED) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "unknown compression method";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((z_state.method >> 4) + 8 > z_state.wbits) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "invalid window size";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.FLAG;  	break;  case inflate_mode.FLAG:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	b = NEXTBYTE (z);  	if (((z_state.method << 8) + b) % 31 != 0) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect header check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	if ((b & unchecked((byte)XZLib.Constant.PRESET_DICT)) == 0) {  		z_state.mode = inflate_mode.BLOCKS;  		break;  	}  	System.Diagnostics.Debug.Assert (false' "The following line was never tested");  	z_state.mode = inflate_mode.DICT4;  	break;  case inflate_mode.DICT4:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.DICT3;  	break;  case inflate_mode.DICT3:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.DICT2;  	break;  case inflate_mode.DICT2:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = (ReturnCode)f;  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.DICT1;  	break;  case inflate_mode.DICT1:  	System.Diagnostics.Debug.Assert (false' "The following lines were never tested");  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	z.adler = z_state.need;  	z_state.mode = inflate_mode.DICT0;  	return ReturnCode.Z_NEED_DICT;  case inflate_mode.DICT0:  	z_state.mode = inflate_mode.BAD;  	z.msg = "need dictionary";  	z_state.marker = 0;  	/* can try inflateSync */return ReturnCode.Z_STREAM_ERROR;  case inflate_mode.BLOCKS:  	r = InfBlock.inflate_blocks (ref z_state.blocks' ref z' r);  	if (r == ReturnCode.Z_DATA_ERROR) {  		z_state.mode = inflate_mode.BAD;  		z_state.marker = 0;  		/* can try inflateSync */break;  	}  	if (r == ReturnCode.Z_OK)  		r = unchecked((ReturnCode)f);  	if (r != ReturnCode.Z_STREAM_END)  		return r;  	r = unchecked((ReturnCode)f);  	InfBlock.inflate_blocks_reset (z_state.blocks' ref z' ref z_state.was);  	if (z_state.nowrap != 0) {  		z_state.mode = inflate_mode.DONE;  		break;  	}  	z_state.mode = inflate_mode.CHECK4;  	break;  case inflate_mode.CHECK4:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  	z_state.mode = inflate_mode.CHECK3;  	break;  case inflate_mode.CHECK3:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  	z_state.mode = inflate_mode.CHECK2;  	break;  case inflate_mode.CHECK2:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  	z_state.mode = inflate_mode.CHECK1;  	break;  case inflate_mode.CHECK1:  	if (z.avail_in == 0)  		return r;  	r = unchecked((ReturnCode)f);  	z_state.need += NEXTBYTE (z);  	if (z_state.was != z_state.need) {  		z_state.mode = inflate_mode.BAD;  		z.msg = "incorrect data check";  		z_state.marker = 5;  		/* can't try inflateSync */break;  	}  	z_state.mode = inflate_mode.DONE;  	break;  case inflate_mode.DONE:  	return ReturnCode.Z_STREAM_END;  case inflate_mode.BAD:  	return ReturnCode.Z_DATA_ERROR;  default:  	return ReturnCode.Z_STREAM_ERROR;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (b != (int)XZLib.Constant.Z_DEFLATED) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "unknown compression method";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if ((z_state.method >> 4) + 8 > z_state.wbits) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "invalid window size";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if ((z_state.method >> 4) + 8 > z_state.wbits) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "invalid window size";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if ((z_state.method >> 4) + 8 > z_state.wbits) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "invalid window size";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (((z_state.method << 8) + b) % 31 != 0) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect header check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (((z_state.method << 8) + b) % 31 != 0) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect header check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (((z_state.method << 8) + b) % 31 != 0) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect header check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need = unchecked((uint)NEXTBYTE (z) << 24);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 16);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.need += unchecked((uint)NEXTBYTE (z) << 8);  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: if (z_state.was != z_state.need) {  	z_state.mode = inflate_mode.BAD;  	z.msg = "incorrect data check";  	z_state.marker = 5;  	/* can't try inflateSync */break;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XInflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XInflate.cs,inflate,The following statement contains a magic number: z_state.marker = 5;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: k -= 16;  
Magic Number,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 43)' (17' 45))
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 43)' (17' 45))
Duplicate Code,Xceed.Compression.CompressionEngine.Managed,XZLib,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XZLib.cs,Adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Missing Default,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\Utils\Streams\WindowStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin: {  	beginOffset = offset;  	offset += m_beginOffset;  	break;  }  case SeekOrigin.Current: {  	beginOffset = (m_innerStream.Position - m_beginOffset) + offset;  	break;  }  case SeekOrigin.End: {  	if (m_length != -1) {  		beginOffset = m_length + offset;  		offset -= (m_innerStream.Length - m_beginOffset - m_length);  	}  	else  		beginOffset = m_innerStream.Length + offset;  	break;  }  }  
Missing Default,Xceed.Compression.CompressionEngine.Managed,InfBlock,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\InfBlock.cs,inflate_blocks,The following switch statement is missing a default case: switch (t >> 1) {  case 0:  	/* stored */DUMPBITS (3' ref b' ref k);  	t = k & 7;  	/* go to byte boundary */DUMPBITS (t' ref b' ref k);  	s.mode = inflate_block_mode.LENS;  	/* get length of stored block */break;  case 1:  	/* fixed */{  		uint bl = 0;  		uint bd = 0;  		InfTrees.inflate_huft[] tl = null;  		InfTrees.inflate_huft[] td = null;  		InfTrees.inflate_trees_fixed (ref bl' ref bd' ref tl' ref td);  		s.codes = InfCodes.inflate_codes_new (bl' bd' tl' td);  		if (s.codes == null) {  			r = ReturnCode.Z_MEM_ERROR;  			return LEAVE (b' k' n' p' q' s' z' r);  		}  	}  	DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.CODES;  	break;  case 2:  	/* dynamic */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.TABLE;  	break;  case 3:  	/* illegal */DUMPBITS (3' ref b' ref k);  	s.mode = inflate_block_mode.BAD;  	z.msg = "invalid block type";  	r = ReturnCode.Z_DATA_ERROR;  	return LEAVE (b' k' n' p' q' s' z' r);  }  
Missing Default,Xceed.Compression.CompressionEngine.Managed,XDeflate,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.GZip.Blueprint\XZLib\XDeflate.cs,deflate,The following switch statement is missing a default case: switch (configuration_table [s.level].func) {  case Compress_func.deflate_stored:  	bstate = deflate_stored (s' flush);  	break;  case Compress_func.deflate_fast:  	bstate = deflate_fast (s' flush);  	break;  case Compress_func.deflate_slow:  	bstate = deflate_slow (s' flush);  	break;  }  
