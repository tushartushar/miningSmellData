Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The method has 115 lines of code.
Long Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The method has 110 lines of code.
Long Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The method has 128 lines of code.
Long Method,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,Flush,The method has 119 lines of code.
Long Method,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,WriteZipToStream,The method has 111 lines of code.
Long Method,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingWriteStream,The method has 100 lines of code.
Long Method,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenRead,The method has 157 lines of code.
Long Method,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenWrite,The method has 138 lines of code.
Long Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,The method has 106 lines of code.
Long Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The method has 256 lines of code.
Long Method,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemLocalHeader,The method has 125 lines of code.
Long Method,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteCentralHeader,The method has 108 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,OpenWrite,The method has 162 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,Update,The method has 146 lines of code.
Long Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The method has 212 lines of code.
Long Method,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The method has 192 lines of code.
Long Method,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The method has 208 lines of code.
Complex Method,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip,UTF8CommentExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8CommentExtraHeader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip,UTF8CommentExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8CommentExtraHeader.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,Cyclomatic complexity of the method is 20
Complex Method,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Zip,UnknownExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnknownExtraHeader.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Read,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Remove,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,Cyclomatic complexity of the method is 24
Complex Method,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,Dispose,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ToCompressionLevel,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadCentralHeader,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadLocalHeader,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,Cyclomatic complexity of the method is 15
Complex Method,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,WriteZipToStream,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,UpdatePrefixStorageItem,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,Cyclomatic complexity of the method is 20
Complex Method,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingWriteStream,Cyclomatic complexity of the method is 18
Complex Method,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,WriteLocalHeader,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,ZippedFile,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,ZippedFolder,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,DoReadItems,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadItem,Cyclomatic complexity of the method is 9
Complex Method,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,Cyclomatic complexity of the method is 12
Complex Method,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,Cyclomatic complexity of the method is 12
Complex Method,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Zip.ReaderWriter,ZipItemLocalHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipItemLocalHeader.cs,ZipItemLocalHeader,Cyclomatic complexity of the method is 20
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,Dispose,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemLocalHeader,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadEndHeader,Cyclomatic complexity of the method is 20
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,Cyclomatic complexity of the method is 49
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadSignature,Cyclomatic complexity of the method is 21
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,FindSignatureInBuffer,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadNextHeaderInLastReadBuffer,Cyclomatic complexity of the method is 23
Complex Method,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemLocalHeader,Cyclomatic complexity of the method is 28
Complex Method,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,InitializeZipWriter,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,OpenRead,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,OpenWrite,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,Update,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,UpdateItems,Cyclomatic complexity of the method is 15
Complex Method,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,Cyclomatic complexity of the method is 40
Complex Method,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,AddItem,Cyclomatic complexity of the method is 29
Complex Method,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Utils.Storage,StorageKeyComparer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageKeyComparer.cs,Compare,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\CombinedStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\CombinedStream.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,HeaderFooterStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\HeaderFooterStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,SHA1Stream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SHA1Stream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,StreamSearcher,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamSearcher.cs,FindImpl,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Streams,StreamSearcher,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamSearcher.cs,ReverseFindImpl,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,Cyclomatic complexity of the method is 29
Complex Method,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,Cyclomatic complexity of the method is 42
Long Parameter List,Xceed.Zip,DiskRequiredEventArgs,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\DiskRequiredEventArgs.cs,DiskRequiredEventArgs,The method has 5 parameters.
Long Parameter List,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,UTF8CommentExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8CommentExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,UnknownExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnknownExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The method has 6 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 5 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 6 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 7 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 8 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 8 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 9 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 8 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 9 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 11 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 7 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 9 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 14 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The method has 15 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The method has 6 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The method has 7 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The method has 9 parameters.
Long Parameter List,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The method has 11 parameters.
Long Parameter List,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The method has 5 parameters.
Long Parameter List,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The method has 5 parameters.
Long Parameter List,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The method has 6 parameters.
Long Parameter List,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The method has 5 parameters.
Long Parameter List,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The method has 6 parameters.
Long Parameter List,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The method has 7 parameters.
Long Parameter List,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,The method has 5 parameters.
Long Parameter List,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,The method has 7 parameters.
Long Parameter List,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenWrite,The method has 9 parameters.
Long Parameter List,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The method has 5 parameters.
Long Parameter List,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The method has 5 parameters.
Long Parameter List,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The method has 6 parameters.
Long Parameter List,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The method has 7 parameters.
Long Parameter List,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The method has 7 parameters.
Long Parameter List,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoOpenWrite,The method has 6 parameters.
Long Parameter List,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoOpenWrite,The method has 8 parameters.
Long Parameter List,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadItem,The method has 5 parameters.
Long Parameter List,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The method has 5 parameters.
Long Parameter List,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The method has 6 parameters.
Long Parameter List,Xceed.Zip.ReaderWriter,ZipItemLocalHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipItemLocalHeader.cs,ZipItemLocalHeader,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,ReadItem,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,OnItemRead,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Text,OEM437Encoding,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Text\OEM437Encoding.cs,GetBytes,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Text,OEM437Encoding,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Text\OEM437Encoding.cs,GetChars,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCryptStream.cs,ZCryptStream,The method has 5 parameters.
Long Identifier,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the parameter preservedPathDestinationFolder is 30.
Long Identifier,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,Read,The length of the parameter bytesToDiscardFromSlidingWindow is 31.
Long Identifier,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,FillSlidingWindow,The length of the parameter bytesToDiscardFromSlidingWindow is 31.
Long Statement,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnBuildingZipByteProgression,The length of the statement  "		if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100)) { " is 121.
Long Statement,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnGatheringZipContentByteProgression,The length of the statement  "		if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100)) { " is 121.
Long Statement,Xceed.Zip,UTF8CommentExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8CommentExtraHeader.cs,Write,The length of the statement  "		throw new InvalidOperationException ("ItemHeader for \"" + header.FileName + "\" didn't provide a file comment char array to UTF8CommentExtraHeader.Write()."); " is 159.
Long Statement,Xceed.Zip,UTF8CommentExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8CommentExtraHeader.cs,Write,The length of the statement  "		throw new InvalidOperationException ("ItemHeader for \"" + header.FileName + "\" didn't provide a raw file comment to UTF8CommentExtraHeader.Write()."); " is 152.
Long Statement,Xceed.Zip,UTF8CommentExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8CommentExtraHeader.cs,Write,The length of the statement  "	uint crc32 = unchecked((uint)ChecksumStream.CalculateCrc32 (transientData.RawFileComment' 0' transientData.RawFileComment.Length' 0)); " is 134.
Long Statement,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The length of the statement  "		throw new InvalidZipStructureException ("The Unicode extra header's reported filename and comment sizes exceed the extra header size."); " is 136.
Long Statement,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The length of the statement  "		string filename = System.Text.Encoding.Unicode.GetString (data' offset' filenameSize * 2).Replace ('/'' System.IO.Path.DirectorySeparatorChar); " is 143.
Long Statement,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The length of the statement  "	System.Diagnostics.Debug.Assert (filenameData.Length % 2 == 0' "We expect the Unicode encoder to always use 2 bytes per char."); " is 128.
Long Statement,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The length of the statement  "		System.Diagnostics.Debug.Assert (commentData.Length % 2 == 0' "We expect the Unicode encoder to always use 2 bytes per char."); " is 127.
Long Statement,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Read,The length of the statement  "		throw new InvalidOperationException ("ItemHeader for \"" + header.FileName + "\" didn't provide a raw filename to UTF8FilenameExtraHeader.Read()."); " is 148.
Long Statement,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Read,The length of the statement  "	uint actualCRC32 = unchecked((uint)ChecksumStream.CalculateCrc32 (transientData.RawFileName' 0' transientData.RawFileName.Length' 0)); " is 134.
Long Statement,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Read,The length of the statement  "		string filename = Encoding.UTF8.GetString (data' offset' filenameSize).Replace ('/'' System.IO.Path.DirectorySeparatorChar); " is 124.
Long Statement,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Write,The length of the statement  "		throw new InvalidOperationException ("ItemHeader for \"" + header.FileName + "\" didn't provide a filename char array to UTF8FilenameExtraHeader.Write()."); " is 156.
Long Statement,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Write,The length of the statement  "		throw new InvalidOperationException ("ItemHeader for \"" + header.FileName + "\" didn't provide a raw filename to UTF8FilenameExtraHeader.Write()."); " is 149.
Long Statement,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Write,The length of the statement  "	/* For speed' we use the filename char array. It has already been 'unfixed' */byte[] filenameData = Encoding.UTF8.GetBytes (transientData.FileNameArray); " is 153.
Long Statement,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Write,The length of the statement  "	uint crc32 = unchecked((uint)ChecksumStream.CalculateCrc32 (transientData.RawFileName' 0' transientData.RawFileName.Length' 0)); " is 128.
Long Statement,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The length of the statement  "	bool needUncompressedSize = (uncompressedSize >= 0xffffffff) || ((compressedSize >= 0xffffffff) && (!fromCentralHeader)); " is 121.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,GetZipContents,The length of the statement  "		AbstractQuickActionItem[] abstractQuickItems = mg_quickZipCompression.GetFolderContents (zipArchive' recursive' fileMasks); " is 123.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,GetZipContents,The length of the statement  "		quickZipItems = Array.ConvertAll (abstractQuickItems' new Converter<AbstractQuickActionItem' QuickZipItem> (ConvertToQuickZipItem)); " is 132.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' string.Empty' EncryptionMethod.Compatible' replaceExistingFiles' recursive' preservePaths' filesToZip); " is 121.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' EncryptionMethod.Compatible' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' filesToZip); " is 155.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' encryptionMethod' replaceExistingFiles' recursive' preservePaths' 0' SplitNameFormat.None' filesToZip); " is 141.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' encryptionMethod' compressionMethod' replaceExistingFiles' recursive' preservePaths' 0' SplitNameFormat.None' null' null' null' null' null' filesToZip); " is 190.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' EncryptionMethod.Compatible' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' splitSize' splitNameFormat' null' null' null' null' null' filesToZip); " is 213.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' encryptionMethod' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' splitSize' splitNameFormat' null' null' null' null' null' filesToZip); " is 202.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' EncryptionMethod.Compatible' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' 0' SplitNameFormat.None' null' diskRequiredCallback' null' null' userParams' filesToZip); " is 232.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' encryptionMethod' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' 0' SplitNameFormat.None' null' diskRequiredCallback' null' null' userParams' filesToZip); " is 221.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' encryptionMethod' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' splitSize' splitNameFormat' null' diskRequiredCallback' null' null' userParams' filesToZip); " is 224.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' EncryptionMethod.Compatible' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' 0' SplitNameFormat.None' sfx' diskRequiredCallback' null' null' userParams' filesToZip); " is 231.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "	Zip (zipFileName' encryptionPassword' encryptionMethod' CompressionMethod.Deflated' replaceExistingFiles' recursive' preservePaths' splitSize' splitNameFormat' sfx' diskRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' filesToZip); " is 261.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The length of the statement  "			List<FileSystemItem> fileSystemItemList = mg_quickZipCompression.CreateItemListFromPaths (zipArchive' true' filesToZip' recursive' notFilter); " is 142.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The length of the statement  "	Unzip (zipFileName' destinationFolder' string.Empty' replaceExistingFiles' recursive' preservePaths' null' null' filesToUnzip); " is 127.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The length of the statement  "	Unzip (zipFileName' destinationFolder' decryptionPassword' replaceExistingFiles' recursive' preservePaths' null' null' filesToUnzip); " is 133.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The length of the statement  "	Unzip (zipFileName' destinationFolder' decryptionPassword' replaceExistingFiles' recursive' preservePaths' diskRequiredCallback' null' null' userParams' filesToUnzip); " is 167.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Unzip,The length of the statement  "		List<FileSystemItem> fileSystemItemList = mg_quickZipCompression.CreateItemListFromPaths (zipArchive' false' filesToUnzip' recursive' notFilter); " is 145.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Remove,The length of the statement  "				if (!pathName.EndsWith (Path.DirectorySeparatorChar.ToString ()) && !pathName.EndsWith (Path.AltDirectorySeparatorChar.ToString ())) { " is 134.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,OnDiskRequired,The length of the statement  "	if ((e.Reason != DiskRequiredReason.Deleting) && ((e.Action == DiskRequiredAction.Fail) || (e.Reason == DiskRequiredReason.Updating))) { " is 136.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,OnDiskRequired,The length of the statement  "		e.Action = (diskRequiredCallBack (e.ZipFile.FullName' e.DiskNumber' userParams)) ? DiskRequiredAction.Continue : DiskRequiredAction.Fail; " is 137.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,OnByteProgression,The length of the statement  "	byteProgressionCallback (e.CurrentItem.FullName' e.CurrentFileBytes.Processed' e.CurrentFileBytes.Total' e.CurrentFileBytes.Percent' e.AllFilesBytes.Processed' e.AllFilesBytes.Total' e.AllFilesBytes.Percent' userParams); " is 220.
Long Statement,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,OnItemProgression,The length of the statement  "	itemProgressionCallback (e.CurrentItem.FullName' e.AllItems.Processed' e.AllItems.Total' e.AllItems.Percent' ref abort' userParams); " is 132.
Long Statement,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadCentralHeader,The length of the statement  "			uint actualCRC32 = unchecked((uint)ChecksumStream.CalculateCrc32 (textData.RawFileComment' 0' textData.RawFileComment.Length' 0)); " is 130.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The length of the statement  "		if (this.Encrypted && this.EncryptionMethod == EncryptionMethod.Compatible && this.m_originalLastModFileTime.HasValue) { " is 120.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadLocalHeader,The length of the statement  "		if ((generalBitFlags & ZipGeneralBitFlags.UsefulBitsMask) != (this.GeneralBitFlags & ZipGeneralBitFlags.UsefulBitsMask)) { " is 122.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadLocalHeader,The length of the statement  "		if ((versionNeeded != this.VersionNeeded) || ((compressionMethod != ZipCompressionMethod.Unknown) && (compressionMethod != this.CompressionMethod))) { " is 150.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadLocalHeader,The length of the statement  "		if ((!this.HasDescriptorHeader) && ((crc32 != this.Crc32) || ((compressedSize != 0xffffffff) && (compressedSize != this.CompressedSize)) || ((uncompressedSize != 0xffffffff) && (uncompressedSize != this.UncompressedSize)))) { " is 225.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The length of the statement  "			if (this.Encrypted && this.EncryptionMethod == EncryptionMethod.Compatible && this.m_originalLastModFileTime.HasValue) { " is 120.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The length of the statement  "		System.Diagnostics.Debug.Assert ((!this.Encrypted) || (this.EncryptionMethod != EncryptionMethod.WinZipAes) || (this.Crc32 == 0)' "A CRC32 was calculated while the file is encrypted with AES."); " is 194.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,GetEffectiveTextEncoding,The length of the statement  "	return this.GetEffectiveTextEncoding (this.m_generalBitFlags' this.m_unicodeOnNonASCIIOnly' containsNonASCII' out nonStandardEncodingUsed); " is 139.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,GetEffectiveTextEncoding,The length of the statement  "	return this.GetEffectiveTextEncoding (this.m_generalBitFlags' this.m_unicodeOnNonASCIIOnly' containsNonASCII' out nonStandardEncodingUsed); " is 139.
Long Statement,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,GetEffectiveTextEncoding,The length of the statement  "	return this.GetEffectiveTextEncoding (generalBitFlags' unicodeOnNonASCIIOnly' containsNonASCII' out nonStandardEncodingUsed); " is 125.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,Dispose,The length of the statement  "          System.Diagnostics.Debug.Assert( m_cachedStreams.Count == 0' "Streams are still open while ZipHandler gets disposed." );" is 120.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,Dispose,The length of the statement  "          System.Diagnostics.Debug.Assert( m_busyStreams.Count == 0' "Streams are still open and in use while ZipHandler gets disposed." );" is 129.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReleaseModify,The length of the statement  "        throw new InvalidOperationException( "ReleaseModify was called once more than AddRefModify. Both calls should always match." );" is 127.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReleaseStream,The length of the statement  "        throw new InvalidOperationException( "ReleaseStream was called once more than AddRefStream. Both calls should always match." );" is 127.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,The length of the statement  "	this.DoChangeDisk (session' storage' ref diskNumber' this.LastDiskNumber' reason' this.m_activeSplitNameFormat' ref storageFile); " is 129.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,The length of the statement  "	if (splitNameFormat != SplitNameFormat.None || (reason == DiskRequiredReason.Updating && (storage.CurrentDiskNumber == 0 || !storage.HaveCurrentDiskNumber))) { " is 159.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,The length of the statement  "		throw new ArgumentOutOfRangeException ("A split size is higher than " + long.MaxValue.ToString ("X") + " bytes is not supported."); " is 131.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,The length of the statement  "	DiskRequiredEventArgs args = new DiskRequiredEventArgs (reason' splitFile' (int)(diskNumber + 1)' splitSize' defaultAction); " is 124.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,RenameItem,The length of the statement  "          SortedList<string' ZipItemHandler> children = new SortedList<string' ZipItemHandler>( this.m_children' StringComparer.OrdinalIgnoreCase );" is 138.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,AddReference,The length of the statement  "		this.UpdatePrefixStorageItem (ref this.m_spanningHeaderStorageItem' this.m_splitSize != 0 || this.m_allowSpanning' this.m_sfxPrefixStorageItem); " is 144.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,Flush,The length of the statement  "          System.Diagnostics.Debug.Assert( this.LastDiskNumber != uint.MaxValue' "We just finished zipping. The last disk cannot be -1." );" is 129.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,Flush,The length of the statement  "          System.Diagnostics.Debug.Assert( previousLastDisk != uint.MaxValue' "previousLastDisk is greater that this.LastDiskNumber. It can't be -1." );" is 142.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The length of the statement  "			throw new InvalidZipStructureException ("The zip end header signature could not be found in the zip file."' this.MainFile); " is 123.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,WriteZipToStream,The length of the statement  "		//System.Diagnostics.Debug.Assert( this.LastDiskNumber == uint.MaxValue' "The SplitNameFormat cannot work if the last disk is not -1 while writing the zip file." ); " is 164.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,WriteZipToStream,The length of the statement  "					throw new FileSystemInternalException ("The Zip64 ending header spanned on the last disk and could not be rewritten to the same position."); " is 140.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,WriteZipToStream,The length of the statement  "				throw new FileSystemInternalException ("The ending header spanned on the last disk and could not be rewritten to the same position."); " is 134.
Long Statement,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The length of the statement  "	else if ((lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))) { " is 169.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "				              throw new FileSystemNotSupportedException( "Cannot decrypt AES-encrypted zip files under the .NET Compact Framework."' null );" is 126.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "				Rfc2898DeriveBytesManager rfc2898DeriveBytesManager = resourceManager.ObtainResource<Rfc2898DeriveBytesManager> (ZipHandler.Rfc2898DeriveBytesManagerResource); " is 159.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "				innerStream = new AesEncryptionStream (innerStream' ZipHandler.AesAlgorithmManager' rfc2898DeriveBytesManager' decryptionPassword' m_header.EncryptionStrength' false); " is 167.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "				throw new FileSystemNotSupportedException ("Unsupported encryption method '" + this.m_header.EncryptionMethod.ToString () + "'."' null); " is 136.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "             * leaving the encryption stream not positioned correctly to read the authentication code. */// If an end of stream marker is present in the compressed data and it's encrypted with WinZipAES " is 189.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "				if (this.m_header.UsesLZMAEndOfStreamMarker && this.Encrypted && this.m_header.EncryptionMethod == EncryptionMethod.WinZipAes) { " is 128.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "				Decompressor decompressor = DecompressorFactory.CreateLzmaDecompressor (compressedSize' uncompressedSize' LZMAHeaderType.Zip); " is 126.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The length of the statement  "			throw new InvalidZipStructureException ("The file is compressed with an unknown compression method."' m_zipHandler.LastZipFile' except); " is 136.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingWriteStream,The length of the statement  "				Rfc2898DeriveBytesManager rfc2898DeriveBytesManager = resourceManager.ObtainResource<Rfc2898DeriveBytesManager> (ZipHandler.Rfc2898DeriveBytesManagerResource); " is 159.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingWriteStream,The length of the statement  "				innerStream = new AesEncryptionStream (stream' ZipHandler.AesAlgorithmManager' rfc2898DeriveBytesManager' this.EncryptionPassword' this.m_header.EncryptionStrength' true); " is 171.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingWriteStream,The length of the statement  "				throw new FileSystemNotSupportedException ("Unsupported encryption method '" + this.m_header.EncryptionMethod.ToString () + "'."' null); " is 136.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingWriteStream,The length of the statement  "			compressStream = new CompressedStream (innerStream' CompressorFactory.CreateLzmaCompressor (this.m_header.CompressionLevel' LZMAHeaderType.Zip)); " is 145.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenRead,The length of the statement  "		#                throw new FileSystemNotSupportedException( "Cannot decrypt AES-encrypted zip files under the .NET Compact Framework."' null );" is 143.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenRead,The length of the statement  "		#                innerStream = new AesEncryptionStream( innerStream' decryptionPassword' m_header.EncryptionStrength' false );" is 126.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenRead,The length of the statement  "            throw new InvalidZipStructureException( "The file is compressed with an unknown compression method."' m_zipHandler.LastZipFile' except );" is 137.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenWrite,The length of the statement  "		throw new FileSystemInternalException ("An unexpected attempt was made to open a folder for writing."' m_zipHandler.LastZipFile); " is 129.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenWrite,The length of the statement  "        throw new FileSystemInternalException( "An unexpected attempt was made to open a folder for writing."' m_zipHandler.LastZipFile );" is 130.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OpenWrite,The length of the statement  "            this.OpenWrite( stream' compressionMethod' compressionLevel' encryptionPassword' encryptionMethod' encryptionStrength )'" is 120.
Long Statement,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,WriteLocalHeader,The length of the statement  "			System.Diagnostics.Debug.Assert ((this.UncompressedSize == 0) || (this.CompressedSize > 0)' "We should already know our compressed size."); " is 139.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenRead,The length of the statement  "		throw new FileSystemNotSupportedException ("ZippedFile objects can only be opened with FileShare.None or FileShare.Read for reading."' this); " is 141.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The length of the statement  "	return this.OpenWrite (FileSystemEvents.Empty' null' compressionMethod' compressionLevel' encryptionPassword' encryptionMethod' encryptionStrength); " is 148.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The length of the statement  "	return this.OpenWrite (FileSystemEvents.Empty' null' overwrite' share' compressionMethod' compressionLevel' encryptionPassword); " is 128.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The length of the statement  "	return this.OpenWrite (events' userData' overwrite' FileShare.None' compressionMethod' compressionLevel' encryptionPassword); " is 125.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The length of the statement  "	return this.DoOpenWrite (session' true' FileShare.None' compressionMethod' compressionLevel' encryptionPassword' encryptionMethod' encryptionStrength); " is 151.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,OpenWrite,The length of the statement  "		throw new FileSystemNotSupportedException ("ZippedFile objects can only be opened with FileShare.None for writing."' this); " is 123.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoOpenRead,The length of the statement  "		throw new FileSystemNotSupportedException ("ZippedFile objects can only be opened with FileShare.None or FileShare.Read for reading."' this); " is 141.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoOpenWrite,The length of the statement  "		throw new FileSystemNotSupportedException ("ZippedFile objects can only be opened with FileShare.None for writing."' this); " is 123.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoOpenWrite,The length of the statement  "	return this.DoOpenWrite (session' overwrite' share' m_zipHandler.DefaultCompressionMethod' m_zipHandler.DefaultCompressionLevel' m_zipHandler.DefaultEncryptionPassword' m_zipHandler.DefaultEncryptionMethod' m_zipHandler.DefaultEncryptionStrength); " is 247.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoOpenWrite,The length of the statement  "			return token.ItemHandler.OpenWrite (session' share' compressionMethod' compressionLevel' encryptionPassword' EncryptionMethod.Compatible' 0' m_zipHandler.DefaultTextEncoding' m_zipHandler.DefaultDefaultUnicodeUsagePolicy); " is 222.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoOpenWrite,The length of the statement  "			return token.ItemHandler.OpenWrite (session' share' compressionMethod' compressionLevel' encryptionPassword' encryptionMethod' encryptionStrength' m_zipHandler.DefaultTextEncoding' m_zipHandler.DefaultDefaultUnicodeUsagePolicy); " is 228.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoCreate,The length of the statement  "				throw new FileSystemInternalException ("An unexpected attempt was made to create an item in a folder that does not exist."' this); " is 130.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoCreate,The length of the statement  "          throw new FileSystemInternalException( "An unexpected attempt was made to create an item in a folder that does not exist."' this );" is 131.
Long Statement,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoApplyPropertiesFrom,The length of the statement  "	if ((m_zipHandler.DefaultEncryptionPassword.Length > 0) && (m_zipHandler.DefaultEncryptionMethod == EncryptionMethod.Compatible)) { " is 131.
Long Statement,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,DoGetFile,The length of the statement  "		System.Diagnostics.Debug.Assert (fileName.IndexOf (Path.DirectorySeparatorChar.ToString ()) == -1' "The fileName parameter cannot end with a directory separator char."); " is 169.
Long Statement,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,DoGetFolder,The length of the statement  "		System.Diagnostics.Debug.Assert (folderName.IndexOf (Path.DirectorySeparatorChar.ToString ()) == -1' "The folderName parameter cannot end with a directory separator char."); " is 173.
Long Statement,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,DoCreate,The length of the statement  "				throw new FileSystemInternalException ("An unexpected attempt was made to create an item in a folder that does not exist."' this); " is 130.
Long Statement,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,DoCreate,The length of the statement  "          throw new FileSystemInternalException( "An unexpected attempt was made to create an item in a folder that does not exist."' this );" is 131.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The length of the statement  "		throw new InvalidZipStructureException ("Could not find a local header where one was expected in the zip file."' this.ZipHandler.LastZipFile); " is 142.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The length of the statement  "              "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );" is 132.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The length of the statement  "		throw new InvalidZipStructureException (String.Format ("Could not find a local header where one was expected in the zip file. Expected 0x{0:x8} but got 0x{1:x8}"' ItemHeader.LocalSignature' signature)' this.ZipHandler.LastZipFile); " is 231.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The length of the statement  "              "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );" is 132.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnUpdateIsUpdateNeeded,The length of the statement  "       * Here' we check for the modified storage marker here. */// We need updating if the storage has been marked as needing updating " is 127.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadItem,The length of the statement  "		throw new InvalidZipStructureException ("Could not find a central header where one was expected in the zip file."' StorageFile); " is 128.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadItem,The length of the statement  "		throw new InvalidZipStructureException ("Could not find a central header where one was expected in the zip file."' StorageFile); " is 128.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadItem,The length of the statement  "		if ((zipReadItemsSession.FirstHeaderDisk > header.LocalHeaderDisk) || (zipReadItemsSession.FirstHeaderDisk == header.LocalHeaderDisk && zipReadItemsSession.FirstHeaderOffset > header.LocalHeaderOffset)) { " is 204.
Long Statement,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnClosingWriteStream,The length of the statement  "	if (!itemHeader.HasDescriptorHeader || ((destStream.CanSeek) && (this.CurrentDiskNumber == itemHeader.LocalHeaderDisk) && ((!itemHeader.Encrypted) || (itemHeader.EncryptionMethod != EncryptionMethod.Compatible)))) { " is 215.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The length of the statement  "				throw new FileSystemIOException ("The parent folder full name is too long for item : " + fileParentFolderPath' null' exception); " is 128.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The length of the statement  "			if ((fileParentFolderPath == Path.DirectorySeparatorChar.ToString ()) || (fileParentFolderPath == Path.AltDirectorySeparatorChar.ToString ())) { " is 144.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,The length of the statement  "			if (!fileParentFolderPath.EndsWith (Path.DirectorySeparatorChar.ToString ()) && !fileParentFolderPath.EndsWith (Path.AltDirectorySeparatorChar.ToString ())) { " is 158.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,The length of the statement  "			if (fileParentFolderPath == Path.DirectorySeparatorChar.ToString () || fileParentFolderPath == Path.AltDirectorySeparatorChar.ToString ()) { " is 140.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "			throw new FileSystemIOException ("The parent folder full name is too long for item : " + fileSystemItem.FullName' null' exception); " is 131.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "				throw new FileSystemIOException ("The parent's full name is too long for item : " + fileSystemItem.FullName' null' exception); " is 126.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "			// If in current folder' no root path specified or sourceFolderPath is a root path' use the destination folder directly. " is 120.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemLocalHeader,The length of the statement  "				throw new Xceed.Zip.ReaderWriter.InvalidZipStructureException ("Unable to find file LocalHeader or CentralDirectory signature of zip file."); " is 141.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemLocalHeader,The length of the statement  "		else if (m_zipReaderState == ZipReaderState.READ_CENTRAL_HEADER || m_zipReaderState == ZipReaderState.READ_ZIP64_ENDHEADER || m_zipReaderState == ZipReaderState.READ_ZIP64_ENDHEADER_LOCATOR || m_zipReaderState == ZipReaderState.READ_ENDHEADER) { " is 245.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,The length of the statement  "							string message = String.Format ("'{0}': The calculated AES authentication value does not match the value read from the zip file."' m_currentItemInfo.FileName); " is 159.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,The length of the statement  "					throw new Xceed.Zip.ReaderWriter.InvalidZipStructureException ("DataDescriptorHeader signature was expected but not found."); " is 125.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,The length of the statement  "			if (!m_currentItemInfo.Encrypted || (m_currentItemInfo.Encrypted && m_currentItemInfo.EncryptionMethod != EncryptionMethod.WinZipAes)) { " is 136.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,The length of the statement  "					string message = String.Format ("'{0}': The calculated CRC does not match the CRC written in the {1} header."' m_currentItemInfo.FileName' m_currentItemInfo.HasDescriptorHeader ? "data descriptor" : "local"); " is 208.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadEndHeader,The length of the statement  "			throw new ZipReaderException ("ReadEndHeader() cannot read the ending header because the stream has not reached the ending header part of the zip archive yet."); " is 161.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadEndHeader,The length of the statement  "				throw new Xceed.Zip.ReaderWriter.InvalidZipStructureException ("A signature that violates the Zip file format was found."); " is 123.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The length of the statement  "			/* TODO: Seek to the central directory' find the item and use its compressed size here */// We won't be able to know when the item data ends. We're screwed " is 155.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The length of the statement  "			throw new ZipReaderException ("Compression method Stored is not supported by " + this.GetType () + " when LocalHeader does not contains CompressedSize field (item " + itemInfo.FileName + ")"); " is 192.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The length of the statement  "		string message = String.Format ("Compression method '{0}' is not supported by '{1}'"' method != null ? method : itemInfo.CompressionMethod.ToString ()' this.GetType ()); " is 169.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The length of the statement  "					string message = String.Format ("Encryption method '{0}' is not supported by '{1}'"' method != null ? method : itemInfo.EncryptionMethod.ToString ()' this.GetType ()); " is 167.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The length of the statement  "					throw new ZipReaderException ("Item: '" + itemInfo.FileName + "' has no LZMA end of data marker and an unknown compressed size. The operation cannot continue."); " is 161.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The length of the statement  "				if (itemInfo.UsesLZMAEndOfStreamMarker && itemInfo.Encrypted && itemInfo.EncryptionMethod == EncryptionMethod.WinZipAes) { " is 122.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The length of the statement  "			m_compressedStream = new CompressedStream (tempNewStream' DecompressorFactory.CreateLzmaDecompressor (compressedSize' uncompressedSize' LZMAHeaderType.Zip)); " is 157.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,IsEmptyFile,The length of the statement  "	emptyFile = emptyFile || (itemInfo.Crc32 == 0 && itemInfo.Encrypted && itemInfo.EncryptionMethod == EncryptionMethod.WinZipAes && itemInfo.EncryptionVendorVersion == 1); " is 169.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,DoReadItemLocalHeader,The length of the statement  "          throw new ZipReaderException( "Error while reading file name from local header. Read bytes: " + buffer.Length + "' expected file name length: " + filenameLength );" is 163.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,DoReadItemLocalHeader,The length of the statement  "        itemInfo.FileName = Xceed.Utils.Strings.Encoding.OEMEncoding.GetString( buffer' 0' buffer.Length ).Replace( '/'' Path.DirectorySeparatorChar );" is 143.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,DoReadItemLocalHeader,The length of the statement  "          throw new ZipReaderException( "Error while reading extra fields from local header. Read bytes: " + extraField.Length + "' expected extra field length: " + extraFieldLength );" is 174.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemDataDescriptorHeader,The length of the statement  "	if (itemInfo.CompressionMethod == ZipCompressionMethod.Stored && compressedSize != 0 && compressedSize != itemInfo.CompressedSize) { " is 132.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemDataDescriptorHeader,The length of the statement  "         * header takes precedence. We've read an incorrect amount. */string message = String.Format ("Compressed size mismatch on uncompressed item {0}. Local header stated {1} bytes while descriptor header states {2} bytes"' itemInfo.FileName' compressedSize' itemInfo.CompressedSize); " is 278.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,OnByteProgression,The length of the statement  "			eventArgs = new ZipReaderByteProgressionEventArgs (m_currentZipItemLocalHeader' m_uncompressedSize' m_currentItemInfo.UncompressedSize); " is 136.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadNextHeaderInLastReadBuffer,The length of the statement  "          throw new ZipReaderException( "Unable to find Zip header: " + searchedSignature.ToString( "X" ) + " (after item " + m_currentItemInfo.FileName + ")" );" is 151.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadNextHeaderInLastReadBuffer,The length of the statement  "		throw new Xceed.Zip.ReaderWriter.InvalidZipStructureException ("Unable to find Zip header: " + searchedSignature.ToString ("X") + " (after item " + m_currentItemInfo.FileName + ")"); " is 182.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,GetRawInnerStream,The length of the statement  "       * without fearing from closing the original stream. */// Wrap the returned stream in a transient stream to protect it from being closed " is 135.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,GetUnzipStream,The length of the statement  "	bool useCompressedSize = !itemInfo.HasDescriptorHeader || (itemInfo.CompressionMethod == ZipCompressionMethod.Stored && compressedSize != 0); " is 141.
Long Statement,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,GetUnzipStream,The length of the statement  "				throw new ZipReaderException ("Compressed size of " + compressedSize.ToString () + "is invalid for item " + itemInfo.FileName + "."); " is 133.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemLocalHeader,The length of the statement  "	/* A new file will be written' we must write data descriptor for last written item */else if (m_zipWriterState == ZipWriterState.WRITE_DATA) { " is 142.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemLocalHeader,The length of the statement  "	if (!CompressedStream.WillUseCompression (ref m_compressionMethod' ref m_compressionLevel) && !this.m_allowUncompressedData) { " is 126.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemLocalHeader,The length of the statement  "		string message = String.Format ("Compression method '{0}' is not supported by '{1}'"' method != null ? method : m_compressionMethod.ToString ()' this.GetType ()); " is 162.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,InitializeZipWriter,The length of the statement  "			string message = String.Format ("Encryption method '{0}' is not supported by '{1}'"' method != null ? method : itemInfo.EncryptionMethod.ToString ()' this.GetType ()); " is 167.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,InitializeZipWriter,The length of the statement  "		m_compressedStream = new CompressedStream (tempNewStream' CompressorFactory.CreateLzmaCompressor (m_compressionLevel' LZMAHeaderType.Zip)); " is 139.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemDataDescriptor,The length of the statement  "	if (!this.m_allowZip64 && (itemInfo.CompressedSize >= 0xffffffff || itemInfo.UncompressedSize >= 0xffffffff || itemInfo.LocalHeaderOffset >= 0xffffffff)) { " is 155.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemDataDescriptor,The length of the statement  "		string message = String.Format ("The current item requires the Zip64 format extensions but they have been disabled. C:{0:X8}' U:{1:X8}' O:{2:X8}"' itemInfo.CompressedSize' itemInfo.UncompressedSize' itemInfo.LocalHeaderOffset); " is 227.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteCentralHeader,The length of the statement  "		string message = String.Format ("The archive's central directory location requires the Zip64 format extensions but they have been disabled. O:{0:X8}"' m_centralDirectoryOffset); " is 177.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteCentralHeader,The length of the statement  "		string message = String.Format ("The archive's central directory size requires the Zip64 format extensions but they have been disabled. S:{0:X8}"' m_centralDirectorySize); " is 171.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,OnByteProgression,The length of the statement  "		ZipWriterByteProgressionEventArgs eventArgs = new ZipWriterByteProgressionEventArgs (m_currentZipItemLocalHeader' totalProcessed); " is 130.
Long Statement,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,AddItem,The length of the statement  "		string message = String.Format ("The number of items in the archive requires the Zip64 format extensions but they have been disabled. C:{0:X8}"' this.m_itemInfoList.Count); " is 172.
Long Statement,Xceed.Utils.Storage,SpannedCommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\SpannedCommitFile.cs,DoAddWriteReference,The length of the statement  "			string message = String.Format ("When updating a split or spanned archive' the temporary folder <{0}> cannot be the same as where the archive is stored <{1}>."' alternateWorkingFolder.FullName' matchingFolder.FullName); " is 219.
Long Statement,Xceed.Utils.Storage,SpannedCommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\SpannedCommitFile.cs,DoReleaseWriteReference,The length of the statement  "			/* OnSpannedCommitMovingWritingFiles() might have changed the current disk number */// Get the first modified disk number " is 121.
Long Statement,Xceed.Utils.Storage,SpannedCommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\SpannedCommitFile.cs,ChangeDisk,The length of the statement  "			throw new NotSupportedException ("SpannedCommitFile doesn't support changing to a previous disk. Only changing to a new disk is supported."); " is 141.
Long Statement,Xceed.Utils.Storage,StorageStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageStream.cs,InternalWrite,The length of the statement  "			System.Diagnostics.Debug.Assert (lastPosition == this.InnerPosition' "All streams should keep their initial position on a failed write."); " is 138.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,SetBatchUpdateable,The length of the statement  "		MethodInfo getBatchUpdateableInfo = item.GetType ().GetProperty ("BatchUpdateable"' BindingFlags.NonPublic | BindingFlags.Instance).GetGetMethod (true); " is 152.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,DoAddWriteReference,The length of the statement  "           * one file' this will fail. But we're ready for this with the try/catch. */m_writingFile = m_matchingFile.ParentFolder.GetFile (m_originalName); " is 144.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,DoReleaseWriteReference,The length of the statement  "					throw new FileSystemIOException ("Though the changes may have been committed' the temporary file could not be deleted."' m_writingFile' except); " is 144.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,DoReleaseWriteReference,The length of the statement  "			throw new FileSystemIOException ("The temporary file could not be copied over its destination file."' m_writingFile' except); " is 125.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,AddWriteReference,The length of the statement  "		System.Diagnostics.Debug.Assert (m_writingRef == 1' "The current implementation does not support opening a file more than once for writing."); " is 142.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "		System.Diagnostics.Debug.Assert (m_writingRef == 1' "The current implementation does not support opening a file more than once for writing."); " is 142.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "								throw new FileSystemIOException ("Could not delete the temporary file while reverting changes."' m_writingFile' except); " is 120.
Long Statement,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The length of the statement  "								throw new FileSystemIOException ("Could not delete the temporary file while reverting changes. The original file could not be renamed to its original name."' m_writingFile' except); " is 181.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,OpenRead,The length of the statement  "					throw new FileSystemInternalException ("A non-seekable stream was open on a file' with a position already behind the target offset."); " is 134.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,The length of the statement  "                 * won't be able to be updated since we never know on which disk a footer is located */m_canUpdateInPlace &= /*item.AllowsUpdateInPlace &&*/(!this.IsSplitOrSpanned && !this.IsSplittingOrSpanning); " is 195.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,RequiresUpdate,The length of the statement  "				m_canUpdateInPlace = m_canUpdateInPlace && ((location.HeaderSize == 0) || (location.HeaderSize == item.CurrentHeaderSize)); " is 123.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,OpenWrite,The length of the statement  "				System.Diagnostics.Debug.Fail ("OpenWrite should always write at the end of the file. The cached offset should match the end of the last item."); " is 145.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,UpdateItems,The length of the statement  "			System.Diagnostics.Debug.Fail ("This should not happen as we made sure this storage did not require an ending header and did not have invalid items."); " is 151.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The length of the statement  "				bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove); " is 132.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,BuildAddItemException,The length of the statement  "		message = String.Format ("{0} {1}\nItem: '{2}'. at {3}. Nearest item is {4}/{5}' '{6}' {{{7}}} at {8}."' message' section' item.FullName' item.Location' nearestIndex' this.m_items.Count' nearest.FullName' nearest.GetType ().Name' nearest.Location); " is 248.
Long Statement,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,BuildAddItemException,The length of the statement  "		message = String.Format ("{0} {1}\nItem: '{2}'. at {3}. Nearest item not found. {4} total."' message' section' item.FullName' item.Location' this.m_items.Count); " is 161.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,GetItem,The length of the statement  "		System.Diagnostics.Debug.Assert (!itemHandler.IsRootFolder' "The root item should have been found by m_itemHandlers.Contains above."); " is 134.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,RenameItem,The length of the statement  "	System.Diagnostics.Debug.Assert (m_itemHandlers.ContainsKey (currentFullName)' "The itemHandler must not have been renamed yet."); " is 130.
Long Statement,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,ReleaseReference,The length of the statement  "               decisions on whether to refresh or not later. *//* PERFORMANCE NOTE: I'd like to avoid making yet another call to Exists as it may" is 130.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageItemHandler.cs,AddChild,The length of the statement  "		System.Diagnostics.Debug.Assert (current.m_children.Count == child.m_children.Count' "A folder being replaced must be addressed by caller."); " is 141.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameChild,The length of the statement  "	System.Diagnostics.Debug.Assert (m_children.ContainsKey (currentFullName)' "The StorageHandler.GetItem mechanism should have populated item's children."); " is 154.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameChild,The length of the statement  "			string message = String.Format ("RenameChild() is attempting to replace an existing child <{0}> of state '{1}' with " + "another item. The existing child should either be not in the list or be unassigned or " + "have been discarded."' newFullName' state); " is 255.
Long Statement,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageItemHandler.cs,RenameTo,The length of the statement  "		SortedList<string' StorageItemHandler> children = new SortedList<string' StorageItemHandler> (m_children' StringComparer.OrdinalIgnoreCase); " is 140.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\CombinedStream.cs,SetLength,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("value"' value' "The length of the stream must be greater than zero."); " is 120.
Long Statement,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\CombinedStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "Count must be less than the buffer's remaining length after the specified offset."); " is 150.
Long Statement,Xceed.Utils.Streams,NotifyStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\NotifyStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,SHA1Stream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SHA1Stream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,SHA1Stream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SHA1Stream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,RemoveRelativePosition,The length of the statement  "		throw new InvalidOperationException ("No relative positions have been created yet. You need to call AddRelativePosition() to create a relative position object."); " is 162.
Long Statement,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("offset"' offset' "The offset must be greater than or equal to zero."); " is 120.
Long Statement,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "Count must be less than the buffer's remaining length after the specified offset."); " is 150.
Long Statement,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,Read,The length of the statement  "	/* This block implements the LockWindow() feature */// If the window is locked and reading from the inner stream would cause bytes " is 130.
Long Statement,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,Read,The length of the statement  "			/* bytesToRead can be set to zero here and cause the stream to end */// Allow to read as many bytes as needed to fill the window " is 128.
Long Statement,Xceed.Utils.Streams,SlidingWindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\SlidingWindowStream.cs,FillSlidingWindow,The length of the statement  "			Buffer.BlockCopy (this.m_slidingWindow' bytesToDiscardFromSlidingWindow' this.m_slidingWindow' 0' this.m_slidingWindowLength - bytesToDiscardFromSlidingWindow); " is 160.
Long Statement,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("size"' size' "The size can be -1 for up to end-of-stream copy' or a value greater than 0."); " is 142.
Long Statement,Xceed.Utils.Streams,StreamSearcher,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamSearcher.cs,ReverseFindImpl,The length of the statement  "		if ((bytesRead = m_stream.Read (buffer' 0' (bytesLeftToRead < buffer.Length ? (int)bytesLeftToRead : buffer.Length))) > 0) { " is 124.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,Seek,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("origin"' origin' "The seek origin is not a valid SeekOrigin member."); " is 120.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,BeginRead,The length of the statement  "		throw new ArgumentOutOfRangeException ("count"' "The count parameter exceeds the buffer's remaining length after offset."); " is 123.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,BeginWrite,The length of the statement  "	/* TODO: Store 'currentLength' and supply it to EndWrite() *///long currentLength = ( m_innerStream.CanSeek && m_length != -1 ) ? m_innerStream.Length : 0; " is 155.
Long Statement,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,CheckInnerStream,The length of the statement  "			throw new IOException ("The inner stream of the WindowStream has been accessed directly' preventing the WindowStream from working properly."); " is 142.
Long Statement,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCryptStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCryptStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Zip.Sfx,SfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\SfxPrefix.cs,SetSourceModule,The length of the statement  "		throw new ArgumentNullException ("sfxModule"' "The SFX module cannot be null. To remove any ZIP file SFX' set the ZipArchive's SfxPrefix property to null."); " is 157.
Long Statement,Xceed.Zip.Sfx,SfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\SfxPrefix.cs,CreatePrefixStorage,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("prefixSize"' prefixSize' "The module size can be -1 for up to end-of-file' or a value greater than 0."); " is 154.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.DestinationFolder])' m_writeUnicodeStrings' ref encodingKey); " is 147.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.Password])' m_writeUnicodeStrings' ref encodingKey); " is 138.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.InsertLastDisk])' m_writeUnicodeStrings' ref encodingKey); " is 144.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.InsertDisk])' m_writeUnicodeStrings' ref encodingKey); " is 140.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.AbortUnzip])' m_writeUnicodeStrings' ref encodingKey); " is 140.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.CreateFolder])' m_writeUnicodeStrings' ref encodingKey); " is 142.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.Overwrite])' m_writeUnicodeStrings' ref encodingKey); " is 139.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.Progress])' m_writeUnicodeStrings' ref encodingKey); " is 138.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogStrings [Sfx.DialogStrings.ProgressBar])' m_writeUnicodeStrings' ref encodingKey); " is 139.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogStrings [Sfx.DialogStrings.Title])' m_writeUnicodeStrings' ref encodingKey); " is 133.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogStrings [Sfx.DialogStrings.CurrentFolder])' m_writeUnicodeStrings' ref encodingKey); " is 141.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.Success])' m_writeUnicodeStrings' ref encodingKey); " is 137.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.Error])' m_writeUnicodeStrings' ref encodingKey); " is 135.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder])' m_writeUnicodeStrings' ref encodingKey); " is 149.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.Introduction])' m_writeUnicodeStrings' ref encodingKey); " is 142.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The length of the statement  "			WriteEncodedString (writer' ReplaceNewVariables (m_dialogMessages [Sfx.DialogMessages.License])' m_writeUnicodeStrings' ref encodingKey); " is 137.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The length of the statement  "			m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey); " is 134.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The length of the statement  "		string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey); " is 122.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The length of the statement  "		m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey); " is 137.
Long Statement,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The length of the statement  "		m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey); " is 138.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Collections\ListBase.cs,ListGetItem,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Collections\ListBase.cs,ArrayInsert,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than or equal to Count."); " is 146.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Collections\ListBase.cs,ArrayRemoveAt,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Collections\ListBase.cs,InternalInsert,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than or equal to Count."); " is 146.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Collections\ListBase.cs,InternalRemoveAt,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Collections\ListBase.cs,InternalSetItem,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Exceptions,ExceptionFilter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Exceptions\ExceptionFilter.cs,IsPublicException,The length of the statement  "	exception is OutOfMemoryException || exception is System.Security.SecurityException || exception is UnauthorizedAccessException || exception is System.IO.PathTooLongException || exception is ArgumentException || exception is System.Reflection.TargetInvocationException); " is 270.
Complex Conditional,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadLocalHeader,The conditional expression  "(!this.HasDescriptorHeader) && ((crc32 != this.Crc32) || ((compressedSize != 0xffffffff) && (compressedSize != this.CompressedSize)) || ((uncompressedSize != 0xffffffff) && (uncompressedSize != this.UncompressedSize)))"  is complex.
Complex Conditional,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DoChangeDisk,The conditional expression  "splitNameFormat != SplitNameFormat.None || (reason == DiskRequiredReason.Updating && (storage.CurrentDiskNumber == 0 || !storage.HaveCurrentDiskNumber))"  is complex.
Complex Conditional,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The conditional expression  "(lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))"  is complex.
Complex Conditional,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnClosingWriteStream,The conditional expression  "!itemHeader.HasDescriptorHeader || ((destStream.CanSeek) && (this.CurrentDiskNumber == itemHeader.LocalHeaderDisk) && ((!itemHeader.Encrypted) || (itemHeader.EncryptionMethod != EncryptionMethod.Compatible)))"  is complex.
Complex Conditional,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemLocalHeader,The conditional expression  "m_zipReaderState == ZipReaderState.READ_CENTRAL_HEADER || m_zipReaderState == ZipReaderState.READ_ZIP64_ENDHEADER || m_zipReaderState == ZipReaderState.READ_ZIP64_ENDHEADER_LOCATOR || m_zipReaderState == ZipReaderState.READ_ENDHEADER"  is complex.
Complex Conditional,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The conditional expression  "!isFolder && itemInfo.HasDescriptorHeader && itemInfo.CompressedSize == 0 && !emptyFile"  is complex.
Complex Conditional,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemDataDescriptor,The conditional expression  "!this.m_allowZip64 && (itemInfo.CompressedSize >= 0xffffffff || itemInfo.UncompressedSize >= 0xffffffff || itemInfo.LocalHeaderOffset >= 0xffffffff)"  is complex.
Complex Conditional,Xceed.Utils.Storage,StorageStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageStream.cs,Read,The conditional expression  "read == 0 && count > 0 && this.m_storage.HaveLastDiskNumber && this.m_storage.LastDiskNumber > 0"  is complex.
Virtual Method Call from Constructor,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,ZippedFile,The constructor "ZippedFile" calls a virtual method "CreateSession".
Virtual Method Call from Constructor,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,ZippedFolder,The constructor "ZippedFolder" calls a virtual method "CreateSession".
Empty Catch Block,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Remove,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadCentralHeader,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadLocalHeader,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,OnReadingCentralDirectory,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoApplyPropertiesTo,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ZippedFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFile.cs,DoApplyPropertiesTo,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,DoApplyPropertiesTo,The method has an empty catch block.
Empty Catch Block,Xceed.Zip,ZippedFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZippedFolder.cs,DoApplyPropertiesTo,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,CloseInnerStreams,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,CloseInnerStreams,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,SpannedCommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\SpannedCommitFile.cs,DoReleaseWriteReference,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,SetBatchUpdateable,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,CommitFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\CommitFile.cs,ReleaseWriteReference,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,OpenWriteStorageFile,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,ReleaseReference,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Storage,StorageHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageHandler.cs,Refresh,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\CombinedStream.cs,CombinedStream,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\CombinedStream.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCryptStream.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.Sfx,SfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\SfxPrefix.cs,CreateSfxPrefix,The method has an empty catch block.
Empty Catch Block,Xceed.Zip.Sfx,SfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\SfxPrefix.cs,CreateSfxPrefix,The method has an empty catch block.
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnBuildingZipByteProgression,The following statement contains a magic number: if (m_zipEvents.WantsBuildingZipByteProgression) {  	m_buildingZipByteProgressionArgs.UserData = m_userData;  	//we want to be able to trigger the initial "0 bytes processed" event.  	if (increment == 0 && m_zipCurrentFileBytes.Processed == 0) {  		try {  			m_zipEvents.OnBuildingZipByteProgression (m_sender' m_buildingZipByteProgressionArgs);  		}  		catch (Exception handlerException) {  			throw new System.Reflection.TargetInvocationException (handlerException);  		}  	}  	int currentRatio = (int)(m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1));  	m_zipCurrentFileBytes.Processed += increment;  	m_zipAllFilesBytes.Processed += increment;  	if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100)) {  		try {  			m_zipEvents.OnBuildingZipByteProgression (m_sender' m_buildingZipByteProgressionArgs);  		}  		catch (Exception handlerException) {  			throw new System.Reflection.TargetInvocationException (handlerException);  		}  	}  	m_userData = m_buildingZipByteProgressionArgs.UserData;  }  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnBuildingZipByteProgression,The following statement contains a magic number: if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100)) {  	try {  		m_zipEvents.OnBuildingZipByteProgression (m_sender' m_buildingZipByteProgressionArgs);  	}  	catch (Exception handlerException) {  		throw new System.Reflection.TargetInvocationException (handlerException);  	}  }  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnCopyingZipByteProgression,The following statement contains a magic number: if (m_zipEvents.WantsCopyingZipByteProgression) {  	//we want to be able to trigger the initial "0 bytes processed" event.  	if (increment == 0 && m_zipCurrentFileBytes.Processed == 0)  		m_zipEvents.OnCopyingZipByteProgression (m_sender' m_copyingZipByteProgressionArgs);  	int currentRatio = (int)(m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1));  	m_zipCurrentFileBytes.Processed += increment;  	m_zipAllFilesBytes.Processed += increment;  	m_copyingZipByteProgressionArgs.UserData = m_userData;  	if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100))  		m_zipEvents.OnCopyingZipByteProgression (m_sender' m_copyingZipByteProgressionArgs);  	m_userData = m_copyingZipByteProgressionArgs.UserData;  }  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnCopyingZipByteProgression,The following statement contains a magic number: if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100))  	m_zipEvents.OnCopyingZipByteProgression (m_sender' m_copyingZipByteProgressionArgs);  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnGatheringZipContentByteProgression,The following statement contains a magic number: if (m_zipEvents.WantsGatheringZipContentByteProgression) {  	m_gatheringZipContentByteProgressionArgs.UserData = m_userData;  	if (increment == 0 && m_zipCurrentFileBytes.Processed == 0) {  		try {  			m_zipEvents.OnGatheringZipContentByteProgression (m_sender' m_gatheringZipContentByteProgressionArgs);  		}  		catch (Exception handlerException) {  			throw new System.Reflection.TargetInvocationException (handlerException);  		}  	}  	int currentRatio = (int)(m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1));  	m_zipCurrentFileBytes.Processed += increment;  	m_zipAllFilesBytes.Processed += increment;  	if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100)) {  		try {  			m_zipEvents.OnGatheringZipContentByteProgression (m_sender' m_gatheringZipContentByteProgressionArgs);  		}  		catch (Exception handlerException) {  			throw new System.Reflection.TargetInvocationException (handlerException);  		}  	}  	m_userData = m_gatheringZipContentByteProgressionArgs.UserData;  }  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnGatheringZipContentByteProgression,The following statement contains a magic number: if ((m_zipCurrentFileBytes.Processed / (ushort.MaxValue + 1) > currentRatio) || (m_zipCurrentFileBytes.Percent == 100)) {  	try {  		m_zipEvents.OnGatheringZipContentByteProgression (m_sender' m_gatheringZipContentByteProgressionArgs);  	}  	catch (Exception handlerException) {  		throw new System.Reflection.TargetInvocationException (handlerException);  	}  }  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnBuildingZipItemCompletion,The following statement contains a magic number: if ((m_zipEvents.WantsBuildingZipItemProgression) && (m_buildingZipItemProgressionArgs.AllItems.Processed > 0)) {  	System.Diagnostics.Debug.Assert (m_buildingZipItemProgressionArgs.AllItems.Percent == 100);  	m_buildingZipItemProgressionArgs.UserData = m_userData;  	try {  		m_zipEvents.OnBuildingZipItemProgression (m_sender' m_buildingZipItemProgressionArgs);  	}  	catch (Exception handlerException) {  		throw new System.Reflection.TargetInvocationException (handlerException);  	}  	m_buildingZipItemProgressionArgs.CurrentItem = null;  	m_buildingZipItemProgressionArgs.TargetItem = null;  	m_userData = m_buildingZipItemProgressionArgs.UserData;  }  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnBuildingZipItemCompletion,The following statement contains a magic number: System.Diagnostics.Debug.Assert (m_buildingZipItemProgressionArgs.AllItems.Percent == 100);  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnReadingZipItemCompletion,The following statement contains a magic number: if ((m_zipEvents.WantsReadingZipItemProgression) && (m_readingZipItemProgressionArgs.AllItems.Processed > 0)) {  	System.Diagnostics.Debug.Assert (m_readingZipItemProgressionArgs.AllItems.Percent == 100);  	m_readingZipItemProgressionArgs.UserData = m_userData;  	try {  		m_zipEvents.OnReadingZipItemProgression (m_sender' m_readingZipItemProgressionArgs);  	}  	catch (Exception handlerException) {  		throw new System.Reflection.TargetInvocationException (handlerException);  	}  	m_readingZipItemProgressionArgs.CurrentItem = null;  	m_readingZipItemProgressionArgs.TargetItem = null;  	m_userData = m_readingZipItemProgressionArgs.UserData;  }  
Magic Number,Xceed.Zip,ZipEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Events)\ZipEventsSession.cs,OnReadingZipItemCompletion,The following statement contains a magic number: System.Diagnostics.Debug.Assert (m_readingZipItemProgressionArgs.AllItems.Percent == 100);  
Magic Number,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Read,The following statement contains a magic number: if (size < 7)  	throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  
Magic Number,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Read,The following statement contains a magic number: if ((vendorVersion != 1) && (vendorVersion != 2)) {  	throw new  	#if !ZIP_NOFILESYSTEM  	FileSystemNotSupportedException   	#else  	          NotSupportedException           #endif  	("Unknown AES extra header version."' null);  }  
Magic Number,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Read,The following statement contains a magic number: if ((strength < 1) || (strength > 3))  	throw new InvalidZipStructureException ("The AES extra header contains an invalid strength value.");  
Magic Number,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Write,The following statement contains a magic number: writer.Write ((short)7);  
Magic Number,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Write,The following statement contains a magic number: if ((encryptionStrength < 1) || (encryptionStrength > 3)) {  	throw new  	#if !ZIP_NOFILESYSTEM  	FileSystemInternalException   	#else  	          InvalidOperationException           #endif  	("Unexpected encryption strength while writing AES extra header.");  }  
Magic Number,Xceed.Zip,AesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\AesExtraHeader.cs,Write,The following statement contains a magic number: return 11;  
Magic Number,Xceed.Zip,UTF8CommentExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8CommentExtraHeader.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasLastModified) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata. Since the last   	// modified date is also read from the central header' we discard this one.  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasLastModified) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata. Since the last   	// modified date is also read from the central header' we discard this one.  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasLastModified) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata. Since the last   	// modified date is also read from the central header' we discard this one.  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (size < 4)  	throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: size -= 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasLastAccessed && !fromCentralHeader) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata.  	if (header.LastAccessedDateTime == DateTime.MinValue) {  		header.LastAccessedDateTime = Dates.FromUnixDateTime (BitConverter.ToUInt32 (data' offset));  	}  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasLastAccessed && !fromCentralHeader) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata.  	if (header.LastAccessedDateTime == DateTime.MinValue) {  		header.LastAccessedDateTime = Dates.FromUnixDateTime (BitConverter.ToUInt32 (data' offset));  	}  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasLastAccessed && !fromCentralHeader) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata.  	if (header.LastAccessedDateTime == DateTime.MinValue) {  		header.LastAccessedDateTime = Dates.FromUnixDateTime (BitConverter.ToUInt32 (data' offset));  	}  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (size < 4)  	throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: size -= 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasCreated && !fromCentralHeader) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata.  	if (header.CreationDateTime == DateTime.MinValue) {  		header.CreationDateTime = Dates.FromUnixDateTime (BitConverter.ToUInt32 (data' offset));  	}  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasCreated && !fromCentralHeader) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata.  	if (header.CreationDateTime == DateTime.MinValue) {  		header.CreationDateTime = Dates.FromUnixDateTime (BitConverter.ToUInt32 (data' offset));  	}  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (hasCreated && !fromCentralHeader) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  	// Information from the local header should only be kept when it's  	// not yet available from any other source. Else simply calling OpenRead  	// on a file would discard any previous changes to metadata.  	if (header.CreationDateTime == DateTime.MinValue) {  		header.CreationDateTime = Dates.FromUnixDateTime (BitConverter.ToUInt32 (data' offset));  	}  	offset += 4;  	size -= 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: if (size < 4)  	throw new InvalidZipStructureException ("The Extended TimeStamp extra header's reported size is too small.");  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Read,The following statement contains a magic number: size -= 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	// We only store the last modified date and time.  	writer.Write ((short)5);  	// 1 byte flag + 4 byte date-time  	// Though the central header will only contain the last modified date-time'   	// the flags byte indicates what's available in the local header. In other words  	// it must match the local header's flags value.  	byte flags = 0x01;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  	}  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	return 9;  }  else {  	// We write all three dates if we have them!  	byte flags = 0x01;  	short size = 5;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  		size += 4;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  		size += 4;  	}  	writer.Write (size);  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	if ((flags & 0x02) == 0x02) {  		writer.Write (Dates.ToUnixDateTime (header.LastAccessedDateTime));  	}  	if ((flags & 0x04) == 0x04) {  		writer.Write (Dates.ToUnixDateTime (header.CreationDateTime));  	}  	return (short)(size + 4);  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	// We only store the last modified date and time.  	writer.Write ((short)5);  	// 1 byte flag + 4 byte date-time  	// Though the central header will only contain the last modified date-time'   	// the flags byte indicates what's available in the local header. In other words  	// it must match the local header's flags value.  	byte flags = 0x01;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  	}  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	return 9;  }  else {  	// We write all three dates if we have them!  	byte flags = 0x01;  	short size = 5;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  		size += 4;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  		size += 4;  	}  	writer.Write (size);  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	if ((flags & 0x02) == 0x02) {  		writer.Write (Dates.ToUnixDateTime (header.LastAccessedDateTime));  	}  	if ((flags & 0x04) == 0x04) {  		writer.Write (Dates.ToUnixDateTime (header.CreationDateTime));  	}  	return (short)(size + 4);  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	// We only store the last modified date and time.  	writer.Write ((short)5);  	// 1 byte flag + 4 byte date-time  	// Though the central header will only contain the last modified date-time'   	// the flags byte indicates what's available in the local header. In other words  	// it must match the local header's flags value.  	byte flags = 0x01;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  	}  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	return 9;  }  else {  	// We write all three dates if we have them!  	byte flags = 0x01;  	short size = 5;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  		size += 4;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  		size += 4;  	}  	writer.Write (size);  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	if ((flags & 0x02) == 0x02) {  		writer.Write (Dates.ToUnixDateTime (header.LastAccessedDateTime));  	}  	if ((flags & 0x04) == 0x04) {  		writer.Write (Dates.ToUnixDateTime (header.CreationDateTime));  	}  	return (short)(size + 4);  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	// We only store the last modified date and time.  	writer.Write ((short)5);  	// 1 byte flag + 4 byte date-time  	// Though the central header will only contain the last modified date-time'   	// the flags byte indicates what's available in the local header. In other words  	// it must match the local header's flags value.  	byte flags = 0x01;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  	}  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	return 9;  }  else {  	// We write all three dates if we have them!  	byte flags = 0x01;  	short size = 5;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  		size += 4;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  		size += 4;  	}  	writer.Write (size);  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	if ((flags & 0x02) == 0x02) {  		writer.Write (Dates.ToUnixDateTime (header.LastAccessedDateTime));  	}  	if ((flags & 0x04) == 0x04) {  		writer.Write (Dates.ToUnixDateTime (header.CreationDateTime));  	}  	return (short)(size + 4);  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	// We only store the last modified date and time.  	writer.Write ((short)5);  	// 1 byte flag + 4 byte date-time  	// Though the central header will only contain the last modified date-time'   	// the flags byte indicates what's available in the local header. In other words  	// it must match the local header's flags value.  	byte flags = 0x01;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  	}  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	return 9;  }  else {  	// We write all three dates if we have them!  	byte flags = 0x01;  	short size = 5;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  		size += 4;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  		size += 4;  	}  	writer.Write (size);  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	if ((flags & 0x02) == 0x02) {  		writer.Write (Dates.ToUnixDateTime (header.LastAccessedDateTime));  	}  	if ((flags & 0x04) == 0x04) {  		writer.Write (Dates.ToUnixDateTime (header.CreationDateTime));  	}  	return (short)(size + 4);  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	// We only store the last modified date and time.  	writer.Write ((short)5);  	// 1 byte flag + 4 byte date-time  	// Though the central header will only contain the last modified date-time'   	// the flags byte indicates what's available in the local header. In other words  	// it must match the local header's flags value.  	byte flags = 0x01;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  	}  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	return 9;  }  else {  	// We write all three dates if we have them!  	byte flags = 0x01;  	short size = 5;  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x02;  		size += 4;  	}  	if (header.LastAccessedDateTime != DateTime.MinValue) {  		flags |= 0x04;  		size += 4;  	}  	writer.Write (size);  	writer.Write (flags);  	writer.Write (Dates.ToUnixDateTime (header.LastModifiedDateTime));  	if ((flags & 0x02) == 0x02) {  		writer.Write (Dates.ToUnixDateTime (header.LastAccessedDateTime));  	}  	if ((flags & 0x04) == 0x04) {  		writer.Write (Dates.ToUnixDateTime (header.CreationDateTime));  	}  	return (short)(size + 4);  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: writer.Write ((short)5);  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: return 9;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (header.LastAccessedDateTime != DateTime.MinValue) {  	flags |= 0x02;  	size += 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: size += 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: if (header.LastAccessedDateTime != DateTime.MinValue) {  	flags |= 0x04;  	size += 4;  }  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: size += 4;  
Magic Number,Xceed.Zip,ExtendedTimeStampExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\ExtendedTimeStampExtraHeader.cs,Write,The following statement contains a magic number: return (short)(size + 4);  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: if (size < 4)  	throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: while (position < size) {  	if (position + 4 > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	short mapTag = BitConverter.ToInt16 (data' offset + position);  	short mapSize = BitConverter.ToInt16 (data' offset + position + 2);  	position += 4;  	// Earlier versions of Xceed Zip ActiveX had a bug where the tag and size were zero.  	// If this the case' and there is no other maps' we fake having read tag 0x0001 and  	// the proper size.  	if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  		mapTag = FileTimesTag;  		mapSize = (short)(size - position);  	}  	if (position + mapSize > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	switch (mapTag) {  	case FileTimesTag:  		if (mapSize < 24)  			throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  		System.Diagnostics.Debug.Assert (fromCentralHeader);  		if (fromCentralHeader) {  			// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  			// stores the UTC filetime' we don't need to convert.  			header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  			header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  			header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  			// Prevent other extra headers from messing with dates.  			header.CanChangeDates = false;  		}  		// This tag normally does not appear in the local header. We could support its   		// presence by comparing the dates' but we currently do not have a way to tell  		// the date was directly modified between reading the central and local headers.  		// We ignore any data that could follow those three dates.  		position += mapSize;  		break;  	default:  		// We ignore this map and do not even keep it!  		position += mapSize;  		break;  	}  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: while (position < size) {  	if (position + 4 > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	short mapTag = BitConverter.ToInt16 (data' offset + position);  	short mapSize = BitConverter.ToInt16 (data' offset + position + 2);  	position += 4;  	// Earlier versions of Xceed Zip ActiveX had a bug where the tag and size were zero.  	// If this the case' and there is no other maps' we fake having read tag 0x0001 and  	// the proper size.  	if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  		mapTag = FileTimesTag;  		mapSize = (short)(size - position);  	}  	if (position + mapSize > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	switch (mapTag) {  	case FileTimesTag:  		if (mapSize < 24)  			throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  		System.Diagnostics.Debug.Assert (fromCentralHeader);  		if (fromCentralHeader) {  			// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  			// stores the UTC filetime' we don't need to convert.  			header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  			header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  			header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  			// Prevent other extra headers from messing with dates.  			header.CanChangeDates = false;  		}  		// This tag normally does not appear in the local header. We could support its   		// presence by comparing the dates' but we currently do not have a way to tell  		// the date was directly modified between reading the central and local headers.  		// We ignore any data that could follow those three dates.  		position += mapSize;  		break;  	default:  		// We ignore this map and do not even keep it!  		position += mapSize;  		break;  	}  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: while (position < size) {  	if (position + 4 > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	short mapTag = BitConverter.ToInt16 (data' offset + position);  	short mapSize = BitConverter.ToInt16 (data' offset + position + 2);  	position += 4;  	// Earlier versions of Xceed Zip ActiveX had a bug where the tag and size were zero.  	// If this the case' and there is no other maps' we fake having read tag 0x0001 and  	// the proper size.  	if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  		mapTag = FileTimesTag;  		mapSize = (short)(size - position);  	}  	if (position + mapSize > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	switch (mapTag) {  	case FileTimesTag:  		if (mapSize < 24)  			throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  		System.Diagnostics.Debug.Assert (fromCentralHeader);  		if (fromCentralHeader) {  			// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  			// stores the UTC filetime' we don't need to convert.  			header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  			header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  			header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  			// Prevent other extra headers from messing with dates.  			header.CanChangeDates = false;  		}  		// This tag normally does not appear in the local header. We could support its   		// presence by comparing the dates' but we currently do not have a way to tell  		// the date was directly modified between reading the central and local headers.  		// We ignore any data that could follow those three dates.  		position += mapSize;  		break;  	default:  		// We ignore this map and do not even keep it!  		position += mapSize;  		break;  	}  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: while (position < size) {  	if (position + 4 > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	short mapTag = BitConverter.ToInt16 (data' offset + position);  	short mapSize = BitConverter.ToInt16 (data' offset + position + 2);  	position += 4;  	// Earlier versions of Xceed Zip ActiveX had a bug where the tag and size were zero.  	// If this the case' and there is no other maps' we fake having read tag 0x0001 and  	// the proper size.  	if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  		mapTag = FileTimesTag;  		mapSize = (short)(size - position);  	}  	if (position + mapSize > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	switch (mapTag) {  	case FileTimesTag:  		if (mapSize < 24)  			throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  		System.Diagnostics.Debug.Assert (fromCentralHeader);  		if (fromCentralHeader) {  			// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  			// stores the UTC filetime' we don't need to convert.  			header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  			header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  			header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  			// Prevent other extra headers from messing with dates.  			header.CanChangeDates = false;  		}  		// This tag normally does not appear in the local header. We could support its   		// presence by comparing the dates' but we currently do not have a way to tell  		// the date was directly modified between reading the central and local headers.  		// We ignore any data that could follow those three dates.  		position += mapSize;  		break;  	default:  		// We ignore this map and do not even keep it!  		position += mapSize;  		break;  	}  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: while (position < size) {  	if (position + 4 > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	short mapTag = BitConverter.ToInt16 (data' offset + position);  	short mapSize = BitConverter.ToInt16 (data' offset + position + 2);  	position += 4;  	// Earlier versions of Xceed Zip ActiveX had a bug where the tag and size were zero.  	// If this the case' and there is no other maps' we fake having read tag 0x0001 and  	// the proper size.  	if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  		mapTag = FileTimesTag;  		mapSize = (short)(size - position);  	}  	if (position + mapSize > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	switch (mapTag) {  	case FileTimesTag:  		if (mapSize < 24)  			throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  		System.Diagnostics.Debug.Assert (fromCentralHeader);  		if (fromCentralHeader) {  			// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  			// stores the UTC filetime' we don't need to convert.  			header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  			header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  			header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  			// Prevent other extra headers from messing with dates.  			header.CanChangeDates = false;  		}  		// This tag normally does not appear in the local header. We could support its   		// presence by comparing the dates' but we currently do not have a way to tell  		// the date was directly modified between reading the central and local headers.  		// We ignore any data that could follow those three dates.  		position += mapSize;  		break;  	default:  		// We ignore this map and do not even keep it!  		position += mapSize;  		break;  	}  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: while (position < size) {  	if (position + 4 > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	short mapTag = BitConverter.ToInt16 (data' offset + position);  	short mapSize = BitConverter.ToInt16 (data' offset + position + 2);  	position += 4;  	// Earlier versions of Xceed Zip ActiveX had a bug where the tag and size were zero.  	// If this the case' and there is no other maps' we fake having read tag 0x0001 and  	// the proper size.  	if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  		mapTag = FileTimesTag;  		mapSize = (short)(size - position);  	}  	if (position + mapSize > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	switch (mapTag) {  	case FileTimesTag:  		if (mapSize < 24)  			throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  		System.Diagnostics.Debug.Assert (fromCentralHeader);  		if (fromCentralHeader) {  			// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  			// stores the UTC filetime' we don't need to convert.  			header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  			header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  			header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  			// Prevent other extra headers from messing with dates.  			header.CanChangeDates = false;  		}  		// This tag normally does not appear in the local header. We could support its   		// presence by comparing the dates' but we currently do not have a way to tell  		// the date was directly modified between reading the central and local headers.  		// We ignore any data that could follow those three dates.  		position += mapSize;  		break;  	default:  		// We ignore this map and do not even keep it!  		position += mapSize;  		break;  	}  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: while (position < size) {  	if (position + 4 > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	short mapTag = BitConverter.ToInt16 (data' offset + position);  	short mapSize = BitConverter.ToInt16 (data' offset + position + 2);  	position += 4;  	// Earlier versions of Xceed Zip ActiveX had a bug where the tag and size were zero.  	// If this the case' and there is no other maps' we fake having read tag 0x0001 and  	// the proper size.  	if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  		mapTag = FileTimesTag;  		mapSize = (short)(size - position);  	}  	if (position + mapSize > size)  		throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  	switch (mapTag) {  	case FileTimesTag:  		if (mapSize < 24)  			throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  		System.Diagnostics.Debug.Assert (fromCentralHeader);  		if (fromCentralHeader) {  			// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  			// stores the UTC filetime' we don't need to convert.  			header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  			header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  			header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  			// Prevent other extra headers from messing with dates.  			header.CanChangeDates = false;  		}  		// This tag normally does not appear in the local header. We could support its   		// presence by comparing the dates' but we currently do not have a way to tell  		// the date was directly modified between reading the central and local headers.  		// We ignore any data that could follow those three dates.  		position += mapSize;  		break;  	default:  		// We ignore this map and do not even keep it!  		position += mapSize;  		break;  	}  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: if (position + 4 > size)  	throw new InvalidZipStructureException ("The FileTimes extra header's reported size is too small.");  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: position += 4;  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: if ((mapTag == 0) && (mapSize == 0) && (size - position == 24)) {  	mapTag = FileTimesTag;  	mapSize = (short)(size - position);  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: switch (mapTag) {  case FileTimesTag:  	if (mapSize < 24)  		throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  	System.Diagnostics.Debug.Assert (fromCentralHeader);  	if (fromCentralHeader) {  		// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  		// stores the UTC filetime' we don't need to convert.  		header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  		header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  		header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  		// Prevent other extra headers from messing with dates.  		header.CanChangeDates = false;  	}  	// This tag normally does not appear in the local header. We could support its   	// presence by comparing the dates' but we currently do not have a way to tell  	// the date was directly modified between reading the central and local headers.  	// We ignore any data that could follow those three dates.  	position += mapSize;  	break;  default:  	// We ignore this map and do not even keep it!  	position += mapSize;  	break;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: switch (mapTag) {  case FileTimesTag:  	if (mapSize < 24)  		throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  	System.Diagnostics.Debug.Assert (fromCentralHeader);  	if (fromCentralHeader) {  		// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  		// stores the UTC filetime' we don't need to convert.  		header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  		header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  		header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  		// Prevent other extra headers from messing with dates.  		header.CanChangeDates = false;  	}  	// This tag normally does not appear in the local header. We could support its   	// presence by comparing the dates' but we currently do not have a way to tell  	// the date was directly modified between reading the central and local headers.  	// We ignore any data that could follow those three dates.  	position += mapSize;  	break;  default:  	// We ignore this map and do not even keep it!  	position += mapSize;  	break;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: switch (mapTag) {  case FileTimesTag:  	if (mapSize < 24)  		throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  	System.Diagnostics.Debug.Assert (fromCentralHeader);  	if (fromCentralHeader) {  		// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  		// stores the UTC filetime' we don't need to convert.  		header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  		header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  		header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  		// Prevent other extra headers from messing with dates.  		header.CanChangeDates = false;  	}  	// This tag normally does not appear in the local header. We could support its   	// presence by comparing the dates' but we currently do not have a way to tell  	// the date was directly modified between reading the central and local headers.  	// We ignore any data that could follow those three dates.  	position += mapSize;  	break;  default:  	// We ignore this map and do not even keep it!  	position += mapSize;  	break;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: if (mapSize < 24)  	throw new InvalidZipStructureException ("The FileTimes extra header contains an invalid map size.");  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  	// stores the UTC filetime' we don't need to convert.  	header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  	header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  	header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  	// Prevent other extra headers from messing with dates.  	header.CanChangeDates = false;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	// The Xceed FileSystem exposed UTC DateTime values. Since this extra header  	// stores the UTC filetime' we don't need to convert.  	header.LastModifiedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position));  	header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  	header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  	// Prevent other extra headers from messing with dates.  	header.CanChangeDates = false;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: header.LastAccessedDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 8));  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Read,The following statement contains a magic number: header.CreationDateTime = DateTime.FromFileTime (BitConverter.ToInt64 (data' offset + position + 16));  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	writer.Write (this.Signature);  	// Total size (does not include signature and total size fields)  	writer.Write ((short)32);  	// 4 (res) + 2 (tag) + 2 (tag size) + 3x8 (dates)  	// 4 bytes reserved for future use  	writer.Write ((int)0);  	// Tag and size (does not include tag and tag size fields)  	writer.Write (FileTimesTag);  	writer.Write ((short)24);  	// 3x8 (dates)  	// This extra header requires the UTC filetimes. The Xceed FileSystem already  	// exposes any DateTime in UTC.  	long lastModifiedFileTime = header.LastModifiedDateTime.ToFileTime ();  	writer.Write (lastModifiedFileTime);  	if (header.LastAccessedDateTime == DateTime.MinValue) {  		writer.Write (lastModifiedFileTime);  	}  	else {  		writer.Write (header.LastAccessedDateTime.ToFileTime ());  	}  	if (header.CreationDateTime == DateTime.MinValue) {  		writer.Write (lastModifiedFileTime);  	}  	else {  		writer.Write (header.CreationDateTime.ToFileTime ());  	}  	return 36;  }  else {  	/* We don't write this header with local headers. */return 0;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	writer.Write (this.Signature);  	// Total size (does not include signature and total size fields)  	writer.Write ((short)32);  	// 4 (res) + 2 (tag) + 2 (tag size) + 3x8 (dates)  	// 4 bytes reserved for future use  	writer.Write ((int)0);  	// Tag and size (does not include tag and tag size fields)  	writer.Write (FileTimesTag);  	writer.Write ((short)24);  	// 3x8 (dates)  	// This extra header requires the UTC filetimes. The Xceed FileSystem already  	// exposes any DateTime in UTC.  	long lastModifiedFileTime = header.LastModifiedDateTime.ToFileTime ();  	writer.Write (lastModifiedFileTime);  	if (header.LastAccessedDateTime == DateTime.MinValue) {  		writer.Write (lastModifiedFileTime);  	}  	else {  		writer.Write (header.LastAccessedDateTime.ToFileTime ());  	}  	if (header.CreationDateTime == DateTime.MinValue) {  		writer.Write (lastModifiedFileTime);  	}  	else {  		writer.Write (header.CreationDateTime.ToFileTime ());  	}  	return 36;  }  else {  	/* We don't write this header with local headers. */return 0;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	writer.Write (this.Signature);  	// Total size (does not include signature and total size fields)  	writer.Write ((short)32);  	// 4 (res) + 2 (tag) + 2 (tag size) + 3x8 (dates)  	// 4 bytes reserved for future use  	writer.Write ((int)0);  	// Tag and size (does not include tag and tag size fields)  	writer.Write (FileTimesTag);  	writer.Write ((short)24);  	// 3x8 (dates)  	// This extra header requires the UTC filetimes. The Xceed FileSystem already  	// exposes any DateTime in UTC.  	long lastModifiedFileTime = header.LastModifiedDateTime.ToFileTime ();  	writer.Write (lastModifiedFileTime);  	if (header.LastAccessedDateTime == DateTime.MinValue) {  		writer.Write (lastModifiedFileTime);  	}  	else {  		writer.Write (header.LastAccessedDateTime.ToFileTime ());  	}  	if (header.CreationDateTime == DateTime.MinValue) {  		writer.Write (lastModifiedFileTime);  	}  	else {  		writer.Write (header.CreationDateTime.ToFileTime ());  	}  	return 36;  }  else {  	/* We don't write this header with local headers. */return 0;  }  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Write,The following statement contains a magic number: writer.Write ((short)32);  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Write,The following statement contains a magic number: writer.Write ((short)24);  
Magic Number,Xceed.Zip,FileTimesExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\FileTimesExtraHeader.cs,Write,The following statement contains a magic number: return 36;  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: offset += 2;  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	commentSize = BitConverter.ToInt16 (data' offset);  	offset += 2;  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: offset += 2;  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: if (filenameSize * 2 + commentSize * 2 > size - minSize)  	throw new InvalidZipStructureException ("The Unicode extra header's reported filename and comment sizes exceed the extra header size.");  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: if (filenameSize * 2 + commentSize * 2 > size - minSize)  	throw new InvalidZipStructureException ("The Unicode extra header's reported filename and comment sizes exceed the extra header size.");  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: if (filenameSize > 0) {  	string filename = System.Text.Encoding.Unicode.GetString (data' offset' filenameSize * 2).Replace ('/'' System.IO.Path.DirectorySeparatorChar);  	offset += filenameSize * 2;  	filename = ItemHeader.FixFilename (filename);  	if (fromCentralHeader || header.Streaming) {  		// Use this filename instead of the one read from the standard header  		header.FileName = filename;  	}  	else {  		// Comparing strings is costly. We actually ignore the filename stored  		// in the local header's Unicode extra header. Furthermore' the file could  		// have been renamed in the meantime!  	}  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: if (filenameSize > 0) {  	string filename = System.Text.Encoding.Unicode.GetString (data' offset' filenameSize * 2).Replace ('/'' System.IO.Path.DirectorySeparatorChar);  	offset += filenameSize * 2;  	filename = ItemHeader.FixFilename (filename);  	if (fromCentralHeader || header.Streaming) {  		// Use this filename instead of the one read from the standard header  		header.FileName = filename;  	}  	else {  		// Comparing strings is costly. We actually ignore the filename stored  		// in the local header's Unicode extra header. Furthermore' the file could  		// have been renamed in the meantime!  	}  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: offset += filenameSize * 2;  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: if (commentSize > 0) {  	// A comment cannot appear in the local header. We ignore "fromCentralHeader"   	// and always set the comment.  	header.FileComment = System.Text.Encoding.Unicode.GetString (data' offset' commentSize * 2);  	offset += commentSize * 2;  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: if (commentSize > 0) {  	// A comment cannot appear in the local header. We ignore "fromCentralHeader"   	// and always set the comment.  	header.FileComment = System.Text.Encoding.Unicode.GetString (data' offset' commentSize * 2);  	offset += commentSize * 2;  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: header.FileComment = System.Text.Encoding.Unicode.GetString (data' offset' commentSize * 2);  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Read,The following statement contains a magic number: offset += commentSize * 2;  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	commentData = System.Text.Encoding.Unicode.GetBytes (header.FileComment);  	size += (short)(commentData.Length + 2);  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: size += (short)(commentData.Length + 2);  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: System.Diagnostics.Debug.Assert (filenameData.Length % 2 == 0' "We expect the Unicode encoder to always use 2 bytes per char.");  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: writer.Write ((short)(filenameData.Length / 2));  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	System.Diagnostics.Debug.Assert (commentData.Length % 2 == 0' "We expect the Unicode encoder to always use 2 bytes per char.");  	writer.Write ((short)(commentData.Length / 2));  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: if (forCentralHeader) {  	System.Diagnostics.Debug.Assert (commentData.Length % 2 == 0' "We expect the Unicode encoder to always use 2 bytes per char.");  	writer.Write ((short)(commentData.Length / 2));  }  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: System.Diagnostics.Debug.Assert (commentData.Length % 2 == 0' "We expect the Unicode encoder to always use 2 bytes per char.");  
Magic Number,Xceed.Zip,UnicodeExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnicodeExtraHeader.cs,Write,The following statement contains a magic number: writer.Write ((short)(commentData.Length / 2));  
Magic Number,Xceed.Zip,UnknownExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UnknownExtraHeader.cs,Write,The following statement contains a magic number: return (short)(data.Length + 4);  
Magic Number,Xceed.Zip,UTF8FilenameExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\UTF8FilenameExtraHeader.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (needUncompressedSize) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	// If we're reading from a central header or the item doesn't use a descriptor header  	if (fromCentralHeader || !header.HasDescriptorHeader) {  		header.UncompressedSize = (long)BitConverter.ToUInt64 (data' offset);  	}  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (needUncompressedSize) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	// If we're reading from a central header or the item doesn't use a descriptor header  	if (fromCentralHeader || !header.HasDescriptorHeader) {  		header.UncompressedSize = (long)BitConverter.ToUInt64 (data' offset);  	}  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (needUncompressedSize) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	// If we're reading from a central header or the item doesn't use a descriptor header  	if (fromCentralHeader || !header.HasDescriptorHeader) {  		header.UncompressedSize = (long)BitConverter.ToUInt64 (data' offset);  	}  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (size < 8)  	throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: size -= 8;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: offset += 8;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (needCompressedSize) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	// If we're reading from a central header or the item doesn't use a descriptor header  	if (fromCentralHeader || !header.HasDescriptorHeader) {  		header.CompressedSize = (long)BitConverter.ToUInt64 (data' offset);  	}  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (needCompressedSize) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	// If we're reading from a central header or the item doesn't use a descriptor header  	if (fromCentralHeader || !header.HasDescriptorHeader) {  		header.CompressedSize = (long)BitConverter.ToUInt64 (data' offset);  	}  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (needCompressedSize) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	// If we're reading from a central header or the item doesn't use a descriptor header  	if (fromCentralHeader || !header.HasDescriptorHeader) {  		header.CompressedSize = (long)BitConverter.ToUInt64 (data' offset);  	}  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (size < 8)  	throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: size -= 8;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: offset += 8;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	if (header.LocalHeaderOffset >= 0xffffffff) {  		if (size < 8)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  		size -= 8;  		offset += 8;  	}  	if (header.LocalHeaderDisk >= 0xffff) {  		if (size < 4)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  		size -= 4;  		offset += 4;  	}  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	if (header.LocalHeaderOffset >= 0xffffffff) {  		if (size < 8)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  		size -= 8;  		offset += 8;  	}  	if (header.LocalHeaderDisk >= 0xffff) {  		if (size < 4)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  		size -= 4;  		offset += 4;  	}  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	if (header.LocalHeaderOffset >= 0xffffffff) {  		if (size < 8)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  		size -= 8;  		offset += 8;  	}  	if (header.LocalHeaderDisk >= 0xffff) {  		if (size < 4)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  		size -= 4;  		offset += 4;  	}  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	if (header.LocalHeaderOffset >= 0xffffffff) {  		if (size < 8)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  		size -= 8;  		offset += 8;  	}  	if (header.LocalHeaderDisk >= 0xffff) {  		if (size < 4)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  		size -= 4;  		offset += 4;  	}  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	if (header.LocalHeaderOffset >= 0xffffffff) {  		if (size < 8)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  		size -= 8;  		offset += 8;  	}  	if (header.LocalHeaderDisk >= 0xffff) {  		if (size < 4)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  		size -= 4;  		offset += 4;  	}  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (fromCentralHeader) {  	if (header.LocalHeaderOffset >= 0xffffffff) {  		if (size < 8)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  		size -= 8;  		offset += 8;  	}  	if (header.LocalHeaderDisk >= 0xffff) {  		if (size < 4)  			throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  		header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  		size -= 4;  		offset += 4;  	}  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (header.LocalHeaderOffset >= 0xffffffff) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (header.LocalHeaderOffset >= 0xffffffff) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (header.LocalHeaderOffset >= 0xffffffff) {  	if (size < 8)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	header.LocalHeaderOffset = (long)BitConverter.ToUInt64 (data' offset);  	size -= 8;  	offset += 8;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (size < 8)  	throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: size -= 8;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: offset += 8;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (header.LocalHeaderDisk >= 0xffff) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  	size -= 4;  	offset += 4;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (header.LocalHeaderDisk >= 0xffff) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  	size -= 4;  	offset += 4;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (header.LocalHeaderDisk >= 0xffff) {  	if (size < 4)  		throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  	header.LocalHeaderDisk = BitConverter.ToUInt32 (data' offset);  	size -= 4;  	offset += 4;  }  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: if (size < 4)  	throw new InvalidZipStructureException ("The Zip64 extra header's reported size is too small.");  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: size -= 4;  
Magic Number,Xceed.Zip,Zip64ExtraHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(ExtraHeaders)\Zip64ExtraHeader.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The following statement contains a magic number: try {  	if (zipFileName == null)  		throw new ArgumentNullException ("zipFileName");  	if (encryptionPassword == null)  		throw new ArgumentNullException ("encryptionPassword");  	if (!Enum.IsDefined (typeof(EncryptionMethod)' encryptionMethod))  		throw new ArgumentException ("Unknown encryption method.");  	if ((splitSize > 0) && (splitNameFormat == SplitNameFormat.None))  		throw new ArgumentException ("The splitNameFormat cannot be None if splitSize is greater than 0."' "splitNameFormat");  	if (filesToZip == null)  		throw new ArgumentNullException ("filesToZip");  	events = new ZipEvents ();  	if (diskRequiredCallback != null) {  		System.Diagnostics.Debug.Assert (splitSize == 0' "QuickZip does not support spanning and splitting at the same time.");  		events.DiskRequired += new DiskRequiredEventHandler (OnDiskRequired);  		mg_quickZipCompression.AddUserData ("DiskRequired"' new object[] {  			diskRequiredCallback'  			userParams  		});  	}  	if (byteProgressionCallback != null) {  		events.ByteProgression += new ByteProgressionEventHandler (OnByteProgression);  		mg_quickZipCompression.AddUserData ("ByteProgression"' new object[] {  			byteProgressionCallback'  			userParams  		});  	}  	if (itemProgressionCallback != null) {  		events.ItemProgression += new ItemProgressionEventHandler (OnItemProgression);  		mg_quickZipCompression.AddUserData ("ItemProgression"' new object[] {  			itemProgressionCallback'  			userParams  		});  	}  	DiskFile zipFile = new DiskFile (zipFileName);  	zipArchive = new ZipArchive (events' null' zipFile);  	if (zipArchive.DiskNumber > 1)  		throw new NotSupportedException ("QuickZip does not support updating spanned or split zip files.");  	zipArchive.AllowSpanning = (diskRequiredCallback != null);  	zipArchive.DefaultEncryptionPassword = encryptionPassword;  	zipArchive.DefaultEncryptionMethod = encryptionMethod;  	zipArchive.DefaultEncryptionStrength = 256;  	zipArchive.SplitNameFormat = splitNameFormat;  	zipArchive.SplitSize = splitSize;  	// SFX does not support BZip2 or PPMd compression methods  	if (sfx != null) {  		#if !XCEEDCF  		#if !MONO  		if ((compressionMethod == CompressionMethod.BZip2) || (compressionMethod == CompressionMethod.PPMd)) {  			throw new NotSupportedException ("SFX module does not support BZip2 and PPMd compression methods");  		}  		#endif  		#else  		          if( compressionMethod == CompressionMethod.BZip2 )           {             throw new NotSupportedException( "SFX module does not support BZip2 compression methods" );           } #endif  	}  	zipArchive.DefaultCompressionMethod = compressionMethod;  	using (new AutoBatchUpdate (zipArchive)) {  		if (sfx != null) {  			zipArchive.SfxPrefix = sfx;  		}  		// The following filter assures that a zip file of size 0 will not be added to the  		// newly created archive when the zipFileName provided represents a file contained  		// in the source folder(s) provided in filesToZip. The NotFilter created is used in   		// the calls to the CopyFilesTo and GetFiles methods.   		FullNameFilter fullNameFilter = new FullNameFilter (zipFile.FullName);  		NotFilter notFilter = new NotFilter (fullNameFilter);  		List<FileSystemItem> fileSystemItemList = mg_quickZipCompression.CreateItemListFromPaths (zipArchive' true' filesToZip' recursive' notFilter);  		mg_multipleItemListFolder = new MultipleItemListFolder (fileSystemItemList' preservePaths);  		mg_multipleItemListFolder.CopyFilesTo (events' null' zipArchive' recursive' replaceExistingFiles' notFilter);  	}  }  catch (FileSystemException except) {  	throw new QuickZipException ("An error occurred while adding files to the zip file."' except);  }  
Magic Number,Xceed.Zip,QuickZip,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\(Quick)\QuickZip.cs,Zip,The following statement contains a magic number: zipArchive.DefaultEncryptionStrength = 256;  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: if ((strength != 128) && (strength != 192) && (strength != 256))  	throw new ArgumentException ("The strength must be 128' 192 or 256."' "strength");  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: if ((strength != 128) && (strength != 192) && (strength != 256))  	throw new ArgumentException ("The strength must be 128' 192 or 256."' "strength");  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: if ((strength != 128) && (strength != 192) && (strength != 256))  	throw new ArgumentException ("The strength must be 128' 192 or 256."' "strength");  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: if (!foundData) {  	/* Use the .NET framework's implementation of Rfc2898DeriveBytes *///DeriveBytesRfc2898 deriveBytes = new DeriveBytesRfc2898( password' record.Salt );  	Rfc2898DeriveBytes deriveBytes = new Rfc2898DeriveBytes (password' record.Salt);  	// Store the Rfc2898DeriveBytes data in our record  	record.EncryptionKey = deriveBytes.GetBytes (keyLength);  	record.AuthenticationKey = deriveBytes.GetBytes (keyLength);  	record.VerifierKey = deriveBytes.GetBytes (2);  	// If we're writing and we have a manager for the Rfc2898DeriveBytes data  	if (writing && rfc2898DeriveBytesManager != null) {  		// Cache the data for reuse  		rfc2898DeriveBytesManager.CacheRfc2898DeriveBytesData (record);  	}  }  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: record.VerifierKey = deriveBytes.GetBytes (2);  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: if (writing) {  	// Write the verifier.  	m_header.Write (verifierKey' 0' verifierKey.Length);  }  else {  	// Compare the verifiers  	byte[] verifierRead = new byte[2];  	int read = innerStream.Read (verifierRead' 0' 2);  	if (read == 1) {  		read = innerStream.Read (verifierRead' 1' 1);  	}  	if (read == 0)  		throw new IOException ("Unexpected end of stream while reading encrypted stream.");  	if ((verifierKey [0] != verifierRead [0]) || (verifierKey [1] != verifierRead [1]))  		throw new InvalidDecryptionPasswordException ("The provided password does not match the verifier key.");  }  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: if (writing) {  	// Write the verifier.  	m_header.Write (verifierKey' 0' verifierKey.Length);  }  else {  	// Compare the verifiers  	byte[] verifierRead = new byte[2];  	int read = innerStream.Read (verifierRead' 0' 2);  	if (read == 1) {  		read = innerStream.Read (verifierRead' 1' 1);  	}  	if (read == 0)  		throw new IOException ("Unexpected end of stream while reading encrypted stream.");  	if ((verifierKey [0] != verifierRead [0]) || (verifierKey [1] != verifierRead [1]))  		throw new InvalidDecryptionPasswordException ("The provided password does not match the verifier key.");  }  
Magic Number,Xceed.Zip,AesEncryptionStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\AesEncryptionStream.cs,AesEncryptionStream,The following statement contains a magic number: m_rijndael = new RijndaelCtrMode (aesAlgorithm' encryptionKey' 16);  
Magic Number,Xceed.Zip,EndHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\EndHeader.cs,WriteZip64EndHeader,The following statement contains a magic number: try {  	writer.Write (Zip64Signature);  	writer.Write ((ulong)44);  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((uint)this.DiskNumber);  	writer.Write ((uint)this.CentralDiskNumber);  	writer.Write ((ulong)this.CentralHeadersCurrentDisk);  	writer.Write ((ulong)this.CentralHeadersTotal);  	writer.Write ((ulong)this.CentralDirectorySize);  	writer.Write ((ulong)this.CentralDirectoryOffset);  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Zip,EndHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\EndHeader.cs,WriteZip64EndHeader,The following statement contains a magic number: writer.Write ((ulong)44);  
Magic Number,Xceed.Zip,EndHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\EndHeader.cs,WriteZip64EndHeader,The following statement contains a magic number: System.Diagnostics.Debug.Assert (zip64EndHeader.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  
Magic Number,Xceed.Zip,EndHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\EndHeader.cs,WriteZip64EndHeader,The following statement contains a magic number: System.Diagnostics.Debug.Assert (zip64EndHeader.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadHeader,The following statement contains a magic number: headerSize = 4;  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The following statement contains a magic number: if (this.UnicodeOnNonASCIIOnly) {  	#if !XCEEDCF && !SILVERLIGHT  	if (Array.Exists<char> (textData.FileNameArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileNameContainsNonASCII = true;  	}  	if (Array.Exists<char> (textData.FileCommentArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileCommentContainsNonASCII = true;  	}  	#else  	        foreach( char c in textData.FileNameArray )         {           if( c >= 128 )           {             textData.FileNameContainsNonASCII = true;           }         }          foreach( char c in textData.FileCommentArray )         {           if( c >= 128 )           {             textData.FileCommentContainsNonASCII = true;           }         }         #endif  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The following statement contains a magic number: if (this.UnicodeOnNonASCIIOnly) {  	#if !XCEEDCF && !SILVERLIGHT  	if (Array.Exists<char> (textData.FileNameArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileNameContainsNonASCII = true;  	}  	if (Array.Exists<char> (textData.FileCommentArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileCommentContainsNonASCII = true;  	}  	#else  	        foreach( char c in textData.FileNameArray )         {           if( c >= 128 )           {             textData.FileNameContainsNonASCII = true;           }         }          foreach( char c in textData.FileCommentArray )         {           if( c >= 128 )           {             textData.FileCommentContainsNonASCII = true;           }         }         #endif  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The following statement contains a magic number: if (Array.Exists<char> (textData.FileNameArray' delegate (char c) {  	return c >= 128;  })) {  	textData.FileNameContainsNonASCII = true;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The following statement contains a magic number: return c >= 128;  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The following statement contains a magic number: if (Array.Exists<char> (textData.FileCommentArray' delegate (char c) {  	return c >= 128;  })) {  	textData.FileCommentContainsNonASCII = true;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteCentralHeader,The following statement contains a magic number: return c >= 128;  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadLocalHeader,The following statement contains a magic number: headerSize = 26;  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The following statement contains a magic number: if (this.UnicodeOnNonASCIIOnly) {  	#if !XCEEDCF && !SILVERLIGHT  	// If we can find a non-ASCII character in the file name  	if (Array.Exists<char> (textData.FileNameArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileNameContainsNonASCII = true;  	}  	if (Array.Exists<char> (textData.FileCommentArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileCommentContainsNonASCII = true;  	}  	#else  	        foreach( char c in textData.FileNameArray )         {           if( c >= 128 )           {             textData.FileNameContainsNonASCII = true;           }         }          foreach( char c in textData.FileCommentArray )         {           if( c >= 128 )           {             textData.FileCommentContainsNonASCII = true;           }         }         #endif  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The following statement contains a magic number: if (this.UnicodeOnNonASCIIOnly) {  	#if !XCEEDCF && !SILVERLIGHT  	// If we can find a non-ASCII character in the file name  	if (Array.Exists<char> (textData.FileNameArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileNameContainsNonASCII = true;  	}  	if (Array.Exists<char> (textData.FileCommentArray' delegate (char c) {  		return c >= 128;  	})) {  		textData.FileCommentContainsNonASCII = true;  	}  	#else  	        foreach( char c in textData.FileNameArray )         {           if( c >= 128 )           {             textData.FileNameContainsNonASCII = true;           }         }          foreach( char c in textData.FileCommentArray )         {           if( c >= 128 )           {             textData.FileCommentContainsNonASCII = true;           }         }         #endif  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The following statement contains a magic number: if (Array.Exists<char> (textData.FileNameArray' delegate (char c) {  	return c >= 128;  })) {  	textData.FileNameContainsNonASCII = true;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The following statement contains a magic number: return c >= 128;  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The following statement contains a magic number: if (Array.Exists<char> (textData.FileCommentArray' delegate (char c) {  	return c >= 128;  })) {  	textData.FileCommentContainsNonASCII = true;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,WriteLocalHeader,The following statement contains a magic number: return c >= 128;  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: try {  	this.CanChangeDates = true;  	while (position < length) {  		if (length - position < 4) {  			#if !SILVERLIGHT  			System.Diagnostics.Debug.Fail ("Invalid extra header. Not enough space left for signature and size");  			#endif  			break;  		}  		short signature = BitConverter.ToInt16 (extraField' position);  		ushort size = BitConverter.ToUInt16 (extraField' position + 2);  		position += 4;  		if (length - position < size) {  			#if !SILVERLIGHT  			System.Diagnostics.Debug.Fail ("Invalid extra header. Size goes beyond total extra headers size.");  			#endif  			break;  		}  		bool mustAdd = false;  		ExtraHeader header = null;  		if (!fromCentralHeader) {  			// Look for header from central header's already read extra headers  			header = this.ExtraHeaders.Find (signature);  		}  		if (header == null) {  			// Clone from available headers.  			header = availableExtraHeaders.Find (signature);  			if (header != null) {  				header = header.CreateInstance (this);  				mustAdd = !header.Volatile;  			}  		}  		if (header == null) {  			header = new UnknownExtraHeader (signature);  			mustAdd = true;  		}  		try {  			header.Read (this' textData' extraField' position' size' fromCentralHeader);  		}  		catch (InvalidZipStructureException   		#if !SILVERLIGHT  		except  		#endif  		) {  			#if !SILVERLIGHT  			// For the moment' the philosophy is to always ignore errors in extra headers.  			System.Diagnostics.Debug.Fail ("An error occurred while reading an extra header."' except.ToString ());  			#endif  			// We skip any remaining data' as we cannot trust we're in sync anymore.  			break;  		}  		position += size;  		// We never add new extra headers only found in the local header.  		if ((mustAdd && fromCentralHeader) || this.Streaming) {  			System.Diagnostics.Debug.Assert (fromCentralHeader || this.Streaming || (header is UnknownExtraHeader));  			this.ExtraHeaders.Add (header);  		}  	}  }  finally {  	this.CanChangeDates = true;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: try {  	this.CanChangeDates = true;  	while (position < length) {  		if (length - position < 4) {  			#if !SILVERLIGHT  			System.Diagnostics.Debug.Fail ("Invalid extra header. Not enough space left for signature and size");  			#endif  			break;  		}  		short signature = BitConverter.ToInt16 (extraField' position);  		ushort size = BitConverter.ToUInt16 (extraField' position + 2);  		position += 4;  		if (length - position < size) {  			#if !SILVERLIGHT  			System.Diagnostics.Debug.Fail ("Invalid extra header. Size goes beyond total extra headers size.");  			#endif  			break;  		}  		bool mustAdd = false;  		ExtraHeader header = null;  		if (!fromCentralHeader) {  			// Look for header from central header's already read extra headers  			header = this.ExtraHeaders.Find (signature);  		}  		if (header == null) {  			// Clone from available headers.  			header = availableExtraHeaders.Find (signature);  			if (header != null) {  				header = header.CreateInstance (this);  				mustAdd = !header.Volatile;  			}  		}  		if (header == null) {  			header = new UnknownExtraHeader (signature);  			mustAdd = true;  		}  		try {  			header.Read (this' textData' extraField' position' size' fromCentralHeader);  		}  		catch (InvalidZipStructureException   		#if !SILVERLIGHT  		except  		#endif  		) {  			#if !SILVERLIGHT  			// For the moment' the philosophy is to always ignore errors in extra headers.  			System.Diagnostics.Debug.Fail ("An error occurred while reading an extra header."' except.ToString ());  			#endif  			// We skip any remaining data' as we cannot trust we're in sync anymore.  			break;  		}  		position += size;  		// We never add new extra headers only found in the local header.  		if ((mustAdd && fromCentralHeader) || this.Streaming) {  			System.Diagnostics.Debug.Assert (fromCentralHeader || this.Streaming || (header is UnknownExtraHeader));  			this.ExtraHeaders.Add (header);  		}  	}  }  finally {  	this.CanChangeDates = true;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: try {  	this.CanChangeDates = true;  	while (position < length) {  		if (length - position < 4) {  			#if !SILVERLIGHT  			System.Diagnostics.Debug.Fail ("Invalid extra header. Not enough space left for signature and size");  			#endif  			break;  		}  		short signature = BitConverter.ToInt16 (extraField' position);  		ushort size = BitConverter.ToUInt16 (extraField' position + 2);  		position += 4;  		if (length - position < size) {  			#if !SILVERLIGHT  			System.Diagnostics.Debug.Fail ("Invalid extra header. Size goes beyond total extra headers size.");  			#endif  			break;  		}  		bool mustAdd = false;  		ExtraHeader header = null;  		if (!fromCentralHeader) {  			// Look for header from central header's already read extra headers  			header = this.ExtraHeaders.Find (signature);  		}  		if (header == null) {  			// Clone from available headers.  			header = availableExtraHeaders.Find (signature);  			if (header != null) {  				header = header.CreateInstance (this);  				mustAdd = !header.Volatile;  			}  		}  		if (header == null) {  			header = new UnknownExtraHeader (signature);  			mustAdd = true;  		}  		try {  			header.Read (this' textData' extraField' position' size' fromCentralHeader);  		}  		catch (InvalidZipStructureException   		#if !SILVERLIGHT  		except  		#endif  		) {  			#if !SILVERLIGHT  			// For the moment' the philosophy is to always ignore errors in extra headers.  			System.Diagnostics.Debug.Fail ("An error occurred while reading an extra header."' except.ToString ());  			#endif  			// We skip any remaining data' as we cannot trust we're in sync anymore.  			break;  		}  		position += size;  		// We never add new extra headers only found in the local header.  		if ((mustAdd && fromCentralHeader) || this.Streaming) {  			System.Diagnostics.Debug.Assert (fromCentralHeader || this.Streaming || (header is UnknownExtraHeader));  			this.ExtraHeaders.Add (header);  		}  	}  }  finally {  	this.CanChangeDates = true;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: while (position < length) {  	if (length - position < 4) {  		#if !SILVERLIGHT  		System.Diagnostics.Debug.Fail ("Invalid extra header. Not enough space left for signature and size");  		#endif  		break;  	}  	short signature = BitConverter.ToInt16 (extraField' position);  	ushort size = BitConverter.ToUInt16 (extraField' position + 2);  	position += 4;  	if (length - position < size) {  		#if !SILVERLIGHT  		System.Diagnostics.Debug.Fail ("Invalid extra header. Size goes beyond total extra headers size.");  		#endif  		break;  	}  	bool mustAdd = false;  	ExtraHeader header = null;  	if (!fromCentralHeader) {  		// Look for header from central header's already read extra headers  		header = this.ExtraHeaders.Find (signature);  	}  	if (header == null) {  		// Clone from available headers.  		header = availableExtraHeaders.Find (signature);  		if (header != null) {  			header = header.CreateInstance (this);  			mustAdd = !header.Volatile;  		}  	}  	if (header == null) {  		header = new UnknownExtraHeader (signature);  		mustAdd = true;  	}  	try {  		header.Read (this' textData' extraField' position' size' fromCentralHeader);  	}  	catch (InvalidZipStructureException   	#if !SILVERLIGHT  	except  	#endif  	) {  		#if !SILVERLIGHT  		// For the moment' the philosophy is to always ignore errors in extra headers.  		System.Diagnostics.Debug.Fail ("An error occurred while reading an extra header."' except.ToString ());  		#endif  		// We skip any remaining data' as we cannot trust we're in sync anymore.  		break;  	}  	position += size;  	// We never add new extra headers only found in the local header.  	if ((mustAdd && fromCentralHeader) || this.Streaming) {  		System.Diagnostics.Debug.Assert (fromCentralHeader || this.Streaming || (header is UnknownExtraHeader));  		this.ExtraHeaders.Add (header);  	}  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: while (position < length) {  	if (length - position < 4) {  		#if !SILVERLIGHT  		System.Diagnostics.Debug.Fail ("Invalid extra header. Not enough space left for signature and size");  		#endif  		break;  	}  	short signature = BitConverter.ToInt16 (extraField' position);  	ushort size = BitConverter.ToUInt16 (extraField' position + 2);  	position += 4;  	if (length - position < size) {  		#if !SILVERLIGHT  		System.Diagnostics.Debug.Fail ("Invalid extra header. Size goes beyond total extra headers size.");  		#endif  		break;  	}  	bool mustAdd = false;  	ExtraHeader header = null;  	if (!fromCentralHeader) {  		// Look for header from central header's already read extra headers  		header = this.ExtraHeaders.Find (signature);  	}  	if (header == null) {  		// Clone from available headers.  		header = availableExtraHeaders.Find (signature);  		if (header != null) {  			header = header.CreateInstance (this);  			mustAdd = !header.Volatile;  		}  	}  	if (header == null) {  		header = new UnknownExtraHeader (signature);  		mustAdd = true;  	}  	try {  		header.Read (this' textData' extraField' position' size' fromCentralHeader);  	}  	catch (InvalidZipStructureException   	#if !SILVERLIGHT  	except  	#endif  	) {  		#if !SILVERLIGHT  		// For the moment' the philosophy is to always ignore errors in extra headers.  		System.Diagnostics.Debug.Fail ("An error occurred while reading an extra header."' except.ToString ());  		#endif  		// We skip any remaining data' as we cannot trust we're in sync anymore.  		break;  	}  	position += size;  	// We never add new extra headers only found in the local header.  	if ((mustAdd && fromCentralHeader) || this.Streaming) {  		System.Diagnostics.Debug.Assert (fromCentralHeader || this.Streaming || (header is UnknownExtraHeader));  		this.ExtraHeaders.Add (header);  	}  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: while (position < length) {  	if (length - position < 4) {  		#if !SILVERLIGHT  		System.Diagnostics.Debug.Fail ("Invalid extra header. Not enough space left for signature and size");  		#endif  		break;  	}  	short signature = BitConverter.ToInt16 (extraField' position);  	ushort size = BitConverter.ToUInt16 (extraField' position + 2);  	position += 4;  	if (length - position < size) {  		#if !SILVERLIGHT  		System.Diagnostics.Debug.Fail ("Invalid extra header. Size goes beyond total extra headers size.");  		#endif  		break;  	}  	bool mustAdd = false;  	ExtraHeader header = null;  	if (!fromCentralHeader) {  		// Look for header from central header's already read extra headers  		header = this.ExtraHeaders.Find (signature);  	}  	if (header == null) {  		// Clone from available headers.  		header = availableExtraHeaders.Find (signature);  		if (header != null) {  			header = header.CreateInstance (this);  			mustAdd = !header.Volatile;  		}  	}  	if (header == null) {  		header = new UnknownExtraHeader (signature);  		mustAdd = true;  	}  	try {  		header.Read (this' textData' extraField' position' size' fromCentralHeader);  	}  	catch (InvalidZipStructureException   	#if !SILVERLIGHT  	except  	#endif  	) {  		#if !SILVERLIGHT  		// For the moment' the philosophy is to always ignore errors in extra headers.  		System.Diagnostics.Debug.Fail ("An error occurred while reading an extra header."' except.ToString ());  		#endif  		// We skip any remaining data' as we cannot trust we're in sync anymore.  		break;  	}  	position += size;  	// We never add new extra headers only found in the local header.  	if ((mustAdd && fromCentralHeader) || this.Streaming) {  		System.Diagnostics.Debug.Assert (fromCentralHeader || this.Streaming || (header is UnknownExtraHeader));  		this.ExtraHeaders.Add (header);  	}  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: if (length - position < 4) {  	#if !SILVERLIGHT  	System.Diagnostics.Debug.Fail ("Invalid extra header. Not enough space left for signature and size");  	#endif  	break;  }  
Magic Number,Xceed.Zip,ItemHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ItemHeader.cs,ReadExtraHeaders,The following statement contains a magic number: position += 4;  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (extension.Length > 1) {  	AbstractFolder parent = zipFile.ParentFolder;  	// The rules we're using for recognition of a name format:  	// - If file.z01 is present' we assume WinZip format  	// - If file.zip.z01 is present' we assume PkZip format  	// - If file.z02 is present (without file.z01)' we assume XceedZipActiveX  	//   and try to locate last part.  	if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the WinZip split name format.  		// This file is the last file.  		return SplitNameFormat.WinZip;  	}  	else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the PkZip split name format.  		// This file is the last file.  		return SplitNameFormat.PkZip;  	}  	else {  		// If we have a ".Z02" file without a ".Z01" file' it means we could be using   		// the Xceed Zip ActiveX split name format.  		AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  		if (secondFile.Exists) {  			// We assume this zip file uses the Xceed Zip ActiveX split name format.  			// If the provided file does not end with a number' we assume we received   			// the first part. We'll look for that last part.  			bool notANumber = true;  			try {  				int.Parse (extension.Substring (2));  				notANumber = false;  			}  			catch {  			}  			if (notANumber) {  				AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  				System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  				int lastNumber = 2;  				AbstractFile lastFile = secondFile;  				foreach (AbstractFile file in files) {  					try {  						int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  						if (number > lastNumber) {  							lastNumber = number;  							lastFile = file;  						}  					}  					catch {  					}  				}  				zipFile = lastFile;  			}  			return SplitNameFormat.XceedZipActiveX;  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (extension.Length > 1) {  	AbstractFolder parent = zipFile.ParentFolder;  	// The rules we're using for recognition of a name format:  	// - If file.z01 is present' we assume WinZip format  	// - If file.zip.z01 is present' we assume PkZip format  	// - If file.z02 is present (without file.z01)' we assume XceedZipActiveX  	//   and try to locate last part.  	if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the WinZip split name format.  		// This file is the last file.  		return SplitNameFormat.WinZip;  	}  	else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the PkZip split name format.  		// This file is the last file.  		return SplitNameFormat.PkZip;  	}  	else {  		// If we have a ".Z02" file without a ".Z01" file' it means we could be using   		// the Xceed Zip ActiveX split name format.  		AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  		if (secondFile.Exists) {  			// We assume this zip file uses the Xceed Zip ActiveX split name format.  			// If the provided file does not end with a number' we assume we received   			// the first part. We'll look for that last part.  			bool notANumber = true;  			try {  				int.Parse (extension.Substring (2));  				notANumber = false;  			}  			catch {  			}  			if (notANumber) {  				AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  				System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  				int lastNumber = 2;  				AbstractFile lastFile = secondFile;  				foreach (AbstractFile file in files) {  					try {  						int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  						if (number > lastNumber) {  							lastNumber = number;  							lastFile = file;  						}  					}  					catch {  					}  				}  				zipFile = lastFile;  			}  			return SplitNameFormat.XceedZipActiveX;  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (extension.Length > 1) {  	AbstractFolder parent = zipFile.ParentFolder;  	// The rules we're using for recognition of a name format:  	// - If file.z01 is present' we assume WinZip format  	// - If file.zip.z01 is present' we assume PkZip format  	// - If file.z02 is present (without file.z01)' we assume XceedZipActiveX  	//   and try to locate last part.  	if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the WinZip split name format.  		// This file is the last file.  		return SplitNameFormat.WinZip;  	}  	else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the PkZip split name format.  		// This file is the last file.  		return SplitNameFormat.PkZip;  	}  	else {  		// If we have a ".Z02" file without a ".Z01" file' it means we could be using   		// the Xceed Zip ActiveX split name format.  		AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  		if (secondFile.Exists) {  			// We assume this zip file uses the Xceed Zip ActiveX split name format.  			// If the provided file does not end with a number' we assume we received   			// the first part. We'll look for that last part.  			bool notANumber = true;  			try {  				int.Parse (extension.Substring (2));  				notANumber = false;  			}  			catch {  			}  			if (notANumber) {  				AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  				System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  				int lastNumber = 2;  				AbstractFile lastFile = secondFile;  				foreach (AbstractFile file in files) {  					try {  						int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  						if (number > lastNumber) {  							lastNumber = number;  							lastFile = file;  						}  					}  					catch {  					}  				}  				zipFile = lastFile;  			}  			return SplitNameFormat.XceedZipActiveX;  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (extension.Length > 1) {  	AbstractFolder parent = zipFile.ParentFolder;  	// The rules we're using for recognition of a name format:  	// - If file.z01 is present' we assume WinZip format  	// - If file.zip.z01 is present' we assume PkZip format  	// - If file.z02 is present (without file.z01)' we assume XceedZipActiveX  	//   and try to locate last part.  	if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the WinZip split name format.  		// This file is the last file.  		return SplitNameFormat.WinZip;  	}  	else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the PkZip split name format.  		// This file is the last file.  		return SplitNameFormat.PkZip;  	}  	else {  		// If we have a ".Z02" file without a ".Z01" file' it means we could be using   		// the Xceed Zip ActiveX split name format.  		AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  		if (secondFile.Exists) {  			// We assume this zip file uses the Xceed Zip ActiveX split name format.  			// If the provided file does not end with a number' we assume we received   			// the first part. We'll look for that last part.  			bool notANumber = true;  			try {  				int.Parse (extension.Substring (2));  				notANumber = false;  			}  			catch {  			}  			if (notANumber) {  				AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  				System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  				int lastNumber = 2;  				AbstractFile lastFile = secondFile;  				foreach (AbstractFile file in files) {  					try {  						int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  						if (number > lastNumber) {  							lastNumber = number;  							lastFile = file;  						}  					}  					catch {  					}  				}  				zipFile = lastFile;  			}  			return SplitNameFormat.XceedZipActiveX;  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (extension.Length > 1) {  	AbstractFolder parent = zipFile.ParentFolder;  	// The rules we're using for recognition of a name format:  	// - If file.z01 is present' we assume WinZip format  	// - If file.zip.z01 is present' we assume PkZip format  	// - If file.z02 is present (without file.z01)' we assume XceedZipActiveX  	//   and try to locate last part.  	if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the WinZip split name format.  		// This file is the last file.  		return SplitNameFormat.WinZip;  	}  	else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the PkZip split name format.  		// This file is the last file.  		return SplitNameFormat.PkZip;  	}  	else {  		// If we have a ".Z02" file without a ".Z01" file' it means we could be using   		// the Xceed Zip ActiveX split name format.  		AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  		if (secondFile.Exists) {  			// We assume this zip file uses the Xceed Zip ActiveX split name format.  			// If the provided file does not end with a number' we assume we received   			// the first part. We'll look for that last part.  			bool notANumber = true;  			try {  				int.Parse (extension.Substring (2));  				notANumber = false;  			}  			catch {  			}  			if (notANumber) {  				AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  				System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  				int lastNumber = 2;  				AbstractFile lastFile = secondFile;  				foreach (AbstractFile file in files) {  					try {  						int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  						if (number > lastNumber) {  							lastNumber = number;  							lastFile = file;  						}  					}  					catch {  					}  				}  				zipFile = lastFile;  			}  			return SplitNameFormat.XceedZipActiveX;  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (extension.Length > 1) {  	AbstractFolder parent = zipFile.ParentFolder;  	// The rules we're using for recognition of a name format:  	// - If file.z01 is present' we assume WinZip format  	// - If file.zip.z01 is present' we assume PkZip format  	// - If file.z02 is present (without file.z01)' we assume XceedZipActiveX  	//   and try to locate last part.  	if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the WinZip split name format.  		// This file is the last file.  		return SplitNameFormat.WinZip;  	}  	else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the PkZip split name format.  		// This file is the last file.  		return SplitNameFormat.PkZip;  	}  	else {  		// If we have a ".Z02" file without a ".Z01" file' it means we could be using   		// the Xceed Zip ActiveX split name format.  		AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  		if (secondFile.Exists) {  			// We assume this zip file uses the Xceed Zip ActiveX split name format.  			// If the provided file does not end with a number' we assume we received   			// the first part. We'll look for that last part.  			bool notANumber = true;  			try {  				int.Parse (extension.Substring (2));  				notANumber = false;  			}  			catch {  			}  			if (notANumber) {  				AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  				System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  				int lastNumber = 2;  				AbstractFile lastFile = secondFile;  				foreach (AbstractFile file in files) {  					try {  						int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  						if (number > lastNumber) {  							lastNumber = number;  							lastFile = file;  						}  					}  					catch {  					}  				}  				zipFile = lastFile;  			}  			return SplitNameFormat.XceedZipActiveX;  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (extension.Length > 1) {  	AbstractFolder parent = zipFile.ParentFolder;  	// The rules we're using for recognition of a name format:  	// - If file.z01 is present' we assume WinZip format  	// - If file.zip.z01 is present' we assume PkZip format  	// - If file.z02 is present (without file.z01)' we assume XceedZipActiveX  	//   and try to locate last part.  	if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the WinZip split name format.  		// This file is the last file.  		return SplitNameFormat.WinZip;  	}  	else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  		// We assume we are using the PkZip split name format.  		// This file is the last file.  		return SplitNameFormat.PkZip;  	}  	else {  		// If we have a ".Z02" file without a ".Z01" file' it means we could be using   		// the Xceed Zip ActiveX split name format.  		AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  		if (secondFile.Exists) {  			// We assume this zip file uses the Xceed Zip ActiveX split name format.  			// If the provided file does not end with a number' we assume we received   			// the first part. We'll look for that last part.  			bool notANumber = true;  			try {  				int.Parse (extension.Substring (2));  				notANumber = false;  			}  			catch {  			}  			if (notANumber) {  				AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  				System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  				int lastNumber = 2;  				AbstractFile lastFile = secondFile;  				foreach (AbstractFile file in files) {  					try {  						int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  						if (number > lastNumber) {  							lastNumber = number;  							lastFile = file;  						}  					}  					catch {  					}  				}  				zipFile = lastFile;  			}  			return SplitNameFormat.XceedZipActiveX;  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the WinZip split name format.  	// This file is the last file.  	return SplitNameFormat.WinZip;  }  else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the WinZip split name format.  	// This file is the last file.  	return SplitNameFormat.WinZip;  }  else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the WinZip split name format.  	// This file is the last file.  	return SplitNameFormat.WinZip;  }  else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the WinZip split name format.  	// This file is the last file.  	return SplitNameFormat.WinZip;  }  else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the WinZip split name format.  	// This file is the last file.  	return SplitNameFormat.WinZip;  }  else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the WinZip split name format.  	// This file is the last file.  	return SplitNameFormat.WinZip;  }  else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (basePattern + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the WinZip split name format.  	// This file is the last file.  	return SplitNameFormat.WinZip;  }  else if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (parent.GetFile (zipFile.Name + extension.Substring (0' 2) + "01").Exists) {  	// We assume we are using the PkZip split name format.  	// This file is the last file.  	return SplitNameFormat.PkZip;  }  else {  	// If we have a ".Z02" file without a ".Z01" file' it means we could be using   	// the Xceed Zip ActiveX split name format.  	AbstractFile secondFile = parent.GetFile (basePattern + extension.Substring (0' 2) + "02");  	if (secondFile.Exists) {  		// We assume this zip file uses the Xceed Zip ActiveX split name format.  		// If the provided file does not end with a number' we assume we received   		// the first part. We'll look for that last part.  		bool notANumber = true;  		try {  			int.Parse (extension.Substring (2));  			notANumber = false;  		}  		catch {  		}  		if (notANumber) {  			AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  			System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  			int lastNumber = 2;  			AbstractFile lastFile = secondFile;  			foreach (AbstractFile file in files) {  				try {  					int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  					if (number > lastNumber) {  						lastNumber = number;  						lastFile = file;  					}  				}  				catch {  				}  			}  			zipFile = lastFile;  		}  		return SplitNameFormat.XceedZipActiveX;  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (secondFile.Exists) {  	// We assume this zip file uses the Xceed Zip ActiveX split name format.  	// If the provided file does not end with a number' we assume we received   	// the first part. We'll look for that last part.  	bool notANumber = true;  	try {  		int.Parse (extension.Substring (2));  		notANumber = false;  	}  	catch {  	}  	if (notANumber) {  		AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  		System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  		int lastNumber = 2;  		AbstractFile lastFile = secondFile;  		foreach (AbstractFile file in files) {  			try {  				int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  				if (number > lastNumber) {  					lastNumber = number;  					lastFile = file;  				}  			}  			catch {  			}  		}  		zipFile = lastFile;  	}  	return SplitNameFormat.XceedZipActiveX;  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (secondFile.Exists) {  	// We assume this zip file uses the Xceed Zip ActiveX split name format.  	// If the provided file does not end with a number' we assume we received   	// the first part. We'll look for that last part.  	bool notANumber = true;  	try {  		int.Parse (extension.Substring (2));  		notANumber = false;  	}  	catch {  	}  	if (notANumber) {  		AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  		System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  		int lastNumber = 2;  		AbstractFile lastFile = secondFile;  		foreach (AbstractFile file in files) {  			try {  				int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  				if (number > lastNumber) {  					lastNumber = number;  					lastFile = file;  				}  			}  			catch {  			}  		}  		zipFile = lastFile;  	}  	return SplitNameFormat.XceedZipActiveX;  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (secondFile.Exists) {  	// We assume this zip file uses the Xceed Zip ActiveX split name format.  	// If the provided file does not end with a number' we assume we received   	// the first part. We'll look for that last part.  	bool notANumber = true;  	try {  		int.Parse (extension.Substring (2));  		notANumber = false;  	}  	catch {  	}  	if (notANumber) {  		AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  		System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  		int lastNumber = 2;  		AbstractFile lastFile = secondFile;  		foreach (AbstractFile file in files) {  			try {  				int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  				if (number > lastNumber) {  					lastNumber = number;  					lastFile = file;  				}  			}  			catch {  			}  		}  		zipFile = lastFile;  	}  	return SplitNameFormat.XceedZipActiveX;  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (secondFile.Exists) {  	// We assume this zip file uses the Xceed Zip ActiveX split name format.  	// If the provided file does not end with a number' we assume we received   	// the first part. We'll look for that last part.  	bool notANumber = true;  	try {  		int.Parse (extension.Substring (2));  		notANumber = false;  	}  	catch {  	}  	if (notANumber) {  		AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  		System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  		int lastNumber = 2;  		AbstractFile lastFile = secondFile;  		foreach (AbstractFile file in files) {  			try {  				int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  				if (number > lastNumber) {  					lastNumber = number;  					lastFile = file;  				}  			}  			catch {  			}  		}  		zipFile = lastFile;  	}  	return SplitNameFormat.XceedZipActiveX;  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: try {  	int.Parse (extension.Substring (2));  	notANumber = false;  }  catch {  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: int.Parse (extension.Substring (2));  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (notANumber) {  	AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  	System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  	int lastNumber = 2;  	AbstractFile lastFile = secondFile;  	foreach (AbstractFile file in files) {  		try {  			int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  			if (number > lastNumber) {  				lastNumber = number;  				lastFile = file;  			}  		}  		catch {  		}  	}  	zipFile = lastFile;  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (notANumber) {  	AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  	System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  	int lastNumber = 2;  	AbstractFile lastFile = secondFile;  	foreach (AbstractFile file in files) {  		try {  			int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  			if (number > lastNumber) {  				lastNumber = number;  				lastFile = file;  			}  		}  		catch {  		}  	}  	zipFile = lastFile;  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: if (notANumber) {  	AbstractFile[] files = parent.GetFiles (false' basePattern + extension.Substring (0' 2) + "*");  	System.Diagnostics.Debug.Assert (files.Length > 0' "Then how come we found .Z02 above?");  	int lastNumber = 2;  	AbstractFile lastFile = secondFile;  	foreach (AbstractFile file in files) {  		try {  			int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  			if (number > lastNumber) {  				lastNumber = number;  				lastFile = file;  			}  		}  		catch {  		}  	}  	zipFile = lastFile;  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: foreach (AbstractFile file in files) {  	try {  		int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  		if (number > lastNumber) {  			lastNumber = number;  			lastFile = file;  		}  	}  	catch {  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,DeduceSplitNameFormat,The following statement contains a magic number: try {  	int number = int.Parse (file.Name.Substring (basePattern.Length + 2));  	if (number > lastNumber) {  		lastNumber = number;  		lastFile = file;  	}  }  catch {  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: try {  	// Seek to end of file before searching for ending header signature  	stream.Seek (0' SeekOrigin.End);  	StreamSearcher searcher = new StreamSearcher (stream);  	// Look backwards for signature in buffer  	if (!searcher.ReverseFind (EndHeader.Signature))  		throw new InvalidZipStructureException ("The zip end header signature could not be found in the zip file."' this.MainFile);  	m_endHeader = new EndHeader (reader);  	#if OBSOLETED_BY_STORAGE  	        m_currentDisk = m_endHeader.DiskNumber;         #endif  	m_previousLastDiskNumber = m_endHeader.DiskNumber;  	if (m_endHeader.Zip64Format) {  		/* Seek to end of file before searching for ending header locator signature              because ReverseFind() is buggy and doesn't always calculate the correct              offset if the stream isn't positioned at the end. */stream.Seek (0' SeekOrigin.End);  		// The Zip64 end header locator is on the same disk  		// and should immediately precede the ending header.  		if (searcher.ReverseFind (EndHeader.Zip64LocatorSignature' true)) {  			m_endHeader.ReadZip64EndLocator (reader);  			// Let's make sure we're still in Zip64 format' we never know!  			if (m_endHeader.Zip64Format) {  				if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  					spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  				}  				stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  				byte[] signature = reader.ReadBytes (4);  				if (signature.Length != 4)  					throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  				if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  					throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  				m_endHeader.ReadZip64EndHeader (reader);  			}  		}  	}  	return m_endHeader;  }  catch (FileSystemIOException except) {  	throw new ZipIOException (this.MainFile' except);  }  catch (IOException except) {  	throw new ZipIOException (this.MainFile' except);  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: try {  	// Seek to end of file before searching for ending header signature  	stream.Seek (0' SeekOrigin.End);  	StreamSearcher searcher = new StreamSearcher (stream);  	// Look backwards for signature in buffer  	if (!searcher.ReverseFind (EndHeader.Signature))  		throw new InvalidZipStructureException ("The zip end header signature could not be found in the zip file."' this.MainFile);  	m_endHeader = new EndHeader (reader);  	#if OBSOLETED_BY_STORAGE  	        m_currentDisk = m_endHeader.DiskNumber;         #endif  	m_previousLastDiskNumber = m_endHeader.DiskNumber;  	if (m_endHeader.Zip64Format) {  		/* Seek to end of file before searching for ending header locator signature              because ReverseFind() is buggy and doesn't always calculate the correct              offset if the stream isn't positioned at the end. */stream.Seek (0' SeekOrigin.End);  		// The Zip64 end header locator is on the same disk  		// and should immediately precede the ending header.  		if (searcher.ReverseFind (EndHeader.Zip64LocatorSignature' true)) {  			m_endHeader.ReadZip64EndLocator (reader);  			// Let's make sure we're still in Zip64 format' we never know!  			if (m_endHeader.Zip64Format) {  				if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  					spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  				}  				stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  				byte[] signature = reader.ReadBytes (4);  				if (signature.Length != 4)  					throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  				if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  					throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  				m_endHeader.ReadZip64EndHeader (reader);  			}  		}  	}  	return m_endHeader;  }  catch (FileSystemIOException except) {  	throw new ZipIOException (this.MainFile' except);  }  catch (IOException except) {  	throw new ZipIOException (this.MainFile' except);  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: if (m_endHeader.Zip64Format) {  	/* Seek to end of file before searching for ending header locator signature              because ReverseFind() is buggy and doesn't always calculate the correct              offset if the stream isn't positioned at the end. */stream.Seek (0' SeekOrigin.End);  	// The Zip64 end header locator is on the same disk  	// and should immediately precede the ending header.  	if (searcher.ReverseFind (EndHeader.Zip64LocatorSignature' true)) {  		m_endHeader.ReadZip64EndLocator (reader);  		// Let's make sure we're still in Zip64 format' we never know!  		if (m_endHeader.Zip64Format) {  			if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  				spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  			}  			stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  			byte[] signature = reader.ReadBytes (4);  			if (signature.Length != 4)  				throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  			if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  				throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  			m_endHeader.ReadZip64EndHeader (reader);  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: if (m_endHeader.Zip64Format) {  	/* Seek to end of file before searching for ending header locator signature              because ReverseFind() is buggy and doesn't always calculate the correct              offset if the stream isn't positioned at the end. */stream.Seek (0' SeekOrigin.End);  	// The Zip64 end header locator is on the same disk  	// and should immediately precede the ending header.  	if (searcher.ReverseFind (EndHeader.Zip64LocatorSignature' true)) {  		m_endHeader.ReadZip64EndLocator (reader);  		// Let's make sure we're still in Zip64 format' we never know!  		if (m_endHeader.Zip64Format) {  			if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  				spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  			}  			stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  			byte[] signature = reader.ReadBytes (4);  			if (signature.Length != 4)  				throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  			if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  				throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  			m_endHeader.ReadZip64EndHeader (reader);  		}  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: if (searcher.ReverseFind (EndHeader.Zip64LocatorSignature' true)) {  	m_endHeader.ReadZip64EndLocator (reader);  	// Let's make sure we're still in Zip64 format' we never know!  	if (m_endHeader.Zip64Format) {  		if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  			spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  		}  		stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  		byte[] signature = reader.ReadBytes (4);  		if (signature.Length != 4)  			throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  		if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  			throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  		m_endHeader.ReadZip64EndHeader (reader);  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: if (searcher.ReverseFind (EndHeader.Zip64LocatorSignature' true)) {  	m_endHeader.ReadZip64EndLocator (reader);  	// Let's make sure we're still in Zip64 format' we never know!  	if (m_endHeader.Zip64Format) {  		if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  			spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  		}  		stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  		byte[] signature = reader.ReadBytes (4);  		if (signature.Length != 4)  			throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  		if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  			throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  		m_endHeader.ReadZip64EndHeader (reader);  	}  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: if (m_endHeader.Zip64Format) {  	if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  		spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  	}  	stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  	byte[] signature = reader.ReadBytes (4);  	if (signature.Length != 4)  		throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  	if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  		throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  	m_endHeader.ReadZip64EndHeader (reader);  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: if (m_endHeader.Zip64Format) {  	if (m_endHeader.DiskNumber != m_endHeader.Zip64EndHeaderDiskNumber) {  		spannedStream.ChangeDisk (m_endHeader.Zip64EndHeaderDiskNumber' Xceed.Utils.Storage.DiskRequiredReason.Reading);  	}  	stream.Seek (m_endHeader.Zip64EndHeaderOffset' SeekOrigin.Begin);  	byte[] signature = reader.ReadBytes (4);  	if (signature.Length != 4)  		throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  	if (BitConverter.ToInt32 (signature' 0) != EndHeader.Zip64Signature)  		throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  	m_endHeader.ReadZip64EndHeader (reader);  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,ReadEndHeader,The following statement contains a magic number: if (signature.Length != 4)  	throw new InvalidZipStructureException ("Could not find a Zip64 End Header where one was expected."' this.MainFile);  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if ((extension == null) || (extension.Length < 2)) {  	extension = ".zip";  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if ((currentDiskNumber == 1) && (splitNameFormat == SplitNameFormat.XceedZipActiveX)) {  	// The first part of an Xceed Zip ActiveX split zip file is the one ending  	// with .zip.  	newName += ".zip";  }  else if ((lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))) {  	// The last part of a PkZip or WinZip split zip file ends with ".zip"' but   	// since the provided file is supposed to be the last part' we return it directly.  	return zipFile;  }  else if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if ((currentDiskNumber == 1) && (splitNameFormat == SplitNameFormat.XceedZipActiveX)) {  	// The first part of an Xceed Zip ActiveX split zip file is the one ending  	// with .zip.  	newName += ".zip";  }  else if ((lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))) {  	// The last part of a PkZip or WinZip split zip file ends with ".zip"' but   	// since the provided file is supposed to be the last part' we return it directly.  	return zipFile;  }  else if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if ((currentDiskNumber == 1) && (splitNameFormat == SplitNameFormat.XceedZipActiveX)) {  	// The first part of an Xceed Zip ActiveX split zip file is the one ending  	// with .zip.  	newName += ".zip";  }  else if ((lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))) {  	// The last part of a PkZip or WinZip split zip file ends with ".zip"' but   	// since the provided file is supposed to be the last part' we return it directly.  	return zipFile;  }  else if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if ((lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))) {  	// The last part of a PkZip or WinZip split zip file ends with ".zip"' but   	// since the provided file is supposed to be the last part' we return it directly.  	return zipFile;  }  else if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if ((lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))) {  	// The last part of a PkZip or WinZip split zip file ends with ".zip"' but   	// since the provided file is supposed to be the last part' we return it directly.  	return zipFile;  }  else if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if ((lastDiskNumber != 0) && (currentDiskNumber == lastDiskNumber) && ((splitNameFormat == SplitNameFormat.PkZip) || (splitNameFormat == SplitNameFormat.WinZip))) {  	// The last part of a PkZip or WinZip split zip file ends with ".zip"' but   	// since the provided file is supposed to be the last part' we return it directly.  	return zipFile;  }  else if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if (splitNameFormat == SplitNameFormat.PkZip) {  	// Above part ".z99"' the PkZip naming looses its "z"  	if (currentDiskNumber > 99)  		newName += extension + "." + currentDiskNumber.ToString ("D2");  	else  		newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  else {  	// Common between XceedZipActiveX and WinZip  	newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  }  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if (currentDiskNumber > 99)  	newName += extension + "." + currentDiskNumber.ToString ("D2");  else  	newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: if (currentDiskNumber > 99)  	newName += extension + "." + currentDiskNumber.ToString ("D2");  else  	newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: newName += extension + extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  
Magic Number,Xceed.Zip,ZipHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipHandler.cs,GetSplitFile,The following statement contains a magic number: newName += extension.Substring (0' 2) + currentDiskNumber.ToString ("D2");  
Magic Number,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The following statement contains a magic number: try {  	// In case of AES encryption' there is no CRC32  	bool calculateChecksum = true;  	if (this.Encrypted) {  		// We must insert an encryption stream in the process  		if (decryptionPassword.Length == 0)  			throw new InvalidDecryptionPasswordException ("The decryption password is empty."' m_zipHandler.LastZipFile);  		switch (m_header.EncryptionMethod) {  		case EncryptionMethod.Compatible:  			long userKey = (m_header.HasDescriptorHeader ? m_header.OriginalEncryptionKey : (Crc32 >> 16));  			try {  				innerStream = new ZCryptStream (innerStream' decryptionPassword' userKey' false);  			}  			catch (ZCryptException) {  				throw new InvalidDecryptionPasswordException ("The decryption password is invalid.");  			}  			break;  		#if !XCEED_NOAES  		case EncryptionMethod.WinZipAes:  			#if ( XCEEDCF )  			              throw new FileSystemNotSupportedException( "Cannot decrypt AES-encrypted zip files under the .NET Compact Framework."' null );               #else  			DisposableResourceManager resourceManager = this.ZipHandler.DisposableResourceManager;  			Rfc2898DeriveBytesManager rfc2898DeriveBytesManager = resourceManager.ObtainResource<Rfc2898DeriveBytesManager> (ZipHandler.Rfc2898DeriveBytesManagerResource);  			innerStream = new AesEncryptionStream (innerStream' ZipHandler.AesAlgorithmManager' rfc2898DeriveBytesManager' decryptionPassword' m_header.EncryptionStrength' false);  			calculateChecksum = false;  			break;  		#endif  		#endif  		default:  			throw new FileSystemNotSupportedException ("Unsupported encryption method '" + this.m_header.EncryptionMethod.ToString () + "'."' null);  		}  	}  	try {  		// If the compression method isn't LZMA  		if (this.CompressionMethod != CompressionMethod.LZMA) {  			// uncompress the data  			innerStream = new CompressedStream (innerStream' this.CompressionMethod' this.CompressionLevel);  		}  		else {  			/* We're gonna assume that this.CompressedSize and this.UncompressedSize              * always contain values. It should since the code makes every effort to              * obtain them when the central header is read. */long compressedSize = this.CompressedSize;  			long uncompressedSize = this.UncompressedSize;  			/* We could let LZMA run unbounded but giving it bounds helps the engine to              * end its processing gracefully if the compressed data is corrupted.              *               * When AES is used however' it's better to let LZMA look for the marker so that              * the encryption inner stream always finds the authentication code located immediately              * after the data. Otherwise' LZMA might stop processing 1 byte before the marker'              * leaving the encryption stream not positioned correctly to read the authentication code. */// If an end of stream marker is present in the compressed data and it's encrypted with WinZipAES  			if (this.m_header.UsesLZMAEndOfStreamMarker && this.Encrypted && this.m_header.EncryptionMethod == EncryptionMethod.WinZipAes) {  				// Let LZMA find the marker while processing  				compressedSize = -1;  				uncompressedSize = -1;  			}  			Decompressor decompressor = DecompressorFactory.CreateLzmaDecompressor (compressedSize' uncompressedSize' LZMAHeaderType.Zip);  			innerStream = new CompressedStream (innerStream' decompressor);  		}  	}  	catch (ArgumentException except) {  		throw new InvalidZipStructureException ("The file is compressed with an unknown compression method."' m_zipHandler.LastZipFile' except);  	}  	if (calculateChecksum) {  		// verify the checksum  		return new ChecksumStream (innerStream' ChecksumType.CRC32' unchecked((int)this.Crc32));  	}  	return innerStream;  }  catch {  	//innerStream.Close();  	throw;  }  
Magic Number,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The following statement contains a magic number: if (this.Encrypted) {  	// We must insert an encryption stream in the process  	if (decryptionPassword.Length == 0)  		throw new InvalidDecryptionPasswordException ("The decryption password is empty."' m_zipHandler.LastZipFile);  	switch (m_header.EncryptionMethod) {  	case EncryptionMethod.Compatible:  		long userKey = (m_header.HasDescriptorHeader ? m_header.OriginalEncryptionKey : (Crc32 >> 16));  		try {  			innerStream = new ZCryptStream (innerStream' decryptionPassword' userKey' false);  		}  		catch (ZCryptException) {  			throw new InvalidDecryptionPasswordException ("The decryption password is invalid.");  		}  		break;  	#if !XCEED_NOAES  	case EncryptionMethod.WinZipAes:  		#if ( XCEEDCF )  		              throw new FileSystemNotSupportedException( "Cannot decrypt AES-encrypted zip files under the .NET Compact Framework."' null );               #else  		DisposableResourceManager resourceManager = this.ZipHandler.DisposableResourceManager;  		Rfc2898DeriveBytesManager rfc2898DeriveBytesManager = resourceManager.ObtainResource<Rfc2898DeriveBytesManager> (ZipHandler.Rfc2898DeriveBytesManagerResource);  		innerStream = new AesEncryptionStream (innerStream' ZipHandler.AesAlgorithmManager' rfc2898DeriveBytesManager' decryptionPassword' m_header.EncryptionStrength' false);  		calculateChecksum = false;  		break;  	#endif  	#endif  	default:  		throw new FileSystemNotSupportedException ("Unsupported encryption method '" + this.m_header.EncryptionMethod.ToString () + "'."' null);  	}  }  
Magic Number,Xceed.Zip,ZipItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipItemHandler.cs,OnPreparingReadStream,The following statement contains a magic number: switch (m_header.EncryptionMethod) {  case EncryptionMethod.Compatible:  	long userKey = (m_header.HasDescriptorHeader ? m_header.OriginalEncryptionKey : (Crc32 >> 16));  	try {  		innerStream = new ZCryptStream (innerStream' decryptionPassword' userKey' false);  	}  	catch (ZCryptException) {  		throw new InvalidDecryptionPasswordException ("The decryption password is invalid.");  	}  	break;  #if !XCEED_NOAES  case EncryptionMethod.WinZipAes:  	#if ( XCEEDCF )  	              throw new FileSystemNotSupportedException( "Cannot decrypt AES-encrypted zip files under the .NET Compact Framework."' null );               #else  	DisposableResourceManager resourceManager = this.ZipHandler.DisposableResourceManager;  	Rfc2898DeriveBytesManager rfc2898DeriveBytesManager = resourceManager.ObtainResource<Rfc2898DeriveBytesManager> (ZipHandler.Rfc2898DeriveBytesManagerResource);  	innerStream = new AesEncryptionStream (innerStream' ZipHandler.AesAlgorithmManager' rfc2898DeriveBytesManager' decryptionPassword' m_header.EncryptionStrength' false);  	calculateChecksum = false;  	break;  #endif  #endif  default:  	throw new FileSystemNotSupportedException ("Unsupported encryption method '" + this.m_header.EncryptionMethod.ToString () + "'."' null);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,DoReadItems,The following statement contains a magic number: try {  	zipReadItemsSession.FirstHeaderDisk = endHeader.DiskNumber;  	zipReadItemsSession.FirstHeaderOffset = endHeader.Offset;  	ZipItemHandler root = (ZipItemHandler)handler.GetItem (Path.DirectorySeparatorChar.ToString ()' true);  	System.Diagnostics.Debug.Assert (root.Exists && !root.FolderPersistent);  	if (zipSession != null)  		zipSession.InitializeTotalItems ((long)(endHeader.CentralHeadersTotal * 2));  	if (endHeader.CentralHeadersTotal > 0) {  		zipReadItemsSession.FirstHeaderDisk = endHeader.CentralDiskNumber;  		zipReadItemsSession.FirstHeaderOffset = endHeader.CentralDirectoryOffset;  		source.Seek (endHeader.CentralDirectoryOffset' SeekOrigin.Begin);  		zipReadItemsSession.NonameFolder = @"\noname" + this.StorageFile.LastWriteDateTime.ToString ("yyyyMMddHHmmss");  		zipReadItemsSession.NonameIndex = 1;  	}  	// Call base class  	base.DoReadItems (session' readItemsSession' source' spannedStream);  	this.CalculateItemsSizes (zipSession' endHeader);  	if (zipSession != null)  		zipSession.OnReadingZipItemCompletion ();  	if (zipReadItemsSession.FirstHeaderDisk > 0 || zipReadItemsSession.FirstHeaderOffset > 0) {  		if ((zipReadItemsSession.FirstHeaderDisk == 0) && (zipReadItemsSession.FirstHeaderOffset == 4)) {  			// We assume this is the spanning signature. We ignore it.  		}  		else if (endHeader.DiskNumber > 0) {  			// We do not support updating spanned SFX zip files.  			// But we can't throw here since it may only be for reading.  			// We simply abandon the SfxPrefix.  		}  		else {  			source.Seek (0' SeekOrigin.Begin);  			System.Diagnostics.Debug.Assert (handler.SfxPrefixStorageItem == null);  			SfxPrefix prefix = SfxPrefix.CreateSfxPrefix (source' zipReadItemsSession.FirstHeaderOffset);  			if (prefix == null)  				throw new FileSystemInternalException ("Default prefix could not be created.");  			handler.SetSfxPrefix (prefix);  			// Mark add the prefix's storage item to the list just like any item would be  			StorageItem sfxPrefixItem = handler.SfxPrefixStorageItem;  			sfxPrefixItem.State = StorageItemState.UpToDate;  			sfxPrefixItem.Location.Storage = this;  			sfxPrefixItem.Location.HeaderSize = zipReadItemsSession.FirstHeaderOffset;  			zipReadItemsSession.Items.Add (sfxPrefixItem.Location' sfxPrefixItem);  		}  	}  }  catch (FileSystemIOException except) {  	throw new ZipIOException (StorageFile' except);  }  catch (IOException except) {  	throw new ZipIOException (StorageFile' except);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,DoReadItems,The following statement contains a magic number: try {  	zipReadItemsSession.FirstHeaderDisk = endHeader.DiskNumber;  	zipReadItemsSession.FirstHeaderOffset = endHeader.Offset;  	ZipItemHandler root = (ZipItemHandler)handler.GetItem (Path.DirectorySeparatorChar.ToString ()' true);  	System.Diagnostics.Debug.Assert (root.Exists && !root.FolderPersistent);  	if (zipSession != null)  		zipSession.InitializeTotalItems ((long)(endHeader.CentralHeadersTotal * 2));  	if (endHeader.CentralHeadersTotal > 0) {  		zipReadItemsSession.FirstHeaderDisk = endHeader.CentralDiskNumber;  		zipReadItemsSession.FirstHeaderOffset = endHeader.CentralDirectoryOffset;  		source.Seek (endHeader.CentralDirectoryOffset' SeekOrigin.Begin);  		zipReadItemsSession.NonameFolder = @"\noname" + this.StorageFile.LastWriteDateTime.ToString ("yyyyMMddHHmmss");  		zipReadItemsSession.NonameIndex = 1;  	}  	// Call base class  	base.DoReadItems (session' readItemsSession' source' spannedStream);  	this.CalculateItemsSizes (zipSession' endHeader);  	if (zipSession != null)  		zipSession.OnReadingZipItemCompletion ();  	if (zipReadItemsSession.FirstHeaderDisk > 0 || zipReadItemsSession.FirstHeaderOffset > 0) {  		if ((zipReadItemsSession.FirstHeaderDisk == 0) && (zipReadItemsSession.FirstHeaderOffset == 4)) {  			// We assume this is the spanning signature. We ignore it.  		}  		else if (endHeader.DiskNumber > 0) {  			// We do not support updating spanned SFX zip files.  			// But we can't throw here since it may only be for reading.  			// We simply abandon the SfxPrefix.  		}  		else {  			source.Seek (0' SeekOrigin.Begin);  			System.Diagnostics.Debug.Assert (handler.SfxPrefixStorageItem == null);  			SfxPrefix prefix = SfxPrefix.CreateSfxPrefix (source' zipReadItemsSession.FirstHeaderOffset);  			if (prefix == null)  				throw new FileSystemInternalException ("Default prefix could not be created.");  			handler.SetSfxPrefix (prefix);  			// Mark add the prefix's storage item to the list just like any item would be  			StorageItem sfxPrefixItem = handler.SfxPrefixStorageItem;  			sfxPrefixItem.State = StorageItemState.UpToDate;  			sfxPrefixItem.Location.Storage = this;  			sfxPrefixItem.Location.HeaderSize = zipReadItemsSession.FirstHeaderOffset;  			zipReadItemsSession.Items.Add (sfxPrefixItem.Location' sfxPrefixItem);  		}  	}  }  catch (FileSystemIOException except) {  	throw new ZipIOException (StorageFile' except);  }  catch (IOException except) {  	throw new ZipIOException (StorageFile' except);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,DoReadItems,The following statement contains a magic number: if (zipSession != null)  	zipSession.InitializeTotalItems ((long)(endHeader.CentralHeadersTotal * 2));  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,DoReadItems,The following statement contains a magic number: zipSession.InitializeTotalItems ((long)(endHeader.CentralHeadersTotal * 2));  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,DoReadItems,The following statement contains a magic number: if (zipReadItemsSession.FirstHeaderDisk > 0 || zipReadItemsSession.FirstHeaderOffset > 0) {  	if ((zipReadItemsSession.FirstHeaderDisk == 0) && (zipReadItemsSession.FirstHeaderOffset == 4)) {  		// We assume this is the spanning signature. We ignore it.  	}  	else if (endHeader.DiskNumber > 0) {  		// We do not support updating spanned SFX zip files.  		// But we can't throw here since it may only be for reading.  		// We simply abandon the SfxPrefix.  	}  	else {  		source.Seek (0' SeekOrigin.Begin);  		System.Diagnostics.Debug.Assert (handler.SfxPrefixStorageItem == null);  		SfxPrefix prefix = SfxPrefix.CreateSfxPrefix (source' zipReadItemsSession.FirstHeaderOffset);  		if (prefix == null)  			throw new FileSystemInternalException ("Default prefix could not be created.");  		handler.SetSfxPrefix (prefix);  		// Mark add the prefix's storage item to the list just like any item would be  		StorageItem sfxPrefixItem = handler.SfxPrefixStorageItem;  		sfxPrefixItem.State = StorageItemState.UpToDate;  		sfxPrefixItem.Location.Storage = this;  		sfxPrefixItem.Location.HeaderSize = zipReadItemsSession.FirstHeaderOffset;  		zipReadItemsSession.Items.Add (sfxPrefixItem.Location' sfxPrefixItem);  	}  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,DoReadItems,The following statement contains a magic number: if ((zipReadItemsSession.FirstHeaderDisk == 0) && (zipReadItemsSession.FirstHeaderOffset == 4)) {  	// We assume this is the spanning signature. We ignore it.  }  else if (endHeader.DiskNumber > 0) {  	// We do not support updating spanned SFX zip files.  	// But we can't throw here since it may only be for reading.  	// We simply abandon the SfxPrefix.  }  else {  	source.Seek (0' SeekOrigin.Begin);  	System.Diagnostics.Debug.Assert (handler.SfxPrefixStorageItem == null);  	SfxPrefix prefix = SfxPrefix.CreateSfxPrefix (source' zipReadItemsSession.FirstHeaderOffset);  	if (prefix == null)  		throw new FileSystemInternalException ("Default prefix could not be created.");  	handler.SetSfxPrefix (prefix);  	// Mark add the prefix's storage item to the list just like any item would be  	StorageItem sfxPrefixItem = handler.SfxPrefixStorageItem;  	sfxPrefixItem.State = StorageItemState.UpToDate;  	sfxPrefixItem.Location.Storage = this;  	sfxPrefixItem.Location.HeaderSize = zipReadItemsSession.FirstHeaderOffset;  	zipReadItemsSession.Items.Add (sfxPrefixItem.Location' sfxPrefixItem);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: try {  	int headerSize;  	if (!itemHeader.ReadLocalHeader (reader' out headerSize)) {  		/*           // A difference was detected between the central and the local header.           // If we're reading an entry while writing a new zip file' we ignore.           if( m_zipHandler.Dirty == Dirtiness.Clean )           {             // Either Ignore or Retry is considered "ignore the differences' but              // continue with that file".             session.OnException( new InvalidZipStructureException(               "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );           }           */}  	itemHeader.Location.HeaderSize = headerSize + 4;  	itemHeader.Location.DataSize = itemHeader.CompressedSize;  	if (itemHeader.HasDescriptorHeader) {  		if (!itemHeader.HasZip64ExtraHeader) {  			itemHeader.Location.FooterSize = 12;  		}  		else {  			itemHeader.Location.FooterSize = 20;  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: try {  	int headerSize;  	if (!itemHeader.ReadLocalHeader (reader' out headerSize)) {  		/*           // A difference was detected between the central and the local header.           // If we're reading an entry while writing a new zip file' we ignore.           if( m_zipHandler.Dirty == Dirtiness.Clean )           {             // Either Ignore or Retry is considered "ignore the differences' but              // continue with that file".             session.OnException( new InvalidZipStructureException(               "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );           }           */}  	itemHeader.Location.HeaderSize = headerSize + 4;  	itemHeader.Location.DataSize = itemHeader.CompressedSize;  	if (itemHeader.HasDescriptorHeader) {  		if (!itemHeader.HasZip64ExtraHeader) {  			itemHeader.Location.FooterSize = 12;  		}  		else {  			itemHeader.Location.FooterSize = 20;  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: try {  	int headerSize;  	if (!itemHeader.ReadLocalHeader (reader' out headerSize)) {  		/*           // A difference was detected between the central and the local header.           // If we're reading an entry while writing a new zip file' we ignore.           if( m_zipHandler.Dirty == Dirtiness.Clean )           {             // Either Ignore or Retry is considered "ignore the differences' but              // continue with that file".             session.OnException( new InvalidZipStructureException(               "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );           }           */}  	itemHeader.Location.HeaderSize = headerSize + 4;  	itemHeader.Location.DataSize = itemHeader.CompressedSize;  	if (itemHeader.HasDescriptorHeader) {  		if (!itemHeader.HasZip64ExtraHeader) {  			itemHeader.Location.FooterSize = 12;  		}  		else {  			itemHeader.Location.FooterSize = 20;  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: itemHeader.Location.HeaderSize = headerSize + 4;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: if (itemHeader.HasDescriptorHeader) {  	if (!itemHeader.HasZip64ExtraHeader) {  		itemHeader.Location.FooterSize = 12;  	}  	else {  		itemHeader.Location.FooterSize = 20;  	}  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: if (itemHeader.HasDescriptorHeader) {  	if (!itemHeader.HasZip64ExtraHeader) {  		itemHeader.Location.FooterSize = 12;  	}  	else {  		itemHeader.Location.FooterSize = 20;  	}  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: if (!itemHeader.HasZip64ExtraHeader) {  	itemHeader.Location.FooterSize = 12;  }  else {  	itemHeader.Location.FooterSize = 20;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: if (!itemHeader.HasZip64ExtraHeader) {  	itemHeader.Location.FooterSize = 12;  }  else {  	itemHeader.Location.FooterSize = 20;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: itemHeader.Location.FooterSize = 12;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadLocalHeader,The following statement contains a magic number: itemHeader.Location.FooterSize = 20;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: try {  	int headerSize;  	if (!itemHeader.ReadLocalHeader (reader' out headerSize)) {  		/*           // A difference was detected between the central and the local header.           // If we're reading an entry while writing a new zip file' we ignore.           if( m_zipHandler.Dirty == Dirtiness.Clean )           {             // Either Ignore or Retry is considered "ignore the differences' but              // continue with that file".             session.OnException( new InvalidZipStructureException(               "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );           }           */}  	item.Location.HeaderSize = headerSize + 4;  	item.Location.DataSize = itemHeader.CompressedSize;  	if (itemHeader.HasDescriptorHeader) {  		if (!itemHeader.HasZip64ExtraHeader) {  			item.Location.FooterSize = 12;  		}  		else {  			item.Location.FooterSize = 20;  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: try {  	int headerSize;  	if (!itemHeader.ReadLocalHeader (reader' out headerSize)) {  		/*           // A difference was detected between the central and the local header.           // If we're reading an entry while writing a new zip file' we ignore.           if( m_zipHandler.Dirty == Dirtiness.Clean )           {             // Either Ignore or Retry is considered "ignore the differences' but              // continue with that file".             session.OnException( new InvalidZipStructureException(               "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );           }           */}  	item.Location.HeaderSize = headerSize + 4;  	item.Location.DataSize = itemHeader.CompressedSize;  	if (itemHeader.HasDescriptorHeader) {  		if (!itemHeader.HasZip64ExtraHeader) {  			item.Location.FooterSize = 12;  		}  		else {  			item.Location.FooterSize = 20;  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: try {  	int headerSize;  	if (!itemHeader.ReadLocalHeader (reader' out headerSize)) {  		/*           // A difference was detected between the central and the local header.           // If we're reading an entry while writing a new zip file' we ignore.           if( m_zipHandler.Dirty == Dirtiness.Clean )           {             // Either Ignore or Retry is considered "ignore the differences' but              // continue with that file".             session.OnException( new InvalidZipStructureException(               "The information contained in the local header does not match the information of the central header."' m_zipHandler.LastZipFile ) );           }           */}  	item.Location.HeaderSize = headerSize + 4;  	item.Location.DataSize = itemHeader.CompressedSize;  	if (itemHeader.HasDescriptorHeader) {  		if (!itemHeader.HasZip64ExtraHeader) {  			item.Location.FooterSize = 12;  		}  		else {  			item.Location.FooterSize = 20;  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: item.Location.HeaderSize = headerSize + 4;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: if (itemHeader.HasDescriptorHeader) {  	if (!itemHeader.HasZip64ExtraHeader) {  		item.Location.FooterSize = 12;  	}  	else {  		item.Location.FooterSize = 20;  	}  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: if (itemHeader.HasDescriptorHeader) {  	if (!itemHeader.HasZip64ExtraHeader) {  		item.Location.FooterSize = 12;  	}  	else {  		item.Location.FooterSize = 20;  	}  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: if (!itemHeader.HasZip64ExtraHeader) {  	item.Location.FooterSize = 12;  }  else {  	item.Location.FooterSize = 20;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: if (!itemHeader.HasZip64ExtraHeader) {  	item.Location.FooterSize = 12;  }  else {  	item.Location.FooterSize = 20;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: item.Location.FooterSize = 12;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnPreparingReadStream,The following statement contains a magic number: item.Location.FooterSize = 20;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,OnMoveItemsSeekToData,The following statement contains a magic number: if (item.Location.HeaderSize >= 26) {  	// Let the base implementation seek using the value we have in memory  	return base.OnMoveItemsSeekToData (session' sourceStream' item);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,ReadItem,The following statement contains a magic number: if (sigBuf.Length != 4)  	throw new InvalidZipStructureException ("Could not find a central header where one was expected in the zip file."' StorageFile);  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: for (int i = this.Items.Count - 1; i >= 0; i--) {  	long size;  	bool calculateHeaderSize;  	// Get the current item  	ItemHeader item = (ItemHeader)this.Items [i];  	StorageKey location = item.Location;  	// If the current item is located on the same disk as the item that follows it  	if (item.LocalHeaderDisk == nextItemDiskNumber) {  		// The item's gross size is the offset of the next item minus the current item's offset  		size = nextItemOffset - location.Offset;  		calculateHeaderSize = true;  	}  	else {  		// ??  		size = (64 * 1024) + location.DataSize + 20;  		calculateHeaderSize = false;  	}  	// If the item has a descriptor header  	if (item.HasDescriptorHeader) {  		long footerSize;  		// If the item doesn't have a Zip64 extra header  		if (!item.HasZip64ExtraHeader) {  			// Use the descriptor header size as the footer size  			footerSize = ItemHeader.DescriptorHeaderSize;  		}  		else {  			// Use the Zip64 descriptor header size as the footer size  			footerSize = ItemHeader.Zip64DescriptorHeaderSize;  		}  		// Store the footer size  		location.FooterSize = footerSize;  		// Remove the footer size from the gross size  		size -= footerSize;  	}  	// If we're confident we can calculate the header size for this item  	if (calculateHeaderSize) {  		// The header size is the remaining gross size minus the data size  		// we got from the central header  		long headerSize = size - location.DataSize;  		// Store the header size  		location.HeaderSize = headerSize;  		// Remove the header size from the gross size  		size -= headerSize;  	}  	else {  		// Assign a default header size that will signify that we must manually calculate the size later  		location.HeaderSize = 4;  		// Remove the header size from the gross size  		size -= 4;  	}  	// Store the item's data size using the remaining gross size  	location.DataSize = size;  	// Remember the current item's disk number and offset  	nextItemDiskNumber = item.LocalHeaderDisk;  	nextItemOffset = location.Offset;  	if (zipSession != null)  		zipSession.OnReadingZipItemProgression (this.StorageFile);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: for (int i = this.Items.Count - 1; i >= 0; i--) {  	long size;  	bool calculateHeaderSize;  	// Get the current item  	ItemHeader item = (ItemHeader)this.Items [i];  	StorageKey location = item.Location;  	// If the current item is located on the same disk as the item that follows it  	if (item.LocalHeaderDisk == nextItemDiskNumber) {  		// The item's gross size is the offset of the next item minus the current item's offset  		size = nextItemOffset - location.Offset;  		calculateHeaderSize = true;  	}  	else {  		// ??  		size = (64 * 1024) + location.DataSize + 20;  		calculateHeaderSize = false;  	}  	// If the item has a descriptor header  	if (item.HasDescriptorHeader) {  		long footerSize;  		// If the item doesn't have a Zip64 extra header  		if (!item.HasZip64ExtraHeader) {  			// Use the descriptor header size as the footer size  			footerSize = ItemHeader.DescriptorHeaderSize;  		}  		else {  			// Use the Zip64 descriptor header size as the footer size  			footerSize = ItemHeader.Zip64DescriptorHeaderSize;  		}  		// Store the footer size  		location.FooterSize = footerSize;  		// Remove the footer size from the gross size  		size -= footerSize;  	}  	// If we're confident we can calculate the header size for this item  	if (calculateHeaderSize) {  		// The header size is the remaining gross size minus the data size  		// we got from the central header  		long headerSize = size - location.DataSize;  		// Store the header size  		location.HeaderSize = headerSize;  		// Remove the header size from the gross size  		size -= headerSize;  	}  	else {  		// Assign a default header size that will signify that we must manually calculate the size later  		location.HeaderSize = 4;  		// Remove the header size from the gross size  		size -= 4;  	}  	// Store the item's data size using the remaining gross size  	location.DataSize = size;  	// Remember the current item's disk number and offset  	nextItemDiskNumber = item.LocalHeaderDisk;  	nextItemOffset = location.Offset;  	if (zipSession != null)  		zipSession.OnReadingZipItemProgression (this.StorageFile);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: for (int i = this.Items.Count - 1; i >= 0; i--) {  	long size;  	bool calculateHeaderSize;  	// Get the current item  	ItemHeader item = (ItemHeader)this.Items [i];  	StorageKey location = item.Location;  	// If the current item is located on the same disk as the item that follows it  	if (item.LocalHeaderDisk == nextItemDiskNumber) {  		// The item's gross size is the offset of the next item minus the current item's offset  		size = nextItemOffset - location.Offset;  		calculateHeaderSize = true;  	}  	else {  		// ??  		size = (64 * 1024) + location.DataSize + 20;  		calculateHeaderSize = false;  	}  	// If the item has a descriptor header  	if (item.HasDescriptorHeader) {  		long footerSize;  		// If the item doesn't have a Zip64 extra header  		if (!item.HasZip64ExtraHeader) {  			// Use the descriptor header size as the footer size  			footerSize = ItemHeader.DescriptorHeaderSize;  		}  		else {  			// Use the Zip64 descriptor header size as the footer size  			footerSize = ItemHeader.Zip64DescriptorHeaderSize;  		}  		// Store the footer size  		location.FooterSize = footerSize;  		// Remove the footer size from the gross size  		size -= footerSize;  	}  	// If we're confident we can calculate the header size for this item  	if (calculateHeaderSize) {  		// The header size is the remaining gross size minus the data size  		// we got from the central header  		long headerSize = size - location.DataSize;  		// Store the header size  		location.HeaderSize = headerSize;  		// Remove the header size from the gross size  		size -= headerSize;  	}  	else {  		// Assign a default header size that will signify that we must manually calculate the size later  		location.HeaderSize = 4;  		// Remove the header size from the gross size  		size -= 4;  	}  	// Store the item's data size using the remaining gross size  	location.DataSize = size;  	// Remember the current item's disk number and offset  	nextItemDiskNumber = item.LocalHeaderDisk;  	nextItemOffset = location.Offset;  	if (zipSession != null)  		zipSession.OnReadingZipItemProgression (this.StorageFile);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: for (int i = this.Items.Count - 1; i >= 0; i--) {  	long size;  	bool calculateHeaderSize;  	// Get the current item  	ItemHeader item = (ItemHeader)this.Items [i];  	StorageKey location = item.Location;  	// If the current item is located on the same disk as the item that follows it  	if (item.LocalHeaderDisk == nextItemDiskNumber) {  		// The item's gross size is the offset of the next item minus the current item's offset  		size = nextItemOffset - location.Offset;  		calculateHeaderSize = true;  	}  	else {  		// ??  		size = (64 * 1024) + location.DataSize + 20;  		calculateHeaderSize = false;  	}  	// If the item has a descriptor header  	if (item.HasDescriptorHeader) {  		long footerSize;  		// If the item doesn't have a Zip64 extra header  		if (!item.HasZip64ExtraHeader) {  			// Use the descriptor header size as the footer size  			footerSize = ItemHeader.DescriptorHeaderSize;  		}  		else {  			// Use the Zip64 descriptor header size as the footer size  			footerSize = ItemHeader.Zip64DescriptorHeaderSize;  		}  		// Store the footer size  		location.FooterSize = footerSize;  		// Remove the footer size from the gross size  		size -= footerSize;  	}  	// If we're confident we can calculate the header size for this item  	if (calculateHeaderSize) {  		// The header size is the remaining gross size minus the data size  		// we got from the central header  		long headerSize = size - location.DataSize;  		// Store the header size  		location.HeaderSize = headerSize;  		// Remove the header size from the gross size  		size -= headerSize;  	}  	else {  		// Assign a default header size that will signify that we must manually calculate the size later  		location.HeaderSize = 4;  		// Remove the header size from the gross size  		size -= 4;  	}  	// Store the item's data size using the remaining gross size  	location.DataSize = size;  	// Remember the current item's disk number and offset  	nextItemDiskNumber = item.LocalHeaderDisk;  	nextItemOffset = location.Offset;  	if (zipSession != null)  		zipSession.OnReadingZipItemProgression (this.StorageFile);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: for (int i = this.Items.Count - 1; i >= 0; i--) {  	long size;  	bool calculateHeaderSize;  	// Get the current item  	ItemHeader item = (ItemHeader)this.Items [i];  	StorageKey location = item.Location;  	// If the current item is located on the same disk as the item that follows it  	if (item.LocalHeaderDisk == nextItemDiskNumber) {  		// The item's gross size is the offset of the next item minus the current item's offset  		size = nextItemOffset - location.Offset;  		calculateHeaderSize = true;  	}  	else {  		// ??  		size = (64 * 1024) + location.DataSize + 20;  		calculateHeaderSize = false;  	}  	// If the item has a descriptor header  	if (item.HasDescriptorHeader) {  		long footerSize;  		// If the item doesn't have a Zip64 extra header  		if (!item.HasZip64ExtraHeader) {  			// Use the descriptor header size as the footer size  			footerSize = ItemHeader.DescriptorHeaderSize;  		}  		else {  			// Use the Zip64 descriptor header size as the footer size  			footerSize = ItemHeader.Zip64DescriptorHeaderSize;  		}  		// Store the footer size  		location.FooterSize = footerSize;  		// Remove the footer size from the gross size  		size -= footerSize;  	}  	// If we're confident we can calculate the header size for this item  	if (calculateHeaderSize) {  		// The header size is the remaining gross size minus the data size  		// we got from the central header  		long headerSize = size - location.DataSize;  		// Store the header size  		location.HeaderSize = headerSize;  		// Remove the header size from the gross size  		size -= headerSize;  	}  	else {  		// Assign a default header size that will signify that we must manually calculate the size later  		location.HeaderSize = 4;  		// Remove the header size from the gross size  		size -= 4;  	}  	// Store the item's data size using the remaining gross size  	location.DataSize = size;  	// Remember the current item's disk number and offset  	nextItemDiskNumber = item.LocalHeaderDisk;  	nextItemOffset = location.Offset;  	if (zipSession != null)  		zipSession.OnReadingZipItemProgression (this.StorageFile);  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: if (item.LocalHeaderDisk == nextItemDiskNumber) {  	// The item's gross size is the offset of the next item minus the current item's offset  	size = nextItemOffset - location.Offset;  	calculateHeaderSize = true;  }  else {  	// ??  	size = (64 * 1024) + location.DataSize + 20;  	calculateHeaderSize = false;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: if (item.LocalHeaderDisk == nextItemDiskNumber) {  	// The item's gross size is the offset of the next item minus the current item's offset  	size = nextItemOffset - location.Offset;  	calculateHeaderSize = true;  }  else {  	// ??  	size = (64 * 1024) + location.DataSize + 20;  	calculateHeaderSize = false;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: if (item.LocalHeaderDisk == nextItemDiskNumber) {  	// The item's gross size is the offset of the next item minus the current item's offset  	size = nextItemOffset - location.Offset;  	calculateHeaderSize = true;  }  else {  	// ??  	size = (64 * 1024) + location.DataSize + 20;  	calculateHeaderSize = false;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: size = (64 * 1024) + location.DataSize + 20;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: size = (64 * 1024) + location.DataSize + 20;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: size = (64 * 1024) + location.DataSize + 20;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: if (calculateHeaderSize) {  	// The header size is the remaining gross size minus the data size  	// we got from the central header  	long headerSize = size - location.DataSize;  	// Store the header size  	location.HeaderSize = headerSize;  	// Remove the header size from the gross size  	size -= headerSize;  }  else {  	// Assign a default header size that will signify that we must manually calculate the size later  	location.HeaderSize = 4;  	// Remove the header size from the gross size  	size -= 4;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: if (calculateHeaderSize) {  	// The header size is the remaining gross size minus the data size  	// we got from the central header  	long headerSize = size - location.DataSize;  	// Store the header size  	location.HeaderSize = headerSize;  	// Remove the header size from the gross size  	size -= headerSize;  }  else {  	// Assign a default header size that will signify that we must manually calculate the size later  	location.HeaderSize = 4;  	// Remove the header size from the gross size  	size -= 4;  }  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: location.HeaderSize = 4;  
Magic Number,Xceed.Zip,ZipStorage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ZipStorage.cs,CalculateItemsSizes,The following statement contains a magic number: size -= 4;  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,The following statement contains a magic number: return this.ReadItemData (stream' 64 * 1024);  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadItemData,The following statement contains a magic number: return this.ReadItemData (stream' 64 * 1024);  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The following statement contains a magic number: if (itemInfo.Encrypted) {  	// Used to detect if wrong password was provided  	bool exceptionOccured = false;  	// TODO: Use the password in the current item local header  	string password = null;  	// m_currentZipItemLocalHeader.EncryptionPassword;  	// If we have no password  	if (String.IsNullOrEmpty (password)) {  		// Use the global password  		password = this.m_encryptionPassword;  		// TODO: Store the global password in the current local header so the user can read it  		//m_currentZipItemLocalHeader.EncryptionPassword = this.m_encryptionPassword;  	}  	do {  		/*           // Keep the initial of the stream in case we have to decrypt           // an encryption stream header           m_backupBufferHelper = new BackupBufferHelper( m_lastReadBuffer' m_lastReadBufferOffset );           */// Simulate an exception if we have no password  		exceptionOccured = String.IsNullOrEmpty (password);  		// No exception occurred  		if (!exceptionOccured) {  			switch (itemInfo.EncryptionMethod) {  			case EncryptionMethod.Compatible:  				// Get user key from item header  				long userKey;  				// = 0;  				if (itemInfo.HasDescriptorHeader) {  					userKey = itemInfo.OriginalEncryptionKey;  				}  				else {  					userKey = itemInfo.Crc32 >> 16;  				}  				// Try to decrypt the stream  				try {  					tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  				}  				catch (ZCryptException) {  					try {  						userKey = itemInfo.EncryptionKey;  						tempNewStream.Close ();  						tempNewStream = null;  						long offset = m_slidingWindowStream.GetRelativePosition (encryptionPosition);  						m_slidingWindowStream.SeekFromCurrentPosition (-offset);  						tempNewStream = this.GetUnzipStream (itemInfo);  						/*                     // Fetch the inner stream again to seek back to the beginning of the read encryption header                     IDisposable disposable = tempNewStream;                     disposable.Dispose();                     tempNewStream = this.GetRawInnerStream();                      // Reverify if we know the compressed size to recreate a WindowStream                     if( itemInfo.CompressedSize != 0 )                     {                       tempNewStream = new WindowStream( tempNewStream' itemInfo.CompressedSize );                     }                     */tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  					}  					catch (ZCryptException) {  						exceptionOccured = true;  					}  				}  				break;  			#if !XCEEDCF && !XCEED_NOAES  			case EncryptionMethod.WinZipAes:  				// The AesEncryptionStream must not close it's innerStream  				// Try to decrypt the stream  				try {  					tempNewStream = m_aesEncryptionStream = new AesEncryptionStream (tempNewStream'   					#if !SILVERLIGHT  					m_aesAlgorithmManager'   					#endif  					m_rfc2898DeriveBytesManager' password' itemInfo.EncryptionStrength' false' false);  					m_sha1Stream = new SHA1Stream (null' m_aesEncryptionStream.AuthenticationKey);  					m_slidingWindowStream.DiscardedDataStream = m_sha1Stream;  					// We must consume the read header to avoid those bytes to be reused  					//m_lastReadBufferOffset += 18;  				}  				catch (InvalidDecryptionPasswordException) {  					exceptionOccured = true;  				}  				break;  			#endif  			default: {  				string method = null;  				#if !XCEEDCF  				method = Enum.GetName (typeof(EncryptionMethod)' itemInfo.EncryptionMethod);  				#endif  				string message = String.Format ("Encryption method '{0}' is not supported by '{1}'"' method != null ? method : itemInfo.EncryptionMethod.ToString ()' this.GetType ());  				throw new ZipReaderException (message);  			}  			}  		}  		// Exception occurred because a wrong password was provided  		if (exceptionOccured) {  			string newPassword;  			bool abort;  			// Assume an empty new password and no abort  			newPassword = String.Empty;  			abort = false;  			// Trigger the event  			this.OnInvalidPassword (ref newPassword' ref abort);  			// If the user wants to abort or no new password was given  			if (abort || String.IsNullOrEmpty (newPassword)) {  				throw new ZipReaderException ("Password exception for item " + itemInfo.FileName + ". ZipReader process aborted.");  			}  			password = newPassword;  			m_encryptionPassword = newPassword;  			m_currentZipItemLocalHeader.EncryptionPassword = newPassword;  			tempNewStream.Close ();  			tempNewStream = null;  			#if !XCEEDCF && !XCEED_NOAES  			m_aesEncryptionStream = null;  			#endif  			long offset = m_slidingWindowStream.GetRelativePosition (encryptionPosition);  			m_slidingWindowStream.SeekFromCurrentPosition (-offset);  			tempNewStream = this.GetUnzipStream (itemInfo);  			/*             // Rollback the value read in the RawStream before getting             if( m_backupBufferHelper != null )             {               m_lastReadBuffer = m_backupBufferHelper.BackupBuffer;               m_backupBufferHelper.Dispose();             }              IDisposable disposable = tempNewStream;             disposable.Dispose();             tempNewStream = this.GetRawInnerStream();              // Reverify if we know the compressed size to recreate a WindowStream             if( itemInfo.CompressedSize != 0 )             {               tempNewStream = new WindowStream( tempNewStream' itemInfo.CompressedSize );             }             */}  	}  	while (exceptionOccured);  	/*         // The encryption Stream was correctly initialized' dispose the          if( m_backupBufferHelper != null )         {           m_backupBufferHelper.Dispose();           m_backupBufferHelper = null;         }         */}  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The following statement contains a magic number: do {  	/*           // Keep the initial of the stream in case we have to decrypt           // an encryption stream header           m_backupBufferHelper = new BackupBufferHelper( m_lastReadBuffer' m_lastReadBufferOffset );           */// Simulate an exception if we have no password  	exceptionOccured = String.IsNullOrEmpty (password);  	// No exception occurred  	if (!exceptionOccured) {  		switch (itemInfo.EncryptionMethod) {  		case EncryptionMethod.Compatible:  			// Get user key from item header  			long userKey;  			// = 0;  			if (itemInfo.HasDescriptorHeader) {  				userKey = itemInfo.OriginalEncryptionKey;  			}  			else {  				userKey = itemInfo.Crc32 >> 16;  			}  			// Try to decrypt the stream  			try {  				tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  			}  			catch (ZCryptException) {  				try {  					userKey = itemInfo.EncryptionKey;  					tempNewStream.Close ();  					tempNewStream = null;  					long offset = m_slidingWindowStream.GetRelativePosition (encryptionPosition);  					m_slidingWindowStream.SeekFromCurrentPosition (-offset);  					tempNewStream = this.GetUnzipStream (itemInfo);  					/*                     // Fetch the inner stream again to seek back to the beginning of the read encryption header                     IDisposable disposable = tempNewStream;                     disposable.Dispose();                     tempNewStream = this.GetRawInnerStream();                      // Reverify if we know the compressed size to recreate a WindowStream                     if( itemInfo.CompressedSize != 0 )                     {                       tempNewStream = new WindowStream( tempNewStream' itemInfo.CompressedSize );                     }                     */tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  				}  				catch (ZCryptException) {  					exceptionOccured = true;  				}  			}  			break;  		#if !XCEEDCF && !XCEED_NOAES  		case EncryptionMethod.WinZipAes:  			// The AesEncryptionStream must not close it's innerStream  			// Try to decrypt the stream  			try {  				tempNewStream = m_aesEncryptionStream = new AesEncryptionStream (tempNewStream'   				#if !SILVERLIGHT  				m_aesAlgorithmManager'   				#endif  				m_rfc2898DeriveBytesManager' password' itemInfo.EncryptionStrength' false' false);  				m_sha1Stream = new SHA1Stream (null' m_aesEncryptionStream.AuthenticationKey);  				m_slidingWindowStream.DiscardedDataStream = m_sha1Stream;  				// We must consume the read header to avoid those bytes to be reused  				//m_lastReadBufferOffset += 18;  			}  			catch (InvalidDecryptionPasswordException) {  				exceptionOccured = true;  			}  			break;  		#endif  		default: {  			string method = null;  			#if !XCEEDCF  			method = Enum.GetName (typeof(EncryptionMethod)' itemInfo.EncryptionMethod);  			#endif  			string message = String.Format ("Encryption method '{0}' is not supported by '{1}'"' method != null ? method : itemInfo.EncryptionMethod.ToString ()' this.GetType ());  			throw new ZipReaderException (message);  		}  		}  	}  	// Exception occurred because a wrong password was provided  	if (exceptionOccured) {  		string newPassword;  		bool abort;  		// Assume an empty new password and no abort  		newPassword = String.Empty;  		abort = false;  		// Trigger the event  		this.OnInvalidPassword (ref newPassword' ref abort);  		// If the user wants to abort or no new password was given  		if (abort || String.IsNullOrEmpty (newPassword)) {  			throw new ZipReaderException ("Password exception for item " + itemInfo.FileName + ". ZipReader process aborted.");  		}  		password = newPassword;  		m_encryptionPassword = newPassword;  		m_currentZipItemLocalHeader.EncryptionPassword = newPassword;  		tempNewStream.Close ();  		tempNewStream = null;  		#if !XCEEDCF && !XCEED_NOAES  		m_aesEncryptionStream = null;  		#endif  		long offset = m_slidingWindowStream.GetRelativePosition (encryptionPosition);  		m_slidingWindowStream.SeekFromCurrentPosition (-offset);  		tempNewStream = this.GetUnzipStream (itemInfo);  		/*             // Rollback the value read in the RawStream before getting             if( m_backupBufferHelper != null )             {               m_lastReadBuffer = m_backupBufferHelper.BackupBuffer;               m_backupBufferHelper.Dispose();             }              IDisposable disposable = tempNewStream;             disposable.Dispose();             tempNewStream = this.GetRawInnerStream();              // Reverify if we know the compressed size to recreate a WindowStream             if( itemInfo.CompressedSize != 0 )             {               tempNewStream = new WindowStream( tempNewStream' itemInfo.CompressedSize );             }             */}  }  while (exceptionOccured);  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The following statement contains a magic number: if (!exceptionOccured) {  	switch (itemInfo.EncryptionMethod) {  	case EncryptionMethod.Compatible:  		// Get user key from item header  		long userKey;  		// = 0;  		if (itemInfo.HasDescriptorHeader) {  			userKey = itemInfo.OriginalEncryptionKey;  		}  		else {  			userKey = itemInfo.Crc32 >> 16;  		}  		// Try to decrypt the stream  		try {  			tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  		}  		catch (ZCryptException) {  			try {  				userKey = itemInfo.EncryptionKey;  				tempNewStream.Close ();  				tempNewStream = null;  				long offset = m_slidingWindowStream.GetRelativePosition (encryptionPosition);  				m_slidingWindowStream.SeekFromCurrentPosition (-offset);  				tempNewStream = this.GetUnzipStream (itemInfo);  				/*                     // Fetch the inner stream again to seek back to the beginning of the read encryption header                     IDisposable disposable = tempNewStream;                     disposable.Dispose();                     tempNewStream = this.GetRawInnerStream();                      // Reverify if we know the compressed size to recreate a WindowStream                     if( itemInfo.CompressedSize != 0 )                     {                       tempNewStream = new WindowStream( tempNewStream' itemInfo.CompressedSize );                     }                     */tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  			}  			catch (ZCryptException) {  				exceptionOccured = true;  			}  		}  		break;  	#if !XCEEDCF && !XCEED_NOAES  	case EncryptionMethod.WinZipAes:  		// The AesEncryptionStream must not close it's innerStream  		// Try to decrypt the stream  		try {  			tempNewStream = m_aesEncryptionStream = new AesEncryptionStream (tempNewStream'   			#if !SILVERLIGHT  			m_aesAlgorithmManager'   			#endif  			m_rfc2898DeriveBytesManager' password' itemInfo.EncryptionStrength' false' false);  			m_sha1Stream = new SHA1Stream (null' m_aesEncryptionStream.AuthenticationKey);  			m_slidingWindowStream.DiscardedDataStream = m_sha1Stream;  			// We must consume the read header to avoid those bytes to be reused  			//m_lastReadBufferOffset += 18;  		}  		catch (InvalidDecryptionPasswordException) {  			exceptionOccured = true;  		}  		break;  	#endif  	default: {  		string method = null;  		#if !XCEEDCF  		method = Enum.GetName (typeof(EncryptionMethod)' itemInfo.EncryptionMethod);  		#endif  		string message = String.Format ("Encryption method '{0}' is not supported by '{1}'"' method != null ? method : itemInfo.EncryptionMethod.ToString ()' this.GetType ());  		throw new ZipReaderException (message);  	}  	}  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The following statement contains a magic number: switch (itemInfo.EncryptionMethod) {  case EncryptionMethod.Compatible:  	// Get user key from item header  	long userKey;  	// = 0;  	if (itemInfo.HasDescriptorHeader) {  		userKey = itemInfo.OriginalEncryptionKey;  	}  	else {  		userKey = itemInfo.Crc32 >> 16;  	}  	// Try to decrypt the stream  	try {  		tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  	}  	catch (ZCryptException) {  		try {  			userKey = itemInfo.EncryptionKey;  			tempNewStream.Close ();  			tempNewStream = null;  			long offset = m_slidingWindowStream.GetRelativePosition (encryptionPosition);  			m_slidingWindowStream.SeekFromCurrentPosition (-offset);  			tempNewStream = this.GetUnzipStream (itemInfo);  			/*                     // Fetch the inner stream again to seek back to the beginning of the read encryption header                     IDisposable disposable = tempNewStream;                     disposable.Dispose();                     tempNewStream = this.GetRawInnerStream();                      // Reverify if we know the compressed size to recreate a WindowStream                     if( itemInfo.CompressedSize != 0 )                     {                       tempNewStream = new WindowStream( tempNewStream' itemInfo.CompressedSize );                     }                     */tempNewStream = new ZCryptStream (tempNewStream' password' userKey' false);  		}  		catch (ZCryptException) {  			exceptionOccured = true;  		}  	}  	break;  #if !XCEEDCF && !XCEED_NOAES  case EncryptionMethod.WinZipAes:  	// The AesEncryptionStream must not close it's innerStream  	// Try to decrypt the stream  	try {  		tempNewStream = m_aesEncryptionStream = new AesEncryptionStream (tempNewStream'   		#if !SILVERLIGHT  		m_aesAlgorithmManager'   		#endif  		m_rfc2898DeriveBytesManager' password' itemInfo.EncryptionStrength' false' false);  		m_sha1Stream = new SHA1Stream (null' m_aesEncryptionStream.AuthenticationKey);  		m_slidingWindowStream.DiscardedDataStream = m_sha1Stream;  		// We must consume the read header to avoid those bytes to be reused  		//m_lastReadBufferOffset += 18;  	}  	catch (InvalidDecryptionPasswordException) {  		exceptionOccured = true;  	}  	break;  #endif  default: {  	string method = null;  	#if !XCEEDCF  	method = Enum.GetName (typeof(EncryptionMethod)' itemInfo.EncryptionMethod);  	#endif  	string message = String.Format ("Encryption method '{0}' is not supported by '{1}'"' method != null ? method : itemInfo.EncryptionMethod.ToString ()' this.GetType ());  	throw new ZipReaderException (message);  }  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The following statement contains a magic number: if (itemInfo.HasDescriptorHeader) {  	userKey = itemInfo.OriginalEncryptionKey;  }  else {  	userKey = itemInfo.Crc32 >> 16;  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,InitializeZipReader,The following statement contains a magic number: userKey = itemInfo.Crc32 >> 16;  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,ReadSignature,The following statement contains a magic number: Debug.Assert (read == 4);  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,DoReadItemLocalHeader,The following statement contains a magic number: if (itemInfo.LocalHeaderOffset == 0) {  	// Get the current position in the zip file stream  	long localHeaderOffset = m_slidingWindowStream.GetRelativePosition (m_innerStreamPosition);  	//m_innerStreamPosition - m_lastReadBuffer.Length + m_lastReadBufferOffset;  	if (localHeaderOffset > 0) {  		// The local header was read' we must subtract the size of the local header to get its offset  		localHeaderOffset -= 4;  		// 4 bytes for LocalHeader signature;  		itemInfo.LocalHeaderOffset = localHeaderOffset;  	}  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,DoReadItemLocalHeader,The following statement contains a magic number: if (localHeaderOffset > 0) {  	// The local header was read' we must subtract the size of the local header to get its offset  	localHeaderOffset -= 4;  	// 4 bytes for LocalHeader signature;  	itemInfo.LocalHeaderOffset = localHeaderOffset;  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipReader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipReader.cs,DoReadItemLocalHeader,The following statement contains a magic number: localHeaderOffset -= 4;  
Magic Number,Xceed.Zip.ReaderWriter,ReaderWriterItemInfo,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ReaderWriterItemInfo.cs,Initialize,The following statement contains a magic number: this.EncryptionStrength = 256;  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemData,The following statement contains a magic number: return this.WriteItemData (itemData' 8 * 1024);  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteItemData,The following statement contains a magic number: return this.WriteItemData (itemData' 8 * 1024);  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: using (MemoryStream memory = new MemoryStream ()) {  	BinaryWriter writer = new BinaryWriter (memory);  	try {  		zip64EndHeaderOffset = (ulong)m_innerStream.Position;  		// Always write Zip64 End Header  		writer.Write (ReaderWriterConstants.Zip64EndHeaderSignature);  		writer.Write ((ulong)44);  		writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  		writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  		writer.Write ((uint)0);  		// Disk Number  		writer.Write ((uint)0);  		// Central Disk Number  		writer.Write ((ulong)m_itemInfoList.Count);  		// Central Headers On Current Disk  		writer.Write ((ulong)m_itemInfoList.Count);  		// Total Central Headers Count  		writer.Write ((ulong)m_centralDirectorySize);  		// Central Directory Size  		writer.Write ((ulong)m_centralDirectoryOffset);  		// Central Directory Offset  		Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  	}  	finally {  		writer.Close ();  	}  	endHeader = memory.ToArray ();  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: using (MemoryStream memory = new MemoryStream ()) {  	BinaryWriter writer = new BinaryWriter (memory);  	try {  		zip64EndHeaderOffset = (ulong)m_innerStream.Position;  		// Always write Zip64 End Header  		writer.Write (ReaderWriterConstants.Zip64EndHeaderSignature);  		writer.Write ((ulong)44);  		writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  		writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  		writer.Write ((uint)0);  		// Disk Number  		writer.Write ((uint)0);  		// Central Disk Number  		writer.Write ((ulong)m_itemInfoList.Count);  		// Central Headers On Current Disk  		writer.Write ((ulong)m_itemInfoList.Count);  		// Total Central Headers Count  		writer.Write ((ulong)m_centralDirectorySize);  		// Central Directory Size  		writer.Write ((ulong)m_centralDirectoryOffset);  		// Central Directory Offset  		Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  	}  	finally {  		writer.Close ();  	}  	endHeader = memory.ToArray ();  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: using (MemoryStream memory = new MemoryStream ()) {  	BinaryWriter writer = new BinaryWriter (memory);  	try {  		zip64EndHeaderOffset = (ulong)m_innerStream.Position;  		// Always write Zip64 End Header  		writer.Write (ReaderWriterConstants.Zip64EndHeaderSignature);  		writer.Write ((ulong)44);  		writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  		writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  		writer.Write ((uint)0);  		// Disk Number  		writer.Write ((uint)0);  		// Central Disk Number  		writer.Write ((ulong)m_itemInfoList.Count);  		// Central Headers On Current Disk  		writer.Write ((ulong)m_itemInfoList.Count);  		// Total Central Headers Count  		writer.Write ((ulong)m_centralDirectorySize);  		// Central Directory Size  		writer.Write ((ulong)m_centralDirectoryOffset);  		// Central Directory Offset  		Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  	}  	finally {  		writer.Close ();  	}  	endHeader = memory.ToArray ();  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: try {  	zip64EndHeaderOffset = (ulong)m_innerStream.Position;  	// Always write Zip64 End Header  	writer.Write (ReaderWriterConstants.Zip64EndHeaderSignature);  	writer.Write ((ulong)44);  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((uint)0);  	// Disk Number  	writer.Write ((uint)0);  	// Central Disk Number  	writer.Write ((ulong)m_itemInfoList.Count);  	// Central Headers On Current Disk  	writer.Write ((ulong)m_itemInfoList.Count);  	// Total Central Headers Count  	writer.Write ((ulong)m_centralDirectorySize);  	// Central Directory Size  	writer.Write ((ulong)m_centralDirectoryOffset);  	// Central Directory Offset  	Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: try {  	zip64EndHeaderOffset = (ulong)m_innerStream.Position;  	// Always write Zip64 End Header  	writer.Write (ReaderWriterConstants.Zip64EndHeaderSignature);  	writer.Write ((ulong)44);  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((uint)0);  	// Disk Number  	writer.Write ((uint)0);  	// Central Disk Number  	writer.Write ((ulong)m_itemInfoList.Count);  	// Central Headers On Current Disk  	writer.Write ((ulong)m_itemInfoList.Count);  	// Total Central Headers Count  	writer.Write ((ulong)m_centralDirectorySize);  	// Central Directory Size  	writer.Write ((ulong)m_centralDirectoryOffset);  	// Central Directory Offset  	Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: try {  	zip64EndHeaderOffset = (ulong)m_innerStream.Position;  	// Always write Zip64 End Header  	writer.Write (ReaderWriterConstants.Zip64EndHeaderSignature);  	writer.Write ((ulong)44);  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((ushort)(ZipVersionField.OsDos | ZipVersionField.VerZip64));  	writer.Write ((uint)0);  	// Disk Number  	writer.Write ((uint)0);  	// Central Disk Number  	writer.Write ((ulong)m_itemInfoList.Count);  	// Central Headers On Current Disk  	writer.Write ((ulong)m_itemInfoList.Count);  	// Total Central Headers Count  	writer.Write ((ulong)m_centralDirectorySize);  	// Central Directory Size  	writer.Write ((ulong)m_centralDirectoryOffset);  	// Central Directory Offset  	Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: writer.Write ((ulong)44);  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  
Magic Number,Xceed.Zip.ReaderWriter,ZipWriter,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\ReaderWriter\ZipWriter.cs,WriteZip64EndHeader,The following statement contains a magic number: Debug.Assert (memory.Length == 44 + 12' "Bad hardcoded value for Zip64 End Header size");  
Magic Number,Xceed.Utils.Encryption,RijndaelCtrMode,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Encryption\RijndaelCtrMode.cs,RijndaelCtrMode,The following statement contains a magic number: m_blockSize = 16;  
Magic Number,Xceed.Utils.Encryption,RijndaelCtrMode,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Encryption\RijndaelCtrMode.cs,RijndaelCtrMode,The following statement contains a magic number: m_rijndael.BlockSize = blockSize * 8;  
Magic Number,Xceed.Utils.Encryption,RijndaelCtrMode,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Encryption\RijndaelCtrMode.cs,UpdateNonce,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (m_nonce [i] < 255) {  		++m_nonce [i];  		break;  	}  	m_nonce [i] = 0;  }  
Magic Number,Xceed.Utils.Encryption,RijndaelCtrMode,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Encryption\RijndaelCtrMode.cs,UpdateNonce,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (m_nonce [i] < 255) {  		++m_nonce [i];  		break;  	}  	m_nonce [i] = 0;  }  
Magic Number,Xceed.Utils.Encryption,RijndaelCtrMode,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Encryption\RijndaelCtrMode.cs,UpdateNonce,The following statement contains a magic number: if (m_nonce [i] < 255) {  	++m_nonce [i];  	break;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: try {  	// The destination storage may be nothing else than ourself!  	// This means newly written items could overlap existing items  	// not yet removed from the list. That's why we must make a copy  	// of the list and empty it before starting to update items.  	SortedList<StorageKey' StorageItem> cloned = new SortedList<StorageKey' StorageItem> (m_items' mg_keyComparer);  	m_items.Clear ();  	this.MovePrefixStorages (session' destStream' destStorage);  	StorageKey firstUpdatedLocation = null;  	if (this.m_firstUpdatedItem != null) {  		firstUpdatedLocation = this.m_firstUpdatedItem.Location;  	}  	uint diskNumber;  	if (firstUpdatedLocation != null) {  		diskNumber = firstUpdatedLocation.DiskNumber;  	}  	else {  		diskNumber = 0;  	}  	if (this.HaveCurrentDiskNumber && this.CurrentDiskNumber != diskNumber) {  		this.ChangeDisk (session' diskNumber' DiskRequiredReason.MovingExistingItems);  	}  	// We need a destination stream that can at least report its position.  	// The caller is responsible for wrapping its non-seekable streams in  	// a PositionedStream' which can provide position based on number  	// of bytes written.  	ISpannedStream spannedSourceStream = null;  	ISpannedStream spannedDestStream = null;  	// Try to retrieve the ISpannedStream interface from the destination stream stack  	spannedDestStream = PassThroughStream.Find<ISpannedStream> (destStream);  	long destStart = 0;  	long blockStart = 0;  	uint blockDiskStart = 0;  	long blockSize = 0;  	if (firstUpdatedLocation != null/*&& this.IsSplittingOrSpanning*/) {  		blockSize = firstUpdatedLocation.Offset;  	}  	IList<StorageItem> clonedValues = cloned.Values;  	int index = 0;  	int count = clonedValues.Count;  	if (firstUpdatedLocation != null) {  		for (; index < count; index++) {  			StorageItem item = clonedValues [index];  			if (item.Location < firstUpdatedLocation) {  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  				if (session != null) {  					long itemSize = item.Location.TotalSize;  					OnPreparingItemMove (session' item' itemSize' destStream);  					OnMovingItem (session' itemSize);  				}  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("FirstUpdatedLocation loop."' argumentException' destStorage' item);  				}  			}  			else {  				break;  			}  		}  	}  	// Walk the cloned list in the correct order. Those items' key will  	// change' but it does not affect the already sorted cloned list.  	//foreach( StorageItem item in cloned.Values )  	for (; index < count; index++) {  		StorageItem item = clonedValues [index];  		bool requiresUpdateOnMove;  		requiresUpdateOnMove = item.RequiresUpdateOnMove;  		if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  			if (session != null)  				OnPreparingItemMove (session' item' 0' destStream);  			if (blockSize == 0) {  				// Beginning of data to copy. Remember source and destination   				// starting points.  				blockStart = item.Location.Offset;  				blockDiskStart = item.Location.DiskNumber;  				destStart = destStream.Position;  			}  			// Though this item has not moved yet' it will get  			// moved to a new location. The sizes do not change.  			item.Location.Offset = destStart + blockSize;  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  			}  			blockSize += item.Location.TotalSize;  			if (session != null)  				OnItemMoved (session' item' destStream);  		}  		else {  			bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  			// If we haven't created the read stream yet and we're about to need it  			if (sourceStream == null && (needsUpdate || blockSize > 0)) {  				sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  			}  			if (session != null) {  				long itemSize = blockSize;  				if (needsUpdate)  					itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  				OnPreparingItemMove (session' item' itemSize' destStream);  			}  			// We must manually update part of this area. But first' do we  			// have previous up-to-date items to copy?  			if (blockSize != 0) {  				if (blockDiskStart != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  				}  				// Avoid useless first seek  				if (blockStart != 0) {  					// We can always seek forward.  					sourceStream.Seek (blockStart' SeekOrigin.Begin);  				}  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  				blockSize = 0;  			}  			System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  			if (needsUpdate) {  				// Before changing our offset' we need to seek to our data.  				if (item.Location.DataSize > 0) {  					uint itemDiskNumber = item.Location.DiskNumber;  					if (itemDiskNumber != this.CurrentDiskNumber) {  						if (spannedSourceStream == null)  							throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  						spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  					}  					OnMoveItemsSeekToData (session' sourceStream' item);  				}  				if (spannedDestStream != null)  					item.Location.DiskNumber = spannedDestStream.DiskNumber;  				else  					item.Location.DiskNumber = destStorage.CurrentDiskNumber;  				// Remember current offset  				item.Location.Offset = destStream.Position;  				// Write Header  				item.Location.HeaderSize = item.WriteHeader (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.HeaderSize);  				// Move existing data if present' or write empty data if newly created.  				if (item.Location.DataSize > 0) {  					if (session == null) {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  					}  					else {  						StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  							OnMovingItem (session' bytesWritten);  						});  					}  				}  				else {  					item.Location.DataSize = item.WriteEmptyData (destStream);  				}  				// Write the footer.  				item.Location.FooterSize = item.WriteFooter (destStream);  				if (session != null)  					this.OnMovingItem (session' item.Location.FooterSize);  				item.Location.Storage = destStorage;  				try {  					destStorage.m_items.Add (item.Location' item);  				}  				catch (ArgumentException argumentException) {  					throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  				}  				if (session != null)  					OnItemMoved (session' item' destStream);  				// The item is responsible for updating its state.  				System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  			}  		}  	}  	// We may have still some pending data to copy.  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (sourceStream == null) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Updating);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		StreamCopy.Copy (sourceStream' destStream' blockSize);  	}  }  finally {  	if (sourceStream != null) {  		sourceStream.Close ();  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: for (; index < count; index++) {  	StorageItem item = clonedValues [index];  	bool requiresUpdateOnMove;  	requiresUpdateOnMove = item.RequiresUpdateOnMove;  	if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  		if (session != null)  			OnPreparingItemMove (session' item' 0' destStream);  		if (blockSize == 0) {  			// Beginning of data to copy. Remember source and destination   			// starting points.  			blockStart = item.Location.Offset;  			blockDiskStart = item.Location.DiskNumber;  			destStart = destStream.Position;  		}  		// Though this item has not moved yet' it will get  		// moved to a new location. The sizes do not change.  		item.Location.Offset = destStart + blockSize;  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  		}  		blockSize += item.Location.TotalSize;  		if (session != null)  			OnItemMoved (session' item' destStream);  	}  	else {  		bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  		// If we haven't created the read stream yet and we're about to need it  		if (sourceStream == null && (needsUpdate || blockSize > 0)) {  			sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  		}  		if (session != null) {  			long itemSize = blockSize;  			if (needsUpdate)  				itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  			OnPreparingItemMove (session' item' itemSize' destStream);  		}  		// We must manually update part of this area. But first' do we  		// have previous up-to-date items to copy?  		if (blockSize != 0) {  			if (blockDiskStart != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  			}  			// Avoid useless first seek  			if (blockStart != 0) {  				// We can always seek forward.  				sourceStream.Seek (blockStart' SeekOrigin.Begin);  			}  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  			blockSize = 0;  		}  		System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  		if (needsUpdate) {  			// Before changing our offset' we need to seek to our data.  			if (item.Location.DataSize > 0) {  				uint itemDiskNumber = item.Location.DiskNumber;  				if (itemDiskNumber != this.CurrentDiskNumber) {  					if (spannedSourceStream == null)  						throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  					spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  				}  				OnMoveItemsSeekToData (session' sourceStream' item);  			}  			if (spannedDestStream != null)  				item.Location.DiskNumber = spannedDestStream.DiskNumber;  			else  				item.Location.DiskNumber = destStorage.CurrentDiskNumber;  			// Remember current offset  			item.Location.Offset = destStream.Position;  			// Write Header  			item.Location.HeaderSize = item.WriteHeader (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.HeaderSize);  			// Move existing data if present' or write empty data if newly created.  			if (item.Location.DataSize > 0) {  				if (session == null) {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  				}  				else {  					StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  						OnMovingItem (session' bytesWritten);  					});  				}  			}  			else {  				item.Location.DataSize = item.WriteEmptyData (destStream);  			}  			// Write the footer.  			item.Location.FooterSize = item.WriteFooter (destStream);  			if (session != null)  				this.OnMovingItem (session' item.Location.FooterSize);  			item.Location.Storage = destStorage;  			try {  				destStorage.m_items.Add (item.Location' item);  			}  			catch (ArgumentException argumentException) {  				throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  			}  			if (session != null)  				OnItemMoved (session' item' destStream);  			// The item is responsible for updating its state.  			System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  		}  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.State == StorageItemState.UpToDate && !requiresUpdateOnMove) {  	if (session != null)  		OnPreparingItemMove (session' item' 0' destStream);  	if (blockSize == 0) {  		// Beginning of data to copy. Remember source and destination   		// starting points.  		blockStart = item.Location.Offset;  		blockDiskStart = item.Location.DiskNumber;  		destStart = destStream.Position;  	}  	// Though this item has not moved yet' it will get  	// moved to a new location. The sizes do not change.  	item.Location.Offset = destStart + blockSize;  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' UpToDate section."' argumentException' destStorage' item);  	}  	blockSize += item.Location.TotalSize;  	if (session != null)  		OnItemMoved (session' item' destStream);  }  else {  	bool needsUpdate = (item.State == StorageItemState.NeedUpdate) || (item.State == StorageItemState.UpToDate && requiresUpdateOnMove);  	// If we haven't created the read stream yet and we're about to need it  	if (sourceStream == null && (needsUpdate || blockSize > 0)) {  		sourceStream = OnMoveItemsOpenSourceStream (session' out spannedSourceStream);  	}  	if (session != null) {  		long itemSize = blockSize;  		if (needsUpdate)  			itemSize += item.CurrentHeaderSize + item.CurrentFooterSize + item.Location.DataSize;  		OnPreparingItemMove (session' item' itemSize' destStream);  	}  	// We must manually update part of this area. But first' do we  	// have previous up-to-date items to copy?  	if (blockSize != 0) {  		if (blockDiskStart != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  		}  		// Avoid useless first seek  		if (blockStart != 0) {  			// We can always seek forward.  			sourceStream.Seek (blockStart' SeekOrigin.Begin);  		}  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  		blockSize = 0;  	}  	System.Diagnostics.Debug.Assert (item.State != StorageItemState.Unassigned);  	if (needsUpdate) {  		// Before changing our offset' we need to seek to our data.  		if (item.Location.DataSize > 0) {  			uint itemDiskNumber = item.Location.DiskNumber;  			if (itemDiskNumber != this.CurrentDiskNumber) {  				if (spannedSourceStream == null)  					throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  				spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  			}  			OnMoveItemsSeekToData (session' sourceStream' item);  		}  		if (spannedDestStream != null)  			item.Location.DiskNumber = spannedDestStream.DiskNumber;  		else  			item.Location.DiskNumber = destStorage.CurrentDiskNumber;  		// Remember current offset  		item.Location.Offset = destStream.Position;  		// Write Header  		item.Location.HeaderSize = item.WriteHeader (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.HeaderSize);  		// Move existing data if present' or write empty data if newly created.  		if (item.Location.DataSize > 0) {  			if (session == null) {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  			}  			else {  				StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  					OnMovingItem (session' bytesWritten);  				});  			}  		}  		else {  			item.Location.DataSize = item.WriteEmptyData (destStream);  		}  		// Write the footer.  		item.Location.FooterSize = item.WriteFooter (destStream);  		if (session != null)  			this.OnMovingItem (session' item.Location.FooterSize);  		item.Location.Storage = destStorage;  		try {  			destStorage.m_items.Add (item.Location' item);  		}  		catch (ArgumentException argumentException) {  			throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  		}  		if (session != null)  			OnItemMoved (session' item' destStream);  		// The item is responsible for updating its state.  		System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  	}  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (blockSize != 0) {  	if (blockDiskStart != this.CurrentDiskNumber) {  		if (spannedSourceStream == null)  			throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  		spannedSourceStream.ChangeDisk (blockDiskStart' DiskRequiredReason.Reading);  	}  	// Avoid useless first seek  	if (blockStart != 0) {  		// We can always seek forward.  		sourceStream.Seek (blockStart' SeekOrigin.Begin);  	}  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  	blockSize = 0;  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  }  else {  	StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024);  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' blockSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (needsUpdate) {  	// Before changing our offset' we need to seek to our data.  	if (item.Location.DataSize > 0) {  		uint itemDiskNumber = item.Location.DiskNumber;  		if (itemDiskNumber != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  		}  		OnMoveItemsSeekToData (session' sourceStream' item);  	}  	if (spannedDestStream != null)  		item.Location.DiskNumber = spannedDestStream.DiskNumber;  	else  		item.Location.DiskNumber = destStorage.CurrentDiskNumber;  	// Remember current offset  	item.Location.Offset = destStream.Position;  	// Write Header  	item.Location.HeaderSize = item.WriteHeader (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.HeaderSize);  	// Move existing data if present' or write empty data if newly created.  	if (item.Location.DataSize > 0) {  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  	}  	else {  		item.Location.DataSize = item.WriteEmptyData (destStream);  	}  	// Write the footer.  	item.Location.FooterSize = item.WriteFooter (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.FooterSize);  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  	}  	if (session != null)  		OnItemMoved (session' item' destStream);  	// The item is responsible for updating its state.  	System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (needsUpdate) {  	// Before changing our offset' we need to seek to our data.  	if (item.Location.DataSize > 0) {  		uint itemDiskNumber = item.Location.DiskNumber;  		if (itemDiskNumber != this.CurrentDiskNumber) {  			if (spannedSourceStream == null)  				throw new ArgumentException ("Source stream must contain a ISpannedStream somewhere in the stream stack.");  			spannedSourceStream.ChangeDisk (itemDiskNumber' DiskRequiredReason.MovingExistingItems);  		}  		OnMoveItemsSeekToData (session' sourceStream' item);  	}  	if (spannedDestStream != null)  		item.Location.DiskNumber = spannedDestStream.DiskNumber;  	else  		item.Location.DiskNumber = destStorage.CurrentDiskNumber;  	// Remember current offset  	item.Location.Offset = destStream.Position;  	// Write Header  	item.Location.HeaderSize = item.WriteHeader (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.HeaderSize);  	// Move existing data if present' or write empty data if newly created.  	if (item.Location.DataSize > 0) {  		if (session == null) {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  		}  		else {  			StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  				OnMovingItem (session' bytesWritten);  			});  		}  	}  	else {  		item.Location.DataSize = item.WriteEmptyData (destStream);  	}  	// Write the footer.  	item.Location.FooterSize = item.WriteFooter (destStream);  	if (session != null)  		this.OnMovingItem (session' item.Location.FooterSize);  	item.Location.Storage = destStorage;  	try {  		destStorage.m_items.Add (item.Location' item);  	}  	catch (ArgumentException argumentException) {  		throw this.BuildAddItemException ("Main loop' !UpToDate section."' argumentException' destStorage' item);  	}  	if (session != null)  		OnItemMoved (session' item' destStream);  	// The item is responsible for updating its state.  	System.Diagnostics.Debug.Assert (item.State == StorageItemState.UpToDate);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.Location.DataSize > 0) {  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  }  else {  	item.Location.DataSize = item.WriteEmptyData (destStream);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (item.Location.DataSize > 0) {  	if (session == null) {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  	}  	else {  		StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  			OnMovingItem (session' bytesWritten);  		});  	}  }  else {  	item.Location.DataSize = item.WriteEmptyData (destStream);  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  }  else {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: if (session == null) {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize);  }  else {  	StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  		OnMovingItem (session' bytesWritten);  	});  }  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,Storage,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\Storage.cs,MoveItems,The following statement contains a magic number: StreamCopy.Copy (sourceStream' destStream' item.Location.DataSize' 64 * 1024' delegate (long bytesWritten) {  	OnMovingItem (session' bytesWritten);  });  
Magic Number,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageItemHandler.cs,GetNextUniqueFullName,The following statement contains a magic number: if (m_duplicateIndex == 0) {  	string fullName = this.FullName;  	string name = this.Name;  	// First time we get called. We must determine the fixed path  	// and dynamic name pattern.  	int lastSeparator = fullName.LastIndexOf (Path.DirectorySeparatorChar);  	System.Diagnostics.Debug.Assert (lastSeparator != -1' "The FullName must at least be rooted.");  	m_duplicatePath = fullName.Substring (0' lastSeparator + 1);  	string _filename' _extension;  	#if USE_XCEED_UTILS_PATHS  	_filename = Xceed.Utils.Paths.Path.GetFileNameWithoutExtensionSimple (name);  	_extension = Xceed.Utils.Paths.Path.GetExtensionSimple (name);  	#else  	        _filename = Path.GetFileNameWithoutExtension( name );         _extension = Path.GetExtension( name );         #endif  	m_duplicateName = _filename;  	m_duplicateExtension = "{{{0}}}" + _extension;  	// This pair may exceed the limit' but it will get handled below.  	m_duplicateIndex = 2;  }  
Magic Number,Xceed.Utils.Storage,StorageItemHandler,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Storage\StorageItemHandler.cs,GetNextUniqueFullName,The following statement contains a magic number: m_duplicateIndex = 2;  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: while (--count >= 0) {  	previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,UniqueCrc32,The following statement contains a magic number: return (uint)(crcTable [(crc ^ input) & 0xff] ^ (crc >> 8));  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: k -= 16;  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,The following statement contains a magic number: if (m_innerStream.CanRead) {  	byte[] buffer = new byte[(skip < 32768 ? skip : 32768)];  	while (skip != 0) {  		// We call our public implementation so it updates our position.  		int read = this.Read (buffer' 0' unchecked((int)(skip < buffer.Length ? skip : buffer.Length)));  		// Have we reached the end of the stream? It's accepted to seek behond  		// the end of the stream.  		if (read == 0)  			break;  		skip -= read;  	}  }  else if (skip != 0) {  	throw new NotSupportedException ("Cannot seek a non-seekable write-only stream.");  }  
Magic Number,Xceed.Utils.Streams,ForwardSeekableStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ForwardSeekableStream.cs,Seek,The following statement contains a magic number: if (m_innerStream.CanRead) {  	byte[] buffer = new byte[(skip < 32768 ? skip : 32768)];  	while (skip != 0) {  		// We call our public implementation so it updates our position.  		int read = this.Read (buffer' 0' unchecked((int)(skip < buffer.Length ? skip : buffer.Length)));  		// Have we reached the end of the stream? It's accepted to seek behond  		// the end of the stream.  		if (read == 0)  			break;  		skip -= read;  	}  }  else if (skip != 0) {  	throw new NotSupportedException ("Cannot seek a non-seekable write-only stream.");  }  
Magic Number,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The following statement contains a magic number: return StreamCopy.Copy (source' dest' size' 8192' null);  
Magic Number,Xceed.Utils.Streams,StreamCopy,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\StreamCopy.cs,Copy,The following statement contains a magic number: return StreamCopy.Copy (source' dest' size' 8192' onBytesWritten);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,ReadHeader,The following statement contains a magic number: if (m_zcrypt.Header [HeaderLength - 1] != ((m_zcrypt.UserSeed >> 8) & 0xff))  	throw new ZCryptException ("Invalid decryption Password");  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: unchecked {  	ushort temp = (ushort)(m_zcrypt.Keys [2] | 2);  	return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: unchecked {  	ushort temp = (ushort)(m_zcrypt.Keys [2] | 2);  	return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: unchecked {  	ushort temp = (ushort)(m_zcrypt.Keys [2] | 2);  	return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [HeaderLength - 2] = (byte)(m_zcrypt.UserSeed & 0xff);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [HeaderLength - 1] = (byte)((m_zcrypt.UserSeed >> 8) & 0xff);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,InitializeKeys,The following statement contains a magic number: m_zcrypt.Keys = new uint[3];  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,InitializeKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = 878082192U;  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,InitializeKeys,The following statement contains a magic number: if (m_zcryptFast [m_zcrypt.Keys [1] % 16] == 0)  	throw new ZCryptException ("Cannot initialize random encryption header");  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: unchecked {  	m_zcrypt.Keys [0] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [0]' b);  	m_zcrypt.Keys [1] += m_zcrypt.Keys [0] & 0xff;  	m_zcrypt.Keys [1] = m_zcrypt.Keys [1] * 134775813U + 1;  	m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: unchecked {  	m_zcrypt.Keys [0] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [0]' b);  	m_zcrypt.Keys [1] += m_zcrypt.Keys [0] & 0xff;  	m_zcrypt.Keys [1] = m_zcrypt.Keys [1] * 134775813U + 1;  	m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: unchecked {  	m_zcrypt.Keys [0] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [0]' b);  	m_zcrypt.Keys [1] += m_zcrypt.Keys [0] & 0xff;  	m_zcrypt.Keys [1] = m_zcrypt.Keys [1] * 134775813U + 1;  	m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (m_icon != null) {  	tempModule = m_sourceModule;  	m_sourceModule = new MemoryFile ();  	tempModule.CopyTo (m_sourceModule' true);  	// Get the new icon data  	MemoryStream memIcon = new MemoryStream ();  	try {  		m_icon.Save (memIcon);  	}  	finally {  		memIcon.Close ();  	}  	byte[] fullIcon = memIcon.ToArray ();  	if (fullIcon.Length == 766) {  		// Tweak icon header  		fullIcon [42] = 0x80;  		// Looking for 24 bytes starting at index 22  		byte[] signature = new byte[24];  		Array.Copy (fullIcon' 22' signature' 0' signature.Length);  		// Find position of SFX icon. We must do this in two operations'  		// since we can't open for both reading and writing.  		long position = -1;  		using (Stream read = m_sourceModule.OpenRead ()) {  			StreamSearcher searcher = new StreamSearcher (read);  			if (searcher.Find (signature)) {  				position = read.Position;  			}  		}  		if (position != -1) {  			using (Stream write = m_sourceModule.OpenWrite (false)) {  				write.Seek (position' SeekOrigin.Begin);  				write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  			}  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (m_icon != null) {  	tempModule = m_sourceModule;  	m_sourceModule = new MemoryFile ();  	tempModule.CopyTo (m_sourceModule' true);  	// Get the new icon data  	MemoryStream memIcon = new MemoryStream ();  	try {  		m_icon.Save (memIcon);  	}  	finally {  		memIcon.Close ();  	}  	byte[] fullIcon = memIcon.ToArray ();  	if (fullIcon.Length == 766) {  		// Tweak icon header  		fullIcon [42] = 0x80;  		// Looking for 24 bytes starting at index 22  		byte[] signature = new byte[24];  		Array.Copy (fullIcon' 22' signature' 0' signature.Length);  		// Find position of SFX icon. We must do this in two operations'  		// since we can't open for both reading and writing.  		long position = -1;  		using (Stream read = m_sourceModule.OpenRead ()) {  			StreamSearcher searcher = new StreamSearcher (read);  			if (searcher.Find (signature)) {  				position = read.Position;  			}  		}  		if (position != -1) {  			using (Stream write = m_sourceModule.OpenWrite (false)) {  				write.Seek (position' SeekOrigin.Begin);  				write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  			}  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (m_icon != null) {  	tempModule = m_sourceModule;  	m_sourceModule = new MemoryFile ();  	tempModule.CopyTo (m_sourceModule' true);  	// Get the new icon data  	MemoryStream memIcon = new MemoryStream ();  	try {  		m_icon.Save (memIcon);  	}  	finally {  		memIcon.Close ();  	}  	byte[] fullIcon = memIcon.ToArray ();  	if (fullIcon.Length == 766) {  		// Tweak icon header  		fullIcon [42] = 0x80;  		// Looking for 24 bytes starting at index 22  		byte[] signature = new byte[24];  		Array.Copy (fullIcon' 22' signature' 0' signature.Length);  		// Find position of SFX icon. We must do this in two operations'  		// since we can't open for both reading and writing.  		long position = -1;  		using (Stream read = m_sourceModule.OpenRead ()) {  			StreamSearcher searcher = new StreamSearcher (read);  			if (searcher.Find (signature)) {  				position = read.Position;  			}  		}  		if (position != -1) {  			using (Stream write = m_sourceModule.OpenWrite (false)) {  				write.Seek (position' SeekOrigin.Begin);  				write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  			}  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (m_icon != null) {  	tempModule = m_sourceModule;  	m_sourceModule = new MemoryFile ();  	tempModule.CopyTo (m_sourceModule' true);  	// Get the new icon data  	MemoryStream memIcon = new MemoryStream ();  	try {  		m_icon.Save (memIcon);  	}  	finally {  		memIcon.Close ();  	}  	byte[] fullIcon = memIcon.ToArray ();  	if (fullIcon.Length == 766) {  		// Tweak icon header  		fullIcon [42] = 0x80;  		// Looking for 24 bytes starting at index 22  		byte[] signature = new byte[24];  		Array.Copy (fullIcon' 22' signature' 0' signature.Length);  		// Find position of SFX icon. We must do this in two operations'  		// since we can't open for both reading and writing.  		long position = -1;  		using (Stream read = m_sourceModule.OpenRead ()) {  			StreamSearcher searcher = new StreamSearcher (read);  			if (searcher.Find (signature)) {  				position = read.Position;  			}  		}  		if (position != -1) {  			using (Stream write = m_sourceModule.OpenWrite (false)) {  				write.Seek (position' SeekOrigin.Begin);  				write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  			}  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (m_icon != null) {  	tempModule = m_sourceModule;  	m_sourceModule = new MemoryFile ();  	tempModule.CopyTo (m_sourceModule' true);  	// Get the new icon data  	MemoryStream memIcon = new MemoryStream ();  	try {  		m_icon.Save (memIcon);  	}  	finally {  		memIcon.Close ();  	}  	byte[] fullIcon = memIcon.ToArray ();  	if (fullIcon.Length == 766) {  		// Tweak icon header  		fullIcon [42] = 0x80;  		// Looking for 24 bytes starting at index 22  		byte[] signature = new byte[24];  		Array.Copy (fullIcon' 22' signature' 0' signature.Length);  		// Find position of SFX icon. We must do this in two operations'  		// since we can't open for both reading and writing.  		long position = -1;  		using (Stream read = m_sourceModule.OpenRead ()) {  			StreamSearcher searcher = new StreamSearcher (read);  			if (searcher.Find (signature)) {  				position = read.Position;  			}  		}  		if (position != -1) {  			using (Stream write = m_sourceModule.OpenWrite (false)) {  				write.Seek (position' SeekOrigin.Begin);  				write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  			}  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (m_icon != null) {  	tempModule = m_sourceModule;  	m_sourceModule = new MemoryFile ();  	tempModule.CopyTo (m_sourceModule' true);  	// Get the new icon data  	MemoryStream memIcon = new MemoryStream ();  	try {  		m_icon.Save (memIcon);  	}  	finally {  		memIcon.Close ();  	}  	byte[] fullIcon = memIcon.ToArray ();  	if (fullIcon.Length == 766) {  		// Tweak icon header  		fullIcon [42] = 0x80;  		// Looking for 24 bytes starting at index 22  		byte[] signature = new byte[24];  		Array.Copy (fullIcon' 22' signature' 0' signature.Length);  		// Find position of SFX icon. We must do this in two operations'  		// since we can't open for both reading and writing.  		long position = -1;  		using (Stream read = m_sourceModule.OpenRead ()) {  			StreamSearcher searcher = new StreamSearcher (read);  			if (searcher.Find (signature)) {  				position = read.Position;  			}  		}  		if (position != -1) {  			using (Stream write = m_sourceModule.OpenWrite (false)) {  				write.Seek (position' SeekOrigin.Begin);  				write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  			}  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (fullIcon.Length == 766) {  	// Tweak icon header  	fullIcon [42] = 0x80;  	// Looking for 24 bytes starting at index 22  	byte[] signature = new byte[24];  	Array.Copy (fullIcon' 22' signature' 0' signature.Length);  	// Find position of SFX icon. We must do this in two operations'  	// since we can't open for both reading and writing.  	long position = -1;  	using (Stream read = m_sourceModule.OpenRead ()) {  		StreamSearcher searcher = new StreamSearcher (read);  		if (searcher.Find (signature)) {  			position = read.Position;  		}  	}  	if (position != -1) {  		using (Stream write = m_sourceModule.OpenWrite (false)) {  			write.Seek (position' SeekOrigin.Begin);  			write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (fullIcon.Length == 766) {  	// Tweak icon header  	fullIcon [42] = 0x80;  	// Looking for 24 bytes starting at index 22  	byte[] signature = new byte[24];  	Array.Copy (fullIcon' 22' signature' 0' signature.Length);  	// Find position of SFX icon. We must do this in two operations'  	// since we can't open for both reading and writing.  	long position = -1;  	using (Stream read = m_sourceModule.OpenRead ()) {  		StreamSearcher searcher = new StreamSearcher (read);  		if (searcher.Find (signature)) {  			position = read.Position;  		}  	}  	if (position != -1) {  		using (Stream write = m_sourceModule.OpenWrite (false)) {  			write.Seek (position' SeekOrigin.Begin);  			write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (fullIcon.Length == 766) {  	// Tweak icon header  	fullIcon [42] = 0x80;  	// Looking for 24 bytes starting at index 22  	byte[] signature = new byte[24];  	Array.Copy (fullIcon' 22' signature' 0' signature.Length);  	// Find position of SFX icon. We must do this in two operations'  	// since we can't open for both reading and writing.  	long position = -1;  	using (Stream read = m_sourceModule.OpenRead ()) {  		StreamSearcher searcher = new StreamSearcher (read);  		if (searcher.Find (signature)) {  			position = read.Position;  		}  	}  	if (position != -1) {  		using (Stream write = m_sourceModule.OpenWrite (false)) {  			write.Seek (position' SeekOrigin.Begin);  			write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (fullIcon.Length == 766) {  	// Tweak icon header  	fullIcon [42] = 0x80;  	// Looking for 24 bytes starting at index 22  	byte[] signature = new byte[24];  	Array.Copy (fullIcon' 22' signature' 0' signature.Length);  	// Find position of SFX icon. We must do this in two operations'  	// since we can't open for both reading and writing.  	long position = -1;  	using (Stream read = m_sourceModule.OpenRead ()) {  		StreamSearcher searcher = new StreamSearcher (read);  		if (searcher.Find (signature)) {  			position = read.Position;  		}  	}  	if (position != -1) {  		using (Stream write = m_sourceModule.OpenWrite (false)) {  			write.Seek (position' SeekOrigin.Begin);  			write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (fullIcon.Length == 766) {  	// Tweak icon header  	fullIcon [42] = 0x80;  	// Looking for 24 bytes starting at index 22  	byte[] signature = new byte[24];  	Array.Copy (fullIcon' 22' signature' 0' signature.Length);  	// Find position of SFX icon. We must do this in two operations'  	// since we can't open for both reading and writing.  	long position = -1;  	using (Stream read = m_sourceModule.OpenRead ()) {  		StreamSearcher searcher = new StreamSearcher (read);  		if (searcher.Find (signature)) {  			position = read.Position;  		}  	}  	if (position != -1) {  		using (Stream write = m_sourceModule.OpenWrite (false)) {  			write.Seek (position' SeekOrigin.Begin);  			write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (fullIcon.Length == 766) {  	// Tweak icon header  	fullIcon [42] = 0x80;  	// Looking for 24 bytes starting at index 22  	byte[] signature = new byte[24];  	Array.Copy (fullIcon' 22' signature' 0' signature.Length);  	// Find position of SFX icon. We must do this in two operations'  	// since we can't open for both reading and writing.  	long position = -1;  	using (Stream read = m_sourceModule.OpenRead ()) {  		StreamSearcher searcher = new StreamSearcher (read);  		if (searcher.Find (signature)) {  			position = read.Position;  		}  	}  	if (position != -1) {  		using (Stream write = m_sourceModule.OpenWrite (false)) {  			write.Seek (position' SeekOrigin.Begin);  			write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: fullIcon [42] = 0x80;  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: Array.Copy (fullIcon' 22' signature' 0' signature.Length);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (position != -1) {  	using (Stream write = m_sourceModule.OpenWrite (false)) {  		write.Seek (position' SeekOrigin.Begin);  		write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: if (position != -1) {  	using (Stream write = m_sourceModule.OpenWrite (false)) {  		write.Seek (position' SeekOrigin.Begin);  		write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: using (Stream write = m_sourceModule.OpenWrite (false)) {  	write.Seek (position' SeekOrigin.Begin);  	write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: using (Stream write = m_sourceModule.OpenWrite (false)) {  	write.Seek (position' SeekOrigin.Begin);  	write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteSfxPrefix,The following statement contains a magic number: write.Write (fullIcon' 22 + signature.Length' fullIcon.Length - 22 - signature.Length);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,GetXceedSfxVersion,The following statement contains a magic number: while (read < 4) {  	int oneRead = prefix.Read (version' read' version.Length - read);  	if (oneRead == 0)  		throw new EndOfStreamException ("Premature end of stream reached.");  	read += oneRead;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,GetXceedSfxVersion,The following statement contains a magic number: return ((int)version [3]) + (((int)version [2]) << 8) + (((int)version [1]) << 16) + (((int)version [0]) << 24);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,GetXceedSfxVersion,The following statement contains a magic number: return ((int)version [3]) + (((int)version [2]) << 8) + (((int)version [1]) << 16) + (((int)version [0]) << 24);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,GetXceedSfxVersion,The following statement contains a magic number: return ((int)version [3]) + (((int)version [2]) << 8) + (((int)version [1]) << 16) + (((int)version [0]) << 24);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,GetXceedSfxVersion,The following statement contains a magic number: return ((int)version [3]) + (((int)version [2]) << 8) + (((int)version [1]) << 16) + (((int)version [0]) << 24);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,GetXceedSfxVersion,The following statement contains a magic number: return ((int)version [3]) + (((int)version [2]) << 8) + (((int)version [1]) << 16) + (((int)version [0]) << 24);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	bool readUnicodeString;  	ReadConfigSignature (reader' out readUnicodeString);  	// If we are to read unicode strings' make sure we'll write them back as unicode  	// strings as well  	m_writeUnicodeStrings = readUnicodeString;  	// We use a very simple XOR encoding  	ushort encodingKey = 0x3C96;  	// Some properties are ignored when reading' and the contents of the matching  	// dialog message dictates their respective value.  	// Display directory prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display progress dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display password prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display folder creation prompt?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display success dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display failure creating folder dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Display introduction dialog?  	ReadEncodedBoolean (reader' ref encodingKey);  	// Read button captions (Buttons.Ok to Buttons.Exit)  	for (int index = (int)Buttons.Ok; index <= (int)Buttons.Exit; index++) {  		// Buttons can't have variables  		m_buttonCaptions [(Buttons)index] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	}  	// The default encryption string is read' but discarded. Wouldn't be nice  	// to tell everybody what it is!  	ReadEncodedString (reader' XceedSfxPrefix.MaximumPasswordSize' readUnicodeString' ref encodingKey);  	// Values match those of the ExistingFileBehavior enumeration  	ushort overwrite = ReadEncodedWord (reader' ref encodingKey);  	if (overwrite < 0 || overwrite > 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_existingFileBehavior = (ExistingFileBehavior)overwrite;  	string beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	m_defaultDestinationFolder = ReplaceOldVariables (beforeReplace' false);  	// If a file is present in the ReadMe field' we set it as the first file to execute  	m_executeAfter.Clear ();  	m_filesToCopy.Clear ();  	m_dllsToRegister.Clear ();  	m_registryKeys.Clear ();  	// This reads the readme field  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumFileNameSize' readUnicodeString' ref encodingKey);  	if (beforeReplace.Length > 0) {  		m_executeAfter.Add (ReplaceOldVariables (beforeReplace' false));  	}  	// This reads the execute after field' holding ExecuteAfter' FilesToCopy'   	// DllsToRegister and RegistryKeys.  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	StringList lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		if (line.Length > 0) {  			bool addToExecute = true;  			if (line [0] == '#' && line.Length > 1) {  				string realLine = line.Substring (2' line.Length - 2);  				if (realLine != null && realLine.Length > 0) {  					switch (line [1]) {  					case 'c':  					case 'C':  						// Copy file  						string[] parts = realLine.Split ('|');  						if (parts.Length != 2)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						m_filesToCopy.Add (parts [0]' parts [1]);  						addToExecute = false;  						break;  					case 'r':  					case 'R':  						// Register dll  						m_dllsToRegister.Add (realLine);  						addToExecute = false;  						break;  					case 'k':  					case 'K':  						parts = realLine.Split ('|');  						object value = null;  						if (parts.Length != 3)  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  							if (!parts [2].EndsWith ("\""))  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							value = parts [2].Substring (1' parts [2].Length - 2);  						}  						else {  							try {  								value = int.Parse (parts [2]);  							}  							catch {  								throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  							}  						}  						m_registryKeys.Add (parts [0]' parts [1]' value);  						addToExecute = false;  						break;  					}  				}  			}  			if (addToExecute) {  				m_executeAfter.Add (line);  			}  		}  	}  	// Messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.DestinationFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Password] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertLastDisk] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.InsertDisk] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.AbortUnzip] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.CreateFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Overwrite] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Progress] = ReplaceOldVariables (beforeReplace' false);  	// Strings  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.ProgressBar] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.Title] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	m_dialogStrings [Sfx.DialogStrings.CurrentFolder] = ReplaceOldVariables (beforeReplace' false);  	// We discard both "Network" and "ShareName"  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	ReadEncodedString (reader' XceedSfxPrefix.MaximumStringSize' readUnicodeString' ref encodingKey);  	// Trial title   	m_trialTitle = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	// Other messages  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Success] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Error] = ReplaceOldVariables (beforeReplace' true);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.ErrorCreatingFolder] = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.Introduction] = ReplaceOldVariables (beforeReplace' false);  	// Trial message  	m_trialMessage = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	// Extension registration and program group to create  	m_programGroup.Items.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumTitleSize' readUnicodeString' ref encodingKey);  	m_programGroup.Title = ReplaceOldVariables (beforeReplace' false);  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_programGroup.Items.Add (elements [1]' elements [0]);  	}  	m_extensionsToAssociate.Clear ();  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumMessageSize' readUnicodeString' ref encodingKey);  	lines = new StringList (ReplaceOldVariables (beforeReplace' false));  	foreach (string line in lines) {  		string[] elements = line.Split ('|');  		if (elements == null || elements.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  	}  	// Delete unzipped files after execution? (install mode)  	m_deleteUnzippedFiles = ReadEncodedBoolean (reader' ref encodingKey);  	// License message (skip the boolean)  	beforeReplace = ReadEncodedString (reader' XceedSfxPrefix.MaximumLicenseSize' readUnicodeString' ref encodingKey);  	m_dialogMessages [Sfx.DialogMessages.License] = ReplaceOldVariables (beforeReplace' false);  	ReadEncodedBoolean (reader' ref encodingKey);  	// New buttons since v1.2  	m_buttonCaptions [Sfx.Buttons.Agree] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	m_buttonCaptions [Sfx.Buttons.Refuse] = ReadEncodedString (reader' XceedSfxPrefix.MaximumCaptionSize' readUnicodeString' ref encodingKey);  	// We skip the machine code  	ReadEncodedWord (reader' ref encodingKey);  	// Key low  	ReadEncodedWord (reader' ref encodingKey);  	// Key high  	ReadEncodedWord (reader' ref encodingKey);  	// Serial low  	ReadEncodedWord (reader' ref encodingKey);  	// Serial high  	// We skip the about box flag  	ReadEncodedBoolean (reader' ref encodingKey);  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (overwrite < 0 || overwrite > 3)  	throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0) {  		bool addToExecute = true;  		if (line [0] == '#' && line.Length > 1) {  			string realLine = line.Substring (2' line.Length - 2);  			if (realLine != null && realLine.Length > 0) {  				switch (line [1]) {  				case 'c':  				case 'C':  					// Copy file  					string[] parts = realLine.Split ('|');  					if (parts.Length != 2)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					m_filesToCopy.Add (parts [0]' parts [1]);  					addToExecute = false;  					break;  				case 'r':  				case 'R':  					// Register dll  					m_dllsToRegister.Add (realLine);  					addToExecute = false;  					break;  				case 'k':  				case 'K':  					parts = realLine.Split ('|');  					object value = null;  					if (parts.Length != 3)  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  						if (!parts [2].EndsWith ("\""))  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						value = parts [2].Substring (1' parts [2].Length - 2);  					}  					else {  						try {  							value = int.Parse (parts [2]);  						}  						catch {  							throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  						}  					}  					m_registryKeys.Add (parts [0]' parts [1]' value);  					addToExecute = false;  					break;  				}  			}  		}  		if (addToExecute) {  			m_executeAfter.Add (line);  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line.Length > 0) {  	bool addToExecute = true;  	if (line [0] == '#' && line.Length > 1) {  		string realLine = line.Substring (2' line.Length - 2);  		if (realLine != null && realLine.Length > 0) {  			switch (line [1]) {  			case 'c':  			case 'C':  				// Copy file  				string[] parts = realLine.Split ('|');  				if (parts.Length != 2)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				m_filesToCopy.Add (parts [0]' parts [1]);  				addToExecute = false;  				break;  			case 'r':  			case 'R':  				// Register dll  				m_dllsToRegister.Add (realLine);  				addToExecute = false;  				break;  			case 'k':  			case 'K':  				parts = realLine.Split ('|');  				object value = null;  				if (parts.Length != 3)  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  					if (!parts [2].EndsWith ("\""))  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					value = parts [2].Substring (1' parts [2].Length - 2);  				}  				else {  					try {  						value = int.Parse (parts [2]);  					}  					catch {  						throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  					}  				}  				m_registryKeys.Add (parts [0]' parts [1]' value);  				addToExecute = false;  				break;  			}  		}  	}  	if (addToExecute) {  		m_executeAfter.Add (line);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (line [0] == '#' && line.Length > 1) {  	string realLine = line.Substring (2' line.Length - 2);  	if (realLine != null && realLine.Length > 0) {  		switch (line [1]) {  		case 'c':  		case 'C':  			// Copy file  			string[] parts = realLine.Split ('|');  			if (parts.Length != 2)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			m_filesToCopy.Add (parts [0]' parts [1]);  			addToExecute = false;  			break;  		case 'r':  		case 'R':  			// Register dll  			m_dllsToRegister.Add (realLine);  			addToExecute = false;  			break;  		case 'k':  		case 'K':  			parts = realLine.Split ('|');  			object value = null;  			if (parts.Length != 3)  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  				if (!parts [2].EndsWith ("\""))  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				value = parts [2].Substring (1' parts [2].Length - 2);  			}  			else {  				try {  					value = int.Parse (parts [2]);  				}  				catch {  					throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  				}  			}  			m_registryKeys.Add (parts [0]' parts [1]' value);  			addToExecute = false;  			break;  		}  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (realLine != null && realLine.Length > 0) {  	switch (line [1]) {  	case 'c':  	case 'C':  		// Copy file  		string[] parts = realLine.Split ('|');  		if (parts.Length != 2)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		m_filesToCopy.Add (parts [0]' parts [1]);  		addToExecute = false;  		break;  	case 'r':  	case 'R':  		// Register dll  		m_dllsToRegister.Add (realLine);  		addToExecute = false;  		break;  	case 'k':  	case 'K':  		parts = realLine.Split ('|');  		object value = null;  		if (parts.Length != 3)  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  			if (!parts [2].EndsWith ("\""))  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			value = parts [2].Substring (1' parts [2].Length - 2);  		}  		else {  			try {  				value = int.Parse (parts [2]);  			}  			catch {  				throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  			}  		}  		m_registryKeys.Add (parts [0]' parts [1]' value);  		addToExecute = false;  		break;  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (parts.Length != 2)  	throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (parts.Length != 3)  	throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  	if (!parts [2].EndsWith ("\""))  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	value = parts [2].Substring (1' parts [2].Length - 2);  }  else {  	try {  		value = int.Parse (parts [2]);  	}  	catch {  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  	if (!parts [2].EndsWith ("\""))  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	value = parts [2].Substring (1' parts [2].Length - 2);  }  else {  	try {  		value = int.Parse (parts [2]);  	}  	catch {  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  	if (!parts [2].EndsWith ("\""))  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	value = parts [2].Substring (1' parts [2].Length - 2);  }  else {  	try {  		value = int.Parse (parts [2]);  	}  	catch {  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  	if (!parts [2].EndsWith ("\""))  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	value = parts [2].Substring (1' parts [2].Length - 2);  }  else {  	try {  		value = int.Parse (parts [2]);  	}  	catch {  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  	if (!parts [2].EndsWith ("\""))  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	value = parts [2].Substring (1' parts [2].Length - 2);  }  else {  	try {  		value = int.Parse (parts [2]);  	}  	catch {  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  	if (!parts [2].EndsWith ("\""))  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	value = parts [2].Substring (1' parts [2].Length - 2);  }  else {  	try {  		value = int.Parse (parts [2]);  	}  	catch {  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  	if (!parts [2].EndsWith ("\""))  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	value = parts [2].Substring (1' parts [2].Length - 2);  }  else {  	try {  		value = int.Parse (parts [2]);  	}  	catch {  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	}  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (!parts [2].EndsWith ("\""))  	throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: value = parts [2].Substring (1' parts [2].Length - 2);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: value = parts [2].Substring (1' parts [2].Length - 2);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: value = parts [2].Substring (1' parts [2].Length - 2);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: try {  	value = int.Parse (parts [2]);  }  catch {  	throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: value = int.Parse (parts [2]);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	string[] elements = line.Split ('|');  	if (elements == null || elements.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_programGroup.Items.Add (elements [1]' elements [0]);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (elements == null || elements.Length != 2)  	throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	string[] elements = line.Split ('|');  	if (elements == null || elements.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: foreach (string line in lines) {  	string[] elements = line.Split ('|');  	if (elements == null || elements.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: if (elements == null || elements.Length != 3)  	throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following statement contains a magic number: m_extensionsToAssociate.Add (elements [0]' elements [1]' elements [2]);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: length = ShiftAndEncode (length' 11' key);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: for (int index = 0; index < toRead; index += 2) {  	ushort value = reader.ReadUInt16 ();  	value = ShiftAndEncode (value' 9' key);  	buffer [index] = (byte)(value & 0xff);  	buffer [index + 1] = (byte)(value >> 8);  	key = ShiftAndEncode (key' 2' 0);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: for (int index = 0; index < toRead; index += 2) {  	ushort value = reader.ReadUInt16 ();  	value = ShiftAndEncode (value' 9' key);  	buffer [index] = (byte)(value & 0xff);  	buffer [index + 1] = (byte)(value >> 8);  	key = ShiftAndEncode (key' 2' 0);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: for (int index = 0; index < toRead; index += 2) {  	ushort value = reader.ReadUInt16 ();  	value = ShiftAndEncode (value' 9' key);  	buffer [index] = (byte)(value & 0xff);  	buffer [index + 1] = (byte)(value >> 8);  	key = ShiftAndEncode (key' 2' 0);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: for (int index = 0; index < toRead; index += 2) {  	ushort value = reader.ReadUInt16 ();  	value = ShiftAndEncode (value' 9' key);  	buffer [index] = (byte)(value & 0xff);  	buffer [index + 1] = (byte)(value >> 8);  	key = ShiftAndEncode (key' 2' 0);  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: index += 2
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: value = ShiftAndEncode (value' 9' key);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: buffer [index + 1] = (byte)(value >> 8);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedString,The following statement contains a magic number: key = ShiftAndEncode (key' 2' 0);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: writer.Write (EncodeAndShift (length' 5' key));  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: while (written < length) {  	ushort twoChars = (ushort)buffer [written];  	if (written + 1 < length)  		twoChars |= (ushort)(buffer [written + 1] << 8);  	writer.Write (EncodeAndShift (twoChars' 7' key));  	key = ShiftAndEncode (key' 2' 0);  	written += 2;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: while (written < length) {  	ushort twoChars = (ushort)buffer [written];  	if (written + 1 < length)  		twoChars |= (ushort)(buffer [written + 1] << 8);  	writer.Write (EncodeAndShift (twoChars' 7' key));  	key = ShiftAndEncode (key' 2' 0);  	written += 2;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: while (written < length) {  	ushort twoChars = (ushort)buffer [written];  	if (written + 1 < length)  		twoChars |= (ushort)(buffer [written + 1] << 8);  	writer.Write (EncodeAndShift (twoChars' 7' key));  	key = ShiftAndEncode (key' 2' 0);  	written += 2;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: while (written < length) {  	ushort twoChars = (ushort)buffer [written];  	if (written + 1 < length)  		twoChars |= (ushort)(buffer [written + 1] << 8);  	writer.Write (EncodeAndShift (twoChars' 7' key));  	key = ShiftAndEncode (key' 2' 0);  	written += 2;  }  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: if (written + 1 < length)  	twoChars |= (ushort)(buffer [written + 1] << 8);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: twoChars |= (ushort)(buffer [written + 1] << 8);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: writer.Write (EncodeAndShift (twoChars' 7' key));  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: key = ShiftAndEncode (key' 2' 0);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedString,The following statement contains a magic number: written += 2;  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedWord,The following statement contains a magic number: value = ShiftAndEncode (value' 11' key);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadEncodedWord,The following statement contains a magic number: key = ShiftAndEncode (key' 3' 0);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedWord,The following statement contains a magic number: writer.Write (EncodeAndShift (value' 5' key));  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,WriteEncodedWord,The following statement contains a magic number: key = ShiftAndEncode (key' 3' 0);  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ShiftAndEncode,The following statement contains a magic number: newValue = ((newValue << leftShift) | (newValue >> (16 - leftShift))) & 0xffff;  
Magic Number,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,EncodeAndShift,The following statement contains a magic number: newValue = ((newValue << leftShift) | (newValue >> (16 - leftShift))) & 0xffff;  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: if (dateTime.Year < 1980) {  	dosDate = DosDateMinValue;  	dosTime = DosTimeMinValue;  }  else {  	dosDate = 0;  	dosTime = 0;  	dosDate |= (ushort)((dateTime.Year - 1980) << 9);  	dosDate |= (ushort)(dateTime.Month << 5);  	dosDate |= (ushort)(dateTime.Day);  	dosTime |= (ushort)(dateTime.Hour << 11);  	dosTime |= (ushort)(dateTime.Minute << 5);  	dosTime |= (ushort)(dateTime.Second / 2);  }  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)((dateTime.Year - 1980) << 9);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)((dateTime.Year - 1980) << 9);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosDate |= (ushort)(dateTime.Month << 5);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Hour << 11);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Minute << 5);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToDosDateTime,The following statement contains a magic number: dosTime |= (ushort)(dateTime.Second / 2);  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToUnixDateTime,The following statement contains a magic number: fileTime /= 10000000;  
Magic Number,Xceed.Utils.Dates,Dates,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Dates\Dates.cs,ToUnixDateTime,The following statement contains a magic number: System.Diagnostics.Debug.Assert ((fileTime >> 32) == 0' "This date is bigger than what can handle a time_t");  
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 43)' (17' 45))
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Missing Default,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\CombinedStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin:  	this.Position = offset;  	break;  case SeekOrigin.End:  	this.Position = this.Length + offset;  	break;  case SeekOrigin.Current:  	this.Position += offset;  	break;  }  
Missing Default,Xceed.Utils.Streams,WindowStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Utils\Streams\WindowStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin: {  	beginOffset = offset;  	offset += m_beginOffset;  	break;  }  case SeekOrigin.Current: {  	beginOffset = (m_innerStream.Position - m_beginOffset) + offset;  	break;  }  case SeekOrigin.End: {  	if (m_length != -1) {  		beginOffset = m_length + offset;  		offset -= (m_innerStream.Length - m_beginOffset - m_length);  	}  	else  		beginOffset = m_innerStream.Length + offset;  	break;  }  }  
Missing Default,Xceed.Zip.Sfx,XceedSfxPrefix,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Zip.Blueprint\Sfx\XceedSfxPrefix.cs,ReadConfiguration,The following switch statement is missing a default case: switch (line [1]) {  case 'c':  case 'C':  	// Copy file  	string[] parts = realLine.Split ('|');  	if (parts.Length != 2)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	m_filesToCopy.Add (parts [0]' parts [1]);  	addToExecute = false;  	break;  case 'r':  case 'R':  	// Register dll  	m_dllsToRegister.Add (realLine);  	addToExecute = false;  	break;  case 'k':  case 'K':  	parts = realLine.Split ('|');  	object value = null;  	if (parts.Length != 3)  		throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  	if ((parts [2].Length == 0) || (parts [2].StartsWith ("\""))) {  		if (!parts [2].EndsWith ("\""))  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		value = parts [2].Substring (1' parts [2].Length - 2);  	}  	else {  		try {  			value = int.Parse (parts [2]);  		}  		catch {  			throw new InvalidSfxModuleException (XceedSfxPrefix.InvalidSfxConfigMessage);  		}  	}  	m_registryKeys.Add (parts [0]' parts [1]' value);  	addToExecute = false;  	break;  }  
