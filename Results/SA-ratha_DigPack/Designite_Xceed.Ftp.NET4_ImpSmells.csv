Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,The method has 102 lines of code.
Long Method,Xceed.Ftp,HttpProxyClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Proxy)\HttpProxyClient.cs,Handshake,The method has 101 lines of code.
Long Method,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The method has 137 lines of code.
Long Method,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The method has 102 lines of code.
Complex Method,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,GetItemInfo,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,DiscardFolderInfo,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Ftp,FtpFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpFolder.cs,DoGetChildItems,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,FtpStream,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,Seek,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Ftp,HttpProxyClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Proxy)\HttpProxyClient.cs,Handshake,Cyclomatic complexity of the method is 21
Complex Method,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveMultipleFiles,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,DeleteFolder,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,RenameFile,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveMultipleFiles,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,OnDownloadDataStreamClosed,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp,FtpListingParserList,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpListingParserList.cs,ParseListing,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp,FtpUnixListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpUNIXListingParser.cs,ParseLine,Cyclomatic complexity of the method is 25
Complex Method,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,AddLine,Cyclomatic complexity of the method is 15
Complex Method,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoDelete,Cyclomatic complexity of the method is 12
Complex Method,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,Cyclomatic complexity of the method is 12
Complex Method,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,Cyclomatic complexity of the method is 12
Complex Method,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,AuthenticationFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AuthenticationFtpCommand.cs,AuthenticationFtpCommand,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp.Engine,BaseStoreFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\BaseStoreFileFtpCommand.cs,ProcessData,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,ConnectFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectFtpCommand.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Ftp.Engine,ConnectFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectFtpCommand.cs,EndExecute,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,CopyStream,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp.Engine,ListFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ListFtpCommand.cs,ProcessData,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Ftp.Engine,RetrieveFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\RetrieveFileFtpCommand.cs,RetrieveFileFtpCommand,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,RetrieveFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\RetrieveFileFtpCommand.cs,ProcessData,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp.Engine,TransferModeFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\TransferModeFtpCommand.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,TypeFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\TypeFtpCommand.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Xceed.Ftp.Engine,DeleteFolderFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\DeleteFolderFtpCommandSequence.cs,OnCommandCompleted,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,OnCommandCompleted,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,Cyclomatic complexity of the method is 16
Complex Method,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,MatchLocalFiles,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,Execute,Cyclomatic complexity of the method is 11
Complex Method,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,ProcessReceivedState,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,ProcessReceivedState,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,ChangeDataChannelSecurityProtocol,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,OnServerCertificateValidationCallback,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Ftp.Engine,FtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandSequence.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Ftp.Engine,FtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandSequence.cs,EndExecute,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,EndConnect,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,Accepted,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\CombinedStream.cs,Seek,Cyclomatic complexity of the method is 10
Complex Method,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\CombinedStream.cs,Read,Cyclomatic complexity of the method is 8
Long Parameter List,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,FtpConnection,The method has 9 parameters.
Long Parameter List,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,FtpConnection,The method has 7 parameters.
Long Parameter List,Xceed.Ftp,FtpFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpFile.cs,OpenWrite,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,FtpStream,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The method has 7 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginAuthenticate,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginAuthenticate,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginAuthenticate,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginLogin,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginLogin,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginChangeUser,The method has 7 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginChangeUser,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginRenameFile,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginGetFolderContents,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveMultipleFiles,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendFile,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendFile,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendMultipleFiles,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The method has 7 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The method has 9 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The method has 20 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The method has 25 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The method has 26 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The method has 9 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The method has 20 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The method has 25 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The method has 26 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The method has 5 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The method has 7 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The method has 10 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The method has 20 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The method has 21 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Delete,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Delete,The method has 20 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Delete,The method has 21 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoReceive,The method has 11 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoGetContents,The method has 6 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoSend,The method has 11 parameters.
Long Parameter List,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoDelete,The method has 6 parameters.
Long Parameter List,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The method has 5 parameters.
Long Parameter List,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The method has 6 parameters.
Long Parameter List,Xceed.Ftp.Engine,ConnectSslFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectSslFtpCommand.cs,ConnectSslFtpCommand,The method has 6 parameters.
Long Parameter List,Xceed.Ftp.Engine,ConnectSslFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectSslFtpCommand.cs,ConnectSslFtpCommand,The method has 5 parameters.
Long Parameter List,Xceed.Ftp.Engine,ConnectSslFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectSslFtpCommand.cs,ConnectSslFtpCommand,The method has 5 parameters.
Long Parameter List,Xceed.Ftp.Engine,ConnectSslProxyFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectSslProxyFtpCommand.cs,ConnectSslProxyFtpCommand,The method has 7 parameters.
Long Parameter List,Xceed.Ftp.Engine,ConnectSslProxyFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectSslProxyFtpCommand.cs,ConnectSslProxyFtpCommand,The method has 6 parameters.
Long Parameter List,Xceed.Ftp.Engine,ConnectSslProxyFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectSslProxyFtpCommand.cs,ConnectSslProxyFtpCommand,The method has 6 parameters.
Long Parameter List,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,MatchRemoteFilesFtpCommandSequence,The method has 6 parameters.
Long Parameter List,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,MatchRemoteFilesFtpCommandSequence,The method has 7 parameters.
Long Parameter List,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,ReceiveMultipleFilesFtpCommandSequence,The method has 7 parameters.
Long Parameter List,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,SendMultipleFilesFtpCommandSequence,The method has 5 parameters.
Long Parameter List,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,OnLocalCertificateSelectionCallback,The method has 5 parameters.
Long Parameter List,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,OnLocalCertificateSelectionCallback,The method has 5 parameters.
Long Parameter List,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,OnLocalCertificateSelectionCallback,The method has 5 parameters.
Long Identifier,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the parameter preservedPathDestinationFolder is 30.
Long Statement,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,GetItemInfo,The length of the statement  "				throw new FileSystemIOException ("An error occured while retrieving a folder's listing information."' new FtpFolder (this' workingFolder)' except); " is 147.
Long Statement,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,UpdateProperties,The length of the statement  "			throw new NotSupportedException ("An FtpListingParser-derived classes must implement a parameterless constructor in order to be used with an FtpConnection."); " is 158.
Long Statement,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,The length of the statement  "				client.Connect (m_hostName' (m_port == 0) ? (990) : (m_port)' m_authenticationMethod' m_verificationFlags' m_clientCertificate); " is 128.
Long Statement,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,UpdateLength,The length of the statement  "		System.Diagnostics.Debug.Assert (m_innerStream == null' "The length should have been updated before a first stream got open."); " is 127.
Long Statement,Xceed.Ftp,HttpProxyClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Proxy)\HttpProxyClient.cs,Handshake,The length of the statement  "		int count = proxyState.SocketStream.Read (proxyState.AsyncReceiveState.Buffer' 0' proxyState.AsyncReceiveState.Buffer.Length); " is 126.
Long Statement,Xceed.Ftp,HttpProxyClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Proxy)\HttpProxyClient.cs,Handshake,The length of the statement  "						System.Diagnostics.Debug.Assert (remaining.Length <= proxyState.Reply.ContentLength' "How could we have both content and remaining data?"); " is 139.
Long Statement,Xceed.Ftp,HttpProxyClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Proxy)\HttpProxyClient.cs,Handshake,The length of the statement  "		while ((proxyState.Reply == null) || (proxyState.Reply.Type == HttpReplyType.Incomplete) || (currentContentLength < proxyState.Reply.ContentLength)); " is 149.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The length of the statement  "		connectCommand = (this.Proxy == null) ? new ConnectFtpCommand (this.Engine.LocalAddress' hostName) : new ConnectProxyFtpCommand (this.Engine.LocalAddress' hostName' this.Proxy); " is 177.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The length of the statement  "			connectCommand = (this.Proxy == null) ? new ConnectFtpCommand (this.Engine.LocalAddress' hostName) : new ConnectProxyFtpCommand (this.Engine.LocalAddress' hostName' this.Proxy); " is 177.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The length of the statement  "			connectCommand = (this.Proxy == null) ? new ConnectSslFtpCommand (this.Engine.LocalAddress' hostName' authenticationMethod' verificationFlags' clientCertificate) : new ConnectSslProxyFtpCommand (this.Engine.LocalAddress' hostName' authenticationMethod' verificationFlags' clientCertificate' this.Proxy); " is 303.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The length of the statement  "		connectCommand = (this.Proxy == null) ? new ConnectFtpCommand (this.Engine.LocalAddress' hostName' port) : new ConnectProxyFtpCommand (this.Engine.LocalAddress' hostName' port' this.Proxy); " is 189.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The length of the statement  "			connectCommand = (this.Proxy == null) ? new ConnectFtpCommand (this.Engine.LocalAddress' hostName' port) : new ConnectProxyFtpCommand (this.Engine.LocalAddress' hostName' port' this.Proxy); " is 189.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The length of the statement  "			connectCommand = (this.Proxy == null) ? new ConnectSslFtpCommand (this.Engine.LocalAddress' hostName' port' authenticationMethod' verificationFlags' clientCertificate) : new ConnectSslProxyFtpCommand (this.Engine.LocalAddress' hostName' port' authenticationMethod' verificationFlags' clientCertificate' this.Proxy); " is 315.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The length of the statement  "		connectCommand = (this.Proxy == null) ? new ConnectFtpCommand (this.Engine.LocalAddress' serverAddress) : new ConnectProxyFtpCommand (this.Engine.LocalAddress' serverAddress' this.Proxy); " is 187.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginAuthenticate,The length of the statement  "	SslAuthenticationFtpCommandSequence sslSequence = new SslAuthenticationFtpCommandSequence (authCommand' new ProtectedBufferSizeFtpCommand ()' protCommand); " is 155.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginAuthenticate,The length of the statement  "		AuthenticationFtpCommand authCommand = new AuthenticationFtpCommand (this.HostName' authenticationMethod' verificationFlags' clientCertificate); " is 144.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginAuthenticate,The length of the statement  "		DataChannelProtectionFtpCommand protCommand = new DataChannelProtectionFtpCommand (dataProtection' (SslProtocols)authenticationMethod); " is 135.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginAuthenticate,The length of the statement  "	return this.BeginAuthenticate (authenticationMethod' verificationFlags' clientCertificate' DataChannelProtection.Clear' callback' state); " is 137.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginLogin,The length of the statement  "		return this.BeginLogin (commandChannel' new UserFtpCommand (userName)' new PasswordFtpCommand (password)' null' callback' state); " is 129.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginLogin,The length of the statement  "		return this.BeginLogin (commandChannel' new UserFtpCommand (userName)' new PasswordFtpCommand (password)' new AccountFtpCommand (accountName)' callback' state); " is 160.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginChangeUser,The length of the statement  "	ChangeUserFtpCommandSequence changeUserSequence = new ChangeUserFtpCommandSequence (reinitCommand' userCommand' passwordCommand' accountCommand); " is 145.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginChangeUser,The length of the statement  "		return this.BeginChangeUser (commandChannel' new ReinitFtpCommand ()' new UserFtpCommand ()' new PasswordFtpCommand ()' null' callback' state); " is 143.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginChangeUser,The length of the statement  "		return this.BeginChangeUser (commandChannel' new ReinitFtpCommand ()' new UserFtpCommand (userName)' new PasswordFtpCommand (password)' null' callback' state); " is 159.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginChangeUser,The length of the statement  "		return this.BeginChangeUser (commandChannel' new ReinitFtpCommand ()' new UserFtpCommand (userName)' new PasswordFtpCommand (password)' new AccountFtpCommand (accountName)' callback' state); " is 190.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,EndDisconnect,The length of the statement  "			throw new FtpInternalException ("Disconnection timed-out' which should never happen."' new FtpTimeoutException ("The FTP command execution timed-out.")); " is 153.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginGetFolderContents,The length of the statement  "	ListFtpCommandSequence listSequence = (parsed) ? (new ListFtpCommandSequence (listCommand' this' this.ListingParsers)) : (new ListFtpCommandSequence (listCommand' this)); " is 170.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginGetFolderContents,The length of the statement  "		return this.BeginGetFolderContents (commandChannel' new ListFtpCommand (this.LocalToServer (remoteFileMask))' true' callback' state); " is 133.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginGetRawFolderContents,The length of the statement  "		return this.BeginGetFolderContents (commandChannel' new ListFtpCommand (this.LocalToServer (remoteFileMask))' false' callback' state); " is 134.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,EndGetRawFolderContents,The length of the statement  "		System.Diagnostics.Debug.Assert (listSequence.Items.Count == 0' "You should not provide a parser when retrieving the raw listing."); " is 132.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The length of the statement  "	ReceiveFileFtpCommandSequence receiveSequence = new ReceiveFileFtpCommandSequence (typeCommand' dataCommand' restartCommand' retrieveCommand); " is 142.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The length of the statement  "		return this.BeginReceiveFile (commandChannel' null' new RetrieveFileFtpCommand (this.LocalToServer (remoteFilename)' localFilename' !append)' callback' state); " is 159.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The length of the statement  "		return this.BeginReceiveFile (commandChannel' (offset == 0) ? (null) : (new RestartFtpCommand (offset))' new RetrieveFileFtpCommand (this.LocalToServer (remoteFilename)' localFilename' !append)' callback' state); " is 212.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The length of the statement  "		return this.BeginReceiveFile (commandChannel' null' new RetrieveFileFtpCommand (this.LocalToServer (remoteFilename)' destination)' callback' state); " is 148.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveFile,The length of the statement  "		return this.BeginReceiveFile (commandChannel' (offset == 0) ? (null) : (new RestartFtpCommand (offset))' new RetrieveFileFtpCommand (this.LocalToServer (remoteFilename)' destination)' callback' state); " is 201.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveMultipleFiles,The length of the statement  "			throw new FileSystemIOException ("The parent's full name is too long for remote file mask : " + remoteFileMask' null' exception); " is 129.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginReceiveMultipleFiles,The length of the statement  "		ReceiveMultipleFilesFtpCommandSequence receiveSequence = new ReceiveMultipleFilesFtpCommandSequence (path' mask' folder' recursive' recreateFolderStructure' this' this.ListingParsers); " is 184.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,EndReceiveMultipleFiles,The length of the statement  "	ReceiveMultipleFilesFtpCommandSequence receiveSequence = sequenceResult.Command as ReceiveMultipleFilesFtpCommandSequence; " is 122.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendFile,The length of the statement  "	SendFileFtpCommandSequence sendFileSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' allocCommand' storeCommand); " is 132.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendFile,The length of the statement  "		BaseStoreFileFtpCommand storeFileCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (localFilename' remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (localFilename' remoteFilename); " is 219.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendFile,The length of the statement  "		BaseStoreFileFtpCommand storeFileCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (localFilename' remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (localFilename' remoteFilename); " is 219.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendFile,The length of the statement  "		BaseStoreFileFtpCommand storeFileCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (source' remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (source' remoteFilename); " is 205.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginSendMultipleFiles,The length of the statement  "		SendMultipleFilesFtpCommandSequence sendSequence = new SendMultipleFilesFtpCommandSequence (localFileMask' recursive' recreateFolderStructure' this.PreAllocateStorage' this); " is 174.
Long Statement,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginGetUploadStream,The length of the statement  "		BaseStoreFileFtpCommand storeCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (remoteFilename); " is 185.
Long Statement,Xceed.Ftp,FileTransferStatusEventArgs,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FileTransferStatusEvent.cs,SetLocalFilename,The length of the statement  "	if (filename.EndsWith (BaseStoreFileFtpCommand.StreamLocalFilename) || filename.EndsWith (RetrieveFileFtpCommand.StreamLocalFilename)) { " is 136.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,KeepAlive,The length of the statement  "		if ((channel.Engine.KeepAliveInterval != TimeSpan.Zero) && (lastKeepAlive.Subtract (m_lastKeepAlive) >= channel.Engine.KeepAliveInterval)) { " is 140.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SetState,The length of the statement  "				throw new FtpInvalidStateException ("Cannot perform the requested operation because the FTP client is not yet connected to an FTP server."); " is 140.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SetState,The length of the statement  "				throw new FtpInvalidStateException ("Cannot perform the requested operation because the FTP client is already connected to an FTP server."); " is 140.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SetState,The length of the statement  "				throw new FtpInvalidStateException ("Cannot perform the requested operation because the FTP client is already processing a command."); " is 134.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "		using (ConnectFtpCommand connectCommand = (m_proxy == null) ? new ConnectFtpCommand (m_engine.LocalAddress' hostName) : new ConnectProxyFtpCommand (m_engine.LocalAddress' hostName' m_proxy)) { " is 192.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "			connectCommand = (m_proxy == null) ? new ConnectFtpCommand (m_engine.LocalAddress' hostName) : new ConnectProxyFtpCommand (m_engine.LocalAddress' hostName' m_proxy); " is 165.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "			connectCommand = (m_proxy == null) ? new ConnectSslFtpCommand (m_engine.LocalAddress' hostName' authenticationMethod' verificationFlags' clientCertificate) : new ConnectSslProxyFtpCommand (m_engine.LocalAddress' hostName' authenticationMethod' verificationFlags' clientCertificate' m_proxy); " is 291.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "		using (ConnectFtpCommand connectCommand = (m_proxy == null) ? new ConnectFtpCommand (m_engine.LocalAddress' hostName' port) : new ConnectProxyFtpCommand (m_engine.LocalAddress' hostName' port' m_proxy)) { " is 204.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "			connectCommand = (m_proxy == null) ? new ConnectFtpCommand (m_engine.LocalAddress' hostName' port) : new ConnectProxyFtpCommand (m_engine.LocalAddress' hostName' port' m_proxy); " is 177.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "			connectCommand = (m_proxy == null) ? new ConnectSslFtpCommand (m_engine.LocalAddress' hostName' port' authenticationMethod' verificationFlags' clientCertificate) : new ConnectSslProxyFtpCommand (m_engine.LocalAddress' hostName' port' authenticationMethod' verificationFlags' clientCertificate' m_proxy); " is 303.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "		using (ConnectFtpCommand connectCommand = (m_proxy == null) ? new ConnectFtpCommand (m_engine.LocalAddress' serverAddress) : new ConnectProxyFtpCommand (m_engine.LocalAddress' serverAddress' m_proxy)) { " is 202.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "			connectCommand = (m_proxy == null) ? new ConnectFtpCommand (m_engine.LocalAddress' serverAddress) : new ConnectProxyFtpCommand (m_engine.LocalAddress' serverAddress' m_proxy); " is 175.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The length of the statement  "			connectCommand = (m_proxy == null) ? new ConnectSslFtpCommand (m_engine.LocalAddress' serverAddress' authenticationMethod' verificationFlags' clientCertificate) : new ConnectSslProxyFtpCommand (m_engine.LocalAddress' serverAddress' authenticationMethod' verificationFlags' clientCertificate' m_proxy); " is 301.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,DoAuthenticate,The length of the statement  "	using (SslAuthenticationFtpCommandSequence sequence = new SslAuthenticationFtpCommandSequence (authCommand' new ProtectedBufferSizeFtpCommand ()' protCommand)) { " is 161.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Authenticate,The length of the statement  "		AuthenticationFtpCommand authCommand = new AuthenticationFtpCommand (this.HostName' authenticationMethod' verificationFlags' clientCertificate); " is 144.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Authenticate,The length of the statement  "		DataChannelProtectionFtpCommand protCommand = new DataChannelProtectionFtpCommand (dataProtection' (SslProtocols)authenticationMethod); " is 135.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Login,The length of the statement  "		this.DoLogin (commandChannel' new UserFtpCommand (userName)' new PasswordFtpCommand (password)' new AccountFtpCommand (accountName)); " is 133.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,DoChangeUser,The length of the statement  "	using (ChangeUserFtpCommandSequence changeUserSequence = new ChangeUserFtpCommandSequence (new ReinitFtpCommand ()' userCommand' passwordCommand' accountCommand)) { " is 164.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ChangeUser,The length of the statement  "		this.DoChangeUser (commandChannel' new UserFtpCommand (userName)' new PasswordFtpCommand (password)' new AccountFtpCommand (accountName)); " is 138.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ChangeDataChannelProtection,The length of the statement  "		using (DataChannelProtectionFtpCommand command = new DataChannelProtectionFtpCommand (dataChannelProtection' sslProtocol)) { " is 124.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,The length of the statement  "		RetrieveFileFtpCommand retrieveCommand = new RetrieveFileFtpCommand (this.LocalToServer (remoteFilename)' localFilename' !append); " is 130.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,The length of the statement  "		using (ReceiveFileFtpCommandSequence receiveSequence = new ReceiveFileFtpCommandSequence (typeCommand' dataCommand' null' retrieveCommand)) { " is 141.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,The length of the statement  "		RetrieveFileFtpCommand retrieveCommand = new RetrieveFileFtpCommand (this.LocalToServer (remoteFilename)' localFilename' !append); " is 130.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,The length of the statement  "		using (ReceiveFileFtpCommandSequence receiveSequence = new ReceiveFileFtpCommandSequence (typeCommand' dataCommand' restartCommand' retrieveCommand)) { " is 151.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,The length of the statement  "		using (ReceiveFileFtpCommandSequence receiveSequence = new ReceiveFileFtpCommandSequence (typeCommand' dataCommand' null' retrieveCommand)) { " is 141.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveFile,The length of the statement  "			using (ReceiveFileFtpCommandSequence receiveSequence = new ReceiveFileFtpCommandSequence (typeCommand' dataCommand' restartCommand' retrieveCommand)) { " is 151.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveMultipleFiles,The length of the statement  "			throw new FileSystemIOException ("The parent's full name is too long for remote file mask : " + remoteFileMask' null' exception); " is 129.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,ReceiveMultipleFiles,The length of the statement  "		using (ReceiveMultipleFilesFtpCommandSequence receiveSequence = new ReceiveMultipleFilesFtpCommandSequence (path' mask' folder' recursive' recreateFolderStructure' this' this.ListingParsers)) { " is 193.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		using (SendFileFtpCommandSequence sendSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' allocCommand' storeCommand)) { " is 137.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		BaseStoreFileFtpCommand storeCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (localFilename' remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (localFilename' remoteFilename); " is 215.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		using (SendFileFtpCommandSequence sendSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' allocCommand' storeCommand)) { " is 137.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		using (SendFileFtpCommandSequence sendSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' allocCommand' storeCommand)) { " is 137.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		BaseStoreFileFtpCommand storeCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (localFilename' remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (localFilename' remoteFilename); " is 215.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		using (SendFileFtpCommandSequence sendSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' allocCommand' storeCommand)) { " is 137.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		BaseStoreFileFtpCommand storeCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (source' remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (source' remoteFilename); " is 201.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFile,The length of the statement  "		using (SendFileFtpCommandSequence sendSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' allocCommand' storeCommand)) { " is 137.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFileToUniqueName,The length of the statement  "		using (SendFileFtpCommandSequence sendSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' allocCommand' uniqueStoreCommand)) { " is 143.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendFileToUniqueName,The length of the statement  "		using (SendFileFtpCommandSequence sendSequence = new SendFileFtpCommandSequence (typeCommand' dataCommand' null' uniqueStoreCommand)) { " is 135.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,SendMultipleFiles,The length of the statement  "		using (SendMultipleFilesFtpCommandSequence sendSequence = new SendMultipleFilesFtpCommandSequence (localFileMask' recursive' recreateFolderStructure' this.PreAllocateStorage' this)) { " is 183.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,GetUploadStream,The length of the statement  "		BaseStoreFileFtpCommand storeCommand = (append) ? (BaseStoreFileFtpCommand)new AppendFileFtpCommand (remoteFilename) : (BaseStoreFileFtpCommand)new StoreFileFtpCommand (remoteFilename); " is 185.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,OnDownloadDataStreamClosed,The length of the statement  "		#        this.Engine.Tracing.DebugWriteLine( "[DEBUG] Timeout in " + System.Reflection.MethodInfo.GetCurrentMethod().Name );" is 124.
Long Statement,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,OnUploadDataStreamClosed,The length of the statement  "		#        this.Engine.Tracing.DebugWriteLine( "[DEBUG] Timeout in " + System.Reflection.MethodInfo.GetCurrentMethod().Name );" is 124.
Long Statement,Xceed.Ftp,FtpUnixListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpUNIXListingParser.cs,ParseLine,The length of the statement  "					dateValue = new DateTime (int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture)' monthValue' dayValue); " is 121.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The length of the statement  "	FtpConnection ftpConnection = new FtpConnection (hostname' port' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication); " is 172.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The length of the statement  "	Receive (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' localDestinationFolder' replaceExistingFiles' recursive' preservePaths' null' // No proxy by default " is 252.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The length of the statement  "	synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' TransferMode.Stream' filesToReceive); " is 178.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The length of the statement  "	Receive (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' localDestinationFolder' replaceExistingFiles' recursive' preservePaths' proxy' timeout' passiveTransfer' defaultRepresentationType' traceWriter' synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' TransferMode.Stream' filesToReceive); " is 475.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The length of the statement  "	FtpConnection ftpConnection = new FtpConnection (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication); " is 192.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The length of the statement  "	DoReceive (ftpConnection' localDestinationFolder' replaceExistingFiles' recursive' preservePaths' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' filesToReceive); " is 234.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The length of the statement  "	FtpConnection ftpConnection = new FtpConnection (hostname' port' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication); " is 172.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The length of the statement  "	Send (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' remoteDestinationFolder' replaceExistingFiles' recursive' preservePaths' null' // No proxy by default " is 250.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The length of the statement  "	synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' filesToSend); " is 154.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The length of the statement  "	Send (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' remoteDestinationFolder' replaceExistingFiles' recursive' preservePaths' proxy' timeout' passiveTransfer' defaultRepresentationType' traceWriter' synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' TransferMode.Stream' filesToSend); " is 470.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The length of the statement  "	FtpConnection ftpConnection = new FtpConnection (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication); " is 192.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The length of the statement  "	DoSend (ftpConnection' remoteDestinationFolder' replaceExistingFiles' recursive' preservePaths' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' filesToSend); " is 229.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The length of the statement  "	FtpConnection ftpConnection = new FtpConnection (hostname' port' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication); " is 172.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The length of the statement  "	return GetFtpContents (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' proxy' timeout' passiveTransfer' defaultRepresentationType' traceWriter' remoteFolderToList' recursive' synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' TransferMode.Stream' filters); " is 379.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The length of the statement  "	FtpConnection ftpConnection = new FtpConnection (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication); " is 192.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,GetFtpContents,The length of the statement  "	return DoGetContents (ftpConnection' remoteFolderToList' recursive' certificateReceivedCallback' certificateRequiredCallback' filters); " is 135.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Delete,The length of the statement  "	Delete (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' recursive' proxy' timeout' passiveTransfer' defaultRepresentationType' traceWriter' synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' userParams' TransferMode.Stream' filesToDelete); " is 362.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Delete,The length of the statement  "	FtpConnection ftpConnection = new FtpConnection (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication); " is 192.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,OnByteProgression,The length of the statement  "	byteProgressionCallback (e.CurrentItem.FullName' e.CurrentFileBytes.Processed' e.CurrentFileBytes.Total' e.CurrentFileBytes.Percent' e.AllFilesBytes.Processed' e.AllFilesBytes.Total' e.AllFilesBytes.Percent' userParams); " is 220.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,OnItemProgression,The length of the statement  "	itemProgressionCallback (e.CurrentItem.FullName' e.AllItems.Processed' e.AllItems.Total' e.AllItems.Percent' ref abort' userParams); " is 132.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoReceive,The length of the statement  "		List<FileSystemItem> fileSystemItemList = mg_quickFtpTransfer.CreateItemListFromPath (false' filesToReceive' recursive); " is 120.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoGetContents,The length of the statement  "		AbstractQuickActionItem[] abstractQuickItems = mg_quickFtpTransfer.GetFolderContents (folderToList' recursive' filters); " is 120.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoGetContents,The length of the statement  "		quickFtpItems = Array.ConvertAll (abstractQuickItems' new Converter<AbstractQuickActionItem' QuickFtpItem> (ConvertToQuickFtpItem)); " is 132.
Long Statement,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoDelete,The length of the statement  "			if (!pathName.EndsWith (Path.DirectorySeparatorChar.ToString ()) && !pathName.EndsWith (Path.AltDirectorySeparatorChar.ToString ())) { " is 134.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The length of the statement  "				throw new FileSystemIOException ("The parent folder full name is too long for item : " + fileParentFolderPath' null' exception); " is 128.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\AbstractQuickAction.cs,CreateItemListFromPaths,The length of the statement  "			if ((fileParentFolderPath == Path.DirectorySeparatorChar.ToString ()) || (fileParentFolderPath == Path.AltDirectorySeparatorChar.ToString ())) { " is 144.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,The length of the statement  "			if (!fileParentFolderPath.EndsWith (Path.DirectorySeparatorChar.ToString ()) && !fileParentFolderPath.EndsWith (Path.AltDirectorySeparatorChar.ToString ())) { " is 158.
Long Statement,Xceed.FileSystem.Quick,AbstractQuickAction,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\AbstractQuickAction.cs,RemoveFiles,The length of the statement  "			if (fileParentFolderPath == Path.DirectorySeparatorChar.ToString () || fileParentFolderPath == Path.AltDirectorySeparatorChar.ToString ()) { " is 140.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "			throw new FileSystemIOException ("The parent folder full name is too long for item : " + fileSystemItem.FullName' null' exception); " is 131.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "				throw new FileSystemIOException ("The parent's full name is too long for item : " + fileSystemItem.FullName' null' exception); " is 126.
Long Statement,Xceed.FileSystem,MultipleItemListFolder,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\MultipleItemListFolder.cs,BuildList,The length of the statement  "			// If in current folder' no root path specified or sourceFolderPath is a root path' use the destination folder directly. " is 120.
Long Statement,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,Abort,The length of the statement  "	      this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] AbortFtpCommand.Abort() does nothing and doesn't call base class" );" is 128.
Long Statement,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,ClaimReply,The length of the statement  "	      this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] AbortFtpCommand.ClaimReply() at " + clientIndex + " of " + clientCount + " claims reply " + chosenIndex );" is 166.
Long Statement,Xceed.Ftp.Engine,ConnectFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectFtpCommand.cs,Execute,The length of the statement  "			result.Complete (new FtpInternalException ("An unexpected error occurred while connecting to remote FTP server."' except)' null); " is 129.
Long Statement,Xceed.Ftp.Engine,ConnectProxyFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectProxyFtpCommand.cs,StartConversation,The length of the statement  "			myResult.Complete (new FtpInternalException ("An unexpected error occurred while connecting to remote FTP server."' except)' null); " is 131.
Long Statement,Xceed.Ftp.Engine,ConnectSslProxyFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ConnectSslProxyFtpCommand.cs,StartConversation,The length of the statement  "			myResult.Complete (new FtpInternalException ("An unexpected error occurred while connecting to remote FTP server."' except)' null); " is 131.
Long Statement,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,ReleaseDataStream,The length of the statement  "				throw new FtpInternalException ("ReleaseDataStream was called with a different data stream."' new ArgumentException ("Invalid data stream"' "dataStream")); " is 155.
Long Statement,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,KeepAlive,The length of the statement  "		if ((channel.Engine.KeepAliveInterval != TimeSpan.Zero) && (lastKeepAlive.Subtract (m_lastKeepAlive) >= channel.Engine.KeepAliveInterval)) { " is 140.
Long Statement,Xceed.Ftp.Engine,NoopFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\NoopFtpCommand.cs,ClaimReply,The length of the statement  "	      this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] NoopFtpCommand.ClaimReply() at " + clientIndex + " of " + clientCount + " claims reply " + chosenIndex );" is 165.
Long Statement,Xceed.Ftp.Engine,PasswordFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PasswordFtpCommand.cs,ProcessSuccessReply,The length of the statement  "	System.Diagnostics.Debug.Assert ((reply.Type == FtpReplyType.PositiveCompletion) || (reply.Type == FtpReplyType.PositiveIntermediate)); " is 135.
Long Statement,Xceed.Ftp.Engine,PortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PortFtpCommand.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "PORT {0}'{1}'{2}'{3}'{4}'{5}"' (address) & 0xff' (address >> 8) & 0xff' (address >> 16) & 0xff' (address >> 24) & 0xff' (port >> 8) & 0xff' (port) & 0xff); " is 208.
Long Statement,Xceed.Ftp.Engine,RestartFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\RestartFtpCommand.cs,ProcessSuccessReply,The length of the statement  "	System.Diagnostics.Debug.Assert ((reply.Type == FtpReplyType.PositiveCompletion) || (reply.Type == FtpReplyType.PositiveIntermediate)); " is 135.
Long Statement,Xceed.Ftp.Engine,RetrieveFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\RetrieveFileFtpCommand.cs,ProcessData,The length of the statement  "						throw new FileSystemIOException ("The parent's full name is too long for local file : " + m_localFile.FullName' m_localFile' exception); " is 136.
Long Statement,Xceed.Ftp.Engine,UserFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\UserFtpCommand.cs,ProcessSuccessReply,The length of the statement  "	System.Diagnostics.Debug.Assert ((reply.Type == FtpReplyType.PositiveCompletion) || (reply.Type == FtpReplyType.PositiveIntermediate)); " is 135.
Long Statement,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,OnMultipleFileTransferError,The length of the statement  "	MultipleFileTransferErrorEventHandler handler = m_eventList [MultipleFileTransferErrorEventKey] as MultipleFileTransferErrorEventHandler; " is 137.
Long Statement,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,OnMultipleFileTransferError,The length of the statement  "		MultipleFileTransferErrorEventArgs args = new MultipleFileTransferErrorEventArgs (localItemName' remoteItemName' remoteItemType' exception); " is 140.
Long Statement,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,OnCommandCompleted,The length of the statement  "		this.InsertCommand (new ListFtpCommandSequence (new ListFtpCommand (m_remoteFileMask' false)' m_commandProvider' m_parsers)); " is 125.
Long Statement,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,OnCommandCompleted,The length of the statement  "					MatchRemoteFilesFtpCommandSequence matchSequence = new MatchRemoteFilesFtpCommandSequence (m_remoteFileMask' localFolder' m_recursive' m_recreateFolderStructure' m_commandProvider' m_parsers' m_eventList); " is 205.
Long Statement,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,OnCommandCompleted,The length of the statement  "		MultipleFileTransferErrorAction action = this.OnMultipleFileTransferError (string.Empty' changeFolderCommand.Folder' (changeFolderCommand.Link ? FtpItemType.Link : FtpItemType.Folder)' except); " is 193.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnMultipleFileTransferError,The length of the statement  "		MultipleFileTransferErrorEventArgs args = new MultipleFileTransferErrorEventArgs (localItemName' remoteItemName' remoteItemType' exception); " is 140.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnCommandStarting,The length of the statement  "		        matchSequence.MultipleFileTransferError += new MultipleFileTransferErrorEventHandler( this.OnMultipleFileTransferError );" is 121.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnCommandStarting,The length of the statement  "		matchSequence.MultipleFileTransferError += (MultipleFileTransferErrorEventHandler)m_multipleFileTransferErrorStorage.Clone (); " is 126.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,The length of the statement  "		MultipleFileTransferErrorAction action = this.OnMultipleFileTransferError (receiveSequence.RetrieveCommand.LocalFilename' receiveSequence.RetrieveCommand.RemoteFilename' receiveSequence.RetrieveCommand.RemoteFileType' except); " is 226.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnDisposing,The length of the statement  "		        matchSequence.MultipleFileTransferError -= new MultipleFileTransferErrorEventHandler( this.OnMultipleFileTransferError );" is 121.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnDisposing,The length of the statement  "		matchSequence.MultipleFileTransferError -= (MultipleFileTransferErrorEventHandler)m_multipleFileTransferErrorStorage.Clone (); " is 126.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnRemoteFileMatched,The length of the statement  "	RetrieveFileFtpCommand retrieveCommand = new RetrieveFileFtpCommand (e.RemoteFile.Name' e.RemoteFile.Type' e.LocalFile' true); " is 126.
Long Statement,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnRemoteFileMatched,The length of the statement  "	ReceiveFileFtpCommandSequence receiveSequence = new ReceiveFileFtpCommandSequence (typeCommand' dataCommand' null' retrieveCommand); " is 132.
Long Statement,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,OnMultipleFileTransferError,The length of the statement  "		MultipleFileTransferErrorEventArgs args = new MultipleFileTransferErrorEventArgs (localItemName' remoteItemName' remoteItemType' exception); " is 140.
Long Statement,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,The length of the statement  "				throw new FileSystemIOException ("The parent's full name is too long for local file mask : " + m_localFileMask' null' exception); " is 129.
Long Statement,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,The length of the statement  "		MultipleFileTransferErrorAction action = this.OnMultipleFileTransferError (string.Empty' changeFolderCommand.Folder' (changeFolderCommand.Link ? FtpItemType.Link : FtpItemType.Folder)' except); " is 193.
Long Statement,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,The length of the statement  "		MultipleFileTransferErrorAction action = this.OnMultipleFileTransferError (sendSequence.StoreCommand.LocalFilename' sendSequence.StoreCommand.RemoteFilename' FtpItemType.File' except); " is 184.
Long Statement,Xceed.Ftp.Engine,BaseFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\BaseFtpCommand.cs,BeginExecute,The length of the statement  "      this.m_ftpEngine.Tracing.DebugWriteLine( "[DEBUG] Calling method " + System.Reflection.MethodInfo.GetCurrentMethod().Name + " for '" + this.GetType().ToString() + " " + this.GetHashCode() + "'" );" is 196.
Long Statement,Xceed.Ftp.Engine,BaseFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\BaseFtpCommand.cs,BeginExecute,The length of the statement  "		throw new FtpException ("An exception occurred while processing a command' see inner exception for more information."' ex); " is 123.
Long Statement,Xceed.Ftp.Engine,BaseFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\BaseFtpCommand.cs,BackgroundWorker_RunWorkerCompleted,The length of the statement  "        this.m_ftpEngine.Tracing.DebugWriteLine( "[DEBUG] BackgroundWorker_RunWorkerCompleted(). command: '{3}'. asyncResult: {0}. exception: {1}. commandReply: {2}"'" is 158.
Long Statement,Xceed.Ftp.Engine,BaseFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\BaseFtpCommand.cs,BackgroundWorker_RunWorkerCompleted,The length of the statement  "        this.m_ftpEngine.Tracing.DebugWriteLine( "[DEBUG] BackgroundWorker_RunWorkerCompleted() EXCEPTION. command: '{0}'. exception: {1}"'" is 131.
Long Statement,Xceed.Ftp.Engine,BaseFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\BaseFtpCommand.cs,GlobalWaitOne,The length of the statement  "          tracing.DebugWriteLine( "[DEBUG] GlobalWaitOne(): waitHandle.SafeWaitHandle.IsClosed == true. Assuming we got a signal." );" is 123.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,Execute,The length of the statement  "        this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] calling method " + System.Reflection.MethodInfo.GetCurrentMethod().Name + " for '" + this.GetType().ToString() + " " + this.GetHashCode() + "'" );" is 206.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,Execute,The length of the statement  "			/* Usually' this involves failure to establish a SSL connection */// Get the reply now' expecting an exception to be thrown " is 123.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,EndExecute,The length of the statement  "        this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] calling method " + System.Reflection.MethodInfo.GetCurrentMethod().Name + " for '" + this.GetType().ToString() + " " + this.GetHashCode() + "'" );" is 206.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,EndExecute,The length of the statement  "			throw new FtpException ("An error occurred during the execution of a command. See the InnerException property for details."' executeResult.Error); " is 146.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,RegisterCommandTimeout,The length of the statement  "          this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] Reply timeout enabled for '" + this.GetType().ToString() + "' " + this.GetHashCode() );" is 147.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,RegisterCommandTimeout,The length of the statement  "		m_commandReplyTimeoutWaitHandle = ThreadPool.RegisterWaitForSingleObject (asyncWaitHandle' new WaitOrTimerCallback (this.OnCommandTimeout)' state' this.CommandChannel.Engine.DefaultTimeout' true); " is 196.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,UnregisterCommandTimeout,The length of the statement  "            this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG]  m_commandReplyTimeoutWaitHandle was null while unregistering ... '" + this.GetType().ToString() + "' " + this.GetHashCode() );" is 187.
Long Statement,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,UnregisterCommandTimeout,The length of the statement  "          this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] Reply timeout disabled for '" + this.GetType().ToString() + "' " + this.GetHashCode() );" is 148.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,Connect,The length of the statement  "		this.Engine.Tracing.WriteLine ("Connected to {0} on {1} @ {2}"' this.CachedServerAddress.ToString ()' DateTime.Now.ToShortDateString ()' DateTime.Now.ToLongTimeString ()); " is 171.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,Disconnect,The length of the statement  "				this.Engine.Tracing.WriteLine ("Disconnected from {0} on {1} @ {2}"' remoteAddress' DateTime.Now.ToShortDateString ()' DateTime.Now.ToLongTimeString ()); " is 153.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,SendString,The length of the statement  "		throw new FtpSslException ("An SSL error occurred while sending a command: unable to authenticate with the server."' except); " is 125.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,MonitorConnectionState,The length of the statement  "      builder.Append( "[DEBUG] FtpCommandChannel.MonitorConnectionState() will make sure we're reading from the network so we can watch for a remote disconnect" );" is 157.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,BeginReceiveReply,The length of the statement  "	      this.Engine.Tracing.DebugWriteLine( "[DEBUG] FtpCommandChannel.BeginReceiveReply() adds client {0:X08}/{1}. monitor {2:X08}/{3} to {4} operation {5:X08}."'" is 155.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,BeginReceiveReply,The length of the statement  "		        this.Engine.Tracing.DebugWriteLine( "[DEBUG] FtpCommandChannel.BeginReceiveReply() calls ReadOperationCompleted( null ) receiveReplyOperation is {0:X08}. m_receiveReplyOperation is {1:X08}"'" is 190.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,EndReceiveReply,The length of the statement  "		throw new FtpException ("A " + exception.GetType ().FullName + " occurred while receiving a reply. Please see and report the value of the InnerException property' which contains the actual exception and stack trace."' exception); " is 229.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,ChangeCommandChannelSecurityProtocol,The length of the statement  "		throw new FtpInternalException ("An error occurred while changing the security protocol for the command channel: the inner socket is null."); " is 141.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,ChangeCommandChannelSecurityProtocol,The length of the statement  "			          this.Engine.Tracing.DebugWriteLine( "[Debug] Ignored " + read + " bytes from socket while changing command channel security" );" is 127.
Long Statement,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,OnServerCertificateValidationCallback,The length of the statement  "		CertificateReceivedEventArgs args = new CertificateReceivedEventArgs (m_serverCertificate' m_verificationFlags' (VerificationStatus)status); " is 140.
Long Statement,Xceed.Ftp.Engine,FtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandSequence.cs,Execute,The length of the statement  "        this.CommandChannel.Engine.Tracing.DebugWriteLine( "[DEBUG] Calling method " + System.Reflection.MethodInfo.GetCurrentMethod().Name + " for '" + this.GetType().ToString() + " " + this.GetHashCode() + "'" );" is 206.
Long Statement,Xceed.Ftp.Engine,FtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandSequence.cs,EndExecute,The length of the statement  "        builder.Append( "[DEBUG] Calling method " + System.Reflection.MethodInfo.GetCurrentMethod().Name + " for '" + this.GetType().ToString() + " " + this.GetHashCode() + "'" );" is 171.
Long Statement,Xceed.Ftp.Engine,FtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandSequence.cs,EndExecute,The length of the statement  "			throw new FtpException ("An error occurred during the execution of a command sequence. See the InnerException property for details."' sequenceResult.Error); " is 156.
Long Statement,Xceed.Ftp.Engine,FtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandSequence.cs,OnCommandStarting,The length of the statement  "				throw new FtpInvalidStateException ("No data channel was created prior to execting a command that requires a data channel."); " is 125.
Long Statement,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Dispose,The length of the statement  "			          m_ftpEngine.Tracing.WriteLine( "Data channel stream is being disposed explicitly. Shutting down sending on the socket." );" is 122.
Long Statement,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Read,The length of the statement  "			          m_ftpEngine.Tracing.WriteLine( "Data channel stream throws {0}: {1}\n{2}"' exception.GetType().Name' exception.Message' exception.StackTrace );" is 143.
Long Statement,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Read,The length of the statement  "		        m_ftpEngine.Tracing.WriteLine( "Data channel stream signals the end of stream because we got a SocketException with an receive error code we find acceptable (timeout or connection closed)" );" is 191.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,BeginConnect,The length of the statement  "				new SocketPermission (NetworkAccess.Accept' TransportType.Tcp' this.LocalAddress.Address.ToString ()' (this.LocalAddress.Port == 0) ? SocketPermission.AllPorts : this.LocalAddress.Port).Assert (); " is 196.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,BeginConnect,The length of the statement  "			new SocketPermission (NetworkAccess.Connect' TransportType.Tcp' remoteAddress.Address.ToString ()' remoteAddress.Port).Assert (); " is 129.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,OnServerCertificateValidationCallback,The length of the statement  "			this.CommandChannel.Engine.Tracing.WriteLine ("The certificate received for the data channel does not match the certificate received for the command channel."); " is 160.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,OnServerCertificateValidationCallback,The length of the statement  "		this.CommandChannel.Engine.Tracing.Write ("An attempt was made to accept a certificate for the data channel while the command channel's certificate is null."); " is 159.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "				base.CommandChannel.Engine.Tracing.WriteLine ("Data connection established with {0} on {1} @ {2}"' socketRemoteAddress.ToString ()' DateTime.Now.ToShortDateString ()' DateTime.Now.ToLongTimeString ()); " is 201.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "					SslStream sslStream = new SslStream (m_socketStream' false' this.OnServerCertificateValidationCallback' this.OnLocalCertificateSelectionCallback); " is 146.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "					sslStream.AuthenticateAsClient (socketRemoteAddress.Address.ToString ()' certificateCollection' this.CommandChannel.DataChannelSecurityProtocol' false); " is 152.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "				base.CommandChannel.Engine.Tracing.WriteLine ("Data connection established with proxy {0} for server {1} on {2} @ {3}"' socketRemoteAddress.ToString ()' m_remoteAddress.ToString ()' DateTime.Now.ToShortDateString ()' DateTime.Now.ToLongTimeString ()); " is 251.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "				byte[] remaining = proxy.Handshake (this.CommandChannel' m_socketStream' m_remoteAddress.Address.ToString ()' m_remoteAddress.Port); " is 132.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "					SslStream sslStream = new SslStream (m_socketStream' false' this.OnServerCertificateValidationCallback' this.OnLocalCertificateSelectionCallback); " is 146.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "					sslStream.AuthenticateAsClient (this.GetRemoteAddress ().Address.ToString ()' null' this.CommandChannel.DataChannelSecurityProtocol' false); " is 140.
Long Statement,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,ConnectCompleted,The length of the statement  "			throw new FtpInternalException ("An unexpected error occurred while accepting the FTP server's data connection."' except); " is 122.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,BeginConnect,The length of the statement  "		new SocketPermission (NetworkAccess.Accept' TransportType.Tcp' this.LocalAddress.Address.ToString ()' this.LocalAddress.Port).Assert (); " is 136.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,CreateListener,The length of the statement  "			new SocketPermission (NetworkAccess.Accept' TransportType.Tcp' localAddress.Address.ToString ()' (localAddress.Port == 0) ? SocketPermission.AllPorts : localAddress.Port).Assert (); " is 181.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,Accepted,The length of the statement  "			this.CommandChannel.Engine.Tracing.WriteLine ("Data connection established with {0} on {1} @ {2}"' (remoteAddress == null) ? string.Empty : remoteAddress.ToString ()' DateTime.Now.ToShortDateString ()' DateTime.Now.ToLongTimeString ()); " is 236.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,Accepted,The length of the statement  "				SslStream sslStream = new SslStream (stream' false' this.OnServerCertificateValidationCallback' this.OnLocalCertificateSelectionCallback); " is 138.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,Accepted,The length of the statement  "				sslStream.AuthenticateAsClient (remoteEndPoint.Address.ToString ()' certificateCollection' this.CommandChannel.DataChannelSecurityProtocol' false); " is 147.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,Accepted,The length of the statement  "			throw new FtpInternalException ("An unexpected error occurred while accepting the FTP server's data connection."' except); " is 122.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,OnServerCertificateValidationCallback,The length of the statement  "			this.CommandChannel.Engine.Tracing.WriteLine ("The certificate received for the data channel does not match the certificate received for the command channel."); " is 160.
Long Statement,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,OnServerCertificateValidationCallback,The length of the statement  "		this.CommandChannel.Engine.Tracing.Write ("An attempt was made to accept a certificate for the data channel while the command channel's certificate is null."); " is 159.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Collections\ListBase.cs,ListGetItem,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Collections\ListBase.cs,ArrayInsert,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than or equal to Count."); " is 146.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Collections\ListBase.cs,ArrayRemoveAt,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Collections\ListBase.cs,InternalInsert,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than or equal to Count."); " is 146.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Collections\ListBase.cs,InternalRemoveAt,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Collections,ListBase,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Collections\ListBase.cs,InternalSetItem,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("index"' index' "The index must be greater than or equal to 0 and less than Count."); " is 134.
Long Statement,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\CombinedStream.cs,SetLength,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("value"' value' "The length of the stream must be greater than zero."); " is 120.
Long Statement,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\CombinedStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "Count must be less than the buffer's remaining length after the specified offset."); " is 150.
Long Statement,Xceed.Utils.Streams,NotifyStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\NotifyStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Complex Conditional,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The conditional expression  "size.Success && month.Success && day.Success && year.Success && time.Success"  is complex.
Complex Conditional,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The conditional expression  "date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success"  is complex.
Complex Conditional,Xceed.Ftp,FtpUnixListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpUNIXListingParser.cs,ParseLine,The conditional expression  "type.Success && size.Success && month.Success && day.Success && (year.Success || time.Success) && name.Success"  is complex.
Complex Conditional,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The conditional expression  "size.Success && day.Success && month.Success && year.Success && time.Success"  is complex.
Empty Catch Block,Xceed.Ftp,BackgroundWorkerWrapper,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(BackgroundWorkerWrapper)\BackgroundWorkerWrapper.cs,CancelWorkerAsync,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,ClearConnections,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpFile.cs,OnWriteStreamClosed,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpFile.cs,OpenWriteAlways,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpFile,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpFile.cs,OpenWriteAlways,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,UpdateStream,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,UpdateStream,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,OnReadStreamClosed,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,QuitCompleted,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,OnDownloadReadingFromStream,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,OnDownloadDataStreamClosed,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,OnUploadWritingToStream,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,OnUploadDataStreamClosed,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,AddLine,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,AddLine,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,DoDelete,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,ProcessPreliminaryReply,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,ProcessErrorReply,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,BeginProcessData,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,CopyStream,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,CopyStream,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataConsumerCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\FtpDataConsumerCommand.cs,TransferEnd,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,ProtectedBufferSizeFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ProtectedBufferSizeFtpCommand.cs,ProcessSuccessReply,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,Execute,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,RetrieveFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\RetrieveFileFtpCommand.cs,ParseFileSize,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommand.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,KeepAlive,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,KeepAlive,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataStream.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpTracing,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpTracing.cs,Write,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpTracing,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpTracing.cs,WriteLine,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpTracing,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpTracing.cs,DebugWriteLine,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,FtpTracing,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpTracing.cs,WriteLine,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,PassiveFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PassiveFtpDataChannel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,Xceed.Ftp.Engine,PortFtpDataChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\PortFtpDataChannel.cs,EndConnect,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\CombinedStream.cs,CombinedStream,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\CombinedStream.cs,Dispose,The method has an empty catch block.
Magic Number,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,The following statement contains a magic number: try {  	// Connect the FtpClient  	if (m_serverAddress == null) {  		#if ( XCEEDSSL )  		// If no AuthenticationMethod is provided or if in explicit ssl  		if ((m_authenticationMethod == AuthenticationMethod.None) || !m_implicitSsl) {  			if (m_port == 0) {  				client.Connect (m_hostName);  			}  			else {  				client.Connect (m_hostName' m_port);  			}  		}  		else {  			client.Connect (m_hostName' (m_port == 0) ? (990) : (m_port)' m_authenticationMethod' m_verificationFlags' m_clientCertificate);  		}  		#else  		            if( m_port == 0 )             {               client.Connect( m_hostName );             }             else             {               client.Connect( m_hostName' m_port );             } #endif  	}  	else {  		#if ( XCEEDSSL )  		System.Diagnostics.Debug.Assert (m_authenticationMethod == AuthenticationMethod.None);  		#endif  		client.Connect (m_serverAddress);  	}  }  catch {  	client.TraceWriter = null;  	#if ( XCEEDSSL )  	client.CertificateReceived -= new CertificateReceivedEventHandler (FtpClient_CertificateReceived);  	client.CertificateRequired -= new CertificateRequiredEventHandler (FtpClient_CertificateRequired);  	#endif  	client.ParsingListingLine -= new ParsingListingLineEventHandler (FtpClient_ParsingListingLine);  	client.Disconnected -= new EventHandler (FtpClient_Disconnected);  	throw;  }  
Magic Number,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,The following statement contains a magic number: if (m_serverAddress == null) {  	#if ( XCEEDSSL )  	// If no AuthenticationMethod is provided or if in explicit ssl  	if ((m_authenticationMethod == AuthenticationMethod.None) || !m_implicitSsl) {  		if (m_port == 0) {  			client.Connect (m_hostName);  		}  		else {  			client.Connect (m_hostName' m_port);  		}  	}  	else {  		client.Connect (m_hostName' (m_port == 0) ? (990) : (m_port)' m_authenticationMethod' m_verificationFlags' m_clientCertificate);  	}  	#else  	            if( m_port == 0 )             {               client.Connect( m_hostName );             }             else             {               client.Connect( m_hostName' m_port );             } #endif  }  else {  	#if ( XCEEDSSL )  	System.Diagnostics.Debug.Assert (m_authenticationMethod == AuthenticationMethod.None);  	#endif  	client.Connect (m_serverAddress);  }  
Magic Number,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,The following statement contains a magic number: if ((m_authenticationMethod == AuthenticationMethod.None) || !m_implicitSsl) {  	if (m_port == 0) {  		client.Connect (m_hostName);  	}  	else {  		client.Connect (m_hostName' m_port);  	}  }  else {  	client.Connect (m_hostName' (m_port == 0) ? (990) : (m_port)' m_authenticationMethod' m_verificationFlags' m_clientCertificate);  }  
Magic Number,Xceed.Ftp,FtpConnection,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpConnection.cs,CreateConnection,The following statement contains a magic number: client.Connect (m_hostName' (m_port == 0) ? (990) : (m_port)' m_authenticationMethod' m_verificationFlags' m_clientCertificate);  
Magic Number,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,Seek,The following statement contains a magic number: if (m_innerStream != null) {  	// If seeking within 32k forward' we simply read that number of bytes.  	if ((offset >= m_position) && (offset - m_position <= 32768)) {  		int count = unchecked((int)(offset - m_position));  		if (count > 0) {  			byte[] buffer = new byte[count];  			while (count > 0) {  				int read = m_innerStream.Read (buffer' 0' count);  				if (read == 0) {  					// We reached the end of the stream. Adjust offset and  					// close stream.  					offset -= count;  					m_innerStream.Close ();  					m_innerStream = null;  					break;  				}  				count -= read;  			}  		}  	}  	else {  		// We flush the current inner stream and simply set the position member.  		// Next time data is read' we will get a new stream at the proper position.  		m_innerStream.Close ();  		m_innerStream = null;  	}  }  
Magic Number,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,Seek,The following statement contains a magic number: if ((offset >= m_position) && (offset - m_position <= 32768)) {  	int count = unchecked((int)(offset - m_position));  	if (count > 0) {  		byte[] buffer = new byte[count];  		while (count > 0) {  			int read = m_innerStream.Read (buffer' 0' count);  			if (read == 0) {  				// We reached the end of the stream. Adjust offset and  				// close stream.  				offset -= count;  				m_innerStream.Close ();  				m_innerStream = null;  				break;  			}  			count -= read;  		}  	}  }  else {  	// We flush the current inner stream and simply set the position member.  	// Next time data is read' we will get a new stream at the proper position.  	m_innerStream.Close ();  	m_innerStream = null;  }  
Magic Number,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The following statement contains a magic number: if (serverAddress.Port == 0) {  	serverAddress.Port = 21;  }  
Magic Number,Xceed.Ftp,AsyncFtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\AsyncFtpClient.cs,BeginConnect,The following statement contains a magic number: serverAddress.Port = 21;  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group size = match.Groups ["size"];  	Group month = match.Groups ["month"];  	Group day = match.Groups ["day"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group type = match.Groups ["type"];  	Group name = match.Groups ["name"];  	if (type.Success && name.Success) {  		FtpItemInfo entry = null;  		if (size.Success && month.Success && day.Success && year.Success && time.Success) {  			entry = this.CreateItem ();  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (monthValue > 12) {  				int temp = dayValue;  				dayValue = monthValue;  				monthValue = temp;  			}  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.DateTime = lastWrite;  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// If we have a previous item' it means it was already complete.  			// We return it and buffer this one. Else we buffer this one  			// and return an empty entry.  			try {  				if (m_lastEntry == null) {  					return FtpItemInfo.Empty;  				}  				else {  					return m_lastEntry;  				}  			}  			finally {  				m_lastEntry = entry;  			}  		}  		else if (m_lastEntry == null) {  			// Case 77714: We now support this scenario.  			entry = this.CreateItem ();  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// We don't need to buffer this item.  			return entry;  		}  		else {  			// Normally' this second line should be of type "MEM". But we still   			// accept any type for the moment' as long as it ends with the same name.  			System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  			// In any case' we'll return the last entry' resetting it to null  			// afterward.  			try {  				if (name.Value.StartsWith (m_lastEntry.Name)) {  					// Yes' it's a second line for the same entry! We use the  					// second line's filename.  					string nameValue = name.Value.TrimEnd (' ');  					if (nameValue.EndsWith ("/")) {  						m_lastEntry.Type = FtpItemType.Folder;  						nameValue = nameValue.Substring (0' nameValue.Length - 1);  					}  					m_lastEntry.Name = nameValue;  				}  				// Else: Though we discard this non-matching incomplete line'  				//       it does not mean the previous line was invalid. We  				//       still must return it.  				return m_lastEntry;  			}  			finally {  				m_lastEntry = null;  			}  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group size = match.Groups ["size"];  	Group month = match.Groups ["month"];  	Group day = match.Groups ["day"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group type = match.Groups ["type"];  	Group name = match.Groups ["name"];  	if (type.Success && name.Success) {  		FtpItemInfo entry = null;  		if (size.Success && month.Success && day.Success && year.Success && time.Success) {  			entry = this.CreateItem ();  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (monthValue > 12) {  				int temp = dayValue;  				dayValue = monthValue;  				monthValue = temp;  			}  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.DateTime = lastWrite;  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// If we have a previous item' it means it was already complete.  			// We return it and buffer this one. Else we buffer this one  			// and return an empty entry.  			try {  				if (m_lastEntry == null) {  					return FtpItemInfo.Empty;  				}  				else {  					return m_lastEntry;  				}  			}  			finally {  				m_lastEntry = entry;  			}  		}  		else if (m_lastEntry == null) {  			// Case 77714: We now support this scenario.  			entry = this.CreateItem ();  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// We don't need to buffer this item.  			return entry;  		}  		else {  			// Normally' this second line should be of type "MEM". But we still   			// accept any type for the moment' as long as it ends with the same name.  			System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  			// In any case' we'll return the last entry' resetting it to null  			// afterward.  			try {  				if (name.Value.StartsWith (m_lastEntry.Name)) {  					// Yes' it's a second line for the same entry! We use the  					// second line's filename.  					string nameValue = name.Value.TrimEnd (' ');  					if (nameValue.EndsWith ("/")) {  						m_lastEntry.Type = FtpItemType.Folder;  						nameValue = nameValue.Substring (0' nameValue.Length - 1);  					}  					m_lastEntry.Name = nameValue;  				}  				// Else: Though we discard this non-matching incomplete line'  				//       it does not mean the previous line was invalid. We  				//       still must return it.  				return m_lastEntry;  			}  			finally {  				m_lastEntry = null;  			}  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group size = match.Groups ["size"];  	Group month = match.Groups ["month"];  	Group day = match.Groups ["day"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group type = match.Groups ["type"];  	Group name = match.Groups ["name"];  	if (type.Success && name.Success) {  		FtpItemInfo entry = null;  		if (size.Success && month.Success && day.Success && year.Success && time.Success) {  			entry = this.CreateItem ();  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (monthValue > 12) {  				int temp = dayValue;  				dayValue = monthValue;  				monthValue = temp;  			}  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.DateTime = lastWrite;  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// If we have a previous item' it means it was already complete.  			// We return it and buffer this one. Else we buffer this one  			// and return an empty entry.  			try {  				if (m_lastEntry == null) {  					return FtpItemInfo.Empty;  				}  				else {  					return m_lastEntry;  				}  			}  			finally {  				m_lastEntry = entry;  			}  		}  		else if (m_lastEntry == null) {  			// Case 77714: We now support this scenario.  			entry = this.CreateItem ();  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// We don't need to buffer this item.  			return entry;  		}  		else {  			// Normally' this second line should be of type "MEM". But we still   			// accept any type for the moment' as long as it ends with the same name.  			System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  			// In any case' we'll return the last entry' resetting it to null  			// afterward.  			try {  				if (name.Value.StartsWith (m_lastEntry.Name)) {  					// Yes' it's a second line for the same entry! We use the  					// second line's filename.  					string nameValue = name.Value.TrimEnd (' ');  					if (nameValue.EndsWith ("/")) {  						m_lastEntry.Type = FtpItemType.Folder;  						nameValue = nameValue.Substring (0' nameValue.Length - 1);  					}  					m_lastEntry.Name = nameValue;  				}  				// Else: Though we discard this non-matching incomplete line'  				//       it does not mean the previous line was invalid. We  				//       still must return it.  				return m_lastEntry;  			}  			finally {  				m_lastEntry = null;  			}  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group size = match.Groups ["size"];  	Group month = match.Groups ["month"];  	Group day = match.Groups ["day"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group type = match.Groups ["type"];  	Group name = match.Groups ["name"];  	if (type.Success && name.Success) {  		FtpItemInfo entry = null;  		if (size.Success && month.Success && day.Success && year.Success && time.Success) {  			entry = this.CreateItem ();  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (monthValue > 12) {  				int temp = dayValue;  				dayValue = monthValue;  				monthValue = temp;  			}  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.DateTime = lastWrite;  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// If we have a previous item' it means it was already complete.  			// We return it and buffer this one. Else we buffer this one  			// and return an empty entry.  			try {  				if (m_lastEntry == null) {  					return FtpItemInfo.Empty;  				}  				else {  					return m_lastEntry;  				}  			}  			finally {  				m_lastEntry = entry;  			}  		}  		else if (m_lastEntry == null) {  			// Case 77714: We now support this scenario.  			entry = this.CreateItem ();  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// We don't need to buffer this item.  			return entry;  		}  		else {  			// Normally' this second line should be of type "MEM". But we still   			// accept any type for the moment' as long as it ends with the same name.  			System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  			// In any case' we'll return the last entry' resetting it to null  			// afterward.  			try {  				if (name.Value.StartsWith (m_lastEntry.Name)) {  					// Yes' it's a second line for the same entry! We use the  					// second line's filename.  					string nameValue = name.Value.TrimEnd (' ');  					if (nameValue.EndsWith ("/")) {  						m_lastEntry.Type = FtpItemType.Folder;  						nameValue = nameValue.Substring (0' nameValue.Length - 1);  					}  					m_lastEntry.Name = nameValue;  				}  				// Else: Though we discard this non-matching incomplete line'  				//       it does not mean the previous line was invalid. We  				//       still must return it.  				return m_lastEntry;  			}  			finally {  				m_lastEntry = null;  			}  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group size = match.Groups ["size"];  	Group month = match.Groups ["month"];  	Group day = match.Groups ["day"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group type = match.Groups ["type"];  	Group name = match.Groups ["name"];  	if (type.Success && name.Success) {  		FtpItemInfo entry = null;  		if (size.Success && month.Success && day.Success && year.Success && time.Success) {  			entry = this.CreateItem ();  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (monthValue > 12) {  				int temp = dayValue;  				dayValue = monthValue;  				monthValue = temp;  			}  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.DateTime = lastWrite;  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// If we have a previous item' it means it was already complete.  			// We return it and buffer this one. Else we buffer this one  			// and return an empty entry.  			try {  				if (m_lastEntry == null) {  					return FtpItemInfo.Empty;  				}  				else {  					return m_lastEntry;  				}  			}  			finally {  				m_lastEntry = entry;  			}  		}  		else if (m_lastEntry == null) {  			// Case 77714: We now support this scenario.  			entry = this.CreateItem ();  			// We parse the filename first' to check for an ending slash  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				entry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			entry.Name = nameValue;  			if (entry.Type == FtpItemType.Unknown) {  				string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  				if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  					entry.Type = FtpItemType.Folder;  				}  				else {  					entry.Type = FtpItemType.File;  				}  			}  			// We don't need to buffer this item.  			return entry;  		}  		else {  			// Normally' this second line should be of type "MEM". But we still   			// accept any type for the moment' as long as it ends with the same name.  			System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  			// In any case' we'll return the last entry' resetting it to null  			// afterward.  			try {  				if (name.Value.StartsWith (m_lastEntry.Name)) {  					// Yes' it's a second line for the same entry! We use the  					// second line's filename.  					string nameValue = name.Value.TrimEnd (' ');  					if (nameValue.EndsWith ("/")) {  						m_lastEntry.Type = FtpItemType.Folder;  						nameValue = nameValue.Substring (0' nameValue.Length - 1);  					}  					m_lastEntry.Name = nameValue;  				}  				// Else: Though we discard this non-matching incomplete line'  				//       it does not mean the previous line was invalid. We  				//       still must return it.  				return m_lastEntry;  			}  			finally {  				m_lastEntry = null;  			}  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (type.Success && name.Success) {  	FtpItemInfo entry = null;  	if (size.Success && month.Success && day.Success && year.Success && time.Success) {  		entry = this.CreateItem ();  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (monthValue > 12) {  			int temp = dayValue;  			dayValue = monthValue;  			monthValue = temp;  		}  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.DateTime = lastWrite;  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// If we have a previous item' it means it was already complete.  		// We return it and buffer this one. Else we buffer this one  		// and return an empty entry.  		try {  			if (m_lastEntry == null) {  				return FtpItemInfo.Empty;  			}  			else {  				return m_lastEntry;  			}  		}  		finally {  			m_lastEntry = entry;  		}  	}  	else if (m_lastEntry == null) {  		// Case 77714: We now support this scenario.  		entry = this.CreateItem ();  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// We don't need to buffer this item.  		return entry;  	}  	else {  		// Normally' this second line should be of type "MEM". But we still   		// accept any type for the moment' as long as it ends with the same name.  		System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  		// In any case' we'll return the last entry' resetting it to null  		// afterward.  		try {  			if (name.Value.StartsWith (m_lastEntry.Name)) {  				// Yes' it's a second line for the same entry! We use the  				// second line's filename.  				string nameValue = name.Value.TrimEnd (' ');  				if (nameValue.EndsWith ("/")) {  					m_lastEntry.Type = FtpItemType.Folder;  					nameValue = nameValue.Substring (0' nameValue.Length - 1);  				}  				m_lastEntry.Name = nameValue;  			}  			// Else: Though we discard this non-matching incomplete line'  			//       it does not mean the previous line was invalid. We  			//       still must return it.  			return m_lastEntry;  		}  		finally {  			m_lastEntry = null;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (type.Success && name.Success) {  	FtpItemInfo entry = null;  	if (size.Success && month.Success && day.Success && year.Success && time.Success) {  		entry = this.CreateItem ();  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (monthValue > 12) {  			int temp = dayValue;  			dayValue = monthValue;  			monthValue = temp;  		}  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.DateTime = lastWrite;  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// If we have a previous item' it means it was already complete.  		// We return it and buffer this one. Else we buffer this one  		// and return an empty entry.  		try {  			if (m_lastEntry == null) {  				return FtpItemInfo.Empty;  			}  			else {  				return m_lastEntry;  			}  		}  		finally {  			m_lastEntry = entry;  		}  	}  	else if (m_lastEntry == null) {  		// Case 77714: We now support this scenario.  		entry = this.CreateItem ();  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// We don't need to buffer this item.  		return entry;  	}  	else {  		// Normally' this second line should be of type "MEM". But we still   		// accept any type for the moment' as long as it ends with the same name.  		System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  		// In any case' we'll return the last entry' resetting it to null  		// afterward.  		try {  			if (name.Value.StartsWith (m_lastEntry.Name)) {  				// Yes' it's a second line for the same entry! We use the  				// second line's filename.  				string nameValue = name.Value.TrimEnd (' ');  				if (nameValue.EndsWith ("/")) {  					m_lastEntry.Type = FtpItemType.Folder;  					nameValue = nameValue.Substring (0' nameValue.Length - 1);  				}  				m_lastEntry.Name = nameValue;  			}  			// Else: Though we discard this non-matching incomplete line'  			//       it does not mean the previous line was invalid. We  			//       still must return it.  			return m_lastEntry;  		}  		finally {  			m_lastEntry = null;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (type.Success && name.Success) {  	FtpItemInfo entry = null;  	if (size.Success && month.Success && day.Success && year.Success && time.Success) {  		entry = this.CreateItem ();  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (monthValue > 12) {  			int temp = dayValue;  			dayValue = monthValue;  			monthValue = temp;  		}  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.DateTime = lastWrite;  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// If we have a previous item' it means it was already complete.  		// We return it and buffer this one. Else we buffer this one  		// and return an empty entry.  		try {  			if (m_lastEntry == null) {  				return FtpItemInfo.Empty;  			}  			else {  				return m_lastEntry;  			}  		}  		finally {  			m_lastEntry = entry;  		}  	}  	else if (m_lastEntry == null) {  		// Case 77714: We now support this scenario.  		entry = this.CreateItem ();  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// We don't need to buffer this item.  		return entry;  	}  	else {  		// Normally' this second line should be of type "MEM". But we still   		// accept any type for the moment' as long as it ends with the same name.  		System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  		// In any case' we'll return the last entry' resetting it to null  		// afterward.  		try {  			if (name.Value.StartsWith (m_lastEntry.Name)) {  				// Yes' it's a second line for the same entry! We use the  				// second line's filename.  				string nameValue = name.Value.TrimEnd (' ');  				if (nameValue.EndsWith ("/")) {  					m_lastEntry.Type = FtpItemType.Folder;  					nameValue = nameValue.Substring (0' nameValue.Length - 1);  				}  				m_lastEntry.Name = nameValue;  			}  			// Else: Though we discard this non-matching incomplete line'  			//       it does not mean the previous line was invalid. We  			//       still must return it.  			return m_lastEntry;  		}  		finally {  			m_lastEntry = null;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (type.Success && name.Success) {  	FtpItemInfo entry = null;  	if (size.Success && month.Success && day.Success && year.Success && time.Success) {  		entry = this.CreateItem ();  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (monthValue > 12) {  			int temp = dayValue;  			dayValue = monthValue;  			monthValue = temp;  		}  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.DateTime = lastWrite;  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// If we have a previous item' it means it was already complete.  		// We return it and buffer this one. Else we buffer this one  		// and return an empty entry.  		try {  			if (m_lastEntry == null) {  				return FtpItemInfo.Empty;  			}  			else {  				return m_lastEntry;  			}  		}  		finally {  			m_lastEntry = entry;  		}  	}  	else if (m_lastEntry == null) {  		// Case 77714: We now support this scenario.  		entry = this.CreateItem ();  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// We don't need to buffer this item.  		return entry;  	}  	else {  		// Normally' this second line should be of type "MEM". But we still   		// accept any type for the moment' as long as it ends with the same name.  		System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  		// In any case' we'll return the last entry' resetting it to null  		// afterward.  		try {  			if (name.Value.StartsWith (m_lastEntry.Name)) {  				// Yes' it's a second line for the same entry! We use the  				// second line's filename.  				string nameValue = name.Value.TrimEnd (' ');  				if (nameValue.EndsWith ("/")) {  					m_lastEntry.Type = FtpItemType.Folder;  					nameValue = nameValue.Substring (0' nameValue.Length - 1);  				}  				m_lastEntry.Name = nameValue;  			}  			// Else: Though we discard this non-matching incomplete line'  			//       it does not mean the previous line was invalid. We  			//       still must return it.  			return m_lastEntry;  		}  		finally {  			m_lastEntry = null;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (type.Success && name.Success) {  	FtpItemInfo entry = null;  	if (size.Success && month.Success && day.Success && year.Success && time.Success) {  		entry = this.CreateItem ();  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (monthValue > 12) {  			int temp = dayValue;  			dayValue = monthValue;  			monthValue = temp;  		}  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.DateTime = lastWrite;  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// If we have a previous item' it means it was already complete.  		// We return it and buffer this one. Else we buffer this one  		// and return an empty entry.  		try {  			if (m_lastEntry == null) {  				return FtpItemInfo.Empty;  			}  			else {  				return m_lastEntry;  			}  		}  		finally {  			m_lastEntry = entry;  		}  	}  	else if (m_lastEntry == null) {  		// Case 77714: We now support this scenario.  		entry = this.CreateItem ();  		// We parse the filename first' to check for an ending slash  		string nameValue = name.Value.TrimEnd (' ');  		if (nameValue.EndsWith ("/")) {  			entry.Type = FtpItemType.Folder;  			nameValue = nameValue.Substring (0' nameValue.Length - 1);  		}  		entry.Name = nameValue;  		if (entry.Type == FtpItemType.Unknown) {  			string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  			if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  				entry.Type = FtpItemType.Folder;  			}  			else {  				entry.Type = FtpItemType.File;  			}  		}  		// We don't need to buffer this item.  		return entry;  	}  	else {  		// Normally' this second line should be of type "MEM". But we still   		// accept any type for the moment' as long as it ends with the same name.  		System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  		// In any case' we'll return the last entry' resetting it to null  		// afterward.  		try {  			if (name.Value.StartsWith (m_lastEntry.Name)) {  				// Yes' it's a second line for the same entry! We use the  				// second line's filename.  				string nameValue = name.Value.TrimEnd (' ');  				if (nameValue.EndsWith ("/")) {  					m_lastEntry.Type = FtpItemType.Folder;  					nameValue = nameValue.Substring (0' nameValue.Length - 1);  				}  				m_lastEntry.Name = nameValue;  			}  			// Else: Though we discard this non-matching incomplete line'  			//       it does not mean the previous line was invalid. We  			//       still must return it.  			return m_lastEntry;  		}  		finally {  			m_lastEntry = null;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && month.Success && day.Success && year.Success && time.Success) {  	entry = this.CreateItem ();  	entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (monthValue > 12) {  		int temp = dayValue;  		dayValue = monthValue;  		monthValue = temp;  	}  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.DateTime = lastWrite;  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// If we have a previous item' it means it was already complete.  	// We return it and buffer this one. Else we buffer this one  	// and return an empty entry.  	try {  		if (m_lastEntry == null) {  			return FtpItemInfo.Empty;  		}  		else {  			return m_lastEntry;  		}  	}  	finally {  		m_lastEntry = entry;  	}  }  else if (m_lastEntry == null) {  	// Case 77714: We now support this scenario.  	entry = this.CreateItem ();  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// We don't need to buffer this item.  	return entry;  }  else {  	// Normally' this second line should be of type "MEM". But we still   	// accept any type for the moment' as long as it ends with the same name.  	System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  	// In any case' we'll return the last entry' resetting it to null  	// afterward.  	try {  		if (name.Value.StartsWith (m_lastEntry.Name)) {  			// Yes' it's a second line for the same entry! We use the  			// second line's filename.  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				m_lastEntry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			m_lastEntry.Name = nameValue;  		}  		// Else: Though we discard this non-matching incomplete line'  		//       it does not mean the previous line was invalid. We  		//       still must return it.  		return m_lastEntry;  	}  	finally {  		m_lastEntry = null;  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && month.Success && day.Success && year.Success && time.Success) {  	entry = this.CreateItem ();  	entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (monthValue > 12) {  		int temp = dayValue;  		dayValue = monthValue;  		monthValue = temp;  	}  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.DateTime = lastWrite;  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// If we have a previous item' it means it was already complete.  	// We return it and buffer this one. Else we buffer this one  	// and return an empty entry.  	try {  		if (m_lastEntry == null) {  			return FtpItemInfo.Empty;  		}  		else {  			return m_lastEntry;  		}  	}  	finally {  		m_lastEntry = entry;  	}  }  else if (m_lastEntry == null) {  	// Case 77714: We now support this scenario.  	entry = this.CreateItem ();  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// We don't need to buffer this item.  	return entry;  }  else {  	// Normally' this second line should be of type "MEM". But we still   	// accept any type for the moment' as long as it ends with the same name.  	System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  	// In any case' we'll return the last entry' resetting it to null  	// afterward.  	try {  		if (name.Value.StartsWith (m_lastEntry.Name)) {  			// Yes' it's a second line for the same entry! We use the  			// second line's filename.  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				m_lastEntry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			m_lastEntry.Name = nameValue;  		}  		// Else: Though we discard this non-matching incomplete line'  		//       it does not mean the previous line was invalid. We  		//       still must return it.  		return m_lastEntry;  	}  	finally {  		m_lastEntry = null;  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && month.Success && day.Success && year.Success && time.Success) {  	entry = this.CreateItem ();  	entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (monthValue > 12) {  		int temp = dayValue;  		dayValue = monthValue;  		monthValue = temp;  	}  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.DateTime = lastWrite;  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// If we have a previous item' it means it was already complete.  	// We return it and buffer this one. Else we buffer this one  	// and return an empty entry.  	try {  		if (m_lastEntry == null) {  			return FtpItemInfo.Empty;  		}  		else {  			return m_lastEntry;  		}  	}  	finally {  		m_lastEntry = entry;  	}  }  else if (m_lastEntry == null) {  	// Case 77714: We now support this scenario.  	entry = this.CreateItem ();  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// We don't need to buffer this item.  	return entry;  }  else {  	// Normally' this second line should be of type "MEM". But we still   	// accept any type for the moment' as long as it ends with the same name.  	System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  	// In any case' we'll return the last entry' resetting it to null  	// afterward.  	try {  		if (name.Value.StartsWith (m_lastEntry.Name)) {  			// Yes' it's a second line for the same entry! We use the  			// second line's filename.  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				m_lastEntry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			m_lastEntry.Name = nameValue;  		}  		// Else: Though we discard this non-matching incomplete line'  		//       it does not mean the previous line was invalid. We  		//       still must return it.  		return m_lastEntry;  	}  	finally {  		m_lastEntry = null;  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && month.Success && day.Success && year.Success && time.Success) {  	entry = this.CreateItem ();  	entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (monthValue > 12) {  		int temp = dayValue;  		dayValue = monthValue;  		monthValue = temp;  	}  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.DateTime = lastWrite;  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// If we have a previous item' it means it was already complete.  	// We return it and buffer this one. Else we buffer this one  	// and return an empty entry.  	try {  		if (m_lastEntry == null) {  			return FtpItemInfo.Empty;  		}  		else {  			return m_lastEntry;  		}  	}  	finally {  		m_lastEntry = entry;  	}  }  else if (m_lastEntry == null) {  	// Case 77714: We now support this scenario.  	entry = this.CreateItem ();  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// We don't need to buffer this item.  	return entry;  }  else {  	// Normally' this second line should be of type "MEM". But we still   	// accept any type for the moment' as long as it ends with the same name.  	System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  	// In any case' we'll return the last entry' resetting it to null  	// afterward.  	try {  		if (name.Value.StartsWith (m_lastEntry.Name)) {  			// Yes' it's a second line for the same entry! We use the  			// second line's filename.  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				m_lastEntry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			m_lastEntry.Name = nameValue;  		}  		// Else: Though we discard this non-matching incomplete line'  		//       it does not mean the previous line was invalid. We  		//       still must return it.  		return m_lastEntry;  	}  	finally {  		m_lastEntry = null;  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && month.Success && day.Success && year.Success && time.Success) {  	entry = this.CreateItem ();  	entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int monthValue = int.Parse (month.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (monthValue > 12) {  		int temp = dayValue;  		dayValue = monthValue;  		monthValue = temp;  	}  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.DateTime = lastWrite;  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// If we have a previous item' it means it was already complete.  	// We return it and buffer this one. Else we buffer this one  	// and return an empty entry.  	try {  		if (m_lastEntry == null) {  			return FtpItemInfo.Empty;  		}  		else {  			return m_lastEntry;  		}  	}  	finally {  		m_lastEntry = entry;  	}  }  else if (m_lastEntry == null) {  	// Case 77714: We now support this scenario.  	entry = this.CreateItem ();  	// We parse the filename first' to check for an ending slash  	string nameValue = name.Value.TrimEnd (' ');  	if (nameValue.EndsWith ("/")) {  		entry.Type = FtpItemType.Folder;  		nameValue = nameValue.Substring (0' nameValue.Length - 1);  	}  	entry.Name = nameValue;  	if (entry.Type == FtpItemType.Unknown) {  		string typeValue = type.Value.ToUpper (CultureInfo.InvariantCulture);  		if ((typeValue == "DIR") || (typeValue == "DDIR") || (typeValue == "FLR")) {  			entry.Type = FtpItemType.Folder;  		}  		else {  			entry.Type = FtpItemType.File;  		}  	}  	// We don't need to buffer this item.  	return entry;  }  else {  	// Normally' this second line should be of type "MEM". But we still   	// accept any type for the moment' as long as it ends with the same name.  	System.Diagnostics.Debug.Assert (type.Value.ToUpper (CultureInfo.InvariantCulture) == "MEM");  	// In any case' we'll return the last entry' resetting it to null  	// afterward.  	try {  		if (name.Value.StartsWith (m_lastEntry.Name)) {  			// Yes' it's a second line for the same entry! We use the  			// second line's filename.  			string nameValue = name.Value.TrimEnd (' ');  			if (nameValue.EndsWith ("/")) {  				m_lastEntry.Type = FtpItemType.Folder;  				nameValue = nameValue.Substring (0' nameValue.Length - 1);  			}  			m_lastEntry.Name = nameValue;  		}  		// Else: Though we discard this non-matching incomplete line'  		//       it does not mean the previous line was invalid. We  		//       still must return it.  		return m_lastEntry;  	}  	finally {  		m_lastEntry = null;  	}  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (monthValue > 12) {  	int temp = dayValue;  	dayValue = monthValue;  	monthValue = temp;  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: yearValue += 2000;  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpAS400ListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpAS400ListingParser.cs,ParseLine,The following statement contains a magic number: yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: if (serverAddress.Port == 0) {  	serverAddress.Port = 21;  }  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: serverAddress.Port = 21;  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: if (serverAddress.Port == 0) {  	if (authenticationMethod == AuthenticationMethod.None) {  		serverAddress.Port = 21;  	}  	else {  		serverAddress.Port = 990;  	}  }  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: if (serverAddress.Port == 0) {  	if (authenticationMethod == AuthenticationMethod.None) {  		serverAddress.Port = 21;  	}  	else {  		serverAddress.Port = 990;  	}  }  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: if (authenticationMethod == AuthenticationMethod.None) {  	serverAddress.Port = 21;  }  else {  	serverAddress.Port = 990;  }  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: if (authenticationMethod == AuthenticationMethod.None) {  	serverAddress.Port = 21;  }  else {  	serverAddress.Port = 990;  }  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: serverAddress.Port = 21;  
Magic Number,Xceed.Ftp,FtpClient,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpClient.cs,Connect,The following statement contains a magic number: serverAddress.Port = 990;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group date1 = match.Groups ["date1"];  	Group date2 = match.Groups ["date2"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group dir = match.Groups ["dir"];  	Group size = match.Groups ["size"];  	Group name = match.Groups ["name"];  	if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  		FtpItemInfo entry = this.CreateItem ();  		// date1 is assumed a month' and date2 a day' unless  		// date1 is greater than 12.  		int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 80)  			yearValue += 2000;  		else if (yearValue < 100)  			yearValue += 1900;  		DateTime lastWrite;  		if (value1 > 12) {  			lastWrite = new DateTime (yearValue' value2' value1);  		}  		else {  			lastWrite = new DateTime (yearValue' value1' value2);  		}  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  		if (dir.Success) {  			entry.Type = FtpItemType.Folder;  			entry.Size = 0;  		}  		else {  			entry.Type = FtpItemType.File;  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		}  		entry.Name = name.Value.TrimEnd (' ');  		return entry;  	}  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group date1 = match.Groups ["date1"];  	Group date2 = match.Groups ["date2"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group dir = match.Groups ["dir"];  	Group size = match.Groups ["size"];  	Group name = match.Groups ["name"];  	if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  		FtpItemInfo entry = this.CreateItem ();  		// date1 is assumed a month' and date2 a day' unless  		// date1 is greater than 12.  		int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 80)  			yearValue += 2000;  		else if (yearValue < 100)  			yearValue += 1900;  		DateTime lastWrite;  		if (value1 > 12) {  			lastWrite = new DateTime (yearValue' value2' value1);  		}  		else {  			lastWrite = new DateTime (yearValue' value1' value2);  		}  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  		if (dir.Success) {  			entry.Type = FtpItemType.Folder;  			entry.Size = 0;  		}  		else {  			entry.Type = FtpItemType.File;  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		}  		entry.Name = name.Value.TrimEnd (' ');  		return entry;  	}  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group date1 = match.Groups ["date1"];  	Group date2 = match.Groups ["date2"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group dir = match.Groups ["dir"];  	Group size = match.Groups ["size"];  	Group name = match.Groups ["name"];  	if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  		FtpItemInfo entry = this.CreateItem ();  		// date1 is assumed a month' and date2 a day' unless  		// date1 is greater than 12.  		int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 80)  			yearValue += 2000;  		else if (yearValue < 100)  			yearValue += 1900;  		DateTime lastWrite;  		if (value1 > 12) {  			lastWrite = new DateTime (yearValue' value2' value1);  		}  		else {  			lastWrite = new DateTime (yearValue' value1' value2);  		}  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  		if (dir.Success) {  			entry.Type = FtpItemType.Folder;  			entry.Size = 0;  		}  		else {  			entry.Type = FtpItemType.File;  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		}  		entry.Name = name.Value.TrimEnd (' ');  		return entry;  	}  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group date1 = match.Groups ["date1"];  	Group date2 = match.Groups ["date2"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group dir = match.Groups ["dir"];  	Group size = match.Groups ["size"];  	Group name = match.Groups ["name"];  	if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  		FtpItemInfo entry = this.CreateItem ();  		// date1 is assumed a month' and date2 a day' unless  		// date1 is greater than 12.  		int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 80)  			yearValue += 2000;  		else if (yearValue < 100)  			yearValue += 1900;  		DateTime lastWrite;  		if (value1 > 12) {  			lastWrite = new DateTime (yearValue' value2' value1);  		}  		else {  			lastWrite = new DateTime (yearValue' value1' value2);  		}  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  		if (dir.Success) {  			entry.Type = FtpItemType.Folder;  			entry.Size = 0;  		}  		else {  			entry.Type = FtpItemType.File;  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		}  		entry.Name = name.Value.TrimEnd (' ');  		return entry;  	}  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group date1 = match.Groups ["date1"];  	Group date2 = match.Groups ["date2"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group dir = match.Groups ["dir"];  	Group size = match.Groups ["size"];  	Group name = match.Groups ["name"];  	if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  		FtpItemInfo entry = this.CreateItem ();  		// date1 is assumed a month' and date2 a day' unless  		// date1 is greater than 12.  		int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 80)  			yearValue += 2000;  		else if (yearValue < 100)  			yearValue += 1900;  		DateTime lastWrite;  		if (value1 > 12) {  			lastWrite = new DateTime (yearValue' value2' value1);  		}  		else {  			lastWrite = new DateTime (yearValue' value1' value2);  		}  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  		if (dir.Success) {  			entry.Type = FtpItemType.Folder;  			entry.Size = 0;  		}  		else {  			entry.Type = FtpItemType.File;  			entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		}  		entry.Name = name.Value.TrimEnd (' ');  		return entry;  	}  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  	FtpItemInfo entry = this.CreateItem ();  	// date1 is assumed a month' and date2 a day' unless  	// date1 is greater than 12.  	int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 80)  		yearValue += 2000;  	else if (yearValue < 100)  		yearValue += 1900;  	DateTime lastWrite;  	if (value1 > 12) {  		lastWrite = new DateTime (yearValue' value2' value1);  	}  	else {  		lastWrite = new DateTime (yearValue' value1' value2);  	}  	DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  	entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  	if (dir.Success) {  		entry.Type = FtpItemType.Folder;  		entry.Size = 0;  	}  	else {  		entry.Type = FtpItemType.File;  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	}  	entry.Name = name.Value.TrimEnd (' ');  	return entry;  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  	FtpItemInfo entry = this.CreateItem ();  	// date1 is assumed a month' and date2 a day' unless  	// date1 is greater than 12.  	int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 80)  		yearValue += 2000;  	else if (yearValue < 100)  		yearValue += 1900;  	DateTime lastWrite;  	if (value1 > 12) {  		lastWrite = new DateTime (yearValue' value2' value1);  	}  	else {  		lastWrite = new DateTime (yearValue' value1' value2);  	}  	DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  	entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  	if (dir.Success) {  		entry.Type = FtpItemType.Folder;  		entry.Size = 0;  	}  	else {  		entry.Type = FtpItemType.File;  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	}  	entry.Name = name.Value.TrimEnd (' ');  	return entry;  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  	FtpItemInfo entry = this.CreateItem ();  	// date1 is assumed a month' and date2 a day' unless  	// date1 is greater than 12.  	int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 80)  		yearValue += 2000;  	else if (yearValue < 100)  		yearValue += 1900;  	DateTime lastWrite;  	if (value1 > 12) {  		lastWrite = new DateTime (yearValue' value2' value1);  	}  	else {  		lastWrite = new DateTime (yearValue' value1' value2);  	}  	DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  	entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  	if (dir.Success) {  		entry.Type = FtpItemType.Folder;  		entry.Size = 0;  	}  	else {  		entry.Type = FtpItemType.File;  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	}  	entry.Name = name.Value.TrimEnd (' ');  	return entry;  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  	FtpItemInfo entry = this.CreateItem ();  	// date1 is assumed a month' and date2 a day' unless  	// date1 is greater than 12.  	int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 80)  		yearValue += 2000;  	else if (yearValue < 100)  		yearValue += 1900;  	DateTime lastWrite;  	if (value1 > 12) {  		lastWrite = new DateTime (yearValue' value2' value1);  	}  	else {  		lastWrite = new DateTime (yearValue' value1' value2);  	}  	DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  	entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  	if (dir.Success) {  		entry.Type = FtpItemType.Folder;  		entry.Size = 0;  	}  	else {  		entry.Type = FtpItemType.File;  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	}  	entry.Name = name.Value.TrimEnd (' ');  	return entry;  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (date1.Success && date2.Success && time.Success && (dir.Success || size.Success) && name.Success) {  	FtpItemInfo entry = this.CreateItem ();  	// date1 is assumed a month' and date2 a day' unless  	// date1 is greater than 12.  	int value1 = int.Parse (date1.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int value2 = int.Parse (date2.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 80)  		yearValue += 2000;  	else if (yearValue < 100)  		yearValue += 1900;  	DateTime lastWrite;  	if (value1 > 12) {  		lastWrite = new DateTime (yearValue' value2' value1);  	}  	else {  		lastWrite = new DateTime (yearValue' value1' value2);  	}  	DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  	entry.DateTime = lastWrite.Add (timeValue.TimeOfDay);  	if (dir.Success) {  		entry.Type = FtpItemType.Folder;  		entry.Size = 0;  	}  	else {  		entry.Type = FtpItemType.File;  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	}  	entry.Name = name.Value.TrimEnd (' ');  	return entry;  }  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 80)  	yearValue += 2000;  else if (yearValue < 100)  	yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 80)  	yearValue += 2000;  else if (yearValue < 100)  	yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 80)  	yearValue += 2000;  else if (yearValue < 100)  	yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 80)  	yearValue += 2000;  else if (yearValue < 100)  	yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: yearValue += 2000;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 100)  	yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 100)  	yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: yearValue += 1900;  
Magic Number,Xceed.Ftp,FtpDosListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpDOSListingParser.cs,ParseLine,The following statement contains a magic number: if (value1 > 12) {  	lastWrite = new DateTime (yearValue' value2' value1);  }  else {  	lastWrite = new DateTime (yearValue' value1' value2);  }  
Magic Number,Xceed.Ftp,FtpListingParserList,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpListingParserList.cs,ParseListing,The following statement contains a magic number: for (int lineIndex = 0; lineIndex <= lineCount; lineIndex++) {  	// "null" for last call' not string.Empty!  	string line = (lineIndex == lineCount) ? null : lines [lineIndex];  	FtpItemInfo bestEntry = null;  	// This loop may remove a parser from the collection. That's why  	// we iterate backward on index.  	for (int selIndex = selectors.Count - 1; selIndex >= 0; selIndex--) {  		ParserSelector selector = selectors [selIndex] as ParserSelector;  		FtpItemInfo entry = selector.ParseLine (line);  		if (entry == null) {  			// We only remove a parser if it's not the last and a line  			// was successfully parsed before.  			if ((hasSucceeded) && (selectors.Count > 1) && (selector.FailureCount > 4)) {  				selector = null;  				selectors.RemoveAt (selIndex);  			}  		}  		else if (!entry.IsEmpty) {  			hasSucceeded = true;  		}  		if (entry != null && (bestEntry == null || bestEntry.IsEmpty))  			bestEntry = entry;  	}  	bool valid = !(bestEntry == null || bestEntry.IsEmpty);  	if ((!valid) && (line != null)) {  		// We must create an empty entry for the event handlers.  		bestEntry = new FtpItemInfo ();  	}  	// If we don't have an item to work with' we don't raise the event  	if ((bestEntry != null) && (!bestEntry.IsEmpty)) {  		// You can see that event handlers can invalidate entries that  		// were parsed correctly.  		// A parser may have buffered information' thus resulting in a valid item  		// without a line. We must always make sure not to pass a null line.  		this.OnParsingListingLine (bestEntry' (line == null) ? string.Empty : line' ref valid);  	}  	if (valid) {  		entries.Add (bestEntry);  	}  }  
Magic Number,Xceed.Ftp,FtpListingParserList,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpListingParserList.cs,ParseListing,The following statement contains a magic number: for (int selIndex = selectors.Count - 1; selIndex >= 0; selIndex--) {  	ParserSelector selector = selectors [selIndex] as ParserSelector;  	FtpItemInfo entry = selector.ParseLine (line);  	if (entry == null) {  		// We only remove a parser if it's not the last and a line  		// was successfully parsed before.  		if ((hasSucceeded) && (selectors.Count > 1) && (selector.FailureCount > 4)) {  			selector = null;  			selectors.RemoveAt (selIndex);  		}  	}  	else if (!entry.IsEmpty) {  		hasSucceeded = true;  	}  	if (entry != null && (bestEntry == null || bestEntry.IsEmpty))  		bestEntry = entry;  }  
Magic Number,Xceed.Ftp,FtpListingParserList,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpListingParserList.cs,ParseListing,The following statement contains a magic number: if (entry == null) {  	// We only remove a parser if it's not the last and a line  	// was successfully parsed before.  	if ((hasSucceeded) && (selectors.Count > 1) && (selector.FailureCount > 4)) {  		selector = null;  		selectors.RemoveAt (selIndex);  	}  }  else if (!entry.IsEmpty) {  	hasSucceeded = true;  }  
Magic Number,Xceed.Ftp,FtpListingParserList,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpListingParserList.cs,ParseListing,The following statement contains a magic number: if ((hasSucceeded) && (selectors.Count > 1) && (selector.FailureCount > 4)) {  	selector = null;  	selectors.RemoveAt (selIndex);  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: try {  	if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  		replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  		if (line.Length == 3 || line [3] == ' ')  			lastLine = true;  	}  }  catch {  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: try {  	if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  		replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  		if (line.Length == 3 || line [3] == ' ')  			lastLine = true;  	}  }  catch {  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: try {  	if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  		replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  		if (line.Length == 3 || line [3] == ' ')  			lastLine = true;  	}  }  catch {  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: try {  	if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  		replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  		if (line.Length == 3 || line [3] == ' ')  			lastLine = true;  	}  }  catch {  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  	replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  	if (line.Length == 3 || line [3] == ' ')  		lastLine = true;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  	replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  	if (line.Length == 3 || line [3] == ' ')  		lastLine = true;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  	replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  	if (line.Length == 3 || line [3] == ' ')  		lastLine = true;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (char.IsDigit (line [0]) && char.IsDigit (line [1]) && char.IsDigit (line [2])) {  	replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  	if (line.Length == 3 || line [3] == ' ')  		lastLine = true;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: replyCode = int.Parse (line.Substring (0' 3)' NumberStyles.None' CultureInfo.InvariantCulture);  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (line.Length == 3 || line [3] == ' ')  	lastLine = true;  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (line.Length == 3 || line [3] == ' ')  	lastLine = true;  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (lastLine) {  	if (line.Length > 4) {  		m_lastLine = line.Substring (4' line.Length - 4);  	}  	else {  		m_lastLine = string.Empty;  	}  	SetType ();  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (lastLine) {  	if (line.Length > 4) {  		m_lastLine = line.Substring (4' line.Length - 4);  	}  	else {  		m_lastLine = string.Empty;  	}  	SetType ();  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (lastLine) {  	if (line.Length > 4) {  		m_lastLine = line.Substring (4' line.Length - 4);  	}  	else {  		m_lastLine = string.Empty;  	}  	SetType ();  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (line.Length > 4) {  	m_lastLine = line.Substring (4' line.Length - 4);  }  else {  	m_lastLine = string.Empty;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (line.Length > 4) {  	m_lastLine = line.Substring (4' line.Length - 4);  }  else {  	m_lastLine = string.Empty;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: if (line.Length > 4) {  	m_lastLine = line.Substring (4' line.Length - 4);  }  else {  	m_lastLine = string.Empty;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: m_lastLine = line.Substring (4' line.Length - 4);  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,AddLine,The following statement contains a magic number: m_lastLine = line.Substring (4' line.Length - 4);  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 559) {  	m_type = FtpReplyType.PermanentNegativeCompletion;  }  else if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 459) {  	m_type = FtpReplyType.TransientNegativeCompletion;  }  else if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 359) {  	m_type = FtpReplyType.PositiveIntermediate;  }  else if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 259) {  	m_type = FtpReplyType.PositiveCompletion;  }  else if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 100 && m_replyCode <= 159) {  	m_type = FtpReplyType.PositivePreliminary;  }  else {  	m_type = FtpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,FtpUnixListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpUNIXListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group type = match.Groups ["type"];  	Group size = match.Groups ["size"];  	Group month = match.Groups ["month"];  	Group day = match.Groups ["day"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	Group name = match.Groups ["name"];  	if (type.Success && size.Success && month.Success && day.Success && (year.Success || time.Success) && name.Success) {  		FtpItemInfo entry = this.CreateItem ();  		int nowDay = DateTime.Now.Day;  		int nowMonth = DateTime.Now.Month;  		int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = DateTime.Now.Year;  		DateTime dateValue = DateTime.MinValue;  		if (year.Success) {  			try {  				dateValue = new DateTime (int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture)' monthValue' dayValue);  			}  			catch (Exception) {  				// We were still not able to create a valid DateTime' use DateTime.MinValue instead  				dateValue = DateTime.MinValue;  			}  		}  		else {  			// We were not able to parse the year' so we must predict   			// if the file day-month is a future day or not. Some servers  			// will only return the year for files at least 6 months' 1 year  			// old. It depends of the implementation.  			// We will assume that if the date is a future date' we use last  			// year instead of this year.  			// If the file month is lower than today's month  			if (nowMonth < monthValue) {  				// We have a future date' so we revert to last year instead of   				// today's date  				yearValue--;  			}  			else if (nowMonth == monthValue) {  				// If the file day is lower than today's day  				// in the same month' it is from last year  				if (nowDay < dayValue) {  					yearValue--;  				}  			}  			try {  				dateValue = new DateTime (yearValue' monthValue' dayValue);  				if (dateValue > DateTime.Now.AddMonths (1)) {  					dateValue = dateValue.AddYears (-1);  				}  				dateValue = dateValue.Add (DateTime.Parse (time.Value' CultureInfo.InvariantCulture).TimeOfDay);  			}  			catch (Exception) {  				// We were still not able to create a valid DateTime' use DateTime.MinValue instead  				dateValue = DateTime.MinValue;  			}  		}  		entry.DateTime = dateValue;  		entry.Name = name.Value.TrimEnd (' ');  		entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		switch (type.Value) {  		case "d":  			entry.Type = FtpItemType.Folder;  			break;  		case "-":  			entry.Type = FtpItemType.File;  			break;  		case "l":  			entry.Type = FtpItemType.Link;  			int redirect = entry.Name.IndexOf (" -> ");  			if (redirect != -1) {  				entry.Name = entry.Name.Substring (0' redirect);  			}  			break;  		default:  			entry.Type = FtpItemType.Unknown;  			break;  		}  		return entry;  	}  }  
Magic Number,Xceed.Ftp,FtpUnixListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpUNIXListingParser.cs,ParseLine,The following statement contains a magic number: if (type.Success && size.Success && month.Success && day.Success && (year.Success || time.Success) && name.Success) {  	FtpItemInfo entry = this.CreateItem ();  	int nowDay = DateTime.Now.Day;  	int nowMonth = DateTime.Now.Month;  	int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = DateTime.Now.Year;  	DateTime dateValue = DateTime.MinValue;  	if (year.Success) {  		try {  			dateValue = new DateTime (int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture)' monthValue' dayValue);  		}  		catch (Exception) {  			// We were still not able to create a valid DateTime' use DateTime.MinValue instead  			dateValue = DateTime.MinValue;  		}  	}  	else {  		// We were not able to parse the year' so we must predict   		// if the file day-month is a future day or not. Some servers  		// will only return the year for files at least 6 months' 1 year  		// old. It depends of the implementation.  		// We will assume that if the date is a future date' we use last  		// year instead of this year.  		// If the file month is lower than today's month  		if (nowMonth < monthValue) {  			// We have a future date' so we revert to last year instead of   			// today's date  			yearValue--;  		}  		else if (nowMonth == monthValue) {  			// If the file day is lower than today's day  			// in the same month' it is from last year  			if (nowDay < dayValue) {  				yearValue--;  			}  		}  		try {  			dateValue = new DateTime (yearValue' monthValue' dayValue);  			if (dateValue > DateTime.Now.AddMonths (1)) {  				dateValue = dateValue.AddYears (-1);  			}  			dateValue = dateValue.Add (DateTime.Parse (time.Value' CultureInfo.InvariantCulture).TimeOfDay);  		}  		catch (Exception) {  			// We were still not able to create a valid DateTime' use DateTime.MinValue instead  			dateValue = DateTime.MinValue;  		}  	}  	entry.DateTime = dateValue;  	entry.Name = name.Value.TrimEnd (' ');  	entry.Size = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	switch (type.Value) {  	case "d":  		entry.Type = FtpItemType.Folder;  		break;  	case "-":  		entry.Type = FtpItemType.File;  		break;  	case "l":  		entry.Type = FtpItemType.Link;  		int redirect = entry.Name.IndexOf (" -> ");  		if (redirect != -1) {  			entry.Name = entry.Name.Substring (0' redirect);  		}  		break;  	default:  		entry.Type = FtpItemType.Unknown;  		break;  	}  	return entry;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group name = match.Groups ["name"];  	Group size = match.Groups ["size"];  	Group day = match.Groups ["day"];  	Group month = match.Groups ["month"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	FtpItemInfo entry = null;  	if (!name.Success) {  		// We may have a buffered item from an incomplete previous line.  		entry = m_incompleteEntry;  	}  	else {  		entry = this.CreateItem ();  		entry.Name = name.Value.TrimEnd (' ');  	}  	m_incompleteEntry = null;  	if (entry != null) {  		if (size.Success && day.Success && month.Success && year.Success && time.Success) {  			// Size expressed in units of 512 bytes  			long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  			// We accept a two-digit year.  			int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.Size = sizeValue;  			entry.DateTime = lastWrite;  			return entry;  		}  		else {  			// This is an incomplete line that should continue on the next one.  			m_incompleteEntry = entry;  			return FtpItemInfo.Empty;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group name = match.Groups ["name"];  	Group size = match.Groups ["size"];  	Group day = match.Groups ["day"];  	Group month = match.Groups ["month"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	FtpItemInfo entry = null;  	if (!name.Success) {  		// We may have a buffered item from an incomplete previous line.  		entry = m_incompleteEntry;  	}  	else {  		entry = this.CreateItem ();  		entry.Name = name.Value.TrimEnd (' ');  	}  	m_incompleteEntry = null;  	if (entry != null) {  		if (size.Success && day.Success && month.Success && year.Success && time.Success) {  			// Size expressed in units of 512 bytes  			long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  			// We accept a two-digit year.  			int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.Size = sizeValue;  			entry.DateTime = lastWrite;  			return entry;  		}  		else {  			// This is an incomplete line that should continue on the next one.  			m_incompleteEntry = entry;  			return FtpItemInfo.Empty;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group name = match.Groups ["name"];  	Group size = match.Groups ["size"];  	Group day = match.Groups ["day"];  	Group month = match.Groups ["month"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	FtpItemInfo entry = null;  	if (!name.Success) {  		// We may have a buffered item from an incomplete previous line.  		entry = m_incompleteEntry;  	}  	else {  		entry = this.CreateItem ();  		entry.Name = name.Value.TrimEnd (' ');  	}  	m_incompleteEntry = null;  	if (entry != null) {  		if (size.Success && day.Success && month.Success && year.Success && time.Success) {  			// Size expressed in units of 512 bytes  			long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  			// We accept a two-digit year.  			int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.Size = sizeValue;  			entry.DateTime = lastWrite;  			return entry;  		}  		else {  			// This is an incomplete line that should continue on the next one.  			m_incompleteEntry = entry;  			return FtpItemInfo.Empty;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group name = match.Groups ["name"];  	Group size = match.Groups ["size"];  	Group day = match.Groups ["day"];  	Group month = match.Groups ["month"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	FtpItemInfo entry = null;  	if (!name.Success) {  		// We may have a buffered item from an incomplete previous line.  		entry = m_incompleteEntry;  	}  	else {  		entry = this.CreateItem ();  		entry.Name = name.Value.TrimEnd (' ');  	}  	m_incompleteEntry = null;  	if (entry != null) {  		if (size.Success && day.Success && month.Success && year.Success && time.Success) {  			// Size expressed in units of 512 bytes  			long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  			// We accept a two-digit year.  			int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.Size = sizeValue;  			entry.DateTime = lastWrite;  			return entry;  		}  		else {  			// This is an incomplete line that should continue on the next one.  			m_incompleteEntry = entry;  			return FtpItemInfo.Empty;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group name = match.Groups ["name"];  	Group size = match.Groups ["size"];  	Group day = match.Groups ["day"];  	Group month = match.Groups ["month"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	FtpItemInfo entry = null;  	if (!name.Success) {  		// We may have a buffered item from an incomplete previous line.  		entry = m_incompleteEntry;  	}  	else {  		entry = this.CreateItem ();  		entry.Name = name.Value.TrimEnd (' ');  	}  	m_incompleteEntry = null;  	if (entry != null) {  		if (size.Success && day.Success && month.Success && year.Success && time.Success) {  			// Size expressed in units of 512 bytes  			long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  			// We accept a two-digit year.  			int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.Size = sizeValue;  			entry.DateTime = lastWrite;  			return entry;  		}  		else {  			// This is an incomplete line that should continue on the next one.  			m_incompleteEntry = entry;  			return FtpItemInfo.Empty;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (match.Success) {  	Group name = match.Groups ["name"];  	Group size = match.Groups ["size"];  	Group day = match.Groups ["day"];  	Group month = match.Groups ["month"];  	Group year = match.Groups ["year"];  	Group time = match.Groups ["time"];  	FtpItemInfo entry = null;  	if (!name.Success) {  		// We may have a buffered item from an incomplete previous line.  		entry = m_incompleteEntry;  	}  	else {  		entry = this.CreateItem ();  		entry.Name = name.Value.TrimEnd (' ');  	}  	m_incompleteEntry = null;  	if (entry != null) {  		if (size.Success && day.Success && month.Success && year.Success && time.Success) {  			// Size expressed in units of 512 bytes  			long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  			// We accept a two-digit year.  			int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  			int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  			if (yearValue < 70) {  				yearValue += 2000;  			}  			else if (yearValue < 100) {  				yearValue += 1900;  			}  			DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  			if (time.Success) {  				DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  				lastWrite = lastWrite.Add (timeValue.TimeOfDay);  			}  			entry.Size = sizeValue;  			entry.DateTime = lastWrite;  			return entry;  		}  		else {  			// This is an incomplete line that should continue on the next one.  			m_incompleteEntry = entry;  			return FtpItemInfo.Empty;  		}  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (entry != null) {  	if (size.Success && day.Success && month.Success && year.Success && time.Success) {  		// Size expressed in units of 512 bytes  		long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  		// We accept a two-digit year.  		int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.Size = sizeValue;  		entry.DateTime = lastWrite;  		return entry;  	}  	else {  		// This is an incomplete line that should continue on the next one.  		m_incompleteEntry = entry;  		return FtpItemInfo.Empty;  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (entry != null) {  	if (size.Success && day.Success && month.Success && year.Success && time.Success) {  		// Size expressed in units of 512 bytes  		long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  		// We accept a two-digit year.  		int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.Size = sizeValue;  		entry.DateTime = lastWrite;  		return entry;  	}  	else {  		// This is an incomplete line that should continue on the next one.  		m_incompleteEntry = entry;  		return FtpItemInfo.Empty;  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (entry != null) {  	if (size.Success && day.Success && month.Success && year.Success && time.Success) {  		// Size expressed in units of 512 bytes  		long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  		// We accept a two-digit year.  		int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.Size = sizeValue;  		entry.DateTime = lastWrite;  		return entry;  	}  	else {  		// This is an incomplete line that should continue on the next one.  		m_incompleteEntry = entry;  		return FtpItemInfo.Empty;  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (entry != null) {  	if (size.Success && day.Success && month.Success && year.Success && time.Success) {  		// Size expressed in units of 512 bytes  		long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  		// We accept a two-digit year.  		int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.Size = sizeValue;  		entry.DateTime = lastWrite;  		return entry;  	}  	else {  		// This is an incomplete line that should continue on the next one.  		m_incompleteEntry = entry;  		return FtpItemInfo.Empty;  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (entry != null) {  	if (size.Success && day.Success && month.Success && year.Success && time.Success) {  		// Size expressed in units of 512 bytes  		long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  		// We accept a two-digit year.  		int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.Size = sizeValue;  		entry.DateTime = lastWrite;  		return entry;  	}  	else {  		// This is an incomplete line that should continue on the next one.  		m_incompleteEntry = entry;  		return FtpItemInfo.Empty;  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (entry != null) {  	if (size.Success && day.Success && month.Success && year.Success && time.Success) {  		// Size expressed in units of 512 bytes  		long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  		// We accept a two-digit year.  		int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  		int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  		if (yearValue < 70) {  			yearValue += 2000;  		}  		else if (yearValue < 100) {  			yearValue += 1900;  		}  		DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  		if (time.Success) {  			DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  			lastWrite = lastWrite.Add (timeValue.TimeOfDay);  		}  		entry.Size = sizeValue;  		entry.DateTime = lastWrite;  		return entry;  	}  	else {  		// This is an incomplete line that should continue on the next one.  		m_incompleteEntry = entry;  		return FtpItemInfo.Empty;  	}  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && day.Success && month.Success && year.Success && time.Success) {  	// Size expressed in units of 512 bytes  	long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  	// We accept a two-digit year.  	int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.Size = sizeValue;  	entry.DateTime = lastWrite;  	return entry;  }  else {  	// This is an incomplete line that should continue on the next one.  	m_incompleteEntry = entry;  	return FtpItemInfo.Empty;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && day.Success && month.Success && year.Success && time.Success) {  	// Size expressed in units of 512 bytes  	long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  	// We accept a two-digit year.  	int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.Size = sizeValue;  	entry.DateTime = lastWrite;  	return entry;  }  else {  	// This is an incomplete line that should continue on the next one.  	m_incompleteEntry = entry;  	return FtpItemInfo.Empty;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && day.Success && month.Success && year.Success && time.Success) {  	// Size expressed in units of 512 bytes  	long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  	// We accept a two-digit year.  	int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.Size = sizeValue;  	entry.DateTime = lastWrite;  	return entry;  }  else {  	// This is an incomplete line that should continue on the next one.  	m_incompleteEntry = entry;  	return FtpItemInfo.Empty;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && day.Success && month.Success && year.Success && time.Success) {  	// Size expressed in units of 512 bytes  	long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  	// We accept a two-digit year.  	int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.Size = sizeValue;  	entry.DateTime = lastWrite;  	return entry;  }  else {  	// This is an incomplete line that should continue on the next one.  	m_incompleteEntry = entry;  	return FtpItemInfo.Empty;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && day.Success && month.Success && year.Success && time.Success) {  	// Size expressed in units of 512 bytes  	long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  	// We accept a two-digit year.  	int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.Size = sizeValue;  	entry.DateTime = lastWrite;  	return entry;  }  else {  	// This is an incomplete line that should continue on the next one.  	m_incompleteEntry = entry;  	return FtpItemInfo.Empty;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (size.Success && day.Success && month.Success && year.Success && time.Success) {  	// Size expressed in units of 512 bytes  	long sizeValue = long.Parse (size.Value' NumberStyles.None' CultureInfo.InvariantCulture) * 512;  	// We accept a two-digit year.  	int monthValue = (Months.IndexOf (month.Value.ToUpper (CultureInfo.InvariantCulture)) / 3) + 1;  	int dayValue = int.Parse (day.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	int yearValue = int.Parse (year.Value' NumberStyles.None' CultureInfo.InvariantCulture);  	if (yearValue < 70) {  		yearValue += 2000;  	}  	else if (yearValue < 100) {  		yearValue += 1900;  	}  	DateTime lastWrite = new DateTime (yearValue' monthValue' dayValue);  	if (time.Success) {  		DateTime timeValue = DateTime.Parse (time.Value' CultureInfo.InvariantCulture);  		lastWrite = lastWrite.Add (timeValue.TimeOfDay);  	}  	entry.Size = sizeValue;  	entry.DateTime = lastWrite;  	return entry;  }  else {  	// This is an incomplete line that should continue on the next one.  	m_incompleteEntry = entry;  	return FtpItemInfo.Empty;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 70) {  	yearValue += 2000;  }  else if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: yearValue += 2000;  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: if (yearValue < 100) {  	yearValue += 1900;  }  
Magic Number,Xceed.Ftp,FtpVmsListingParser,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\FtpVMSListingParser.cs,ParseLine,The following statement contains a magic number: yearValue += 1900;  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 500 && m_replyCode <= 599) {  	m_type = HttpReplyType.ServerError;  }  else if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 400 && m_replyCode <= 499) {  	m_type = HttpReplyType.ClientError;  }  else if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 300 && m_replyCode <= 399) {  	m_type = HttpReplyType.Redirection;  }  else if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 200 && m_replyCode <= 299) {  	m_type = HttpReplyType.Success;  }  else if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,HttpReply,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\HttpReply.cs,SetType,The following statement contains a magic number: if (m_replyCode >= 100 && m_replyCode <= 199) {  	m_type = HttpReplyType.Informational;  }  else {  	m_type = HttpReplyType.Invalid;  }  
Magic Number,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Receive,The following statement contains a magic number: Receive (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' localDestinationFolder' replaceExistingFiles' recursive' preservePaths' null' // No proxy by default  30' // Default timeout value  true' // Passive transfer active by default  RepresentationType.Binary' // Binary representation by default  null' // No trace writer by default  synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' TransferMode.Stream' filesToReceive);  
Magic Number,Xceed.Ftp,QuickFtp,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(Quick)\QuickFtp.cs,Send,The following statement contains a magic number: Send (hostname' port' username' password' authenticationMethod' verificationFlags' clientCertificate' dataChannelProtection' implicitAuthentication' remoteDestinationFolder' replaceExistingFiles' recursive' preservePaths' null' // No proxy by default  30' // Default timeout value  true' // Passive transfer active by default  RepresentationType.Binary' // Binary representation by default  null' // No trace writer by default  synchronizingObject' certificateReceivedCallback' certificateRequiredCallback' byteProgressionCallback' itemProgressionCallback' userParams' filesToSend);  
Magic Number,Xceed.Ftp,StringList,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\StringList.cs,ToString,The following statement contains a magic number: for (int index = 0; index < base.Count; index++) {  	size += ((string)(array [index])).Length + 2;  }  
Magic Number,Xceed.Ftp,StringList,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\StringList.cs,ToString,The following statement contains a magic number: size += ((string)(array [index])).Length + 2;  
Magic Number,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,SendCommand,The following statement contains a magic number: if (m_sendTelnetInterruptSignal) {  	// We must send the Telnet IP signal (AIC + IP)  	commandChannel.SendBytes (new byte[] {  		255'  		244  	});  	// We then send the TELNET synch signal.  	commandChannel.SendBytes (new byte[] {  		242  	});  }  
Magic Number,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,SendCommand,The following statement contains a magic number: if (m_sendTelnetInterruptSignal) {  	// We must send the Telnet IP signal (AIC + IP)  	commandChannel.SendBytes (new byte[] {  		255'  		244  	});  	// We then send the TELNET synch signal.  	commandChannel.SendBytes (new byte[] {  		242  	});  }  
Magic Number,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,SendCommand,The following statement contains a magic number: if (m_sendTelnetInterruptSignal) {  	// We must send the Telnet IP signal (AIC + IP)  	commandChannel.SendBytes (new byte[] {  		255'  		244  	});  	// We then send the TELNET synch signal.  	commandChannel.SendBytes (new byte[] {  		242  	});  }  
Magic Number,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,SendCommand,The following statement contains a magic number: commandChannel.SendBytes (new byte[] {  	255'  	244  });  
Magic Number,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,SendCommand,The following statement contains a magic number: commandChannel.SendBytes (new byte[] {  	255'  	244  });  
Magic Number,Xceed.Ftp.Engine,AbortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\AbortFtpCommand.cs,SendCommand,The following statement contains a magic number: commandChannel.SendBytes (new byte[] {  	242  });  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: while (commaCount < 5) {  	try {  		int index = message.LastIndexOf ('''' commaIndex - 1);  		if (index == -1)  			throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  		commaIndex = index;  		commaCount++;  	}  	catch {  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	}  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: System.Diagnostics.Debug.Assert (parts.Length == 6' "Invalid algo above.");  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	try {  		long part = long.Parse (parts [i]' NumberStyles.None' CultureInfo.InvariantCulture);  		if (part < 0 || part > 0xff)  			throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  		address += (part << (i * 8));  	}  	catch {  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	}  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	try {  		long part = long.Parse (parts [i]' NumberStyles.None' CultureInfo.InvariantCulture);  		if (part < 0 || part > 0xff)  			throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  		address += (part << (i * 8));  	}  	catch {  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	}  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: try {  	long part = long.Parse (parts [i]' NumberStyles.None' CultureInfo.InvariantCulture);  	if (part < 0 || part > 0xff)  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	address += (part << (i * 8));  }  catch {  	throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: address += (part << (i * 8));  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: for (int i = 4; i < 6; i++) {  	try {  		int part = int.Parse (parts [i]' NumberStyles.None' CultureInfo.InvariantCulture);  		if (part < 0 || part > 0xff)  			throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  		port = (port << 8) + part;  	}  	catch {  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	}  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: for (int i = 4; i < 6; i++) {  	try {  		int part = int.Parse (parts [i]' NumberStyles.None' CultureInfo.InvariantCulture);  		if (part < 0 || part > 0xff)  			throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  		port = (port << 8) + part;  	}  	catch {  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	}  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: for (int i = 4; i < 6; i++) {  	try {  		int part = int.Parse (parts [i]' NumberStyles.None' CultureInfo.InvariantCulture);  		if (part < 0 || part > 0xff)  			throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  		port = (port << 8) + part;  	}  	catch {  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	}  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: try {  	int part = int.Parse (parts [i]' NumberStyles.None' CultureInfo.InvariantCulture);  	if (part < 0 || part > 0xff)  		throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  	port = (port << 8) + part;  }  catch {  	throw new FtpReplyException (reply' "Invalid reply format to PASV command.");  }  
Magic Number,Xceed.Ftp.Engine,PassiveFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PassiveFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: port = (port << 8) + part;  
Magic Number,Xceed.Ftp.Engine,PortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PortFtpCommand.cs,ToString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "PORT {0}'{1}'{2}'{3}'{4}'{5}"' (address) & 0xff' (address >> 8) & 0xff' (address >> 16) & 0xff' (address >> 24) & 0xff' (port >> 8) & 0xff' (port) & 0xff);  
Magic Number,Xceed.Ftp.Engine,PortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PortFtpCommand.cs,ToString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "PORT {0}'{1}'{2}'{3}'{4}'{5}"' (address) & 0xff' (address >> 8) & 0xff' (address >> 16) & 0xff' (address >> 24) & 0xff' (port >> 8) & 0xff' (port) & 0xff);  
Magic Number,Xceed.Ftp.Engine,PortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PortFtpCommand.cs,ToString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "PORT {0}'{1}'{2}'{3}'{4}'{5}"' (address) & 0xff' (address >> 8) & 0xff' (address >> 16) & 0xff' (address >> 24) & 0xff' (port >> 8) & 0xff' (port) & 0xff);  
Magic Number,Xceed.Ftp.Engine,PortFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\PortFtpCommand.cs,ToString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "PORT {0}'{1}'{2}'{3}'{4}'{5}"' (address) & 0xff' (address >> 8) & 0xff' (address >> 16) & 0xff' (address >> 24) & 0xff' (port >> 8) & 0xff' (port) & 0xff);  
Magic Number,Xceed.Ftp.Engine,ProtectedBufferSizeFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ProtectedBufferSizeFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: if (index != -1) {  	index += 5;  	int end = index;  	while ((end < message.Length) && (char.IsDigit (message [end]))) {  		end++;  	}  	if (end > index) {  		try {  			int newSize = int.Parse (message.Substring (index' end - index));  			System.Diagnostics.Debug.Assert (newSize <= m_size' "The smallest number should be used.");  			m_size = newSize;  		}  		catch {  		}  	}  }  
Magic Number,Xceed.Ftp.Engine,ProtectedBufferSizeFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\ProtectedBufferSizeFtpCommand.cs,ProcessSuccessReply,The following statement contains a magic number: index += 5;  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: try {  	#if ( !XCEEDCF )  	if (m_sendTelnetInterruptSignal) {  		// We must send the Telnet IP signal (AIC + IP)  		commandChannel.SendBytes (new byte[] {  			255'  			244  		});  		// We then send the TELNET synch signal.  		commandChannel.SendBytes (new byte[] {  			242  		});  	}  	#else  	        // Sockets in CompactFramework does not support out-of-band. Since the interrupt signal         // should always be sent out-of-band' we don't send the signal. #endif  	// Now we can send the QUIT command  	base.SendCommand (commandChannel);  }  finally {  	// We make sure all pending commands are aborted too. Yes' our own command   	// will get called' but it does nothing!  	commandChannel.AbortFtpCommands ();  }  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: try {  	#if ( !XCEEDCF )  	if (m_sendTelnetInterruptSignal) {  		// We must send the Telnet IP signal (AIC + IP)  		commandChannel.SendBytes (new byte[] {  			255'  			244  		});  		// We then send the TELNET synch signal.  		commandChannel.SendBytes (new byte[] {  			242  		});  	}  	#else  	        // Sockets in CompactFramework does not support out-of-band. Since the interrupt signal         // should always be sent out-of-band' we don't send the signal. #endif  	// Now we can send the QUIT command  	base.SendCommand (commandChannel);  }  finally {  	// We make sure all pending commands are aborted too. Yes' our own command   	// will get called' but it does nothing!  	commandChannel.AbortFtpCommands ();  }  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: try {  	#if ( !XCEEDCF )  	if (m_sendTelnetInterruptSignal) {  		// We must send the Telnet IP signal (AIC + IP)  		commandChannel.SendBytes (new byte[] {  			255'  			244  		});  		// We then send the TELNET synch signal.  		commandChannel.SendBytes (new byte[] {  			242  		});  	}  	#else  	        // Sockets in CompactFramework does not support out-of-band. Since the interrupt signal         // should always be sent out-of-band' we don't send the signal. #endif  	// Now we can send the QUIT command  	base.SendCommand (commandChannel);  }  finally {  	// We make sure all pending commands are aborted too. Yes' our own command   	// will get called' but it does nothing!  	commandChannel.AbortFtpCommands ();  }  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: if (m_sendTelnetInterruptSignal) {  	// We must send the Telnet IP signal (AIC + IP)  	commandChannel.SendBytes (new byte[] {  		255'  		244  	});  	// We then send the TELNET synch signal.  	commandChannel.SendBytes (new byte[] {  		242  	});  }  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: if (m_sendTelnetInterruptSignal) {  	// We must send the Telnet IP signal (AIC + IP)  	commandChannel.SendBytes (new byte[] {  		255'  		244  	});  	// We then send the TELNET synch signal.  	commandChannel.SendBytes (new byte[] {  		242  	});  }  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: if (m_sendTelnetInterruptSignal) {  	// We must send the Telnet IP signal (AIC + IP)  	commandChannel.SendBytes (new byte[] {  		255'  		244  	});  	// We then send the TELNET synch signal.  	commandChannel.SendBytes (new byte[] {  		242  	});  }  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: commandChannel.SendBytes (new byte[] {  	255'  	244  });  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: commandChannel.SendBytes (new byte[] {  	255'  	244  });  
Magic Number,Xceed.Ftp.Engine,QuitFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\QuitFtpCommand.cs,SendCommand,The following statement contains a magic number: commandChannel.SendBytes (new byte[] {  	242  });  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (index == -1) {  	// We simply take the end up to a space  	index = message.LastIndexOf (' ');  	if (index == -1) {  		// We're out of luck. Try locating colon.  		index = message.LastIndexOf (':');  		if (index != -1) {  			m_uniqueFilename = message.Substring (index + 1);  		}  		// Else we abandon.  	}  	else {  		m_uniqueFilename = message.Substring (index + 1);  	}  }  else {  	if (message.EndsWith (".")) {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  	}  	else {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  	}  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (index == -1) {  	// We simply take the end up to a space  	index = message.LastIndexOf (' ');  	if (index == -1) {  		// We're out of luck. Try locating colon.  		index = message.LastIndexOf (':');  		if (index != -1) {  			m_uniqueFilename = message.Substring (index + 1);  		}  		// Else we abandon.  	}  	else {  		m_uniqueFilename = message.Substring (index + 1);  	}  }  else {  	if (message.EndsWith (".")) {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  	}  	else {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  	}  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (index == -1) {  	// We simply take the end up to a space  	index = message.LastIndexOf (' ');  	if (index == -1) {  		// We're out of luck. Try locating colon.  		index = message.LastIndexOf (':');  		if (index != -1) {  			m_uniqueFilename = message.Substring (index + 1);  		}  		// Else we abandon.  	}  	else {  		m_uniqueFilename = message.Substring (index + 1);  	}  }  else {  	if (message.EndsWith (".")) {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  	}  	else {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  	}  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (index == -1) {  	// We simply take the end up to a space  	index = message.LastIndexOf (' ');  	if (index == -1) {  		// We're out of luck. Try locating colon.  		index = message.LastIndexOf (':');  		if (index != -1) {  			m_uniqueFilename = message.Substring (index + 1);  		}  		// Else we abandon.  	}  	else {  		m_uniqueFilename = message.Substring (index + 1);  	}  }  else {  	if (message.EndsWith (".")) {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  	}  	else {  		m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  	}  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (message.EndsWith (".")) {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  }  else {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (message.EndsWith (".")) {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  }  else {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (message.EndsWith (".")) {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  }  else {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: if (message.EndsWith (".")) {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  }  else {  	m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  }  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: m_uniqueFilename = message.Substring (index + 5' message.Length - index - 6);  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  
Magic Number,Xceed.Ftp.Engine,StoreUniqueFileFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\StoreUniqueFileFtpCommand.cs,RetrieveUniqueFilename,The following statement contains a magic number: m_uniqueFilename = message.Substring (index + 5' message.Length - index - 5);  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: lock (this) {  	// This is a two-step process' to avoid allocating   	// too much memory for nothing' and check if this buffer  	// really needs conversion. The main optimisation is that  	// most text files on Windows systems already are NVT-ASCII  	// compliant.  	int requiredSize = 0;  	byte lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// CR == 13' LF == 10  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We will need to replace \n by \r\n  				requiredSize++;  			}  		}  		else {  			if (lastByte == 13) {  				// We will need to replace \r by \r\n  				requiredSize++;  			}  		}  		lastByte = buffer [index];  		requiredSize++;  	}  	if (requiredSize == count) {  		// Since conversion cannot shrink size' it means  		// no conversion is required.  		m_lastByte = lastByte;  		return null;  	}  	else {  		// Second pass: Actually convert!  		byte[] converted = new byte[requiredSize];  		int convertedIndex = 0;  		lastByte = m_lastByte;  		for (int index = offset; index < offset + count; index++) {  			// Note: We could check for overflow everytime we  			// increment convertedIndex. But for performance' we  			// rely on .NET's bound checking.  			if (buffer [index] == 10) {  				if (lastByte != 13) {  					// We must write \r before this single \n  					converted [convertedIndex++] = 13;  				}  			}  			else {  				if (lastByte == 13) {  					// We must write \n after this preceding \r  					converted [convertedIndex++] = 10;  				}  			}  			lastByte = buffer [index];  			converted [convertedIndex++] = lastByte;  		}  		m_lastByte = lastByte;  		return converted;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// CR == 13' LF == 10  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We will need to replace \n by \r\n  			requiredSize++;  		}  	}  	else {  		if (lastByte == 13) {  			// We will need to replace \r by \r\n  			requiredSize++;  		}  	}  	lastByte = buffer [index];  	requiredSize++;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// CR == 13' LF == 10  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We will need to replace \n by \r\n  			requiredSize++;  		}  	}  	else {  		if (lastByte == 13) {  			// We will need to replace \r by \r\n  			requiredSize++;  		}  	}  	lastByte = buffer [index];  	requiredSize++;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// CR == 13' LF == 10  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We will need to replace \n by \r\n  			requiredSize++;  		}  	}  	else {  		if (lastByte == 13) {  			// We will need to replace \r by \r\n  			requiredSize++;  		}  	}  	lastByte = buffer [index];  	requiredSize++;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We will need to replace \n by \r\n  		requiredSize++;  	}  }  else {  	if (lastByte == 13) {  		// We will need to replace \r by \r\n  		requiredSize++;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We will need to replace \n by \r\n  		requiredSize++;  	}  }  else {  	if (lastByte == 13) {  		// We will need to replace \r by \r\n  		requiredSize++;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We will need to replace \n by \r\n  		requiredSize++;  	}  }  else {  	if (lastByte == 13) {  		// We will need to replace \r by \r\n  		requiredSize++;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (lastByte != 13) {  	// We will need to replace \n by \r\n  	requiredSize++;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (lastByte == 13) {  	// We will need to replace \r by \r\n  	requiredSize++;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (requiredSize == count) {  	// Since conversion cannot shrink size' it means  	// no conversion is required.  	m_lastByte = lastByte;  	return null;  }  else {  	// Second pass: Actually convert!  	byte[] converted = new byte[requiredSize];  	int convertedIndex = 0;  	lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// Note: We could check for overflow everytime we  		// increment convertedIndex. But for performance' we  		// rely on .NET's bound checking.  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We must write \r before this single \n  				converted [convertedIndex++] = 13;  			}  		}  		else {  			if (lastByte == 13) {  				// We must write \n after this preceding \r  				converted [convertedIndex++] = 10;  			}  		}  		lastByte = buffer [index];  		converted [convertedIndex++] = lastByte;  	}  	m_lastByte = lastByte;  	return converted;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (requiredSize == count) {  	// Since conversion cannot shrink size' it means  	// no conversion is required.  	m_lastByte = lastByte;  	return null;  }  else {  	// Second pass: Actually convert!  	byte[] converted = new byte[requiredSize];  	int convertedIndex = 0;  	lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// Note: We could check for overflow everytime we  		// increment convertedIndex. But for performance' we  		// rely on .NET's bound checking.  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We must write \r before this single \n  				converted [convertedIndex++] = 13;  			}  		}  		else {  			if (lastByte == 13) {  				// We must write \n after this preceding \r  				converted [convertedIndex++] = 10;  			}  		}  		lastByte = buffer [index];  		converted [convertedIndex++] = lastByte;  	}  	m_lastByte = lastByte;  	return converted;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (requiredSize == count) {  	// Since conversion cannot shrink size' it means  	// no conversion is required.  	m_lastByte = lastByte;  	return null;  }  else {  	// Second pass: Actually convert!  	byte[] converted = new byte[requiredSize];  	int convertedIndex = 0;  	lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// Note: We could check for overflow everytime we  		// increment convertedIndex. But for performance' we  		// rely on .NET's bound checking.  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We must write \r before this single \n  				converted [convertedIndex++] = 13;  			}  		}  		else {  			if (lastByte == 13) {  				// We must write \n after this preceding \r  				converted [convertedIndex++] = 10;  			}  		}  		lastByte = buffer [index];  		converted [convertedIndex++] = lastByte;  	}  	m_lastByte = lastByte;  	return converted;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (requiredSize == count) {  	// Since conversion cannot shrink size' it means  	// no conversion is required.  	m_lastByte = lastByte;  	return null;  }  else {  	// Second pass: Actually convert!  	byte[] converted = new byte[requiredSize];  	int convertedIndex = 0;  	lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// Note: We could check for overflow everytime we  		// increment convertedIndex. But for performance' we  		// rely on .NET's bound checking.  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We must write \r before this single \n  				converted [convertedIndex++] = 13;  			}  		}  		else {  			if (lastByte == 13) {  				// We must write \n after this preceding \r  				converted [convertedIndex++] = 10;  			}  		}  		lastByte = buffer [index];  		converted [convertedIndex++] = lastByte;  	}  	m_lastByte = lastByte;  	return converted;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (requiredSize == count) {  	// Since conversion cannot shrink size' it means  	// no conversion is required.  	m_lastByte = lastByte;  	return null;  }  else {  	// Second pass: Actually convert!  	byte[] converted = new byte[requiredSize];  	int convertedIndex = 0;  	lastByte = m_lastByte;  	for (int index = offset; index < offset + count; index++) {  		// Note: We could check for overflow everytime we  		// increment convertedIndex. But for performance' we  		// rely on .NET's bound checking.  		if (buffer [index] == 10) {  			if (lastByte != 13) {  				// We must write \r before this single \n  				converted [convertedIndex++] = 13;  			}  		}  		else {  			if (lastByte == 13) {  				// We must write \n after this preceding \r  				converted [convertedIndex++] = 10;  			}  		}  		lastByte = buffer [index];  		converted [convertedIndex++] = lastByte;  	}  	m_lastByte = lastByte;  	return converted;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// Note: We could check for overflow everytime we  	// increment convertedIndex. But for performance' we  	// rely on .NET's bound checking.  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We must write \r before this single \n  			converted [convertedIndex++] = 13;  		}  	}  	else {  		if (lastByte == 13) {  			// We must write \n after this preceding \r  			converted [convertedIndex++] = 10;  		}  	}  	lastByte = buffer [index];  	converted [convertedIndex++] = lastByte;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// Note: We could check for overflow everytime we  	// increment convertedIndex. But for performance' we  	// rely on .NET's bound checking.  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We must write \r before this single \n  			converted [convertedIndex++] = 13;  		}  	}  	else {  		if (lastByte == 13) {  			// We must write \n after this preceding \r  			converted [convertedIndex++] = 10;  		}  	}  	lastByte = buffer [index];  	converted [convertedIndex++] = lastByte;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// Note: We could check for overflow everytime we  	// increment convertedIndex. But for performance' we  	// rely on .NET's bound checking.  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We must write \r before this single \n  			converted [convertedIndex++] = 13;  		}  	}  	else {  		if (lastByte == 13) {  			// We must write \n after this preceding \r  			converted [convertedIndex++] = 10;  		}  	}  	lastByte = buffer [index];  	converted [convertedIndex++] = lastByte;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// Note: We could check for overflow everytime we  	// increment convertedIndex. But for performance' we  	// rely on .NET's bound checking.  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We must write \r before this single \n  			converted [convertedIndex++] = 13;  		}  	}  	else {  		if (lastByte == 13) {  			// We must write \n after this preceding \r  			converted [convertedIndex++] = 10;  		}  	}  	lastByte = buffer [index];  	converted [convertedIndex++] = lastByte;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: for (int index = offset; index < offset + count; index++) {  	// Note: We could check for overflow everytime we  	// increment convertedIndex. But for performance' we  	// rely on .NET's bound checking.  	if (buffer [index] == 10) {  		if (lastByte != 13) {  			// We must write \r before this single \n  			converted [convertedIndex++] = 13;  		}  	}  	else {  		if (lastByte == 13) {  			// We must write \n after this preceding \r  			converted [convertedIndex++] = 10;  		}  	}  	lastByte = buffer [index];  	converted [convertedIndex++] = lastByte;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We must write \r before this single \n  		converted [convertedIndex++] = 13;  	}  }  else {  	if (lastByte == 13) {  		// We must write \n after this preceding \r  		converted [convertedIndex++] = 10;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We must write \r before this single \n  		converted [convertedIndex++] = 13;  	}  }  else {  	if (lastByte == 13) {  		// We must write \n after this preceding \r  		converted [convertedIndex++] = 10;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We must write \r before this single \n  		converted [convertedIndex++] = 13;  	}  }  else {  	if (lastByte == 13) {  		// We must write \n after this preceding \r  		converted [convertedIndex++] = 10;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We must write \r before this single \n  		converted [convertedIndex++] = 13;  	}  }  else {  	if (lastByte == 13) {  		// We must write \n after this preceding \r  		converted [convertedIndex++] = 10;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (buffer [index] == 10) {  	if (lastByte != 13) {  		// We must write \r before this single \n  		converted [convertedIndex++] = 13;  	}  }  else {  	if (lastByte == 13) {  		// We must write \n after this preceding \r  		converted [convertedIndex++] = 10;  	}  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (lastByte != 13) {  	// We must write \r before this single \n  	converted [convertedIndex++] = 13;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (lastByte != 13) {  	// We must write \r before this single \n  	converted [convertedIndex++] = 13;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: converted [convertedIndex++] = 13;  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (lastByte == 13) {  	// We must write \n after this preceding \r  	converted [convertedIndex++] = 10;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: if (lastByte == 13) {  	// We must write \n after this preceding \r  	converted [convertedIndex++] = 10;  }  
Magic Number,Xceed.Ftp.Engine,FtpAsciiDataStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpAsciiDataStream.cs,ConvertToAscii,The following statement contains a magic number: converted [convertedIndex++] = 10;  
Magic Number,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,FtpCommandChannel,The following statement contains a magic number: m_queuedReplies = new Queue<FtpReply> (2);  
Magic Number,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Dispose,The following statement contains a magic number: if (!m_disposed) {  	if (disposing) {  		#if DEBUG_DATACHANNEL  		          m_ftpEngine.Tracing.WriteLine( "Data channel stream is being disposed explicitly. Shutting down sending on the socket." );           #endif  		m_socket.Shutdown (SocketShutdown.Send);  		try {  			byte[] buffer = new byte[100];  			while (m_socket.Receive (buffer' SocketFlags.None) > 0)  				;  		}  		catch (Exception) {  		}  		#if DEBUG_DATACHANNEL  		          m_ftpEngine.Tracing.WriteLine( "Closing the data channel network stream" );           #endif  		m_innerStream.Close ();  	}  	m_innerStream = null;  	m_disposed = true;  }  
Magic Number,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Dispose,The following statement contains a magic number: if (disposing) {  	#if DEBUG_DATACHANNEL  	          m_ftpEngine.Tracing.WriteLine( "Data channel stream is being disposed explicitly. Shutting down sending on the socket." );           #endif  	m_socket.Shutdown (SocketShutdown.Send);  	try {  		byte[] buffer = new byte[100];  		while (m_socket.Receive (buffer' SocketFlags.None) > 0)  			;  	}  	catch (Exception) {  	}  	#if DEBUG_DATACHANNEL  	          m_ftpEngine.Tracing.WriteLine( "Closing the data channel network stream" );           #endif  	m_innerStream.Close ();  }  
Magic Number,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Dispose,The following statement contains a magic number: try {  	byte[] buffer = new byte[100];  	while (m_socket.Receive (buffer' SocketFlags.None) > 0)  		;  }  catch (Exception) {  }  
Magic Number,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Read,The following statement contains a magic number: try {  	#if DEBUG_DATACHANNEL  	        m_ftpEngine.Tracing.WriteLine( "Data channel stream asks to receive at most {0} bytes of data"' count );         #endif  	bytesRead = networkStream.Read (buffer' offset' count);  	#if DEBUG_DATACHANNEL  	        m_ftpEngine.Tracing.WriteLine( "Data channel stream received {0} bytes"' bytesRead );         #endif  }  catch (IOException exception) {  	SocketException socketExeption;  	/* We watch for the socket receive timeout here. The timeout occurs if the socket receives          * no data for the value in Socket.ReceiveTimeout property.          *           * If some data is received and then stops' this timeout will not trigger.           * NetworkStream.ReceiveTimeout is used in that case.          *           * We concern ourselves with the socket timeout only here because we want to watch for the case          * where the server has sent us an entire file but the last read will never unblock because          * there is no more data.          */socketExeption = exception.InnerException as SocketException;  	// If the socket ReceiveTimeout hasn't expired and the connection hasn't been forcibly closed  	if (socketExeption == null || (socketExeption.ErrorCode != 10060 && socketExeption.ErrorCode != 10054)) {  		#if DEBUG_DATACHANNEL  		          m_ftpEngine.Tracing.WriteLine( "Data channel stream throws {0}: {1}\n{2}"' exception.GetType().Name' exception.Message' exception.StackTrace );           #endif  		// It's not the expected exception' throw it  		throw exception;  	}  	#if DEBUG_DATACHANNEL  	        m_ftpEngine.Tracing.WriteLine( "Data channel stream signals the end of stream because we got a SocketException with an receive error code we find acceptable (timeout or connection closed)" );         #endif  	// We don't consider this an error. We gracefully say that the stream has ended  	bytesRead = 0;  }  
Magic Number,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Read,The following statement contains a magic number: try {  	#if DEBUG_DATACHANNEL  	        m_ftpEngine.Tracing.WriteLine( "Data channel stream asks to receive at most {0} bytes of data"' count );         #endif  	bytesRead = networkStream.Read (buffer' offset' count);  	#if DEBUG_DATACHANNEL  	        m_ftpEngine.Tracing.WriteLine( "Data channel stream received {0} bytes"' bytesRead );         #endif  }  catch (IOException exception) {  	SocketException socketExeption;  	/* We watch for the socket receive timeout here. The timeout occurs if the socket receives          * no data for the value in Socket.ReceiveTimeout property.          *           * If some data is received and then stops' this timeout will not trigger.           * NetworkStream.ReceiveTimeout is used in that case.          *           * We concern ourselves with the socket timeout only here because we want to watch for the case          * where the server has sent us an entire file but the last read will never unblock because          * there is no more data.          */socketExeption = exception.InnerException as SocketException;  	// If the socket ReceiveTimeout hasn't expired and the connection hasn't been forcibly closed  	if (socketExeption == null || (socketExeption.ErrorCode != 10060 && socketExeption.ErrorCode != 10054)) {  		#if DEBUG_DATACHANNEL  		          m_ftpEngine.Tracing.WriteLine( "Data channel stream throws {0}: {1}\n{2}"' exception.GetType().Name' exception.Message' exception.StackTrace );           #endif  		// It's not the expected exception' throw it  		throw exception;  	}  	#if DEBUG_DATACHANNEL  	        m_ftpEngine.Tracing.WriteLine( "Data channel stream signals the end of stream because we got a SocketException with an receive error code we find acceptable (timeout or connection closed)" );         #endif  	// We don't consider this an error. We gracefully say that the stream has ended  	bytesRead = 0;  }  
Magic Number,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Read,The following statement contains a magic number: if (socketExeption == null || (socketExeption.ErrorCode != 10060 && socketExeption.ErrorCode != 10054)) {  	#if DEBUG_DATACHANNEL  	          m_ftpEngine.Tracing.WriteLine( "Data channel stream throws {0}: {1}\n{2}"' exception.GetType().Name' exception.Message' exception.StackTrace );           #endif  	// It's not the expected exception' throw it  	throw exception;  }  
Magic Number,Xceed.Ftp.Engine,FtpDataChannelStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpDataChannelStream.cs,Read,The following statement contains a magic number: if (socketExeption == null || (socketExeption.ErrorCode != 10060 && socketExeption.ErrorCode != 10054)) {  	#if DEBUG_DATACHANNEL  	          m_ftpEngine.Tracing.WriteLine( "Data channel stream throws {0}: {1}\n{2}"' exception.GetType().Name' exception.Message' exception.StackTrace );           #endif  	// It's not the expected exception' throw it  	throw exception;  }  
Missing Default,Xceed.Ftp,FtpStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\(FileSystem)\FtpStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Current:  	offset += m_position;  	break;  case SeekOrigin.End:  	// Adding a negative value  	offset = length + offset;  	break;  }  
Missing Default,Xceed.Ftp.Engine,DataChannelProtectionFtpCommand,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Commands)\DataChannelProtectionFtpCommand.cs,ToString,The following switch statement is missing a default case: switch (m_protection) {  case DataChannelProtection.Clear:  	command += "C";  	break;  case DataChannelProtection.Private:  	command += "P";  	break;  }  
Missing Default,Xceed.Ftp.Engine,MatchRemoteFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\MatchRemoteFilesFtpCommandSequence.cs,OnCommandCompleted,The following switch statement is missing a default case: switch (action) {  case MultipleFileTransferErrorAction.Abort:  	return true;  case MultipleFileTransferErrorAction.Ignore:  	this.RemoveNextCommand (typeof(MatchRemoteFilesFtpCommandSequence)).Dispose ();  	this.RemoveNextCommand (typeof(ChangeFolderFtpCommand)).Dispose ();  	return false;  case MultipleFileTransferErrorAction.Retry:  	// We cannot reuse the same instance since command is disposable.  	this.InsertCommand (changeFolderCommand.GetCopy ());  	return false;  }  
Missing Default,Xceed.Ftp.Engine,ReceiveMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\ReceiveMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,The following switch statement is missing a default case: switch (action) {  case MultipleFileTransferErrorAction.Abort:  	return true;  case MultipleFileTransferErrorAction.Ignore:  	this.SkipFile ();  	return false;  case MultipleFileTransferErrorAction.Retry:  	// We cannot reuse same instance since disposable.  	receiveSequence = (ReceiveFileFtpCommandSequence)receiveSequence.GetCopy ();  	// Copies are not advised with original delegates.  	receiveSequence.RetrieveCommand.Progression += new ProgressionEventHandler (this.OnProgression);  	this.InsertCommand (receiveSequence);  	return false;  }  
Missing Default,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,The following switch statement is missing a default case: switch (action) {  case MultipleFileTransferErrorAction.Abort:  	return true;  case MultipleFileTransferErrorAction.Ignore:  	// We must skip all commands between the following open marker  	// and its matching close marker.  	this.RemoveMarkedCommands ();  	return false;  case MultipleFileTransferErrorAction.Retry:  	// We cannot reuse same instances' since commands are disposable.  	if (lastFailedCreateFolder != null) {  		this.InsertCommand (lastFailedCreateFolder.GetCopy ());  	}  	this.InsertCommand (changeFolderCommand.GetCopy ());  	return false;  }  
Missing Default,Xceed.Ftp.Engine,SendMultipleFilesFtpCommandSequence,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\(Sequences)\SendMultipleFilesFtpCommandSequence.cs,OnCommandCompleted,The following switch statement is missing a default case: switch (action) {  case MultipleFileTransferErrorAction.Abort:  	return true;  case MultipleFileTransferErrorAction.Ignore:  	this.SkipFile ();  	return false;  case MultipleFileTransferErrorAction.Retry:  	sendSequence = (SendFileFtpCommandSequence)sendSequence.GetCopy ();  	// Copies are not advised with original delegates.  	sendSequence.StoreCommand.Progression += new ProgressionEventHandler (this.OnProgression);  	this.InsertCommand (sendSequence);  	return false;  }  
Missing Default,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,ChangeDataChannelSecurityProtocol,The following switch statement is missing a default case: switch (dataChannelProtection) {  case DataChannelProtection.Clear:  	if (sslProtocol != System.Security.Authentication.SslProtocols.None)  		sslProtocol = SslProtocols.None;  	break;  case DataChannelProtection.Private:  	if (sslProtocol == System.Security.Authentication.SslProtocols.None)  		throw new FtpException ("Cannot change the data channel protection to Private and specify None as SslProtocols.");  	break;  }  
Missing Default,Xceed.Ftp.Engine,FtpCommandChannel,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Engine\FtpCommandChannel.cs,OnServerCertificateValidationCallback,The following switch statement is missing a default case: switch (args.Action) {  case VerificationAction.VerifyAgain:  	System.Diagnostics.Debug.Assert (handler != null' "Only a valid handler should be able to set this value.");  	m_verificationFlags = args.Flags;  	verifyAgain = true;  	break;  case VerificationAction.Accept:  	return true;  case VerificationAction.Reject:  	return false;  }  
Missing Default,Xceed.Utils.Streams,CombinedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Ftp.Blueprint\Utils\Streams\CombinedStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin:  	this.Position = offset;  	break;  case SeekOrigin.End:  	this.Position = this.Length + offset;  	break;  case SeekOrigin.Current:  	this.Position += offset;  	break;  }  
