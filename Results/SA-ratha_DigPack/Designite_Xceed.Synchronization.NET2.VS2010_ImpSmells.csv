Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The method has 231 lines of code.
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The method has 122 lines of code.
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderEntities,The method has 135 lines of code.
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage1MasterItem,The method has 182 lines of code.
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage2ConflictResolution,The method has 152 lines of code.
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The method has 207 lines of code.
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage3Analysis,The method has 109 lines of code.
Long Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage4FileOperations,The method has 135 lines of code.
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,Cyclomatic complexity of the method is 41
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolders,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderFiles,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderEntities,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,LoadMetaData,Cyclomatic complexity of the method is 13
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage1MasterItem,Cyclomatic complexity of the method is 26
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage2ConflictResolution,Cyclomatic complexity of the method is 19
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,Cyclomatic complexity of the method is 22
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage3Analysis,Cyclomatic complexity of the method is 15
Complex Method,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage4FileOperations,Cyclomatic complexity of the method is 31
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SynchronizationEventsSession,The method has 5 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetMetaDataSaveArgs,The method has 7 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetMetaDataLoadArgs,The method has 7 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetCompareFileDataArgs,The method has 5 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetCompareFileDataArgs,The method has 8 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetConflictArgs,The method has 6 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetConflictArgs,The method has 9 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetGetFileFromFolderArgs,The method has 5 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetAnalysisArgs,The method has 5 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetAnalysisArgs,The method has 8 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetFolderProgressionArgs,The method has 11 parameters.
Long Parameter List,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetFolderOperationAnalysisArgs,The method has 5 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The method has 6 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The method has 7 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The method has 8 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The method has 10 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The method has 7 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolders,The method has 7 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolder,The method has 12 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderFiles,The method has 13 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderEntities,The method has 7 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage1MasterItem,The method has 9 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage2ConflictResolution,The method has 9 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The method has 5 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,UpdateLatestFileIndex,The method has 6 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage3Analysis,The method has 10 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage4FileOperations,The method has 7 parameters.
Long Parameter List,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,PerformFirstPassOnItem,The method has 7 parameters.
Long Identifier,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetMetaDataSaveArgs,The length of the parameter componentAccessesMetaDataFileData is 33.
Long Identifier,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetMetaDataLoadArgs,The length of the parameter componentAccessesMetaDataFileData is 33.
Long Identifier,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The length of the parameter synchronizationEventsParameter is 30.
Long Identifier,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The length of the parameter fileSystemEventsUserDataParameter is 33.
Long Identifier,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The length of the parameter synchronizationEventsUserDataParameter is 38.
Long Identifier,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage2ConflictResolution,The length of the parameter ModifiedAfterLastSynchronizationCount is 37.
Long Statement,Xceed.Synchronization,SynchronizationEvents,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEvents.cs,CreateSession,The length of the statement  "	return new SynchronizationEventsSession (this' synchronizationEventsUserData' fileSystemEvents' fileSystemEventsUserData' sender); " is 130.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,OnFolderSynchronizationProgression,The length of the statement  "		this.EventsInternal.OnFolderSynchronizationProgression (this.SenderInternal' this.FolderSynchronizationProgressionArgs); " is 120.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,OnProgression,The length of the statement  "		if ((this.FilesBytes.Processed / divisor > currentRatio) || (this.FilesItems.Processed > currentItems) || (this.FilesBytes.Percent == 100)) { " is 141.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,OnCompleted,The length of the statement  "			this.OnProgression (this.FilesBytes.Total - this.FilesBytes.Processed' this.FilesItems.Total - this.FilesItems.Processed); " is 122.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetCompareFileDataArgs,The length of the statement  "	this.SetCompareFileDataArgs (componentComparesFiles' filesEqualToMaster' false' files' false' filesToCompare' true' masterFileIndex); " is 133.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetCompareFileDataArgs,The length of the statement  "	this.FilesEqualToMaster = (bool[])Synchronizer.CopyArray (this.FilesEqualToMaster' filesEqualToMaster' copyFilesEqualToMaster); " is 127.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetCompareFileDataArgs,The length of the statement  "	this.FilesToCompare = (AbstractFile[])Synchronizer.CopyArray (this.FilesToCompare' filesToCompare' typeof(AbstractFile)); " is 121.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetConflictArgs,The length of the statement  "	this.SetConflictArgs (files' false' conflictReasons' false' actions' false' originalMasterFileIndex' suggestedMasterFileIndex' cancel); " is 135.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetConflictArgs,The length of the statement  "	this.ConflictReasons = (SynchronizationConflictReason[])Synchronizer.CopyArray (this.ConflictReasons' conflictReasons' copyConflictReasons); " is 140.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetAnalysisArgs,The length of the statement  "	this.ConflictReasons = (SynchronizationConflictReason[])Synchronizer.CopyArray (this.ConflictReasons' reasons' copyReasons); " is 124.
Long Statement,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,SetFolderProgressionArgs,The length of the statement  "	args.IrrelevantItemIndexes = (int[])Synchronizer.CopyArray (args.IrrelevantItemIndexes' irrelevantItemIndexes' typeof(int)); " is 124.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The length of the statement  "	result |= Synchronize (events' fileSystemEventsUserData' synchronizationEvents' synchronizationEventsUserData' options' masterItemIndex' metadataItem' items' irrelevantItems' (Filter[])filters.ToArray (typeof(Filter))); " is 219.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The length of the statement  "	return Synchronize (fileSystemEvents' null' synchronizationEvents' null' options' -1' metadataItem' items' null' filters); " is 122.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The length of the statement  "	return Synchronize (fileSystemEvents' fileSystemEventsUserData' synchronizationEvents' synchronizationEventsUserData' options' -1' metadataItem' items' null' filters); " is 167.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The length of the statement  "	return Synchronize (fileSystemEvents' null' synchronizationEvents' null' options' masterItemIndex' metadataItem' items' null' filters); " is 135.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The length of the statement  "	return Synchronize (fileSystemEvents' fileSystemEventsUserData' synchronizationEvents' synchronizationEventsUserData' options' masterItemIndex' metadataItem' items' null' filters); " is 180.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The length of the statement  "	result |= Synchronize (fileSystemEvents' fileSystemEventsUserData' synchronizationEvents' synchronizationEventsUserData' options' masterItemIndex' metadataItem' items' null' filters); " is 183.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The length of the statement  "	session = synchronizationEvents.CreateSession (fileSystemEvents' fileSystemEventsUserData' null' synchronizationEventsUserData); " is 128.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Synchronize,The length of the statement  "	result |= DoSynchronize (session' options' masterItemIndex' metaDataItem' workItems' workIrrelevantItemIndexes' filters); " is 121.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The length of the statement  "	masterItemIndex = Stage1MasterItem (session' session.Options' metaDataItem' workItems' workIrrelevantItemIndexes' masterItemIndex' out allFolder' out proceed' filters); " is 168.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The length of the statement  "			masterItemIndex = Stage2ConflictResolution (session' session.Options' files' masterItemIndex' manualMasterFile' reasons' actions' dataEqualToMaster' out proceed); " is 162.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The length of the statement  "			cancel = Stage3Analysis (session' session.Options' files' masterItemIndex' lastSynchronizationDate' actions' reasons' dataEqualToMaster' out proceed' out retry); " is 161.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The length of the statement  "			if ((session.SynchronizationResult & (SynchronizationResult.ItemsSynchronized | SynchronizationResult.NoActionTaken)) == (SynchronizationResult.ItemsSynchronized | SynchronizationResult.NoActionTaken)) { " is 203.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The length of the statement  "			SynchronizeFolderEntities (session' session.Options' masterItemIndex' metaDataItem' workItems' workIrrelevantItemIndexes' filters); " is 131.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolders,The length of the statement  "	SynchronizeFolder (session' options' masterItemIndex' metaDataItem' filters' folders' workArrayList' workIrrelevantItemIndexes' (AbstractFolder)folders [masterFolderIndex]' masterFolderIndex' processedContent [masterFolderIndex]' out abort); " is 241.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolders,The length of the statement  "				SynchronizeFolder (session' options' masterItemIndex' metaDataItem' filters' folders' workArrayList' workIrrelevantItemIndexes' (AbstractFolder)folders [i]' i' processedContent [i]' out abort); " is 193.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolder,The length of the statement  "				SynchronizeFolderFiles (session' options' masterItemIndex' metaDataItem' filters' folders' workArrayList' workIrrelevantItemIndexes' folderIndex' subFolders [i]' files' processedContent' out abort); " is 198.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolder,The length of the statement  "		SynchronizeFolderFiles (session' options' masterItemIndex' metaDataItem' filters' folders' workArrayList' workIrrelevantItemIndexes' folderIndex' folder' files' processedContent' out abort); " is 190.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderFiles,The length of the statement  "				session.SetFolderProgressionArgs (file' workArrayList' options' true' masterItemIndex' metaDataItem' workIrrelevantItemIndexes' filters' false' false' false); " is 158.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderFiles,The length of the statement  "					DoSynchronize (session' args.Options' args.MasterItemIndex' args.MetaDataItem' workArrayList' workIrrelevantItemIndexes' args.Filters); " is 135.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SynchronizeFolderEntities,The length of the statement  "						actions [i] = options.AllowCreations ? SynchronizationAction.CreateOrOverwriteWithMaster : SynchronizationAction.SuspendedCreateOrOverwrite; " is 140.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,MetaDataObtainFileFromFileSystemItem,The length of the statement  "				throw new ArgumentException ("When performing folder synchronizations' the only supported locations for meta data are folders."' "metaDataItem"); " is 145.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,LoadMetaData,The length of the statement  "				stream = file.OpenRead (session.FileSystemEvents' session.FileSystemEventsUserData' FileShare.ReadWrite | FileShare.Inheritable); " is 129.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SaveMetaData,The length of the statement  "				stream = file.OpenWrite (session.FileSystemEvents' session.FileSystemEventsUserData' true' FileShare.ReadWrite | FileShare.Inheritable); " is 136.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SaveMetaData,The length of the statement  "				stream = file.CreateWrite (session.FileSystemEvents' session.FileSystemEventsUserData' FileShare.ReadWrite | FileShare.Inheritable); " is 132.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage1MasterItem,The length of the statement  "			session.SetGetFileFromFolderArgs ((FileSystemItem[])items.ToArray (typeof(FileSystemItem))' false' masterItemIndex' null' null); " is 128.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage2ConflictResolution,The length of the statement  "	if (masterItemIndex >= 0 && (reasons [masterItemIndex] & SynchronizationConflictReason.ModifiedAfterLastSynchronization) != 0 && ModifiedAfterLastSynchronizationCount <= 1) { " is 174.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The length of the statement  "		session.SetCompareFileDataArgs (args.ComponentComparesFiles' dataEqualToMaster' false' files' true' filesToCompare' true' masterFileIndex); " is 139.
Long Statement,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage3Analysis,The length of the statement  "		/* We will use a copy of the file list so the user doesn't mess with our list */// Fill the relevant session fields for the analysis event " is 138.
Complex Conditional,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,DoSynchronize,The conditional expression  "!session.Options.PreviewOnly && session.Options.UseMetaData && session.Name.Length > 0 && files.Length > 1"  is complex.
Empty Catch Block,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,LoadMetaData,The method has an empty catch block.
Magic Number,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The following statement contains a magic number: k -= 16;  
Magic Number,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,OnProgression,The following statement contains a magic number: if (this.EventsInternal.WantsSynchronizationProgression) {  	long divisor = this.Options.ByteProgressionTriggerThreshold + 1;  	long currentItems = this.FilesItems.Processed;  	int currentRatio = (int)(this.FilesBytes.Processed / divisor);  	this.FilesBytes.Processed += bytesProcessed;  	this.AllFilesBytes.Processed += bytesProcessed;  	this.FilesItems.Processed += itemsProcessed;  	this.AllFilesItems.Processed += itemsProcessed;  	if ((this.FilesBytes.Processed / divisor > currentRatio) || (this.FilesItems.Processed > currentItems) || (this.FilesBytes.Percent == 100)) {  		try {  			this.EventsInternal.OnSynchronizationProgression (this.SenderInternal' this.ProgressionArgs);  		}  		catch (Exception handlerException) {  			throw new System.Reflection.TargetInvocationException (handlerException);  		}  	}  }  
Magic Number,Xceed.Synchronization,SynchronizationEventsSession,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\SynchronizationEventsSession.cs,OnProgression,The following statement contains a magic number: if ((this.FilesBytes.Processed / divisor > currentRatio) || (this.FilesItems.Processed > currentItems) || (this.FilesBytes.Percent == 100)) {  	try {  		this.EventsInternal.OnSynchronizationProgression (this.SenderInternal' this.ProgressionArgs);  	}  	catch (Exception handlerException) {  		throw new System.Reflection.TargetInvocationException (handlerException);  	}  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: do {  	while (enumerator.MoveNext ()) {  		if ((parameter = enumerator.Current) == null) {  			continue;  		}  		if ((parameterArray = parameter as Array) != null) {  			Type type = parameterArray.GetType ();  			if (type == typeof(FileSystemItem[]) || type == typeof(AbstractFile[]) || type == typeof(AbstractFolder[])) {  				items.AddRange (parameterArray);  			}  			else if (type == typeof(Filter[])) {  				filters.AddRange (parameterArray);  			}  			else if (type == typeof(int[])) {  				if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  					irrelevantItems.Clear ();  				}  				irrelevantItems.AddRange (parameterArray);  			}  			else {  				// If we don't have a parameter stack  				if (parameterListStack == null) {  					// Create one  					parameterListStack = new Stack (2);  					// Push the current parameters on the stack  					parameterListStack.Push (enumerator);  				}  				// Create an enumerator from the array  				enumerator = parameterArray.GetEnumerator ();  				enumerator.Reset ();  				// Push the new enumerator on top of the stack for immediate processing  				parameterListStack.Push (enumerator);  			}  		}  		else if (parameter is AbstractFile) {  			items.Add (parameter);  		}  		else if (parameter is AbstractFolder) {  			items.Add (parameter);  		}  		else if (parameter is Filter) {  			filters.Add (parameter);  		}  		else if ((eventsParameter = parameter as FileSystemEvents) != null) {  			events = eventsParameter;  		}  		else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  			synchronizationEvents = synchronizationEventsParameter;  		}  		else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  			options = optionsParameter;  		}  		else if (parameter is Int32) {  			masterItemIndex = (int)parameter;  		}  		else if ((userDataParameter = parameter as UserDataParameter) != null) {  			fileSystemEventsUserData = userDataParameter.UserData;  			synchronizationEventsUserData = userDataParameter.UserData;  		}  		else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  			fileSystemEventsUserData = userDataParameter.UserData;  		}  		else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  			synchronizationEventsUserData = userDataParameter.UserData;  		}  		else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  			metadataItem = metadataItemParameter.Item;  		}  		else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  			if (masterItemParameter.Index >= 0) {  				masterItemIndex = masterItemParameter.Index;  			}  			else {  				masterItem = masterItemParameter.Item;  			}  		}  		else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  			if (irrelevantItemsParameter.Indexes != null) {  				if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  					irrelevantItems.Clear ();  				}  				irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  			}  			else {  				if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  					irrelevantItems.Clear ();  				}  				irrelevantItems.AddRange (irrelevantItemsParameter.Items);  			}  		}  		else if (parameter == SynchronizeCommandParameter.ResetItemList) {  			items.Clear ();  		}  		else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  			filters.Clear ();  		}  		else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  			irrelevantItems.Clear ();  		}  		else if (parameter == SynchronizeCommandParameter.ResetParameters) {  			// Reset the parameters  			items.Clear ();  			filters.Clear ();  			irrelevantItems.Clear ();  			events = FileSystemEvents.Empty;  			synchronizationEvents = SynchronizationEvents.Empty;  			fileSystemEventsUserData = null;  			synchronizationEventsUserData = null;  			options = SynchronizationOptions.Default;  			metadataItem = DefaultMetadataItem;  			masterItemIndex = -1;  			masterItem = null;  		}  		/* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  			// If we don't have a parameter stack yet  			if (parameterListStack == null) {  				// Create one  				parameterListStack = new Stack (2);  				// Push our current parameter enumerator  				parameterListStack.Push (enumerator);  			}  			// Get an enumerator from the enumerable  			enumerator = enumerable.GetEnumerator ();  			enumerator.Reset ();  			// Push the new enumerator on top of the stack for immediate processing  			parameterListStack.Push (enumerator);  		}  		else {  			throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  		}  	}  	// If we have a parameter list stack  	if (parameterListStack != null) {  		// Pop the top element as we're done with it  		parameterListStack.Pop ();  		// If we still have elements in the list  		if (parameterListStack.Count > 0) {  			// Peek at and store the top element  			enumerator = (IEnumerator)parameterListStack.Peek ();  		}  	}  }  // While we have a parameter list stack and it's not empty  while (parameterListStack != null && parameterListStack.Count > 0);  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: do {  	while (enumerator.MoveNext ()) {  		if ((parameter = enumerator.Current) == null) {  			continue;  		}  		if ((parameterArray = parameter as Array) != null) {  			Type type = parameterArray.GetType ();  			if (type == typeof(FileSystemItem[]) || type == typeof(AbstractFile[]) || type == typeof(AbstractFolder[])) {  				items.AddRange (parameterArray);  			}  			else if (type == typeof(Filter[])) {  				filters.AddRange (parameterArray);  			}  			else if (type == typeof(int[])) {  				if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  					irrelevantItems.Clear ();  				}  				irrelevantItems.AddRange (parameterArray);  			}  			else {  				// If we don't have a parameter stack  				if (parameterListStack == null) {  					// Create one  					parameterListStack = new Stack (2);  					// Push the current parameters on the stack  					parameterListStack.Push (enumerator);  				}  				// Create an enumerator from the array  				enumerator = parameterArray.GetEnumerator ();  				enumerator.Reset ();  				// Push the new enumerator on top of the stack for immediate processing  				parameterListStack.Push (enumerator);  			}  		}  		else if (parameter is AbstractFile) {  			items.Add (parameter);  		}  		else if (parameter is AbstractFolder) {  			items.Add (parameter);  		}  		else if (parameter is Filter) {  			filters.Add (parameter);  		}  		else if ((eventsParameter = parameter as FileSystemEvents) != null) {  			events = eventsParameter;  		}  		else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  			synchronizationEvents = synchronizationEventsParameter;  		}  		else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  			options = optionsParameter;  		}  		else if (parameter is Int32) {  			masterItemIndex = (int)parameter;  		}  		else if ((userDataParameter = parameter as UserDataParameter) != null) {  			fileSystemEventsUserData = userDataParameter.UserData;  			synchronizationEventsUserData = userDataParameter.UserData;  		}  		else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  			fileSystemEventsUserData = userDataParameter.UserData;  		}  		else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  			synchronizationEventsUserData = userDataParameter.UserData;  		}  		else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  			metadataItem = metadataItemParameter.Item;  		}  		else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  			if (masterItemParameter.Index >= 0) {  				masterItemIndex = masterItemParameter.Index;  			}  			else {  				masterItem = masterItemParameter.Item;  			}  		}  		else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  			if (irrelevantItemsParameter.Indexes != null) {  				if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  					irrelevantItems.Clear ();  				}  				irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  			}  			else {  				if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  					irrelevantItems.Clear ();  				}  				irrelevantItems.AddRange (irrelevantItemsParameter.Items);  			}  		}  		else if (parameter == SynchronizeCommandParameter.ResetItemList) {  			items.Clear ();  		}  		else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  			filters.Clear ();  		}  		else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  			irrelevantItems.Clear ();  		}  		else if (parameter == SynchronizeCommandParameter.ResetParameters) {  			// Reset the parameters  			items.Clear ();  			filters.Clear ();  			irrelevantItems.Clear ();  			events = FileSystemEvents.Empty;  			synchronizationEvents = SynchronizationEvents.Empty;  			fileSystemEventsUserData = null;  			synchronizationEventsUserData = null;  			options = SynchronizationOptions.Default;  			metadataItem = DefaultMetadataItem;  			masterItemIndex = -1;  			masterItem = null;  		}  		/* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  			// If we don't have a parameter stack yet  			if (parameterListStack == null) {  				// Create one  				parameterListStack = new Stack (2);  				// Push our current parameter enumerator  				parameterListStack.Push (enumerator);  			}  			// Get an enumerator from the enumerable  			enumerator = enumerable.GetEnumerator ();  			enumerator.Reset ();  			// Push the new enumerator on top of the stack for immediate processing  			parameterListStack.Push (enumerator);  		}  		else {  			throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  		}  	}  	// If we have a parameter list stack  	if (parameterListStack != null) {  		// Pop the top element as we're done with it  		parameterListStack.Pop ();  		// If we still have elements in the list  		if (parameterListStack.Count > 0) {  			// Peek at and store the top element  			enumerator = (IEnumerator)parameterListStack.Peek ();  		}  	}  }  // While we have a parameter list stack and it's not empty  while (parameterListStack != null && parameterListStack.Count > 0);  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: while (enumerator.MoveNext ()) {  	if ((parameter = enumerator.Current) == null) {  		continue;  	}  	if ((parameterArray = parameter as Array) != null) {  		Type type = parameterArray.GetType ();  		if (type == typeof(FileSystemItem[]) || type == typeof(AbstractFile[]) || type == typeof(AbstractFolder[])) {  			items.AddRange (parameterArray);  		}  		else if (type == typeof(Filter[])) {  			filters.AddRange (parameterArray);  		}  		else if (type == typeof(int[])) {  			if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  				irrelevantItems.Clear ();  			}  			irrelevantItems.AddRange (parameterArray);  		}  		else {  			// If we don't have a parameter stack  			if (parameterListStack == null) {  				// Create one  				parameterListStack = new Stack (2);  				// Push the current parameters on the stack  				parameterListStack.Push (enumerator);  			}  			// Create an enumerator from the array  			enumerator = parameterArray.GetEnumerator ();  			enumerator.Reset ();  			// Push the new enumerator on top of the stack for immediate processing  			parameterListStack.Push (enumerator);  		}  	}  	else if (parameter is AbstractFile) {  		items.Add (parameter);  	}  	else if (parameter is AbstractFolder) {  		items.Add (parameter);  	}  	else if (parameter is Filter) {  		filters.Add (parameter);  	}  	else if ((eventsParameter = parameter as FileSystemEvents) != null) {  		events = eventsParameter;  	}  	else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  		synchronizationEvents = synchronizationEventsParameter;  	}  	else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  		options = optionsParameter;  	}  	else if (parameter is Int32) {  		masterItemIndex = (int)parameter;  	}  	else if ((userDataParameter = parameter as UserDataParameter) != null) {  		fileSystemEventsUserData = userDataParameter.UserData;  		synchronizationEventsUserData = userDataParameter.UserData;  	}  	else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  		fileSystemEventsUserData = userDataParameter.UserData;  	}  	else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  		synchronizationEventsUserData = userDataParameter.UserData;  	}  	else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  		metadataItem = metadataItemParameter.Item;  	}  	else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  		if (masterItemParameter.Index >= 0) {  			masterItemIndex = masterItemParameter.Index;  		}  		else {  			masterItem = masterItemParameter.Item;  		}  	}  	else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  		if (irrelevantItemsParameter.Indexes != null) {  			if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  				irrelevantItems.Clear ();  			}  			irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  		}  		else {  			if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  				irrelevantItems.Clear ();  			}  			irrelevantItems.AddRange (irrelevantItemsParameter.Items);  		}  	}  	else if (parameter == SynchronizeCommandParameter.ResetItemList) {  		items.Clear ();  	}  	else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  		filters.Clear ();  	}  	else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  		irrelevantItems.Clear ();  	}  	else if (parameter == SynchronizeCommandParameter.ResetParameters) {  		// Reset the parameters  		items.Clear ();  		filters.Clear ();  		irrelevantItems.Clear ();  		events = FileSystemEvents.Empty;  		synchronizationEvents = SynchronizationEvents.Empty;  		fileSystemEventsUserData = null;  		synchronizationEventsUserData = null;  		options = SynchronizationOptions.Default;  		metadataItem = DefaultMetadataItem;  		masterItemIndex = -1;  		masterItem = null;  	}  	/* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  		// If we don't have a parameter stack yet  		if (parameterListStack == null) {  			// Create one  			parameterListStack = new Stack (2);  			// Push our current parameter enumerator  			parameterListStack.Push (enumerator);  		}  		// Get an enumerator from the enumerable  		enumerator = enumerable.GetEnumerator ();  		enumerator.Reset ();  		// Push the new enumerator on top of the stack for immediate processing  		parameterListStack.Push (enumerator);  	}  	else {  		throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  	}  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: while (enumerator.MoveNext ()) {  	if ((parameter = enumerator.Current) == null) {  		continue;  	}  	if ((parameterArray = parameter as Array) != null) {  		Type type = parameterArray.GetType ();  		if (type == typeof(FileSystemItem[]) || type == typeof(AbstractFile[]) || type == typeof(AbstractFolder[])) {  			items.AddRange (parameterArray);  		}  		else if (type == typeof(Filter[])) {  			filters.AddRange (parameterArray);  		}  		else if (type == typeof(int[])) {  			if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  				irrelevantItems.Clear ();  			}  			irrelevantItems.AddRange (parameterArray);  		}  		else {  			// If we don't have a parameter stack  			if (parameterListStack == null) {  				// Create one  				parameterListStack = new Stack (2);  				// Push the current parameters on the stack  				parameterListStack.Push (enumerator);  			}  			// Create an enumerator from the array  			enumerator = parameterArray.GetEnumerator ();  			enumerator.Reset ();  			// Push the new enumerator on top of the stack for immediate processing  			parameterListStack.Push (enumerator);  		}  	}  	else if (parameter is AbstractFile) {  		items.Add (parameter);  	}  	else if (parameter is AbstractFolder) {  		items.Add (parameter);  	}  	else if (parameter is Filter) {  		filters.Add (parameter);  	}  	else if ((eventsParameter = parameter as FileSystemEvents) != null) {  		events = eventsParameter;  	}  	else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  		synchronizationEvents = synchronizationEventsParameter;  	}  	else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  		options = optionsParameter;  	}  	else if (parameter is Int32) {  		masterItemIndex = (int)parameter;  	}  	else if ((userDataParameter = parameter as UserDataParameter) != null) {  		fileSystemEventsUserData = userDataParameter.UserData;  		synchronizationEventsUserData = userDataParameter.UserData;  	}  	else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  		fileSystemEventsUserData = userDataParameter.UserData;  	}  	else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  		synchronizationEventsUserData = userDataParameter.UserData;  	}  	else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  		metadataItem = metadataItemParameter.Item;  	}  	else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  		if (masterItemParameter.Index >= 0) {  			masterItemIndex = masterItemParameter.Index;  		}  		else {  			masterItem = masterItemParameter.Item;  		}  	}  	else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  		if (irrelevantItemsParameter.Indexes != null) {  			if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  				irrelevantItems.Clear ();  			}  			irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  		}  		else {  			if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  				irrelevantItems.Clear ();  			}  			irrelevantItems.AddRange (irrelevantItemsParameter.Items);  		}  	}  	else if (parameter == SynchronizeCommandParameter.ResetItemList) {  		items.Clear ();  	}  	else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  		filters.Clear ();  	}  	else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  		irrelevantItems.Clear ();  	}  	else if (parameter == SynchronizeCommandParameter.ResetParameters) {  		// Reset the parameters  		items.Clear ();  		filters.Clear ();  		irrelevantItems.Clear ();  		events = FileSystemEvents.Empty;  		synchronizationEvents = SynchronizationEvents.Empty;  		fileSystemEventsUserData = null;  		synchronizationEventsUserData = null;  		options = SynchronizationOptions.Default;  		metadataItem = DefaultMetadataItem;  		masterItemIndex = -1;  		masterItem = null;  	}  	/* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  		// If we don't have a parameter stack yet  		if (parameterListStack == null) {  			// Create one  			parameterListStack = new Stack (2);  			// Push our current parameter enumerator  			parameterListStack.Push (enumerator);  		}  		// Get an enumerator from the enumerable  		enumerator = enumerable.GetEnumerator ();  		enumerator.Reset ();  		// Push the new enumerator on top of the stack for immediate processing  		parameterListStack.Push (enumerator);  	}  	else {  		throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  	}  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((parameterArray = parameter as Array) != null) {  	Type type = parameterArray.GetType ();  	if (type == typeof(FileSystemItem[]) || type == typeof(AbstractFile[]) || type == typeof(AbstractFolder[])) {  		items.AddRange (parameterArray);  	}  	else if (type == typeof(Filter[])) {  		filters.AddRange (parameterArray);  	}  	else if (type == typeof(int[])) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (parameterArray);  	}  	else {  		// If we don't have a parameter stack  		if (parameterListStack == null) {  			// Create one  			parameterListStack = new Stack (2);  			// Push the current parameters on the stack  			parameterListStack.Push (enumerator);  		}  		// Create an enumerator from the array  		enumerator = parameterArray.GetEnumerator ();  		enumerator.Reset ();  		// Push the new enumerator on top of the stack for immediate processing  		parameterListStack.Push (enumerator);  	}  }  else if (parameter is AbstractFile) {  	items.Add (parameter);  }  else if (parameter is AbstractFolder) {  	items.Add (parameter);  }  else if (parameter is Filter) {  	filters.Add (parameter);  }  else if ((eventsParameter = parameter as FileSystemEvents) != null) {  	events = eventsParameter;  }  else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  	synchronizationEvents = synchronizationEventsParameter;  }  else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((parameterArray = parameter as Array) != null) {  	Type type = parameterArray.GetType ();  	if (type == typeof(FileSystemItem[]) || type == typeof(AbstractFile[]) || type == typeof(AbstractFolder[])) {  		items.AddRange (parameterArray);  	}  	else if (type == typeof(Filter[])) {  		filters.AddRange (parameterArray);  	}  	else if (type == typeof(int[])) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (parameterArray);  	}  	else {  		// If we don't have a parameter stack  		if (parameterListStack == null) {  			// Create one  			parameterListStack = new Stack (2);  			// Push the current parameters on the stack  			parameterListStack.Push (enumerator);  		}  		// Create an enumerator from the array  		enumerator = parameterArray.GetEnumerator ();  		enumerator.Reset ();  		// Push the new enumerator on top of the stack for immediate processing  		parameterListStack.Push (enumerator);  	}  }  else if (parameter is AbstractFile) {  	items.Add (parameter);  }  else if (parameter is AbstractFolder) {  	items.Add (parameter);  }  else if (parameter is Filter) {  	filters.Add (parameter);  }  else if ((eventsParameter = parameter as FileSystemEvents) != null) {  	events = eventsParameter;  }  else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  	synchronizationEvents = synchronizationEventsParameter;  }  else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (type == typeof(FileSystemItem[]) || type == typeof(AbstractFile[]) || type == typeof(AbstractFolder[])) {  	items.AddRange (parameterArray);  }  else if (type == typeof(Filter[])) {  	filters.AddRange (parameterArray);  }  else if (type == typeof(int[])) {  	if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  		irrelevantItems.Clear ();  	}  	irrelevantItems.AddRange (parameterArray);  }  else {  	// If we don't have a parameter stack  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push the current parameters on the stack  		parameterListStack.Push (enumerator);  	}  	// Create an enumerator from the array  	enumerator = parameterArray.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (type == typeof(Filter[])) {  	filters.AddRange (parameterArray);  }  else if (type == typeof(int[])) {  	if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  		irrelevantItems.Clear ();  	}  	irrelevantItems.AddRange (parameterArray);  }  else {  	// If we don't have a parameter stack  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push the current parameters on the stack  		parameterListStack.Push (enumerator);  	}  	// Create an enumerator from the array  	enumerator = parameterArray.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (type == typeof(int[])) {  	if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  		irrelevantItems.Clear ();  	}  	irrelevantItems.AddRange (parameterArray);  }  else {  	// If we don't have a parameter stack  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push the current parameters on the stack  		parameterListStack.Push (enumerator);  	}  	// Create an enumerator from the array  	enumerator = parameterArray.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameterListStack == null) {  	// Create one  	parameterListStack = new Stack (2);  	// Push the current parameters on the stack  	parameterListStack.Push (enumerator);  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: parameterListStack = new Stack (2);  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter is AbstractFile) {  	items.Add (parameter);  }  else if (parameter is AbstractFolder) {  	items.Add (parameter);  }  else if (parameter is Filter) {  	filters.Add (parameter);  }  else if ((eventsParameter = parameter as FileSystemEvents) != null) {  	events = eventsParameter;  }  else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  	synchronizationEvents = synchronizationEventsParameter;  }  else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter is AbstractFolder) {  	items.Add (parameter);  }  else if (parameter is Filter) {  	filters.Add (parameter);  }  else if ((eventsParameter = parameter as FileSystemEvents) != null) {  	events = eventsParameter;  }  else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  	synchronizationEvents = synchronizationEventsParameter;  }  else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter is Filter) {  	filters.Add (parameter);  }  else if ((eventsParameter = parameter as FileSystemEvents) != null) {  	events = eventsParameter;  }  else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  	synchronizationEvents = synchronizationEventsParameter;  }  else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((eventsParameter = parameter as FileSystemEvents) != null) {  	events = eventsParameter;  }  else if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  	synchronizationEvents = synchronizationEventsParameter;  }  else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((synchronizationEventsParameter = parameter as SynchronizationEvents) != null) {  	synchronizationEvents = synchronizationEventsParameter;  }  else if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((optionsParameter = parameter as SynchronizationOptions) != null) {  	options = optionsParameter;  }  else if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter is Int32) {  	masterItemIndex = (int)parameter;  }  else if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((userDataParameter = parameter as UserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((fileSystemEventsUserDataParameter = parameter as FileSystemEventsUserDataParameter) != null) {  	fileSystemEventsUserData = userDataParameter.UserData;  }  else if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((synchronizationEventsUserDataParameter = parameter as SynchronizationEventsUserDataParameter) != null) {  	synchronizationEventsUserData = userDataParameter.UserData;  }  else if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((metadataItemParameter = parameter as MetadataItemParameter) != null) {  	metadataItem = metadataItemParameter.Item;  }  else if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((masterItemParameter = parameter as MasterItemParameter) != null) {  	if (masterItemParameter.Index >= 0) {  		masterItemIndex = masterItemParameter.Index;  	}  	else {  		masterItem = masterItemParameter.Item;  	}  }  else if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((irrelevantItemsParameter = parameter as IrrelevantItemsParameter) != null) {  	if (irrelevantItemsParameter.Indexes != null) {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is int)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Indexes);  	}  	else {  		if (irrelevantItems.Count > 0 && !(irrelevantItems [0] is FileSystemItem)) {  			irrelevantItems.Clear ();  		}  		irrelevantItems.AddRange (irrelevantItemsParameter.Items);  	}  }  else if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter == SynchronizeCommandParameter.ResetItemList) {  	items.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter == SynchronizeCommandParameter.ResetFilterList) {  	filters.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter == SynchronizeCommandParameter.ResetIrrelevantItemIndexList) {  	irrelevantItems.Clear ();  }  else if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameter == SynchronizeCommandParameter.ResetParameters) {  	// Reset the parameters  	items.Clear ();  	filters.Clear ();  	irrelevantItems.Clear ();  	events = FileSystemEvents.Empty;  	synchronizationEvents = SynchronizationEvents.Empty;  	fileSystemEventsUserData = null;  	synchronizationEventsUserData = null;  	options = SynchronizationOptions.Default;  	metadataItem = DefaultMetadataItem;  	masterItemIndex = -1;  	masterItem = null;  }  /* This test should always be the last one before failure            * so that other more specific type who also happen to implement            * IEnumerable aren't ignored. */else if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if ((enumerable = parameter as IEnumerable) != null) {  	// If we don't have a parameter stack yet  	if (parameterListStack == null) {  		// Create one  		parameterListStack = new Stack (2);  		// Push our current parameter enumerator  		parameterListStack.Push (enumerator);  	}  	// Get an enumerator from the enumerable  	enumerator = enumerable.GetEnumerator ();  	enumerator.Reset ();  	// Push the new enumerator on top of the stack for immediate processing  	parameterListStack.Push (enumerator);  }  else {  	throw new ArgumentException ("The synchronize parameter array contains an unrecognized type."' "parameters");  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: if (parameterListStack == null) {  	// Create one  	parameterListStack = new Stack (2);  	// Push our current parameter enumerator  	parameterListStack.Push (enumerator);  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,EasySynchronize,The following statement contains a magic number: parameterListStack = new Stack (2);  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SaveMetaData,The following statement contains a magic number: if (writer == null) {  	if (metaDataItem != null) {  		file = MetaDataObtainFileFromFileSystemItem (session' options' metaDataItem);  		args.MetaDataFile = file;  		if (file.Exists) {  			stream = file.OpenWrite (session.FileSystemEvents' session.FileSystemEventsUserData' true' FileShare.ReadWrite | FileShare.Inheritable);  		}  		else {  			/* BUG: There seems to be a design bug in .NET that fails to address the              * note found in Window's CreateFile() that says:              *               * Windows Server 2003 and Windows XP/2000:  If CREATE_ALWAYS and              * FILE_ATTRIBUTE_NORMAL are specified' CreateFile fails and sets the               * last error to ERROR_ACCESS_DENIED if the file exists and has the               * FILE_ATTRIBUTE_HIDDEN or FILE_ATTRIBUTE_SYSTEM attribute. To avoid               * the error' specify the same attributes as the existing file.              *               * Hence' we cannot seem to be able to open hidden disk files in .NET *///file.Attributes &= ~FileAttributes.Normal;  			//file.Attributes |= FileAttributes.Hidden;  			stream = file.CreateWrite (session.FileSystemEvents' session.FileSystemEventsUserData' FileShare.ReadWrite | FileShare.Inheritable);  		}  		writer = internalWriter = new XmlTextWriter (stream' Encoding.Unicode);  		args.MetaDataXmlWriter = writer;  		internalWriter.Formatting = Formatting.Indented;  		internalWriter.Indentation = 4;  		internalWriter.WriteStartDocument ();  	}  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SaveMetaData,The following statement contains a magic number: if (metaDataItem != null) {  	file = MetaDataObtainFileFromFileSystemItem (session' options' metaDataItem);  	args.MetaDataFile = file;  	if (file.Exists) {  		stream = file.OpenWrite (session.FileSystemEvents' session.FileSystemEventsUserData' true' FileShare.ReadWrite | FileShare.Inheritable);  	}  	else {  		/* BUG: There seems to be a design bug in .NET that fails to address the              * note found in Window's CreateFile() that says:              *               * Windows Server 2003 and Windows XP/2000:  If CREATE_ALWAYS and              * FILE_ATTRIBUTE_NORMAL are specified' CreateFile fails and sets the               * last error to ERROR_ACCESS_DENIED if the file exists and has the               * FILE_ATTRIBUTE_HIDDEN or FILE_ATTRIBUTE_SYSTEM attribute. To avoid               * the error' specify the same attributes as the existing file.              *               * Hence' we cannot seem to be able to open hidden disk files in .NET *///file.Attributes &= ~FileAttributes.Normal;  		//file.Attributes |= FileAttributes.Hidden;  		stream = file.CreateWrite (session.FileSystemEvents' session.FileSystemEventsUserData' FileShare.ReadWrite | FileShare.Inheritable);  	}  	writer = internalWriter = new XmlTextWriter (stream' Encoding.Unicode);  	args.MetaDataXmlWriter = writer;  	internalWriter.Formatting = Formatting.Indented;  	internalWriter.Indentation = 4;  	internalWriter.WriteStartDocument ();  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,SaveMetaData,The following statement contains a magic number: internalWriter.Indentation = 4;  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: if (args.ComponentComparesFiles) {  	FileShare share;  	Stream reader1' reader2;  	int data1' data2;  	int previousBytesRead;  	reader1 = null;  	reader2 = null;  	// Add the file size to the amount to be processed  	session.AddFilesBytesToProcess (file1.Size);  	previousBytesRead = 0;  	share = FileShare.Read;  	try {  		// Open the master file for reading  		reader1 = file1.OpenRead (share);  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current file  			file2 = (AbstractFile)filesToCompare [i];  			// If we have a file to compare  			if (file2 != null) {  				// Assume the files are equal  				dataEqualToMaster [i] = true;  				// Clear the current slot  				filesToCompare [i] = null;  				// Open the current file for reading  				filesToCompare [i] = file2.OpenRead (share);  			}  		}  		do {  			/* TODO: Find a way to optimize this loop */// Get data from the master stream  			data1 = reader1.ReadByte ();  			// Go through all the files to compare in reverse order  			for (i = filesToCompare.Length - 1; i >= 0; i--) {  				// Get the current stream  				reader2 = (Stream)filesToCompare [i];  				// If we have a stream  				if (reader2 != null) {  					// Get data from the current stream  					data2 = reader2.ReadByte ();  					// If the data isn't the same  					if (data1 != data2) {  						// The files are not equal  						dataEqualToMaster [i] = false;  						// No need to compare this file anymore  						filesToCompare [i] = null;  						// Decrement the number of files to compare  						count--;  						// Close the current stream  						reader2.Close ();  					}  				}  			}  			// If we've reached a certain amount of read data  			if (previousBytesRead >= 32 * 1024) {  				// Add the file size to the amount to be processed  				session.OnProgression (previousBytesRead' 0);  				// Reset the counter  				previousBytesRead = 0;  			}  			// Increment the counter  			previousBytesRead += 1;  		}  		// Until we haven't reached the end of the file and still have  		// files to compare to  		while (data1 != -1 && count > 0);  	}  	catch (Exception) {  		object value;  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current value  			value = filesToCompare [i];  			// If we have a value  			if (value != null) {  				// Assume the current file is not equal  				dataEqualToMaster [i] = false;  			}  		}  	}  	finally {  		// If we have a master reader  		if (reader1 != null) {  			// Close it  			reader1.Close ();  			reader1 = null;  		}  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current stream  			reader2 = filesToCompare [i] as Stream;  			// If we have a reader  			if (reader2 != null) {  				// Close it  				reader2.Close ();  				reader2 = null;  			}  		}  	}  	// Force complete  	session.OnCompleted ();  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: if (args.ComponentComparesFiles) {  	FileShare share;  	Stream reader1' reader2;  	int data1' data2;  	int previousBytesRead;  	reader1 = null;  	reader2 = null;  	// Add the file size to the amount to be processed  	session.AddFilesBytesToProcess (file1.Size);  	previousBytesRead = 0;  	share = FileShare.Read;  	try {  		// Open the master file for reading  		reader1 = file1.OpenRead (share);  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current file  			file2 = (AbstractFile)filesToCompare [i];  			// If we have a file to compare  			if (file2 != null) {  				// Assume the files are equal  				dataEqualToMaster [i] = true;  				// Clear the current slot  				filesToCompare [i] = null;  				// Open the current file for reading  				filesToCompare [i] = file2.OpenRead (share);  			}  		}  		do {  			/* TODO: Find a way to optimize this loop */// Get data from the master stream  			data1 = reader1.ReadByte ();  			// Go through all the files to compare in reverse order  			for (i = filesToCompare.Length - 1; i >= 0; i--) {  				// Get the current stream  				reader2 = (Stream)filesToCompare [i];  				// If we have a stream  				if (reader2 != null) {  					// Get data from the current stream  					data2 = reader2.ReadByte ();  					// If the data isn't the same  					if (data1 != data2) {  						// The files are not equal  						dataEqualToMaster [i] = false;  						// No need to compare this file anymore  						filesToCompare [i] = null;  						// Decrement the number of files to compare  						count--;  						// Close the current stream  						reader2.Close ();  					}  				}  			}  			// If we've reached a certain amount of read data  			if (previousBytesRead >= 32 * 1024) {  				// Add the file size to the amount to be processed  				session.OnProgression (previousBytesRead' 0);  				// Reset the counter  				previousBytesRead = 0;  			}  			// Increment the counter  			previousBytesRead += 1;  		}  		// Until we haven't reached the end of the file and still have  		// files to compare to  		while (data1 != -1 && count > 0);  	}  	catch (Exception) {  		object value;  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current value  			value = filesToCompare [i];  			// If we have a value  			if (value != null) {  				// Assume the current file is not equal  				dataEqualToMaster [i] = false;  			}  		}  	}  	finally {  		// If we have a master reader  		if (reader1 != null) {  			// Close it  			reader1.Close ();  			reader1 = null;  		}  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current stream  			reader2 = filesToCompare [i] as Stream;  			// If we have a reader  			if (reader2 != null) {  				// Close it  				reader2.Close ();  				reader2 = null;  			}  		}  	}  	// Force complete  	session.OnCompleted ();  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: try {  	// Open the master file for reading  	reader1 = file1.OpenRead (share);  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current file  		file2 = (AbstractFile)filesToCompare [i];  		// If we have a file to compare  		if (file2 != null) {  			// Assume the files are equal  			dataEqualToMaster [i] = true;  			// Clear the current slot  			filesToCompare [i] = null;  			// Open the current file for reading  			filesToCompare [i] = file2.OpenRead (share);  		}  	}  	do {  		/* TODO: Find a way to optimize this loop */// Get data from the master stream  		data1 = reader1.ReadByte ();  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current stream  			reader2 = (Stream)filesToCompare [i];  			// If we have a stream  			if (reader2 != null) {  				// Get data from the current stream  				data2 = reader2.ReadByte ();  				// If the data isn't the same  				if (data1 != data2) {  					// The files are not equal  					dataEqualToMaster [i] = false;  					// No need to compare this file anymore  					filesToCompare [i] = null;  					// Decrement the number of files to compare  					count--;  					// Close the current stream  					reader2.Close ();  				}  			}  		}  		// If we've reached a certain amount of read data  		if (previousBytesRead >= 32 * 1024) {  			// Add the file size to the amount to be processed  			session.OnProgression (previousBytesRead' 0);  			// Reset the counter  			previousBytesRead = 0;  		}  		// Increment the counter  		previousBytesRead += 1;  	}  	// Until we haven't reached the end of the file and still have  	// files to compare to  	while (data1 != -1 && count > 0);  }  catch (Exception) {  	object value;  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current value  		value = filesToCompare [i];  		// If we have a value  		if (value != null) {  			// Assume the current file is not equal  			dataEqualToMaster [i] = false;  		}  	}  }  finally {  	// If we have a master reader  	if (reader1 != null) {  		// Close it  		reader1.Close ();  		reader1 = null;  	}  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current stream  		reader2 = filesToCompare [i] as Stream;  		// If we have a reader  		if (reader2 != null) {  			// Close it  			reader2.Close ();  			reader2 = null;  		}  	}  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: try {  	// Open the master file for reading  	reader1 = file1.OpenRead (share);  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current file  		file2 = (AbstractFile)filesToCompare [i];  		// If we have a file to compare  		if (file2 != null) {  			// Assume the files are equal  			dataEqualToMaster [i] = true;  			// Clear the current slot  			filesToCompare [i] = null;  			// Open the current file for reading  			filesToCompare [i] = file2.OpenRead (share);  		}  	}  	do {  		/* TODO: Find a way to optimize this loop */// Get data from the master stream  		data1 = reader1.ReadByte ();  		// Go through all the files to compare in reverse order  		for (i = filesToCompare.Length - 1; i >= 0; i--) {  			// Get the current stream  			reader2 = (Stream)filesToCompare [i];  			// If we have a stream  			if (reader2 != null) {  				// Get data from the current stream  				data2 = reader2.ReadByte ();  				// If the data isn't the same  				if (data1 != data2) {  					// The files are not equal  					dataEqualToMaster [i] = false;  					// No need to compare this file anymore  					filesToCompare [i] = null;  					// Decrement the number of files to compare  					count--;  					// Close the current stream  					reader2.Close ();  				}  			}  		}  		// If we've reached a certain amount of read data  		if (previousBytesRead >= 32 * 1024) {  			// Add the file size to the amount to be processed  			session.OnProgression (previousBytesRead' 0);  			// Reset the counter  			previousBytesRead = 0;  		}  		// Increment the counter  		previousBytesRead += 1;  	}  	// Until we haven't reached the end of the file and still have  	// files to compare to  	while (data1 != -1 && count > 0);  }  catch (Exception) {  	object value;  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current value  		value = filesToCompare [i];  		// If we have a value  		if (value != null) {  			// Assume the current file is not equal  			dataEqualToMaster [i] = false;  		}  	}  }  finally {  	// If we have a master reader  	if (reader1 != null) {  		// Close it  		reader1.Close ();  		reader1 = null;  	}  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current stream  		reader2 = filesToCompare [i] as Stream;  		// If we have a reader  		if (reader2 != null) {  			// Close it  			reader2.Close ();  			reader2 = null;  		}  	}  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: do {  	/* TODO: Find a way to optimize this loop */// Get data from the master stream  	data1 = reader1.ReadByte ();  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current stream  		reader2 = (Stream)filesToCompare [i];  		// If we have a stream  		if (reader2 != null) {  			// Get data from the current stream  			data2 = reader2.ReadByte ();  			// If the data isn't the same  			if (data1 != data2) {  				// The files are not equal  				dataEqualToMaster [i] = false;  				// No need to compare this file anymore  				filesToCompare [i] = null;  				// Decrement the number of files to compare  				count--;  				// Close the current stream  				reader2.Close ();  			}  		}  	}  	// If we've reached a certain amount of read data  	if (previousBytesRead >= 32 * 1024) {  		// Add the file size to the amount to be processed  		session.OnProgression (previousBytesRead' 0);  		// Reset the counter  		previousBytesRead = 0;  	}  	// Increment the counter  	previousBytesRead += 1;  }  // Until we haven't reached the end of the file and still have  // files to compare to  while (data1 != -1 && count > 0);  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: do {  	/* TODO: Find a way to optimize this loop */// Get data from the master stream  	data1 = reader1.ReadByte ();  	// Go through all the files to compare in reverse order  	for (i = filesToCompare.Length - 1; i >= 0; i--) {  		// Get the current stream  		reader2 = (Stream)filesToCompare [i];  		// If we have a stream  		if (reader2 != null) {  			// Get data from the current stream  			data2 = reader2.ReadByte ();  			// If the data isn't the same  			if (data1 != data2) {  				// The files are not equal  				dataEqualToMaster [i] = false;  				// No need to compare this file anymore  				filesToCompare [i] = null;  				// Decrement the number of files to compare  				count--;  				// Close the current stream  				reader2.Close ();  			}  		}  	}  	// If we've reached a certain amount of read data  	if (previousBytesRead >= 32 * 1024) {  		// Add the file size to the amount to be processed  		session.OnProgression (previousBytesRead' 0);  		// Reset the counter  		previousBytesRead = 0;  	}  	// Increment the counter  	previousBytesRead += 1;  }  // Until we haven't reached the end of the file and still have  // files to compare to  while (data1 != -1 && count > 0);  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: if (previousBytesRead >= 32 * 1024) {  	// Add the file size to the amount to be processed  	session.OnProgression (previousBytesRead' 0);  	// Reset the counter  	previousBytesRead = 0;  }  
Magic Number,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,CompareFileData,The following statement contains a magic number: if (previousBytesRead >= 32 * 1024) {  	// Add the file size to the amount to be processed  	session.OnProgression (previousBytesRead' 0);  	// Reset the counter  	previousBytesRead = 0;  }  
Duplicate Code,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The method contains a code clone-set at the following line numbers (starting from the method definition): ((16' 35)' (18' 37)' (20' 39)' (22' 41)' (24' 43)' (26' 45)' (28' 47))
Duplicate Code,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The method contains a code clone-set at the following line numbers (starting from the method definition): ((16' 44)' (18' 46))
Duplicate Code,Xceed.Synchronization,Checksums,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Checksums.cs,CalculateAdler32Checksum,The method contains a code clone-set at the following line numbers (starting from the method definition): ((16' 35)' (20' 39)' (22' 41)' (24' 43)' (26' 45)' (28' 47))
Missing Default,Xceed.Synchronization,Synchronizer,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Synchronization.Blueprint\Synchronizer.cs,Stage4FileOperations,The following switch statement is missing a default case: switch (actions [i]) {  // If we are to overwrite the current file with the master  case SynchronizationAction.CreateOrOverwriteWithMaster:  	// If we have a master file  	if (masterFile != null) {  		// If the master file exists  		if (masterFile.Exists) {  			// Add the master file's size to the bytes to process  			session.AddFilesBytesToProcess (masterFile.Size);  		}  		// If we have no mirrored files object  		if (mirroredFiles == null) {  			// Set it up here  			mirroredFiles = new MirroredFiles ();  			mirroredFiles.Session = session;  			mirroredFiles.Checksum = 0;  		}  		// Add the current file to the mirrored files list  		mirroredFiles.Files.Add (current);  	}  	break;  // If we are to only overwrite the attributes with the master's  case SynchronizationAction.OverwriteAttributesOnly:  	// If we have a master file  	if (masterFile != null) {  		// If we are not only doing a preview  		if (!preview) {  			// Apply the master's attibutes to the current file  			masterFile.ApplyPropertiesTo (events' userData' current);  		}  		// Mark that one or more files were synchronized  		session.SynchronizationResult |= SynchronizationResult.ItemsSynchronized;  		actionsTaken = true;  	}  	break;  // If we are to delete the current file  case SynchronizationAction.Delete:  	// If we are not only doing a preview  	if (!preview) {  		// Delete the current file  		current.Delete (events' userData);  	}  	// Mark that one or more files were deleted  	session.SynchronizationResult |= SynchronizationResult.SomeItemsDeleted;  	actionsTaken = true;  	break;  case SynchronizationAction.SuspendedCreateOrOverwrite:  case SynchronizationAction.SuspendedDelete:  	// Mark that one or more actions were suspended  	session.SynchronizationResult |= SynchronizationResult.SomeActionsSuspended;  	break;  }  
