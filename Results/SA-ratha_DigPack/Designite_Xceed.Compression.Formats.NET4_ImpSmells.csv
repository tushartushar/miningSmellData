Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The method has 173 lines of code.
Long Method,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The method has 108 lines of code.
Complex Method,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,Cyclomatic complexity of the method is 23
Complex Method,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,Cyclomatic complexity of the method is 14
Complex Method,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Compress,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,Cyclomatic complexity of the method is 28
Complex Method,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,Cyclomatic complexity of the method is 24
Complex Method,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Compress,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Compress,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Xceed.Utils.Streams,HeaderFooterStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\HeaderFooterStream.cs,Read,Cyclomatic complexity of the method is 9
Long Parameter List,Xceed.Compression.Formats,GZipHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipHeader.cs,GZipHeader,The method has 6 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,XceedCompressedStream,The method has 5 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,XceedCompressedStream,The method has 5 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,XceedCompressedStream,The method has 6 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Compress,The method has 6 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,XceedCompressedStreamEx,The method has 5 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Compress,The method has 6 parameters.
Long Parameter List,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Compress,The method has 5 parameters.
Long Parameter List,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCryptStream.cs,ZCryptStream,The method has 5 parameters.
Long Statement,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,Read,The length of the statement  "		throw new IOException (String.Format ("The checksum for the data read from the stream (0x{0:X8}) does not match the expected checksum (0x{1:X8})."' m_checksum' m_expectedChecksum)); " is 181.
Long Statement,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateCrc32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The length of the statement  "			throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream."); " is 153.
Long Statement,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The length of the statement  "	CompressedStream newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level + 128' this.m_enforceFormatIntegrity); " is 133.
Long Statement,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The length of the statement  "	CompressedStream newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level + 128' this.m_enforceFormatIntegrity); " is 133.
Long Statement,Xceed.Compression.Formats,GZipHeader,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipHeader.cs,CheckIfLocked,The length of the statement  "		throw new InvalidOperationException ("An attempt was made to modify the header. Once data is written to the GZipCompressedStream' the header cannot be modified."); " is 163.
Long Statement,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,ReadHeader,The length of the statement  "			throw new IOException (String.Format ("Not enough data in the stream for the PPMd header. {0} bytes required' {1} read."' header.Length' read)); " is 144.
Long Statement,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,ReadHeader,The length of the statement  "				throw new IOException (String.Format ("Invalid PPMd signature in header. Expected {0:X8}' {1:X8} found."' ManagedPPMdCompressor.Signature' signature)); " is 151.
Long Statement,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,ReadHeader,The length of the statement  "				throw new IOException (String.Format ("Unsupported PPMd variant in header. Expected {0}' {1} found."' ManagedPPMdCompressor.Variant' variant)); " is 143.
Long Statement,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,ReadHeader,The length of the statement  "		if (ManagedPPMdDecompressor.ReadPPMdZipHeader (stream' out this.m_allocatorSize' out this.m_modelOrder' out this.m_method)) { " is 125.
Long Statement,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("method"' method' "An attempt was made to use an unknown compression method."); " is 128.
Long Statement,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Compress,The length of the statement  "	using (XceedCompressedStream standard = new XceedCompressedStream (memoryStream' method' level' false' encryptionPassword)) { " is 125.
Long Statement,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The length of the statement  "		throw new NotSupportedException ("The XceedCompressedStream does not support having data written in its reserved bits."); " is 121.
Long Statement,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The length of the statement  "		throw new NotSupportedException ("An attempt was made to use an unsupported compression method (" + m_method.ToString () + ")."); " is 129.
Long Statement,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("method"' method' "An attempt was made to use an unknown compression method."); " is 128.
Long Statement,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Compress,The length of the statement  "	using (XceedCompressedStreamEx standard = new XceedCompressedStreamEx (memoryStream' method' level' encryptionPassword)) { " is 122.
Long Statement,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Compress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Decompress,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count parameter exceeds the buffer's remaining length after offset."); " is 140.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCryptStream.cs,Read,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Long Statement,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCryptStream.cs,Write,The length of the statement  "		ThrowException.ThrowArgumentOutOfRangeException ("count"' count' "The count exceeds the buffer's remaining length after offset."); " is 130.
Empty Catch Block,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The method has an empty catch block.
Empty Catch Block,Xceed.Utils.Streams,ZCryptStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCryptStream.cs,Dispose,The method has an empty catch block.
Magic Number,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (BZip2CompressedStream bzip2 = new BZip2CompressedStream (inputStream)) {  			byte[] bytes = new byte[64 * 1024];  			int read = 0;  			while ((read = bzip2.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (BZip2CompressedStream bzip2 = new BZip2CompressedStream (inputStream)) {  			byte[] bytes = new byte[64 * 1024];  			int read = 0;  			while ((read = bzip2.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (BZip2CompressedStream bzip2 = new BZip2CompressedStream (inputStream)) {  		byte[] bytes = new byte[64 * 1024];  		int read = 0;  		while ((read = bzip2.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (BZip2CompressedStream bzip2 = new BZip2CompressedStream (inputStream)) {  		byte[] bytes = new byte[64 * 1024];  		int read = 0;  		while ((read = bzip2.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,The following statement contains a magic number: using (BZip2CompressedStream bzip2 = new BZip2CompressedStream (inputStream)) {  	byte[] bytes = new byte[64 * 1024];  	int read = 0;  	while ((read = bzip2.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,BZip2CompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\BZip2CompressedStream.cs,Decompress,The following statement contains a magic number: using (BZip2CompressedStream bzip2 = new BZip2CompressedStream (inputStream)) {  	byte[] bytes = new byte[64 * 1024];  	int read = 0;  	while ((read = bzip2.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: while (--count >= 0) {  	previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: buffer = new byte[8 * 1024];  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: buffer = new byte[8 * 1024];  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		// TODO: Can't all this wrap? Shouldn't we put this in an unchecked block?  		//       From what i have found adler32 is based on the Flecther checksum  		//       algorithm which is insensitive to single byte changes.  		//       http://www.gzip.org/zlib/rfc-zlib.html#references  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	else if (fastAdler [k] % 16 == 0) {  		s1 += fastAdler [k];  		s2 -= fastAdler [k];  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		// TODO: Can't all this wrap? Shouldn't we put this in an unchecked block?  		//       From what i have found adler32 is based on the Flecther checksum  		//       algorithm which is insensitive to single byte changes.  		//       http://www.gzip.org/zlib/rfc-zlib.html#references  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	else if (fastAdler [k] % 16 == 0) {  		s1 += fastAdler [k];  		s2 -= fastAdler [k];  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		// TODO: Can't all this wrap? Shouldn't we put this in an unchecked block?  		//       From what i have found adler32 is based on the Flecther checksum  		//       algorithm which is insensitive to single byte changes.  		//       http://www.gzip.org/zlib/rfc-zlib.html#references  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	else if (fastAdler [k] % 16 == 0) {  		s1 += fastAdler [k];  		s2 -= fastAdler [k];  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	// TODO: Can't all this wrap? Shouldn't we put this in an unchecked block?  	//       From what i have found adler32 is based on the Flecther checksum  	//       algorithm which is insensitive to single byte changes.  	//       http://www.gzip.org/zlib/rfc-zlib.html#references  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	// TODO: Can't all this wrap? Shouldn't we put this in an unchecked block?  	//       From what i have found adler32 is based on the Flecther checksum  	//       algorithm which is insensitive to single byte changes.  	//       http://www.gzip.org/zlib/rfc-zlib.html#references  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: k -= 16;  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: if (k != 0) {  	do {  		s1 += buf [startindex++];  		s2 += s1;  	}  	while (--k != 0);  }  else if (fastAdler [k] % 16 == 0) {  	s1 += fastAdler [k];  	s2 -= fastAdler [k];  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: if (fastAdler [k] % 16 == 0) {  	s1 += fastAdler [k];  	s2 -= fastAdler [k];  }  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: buffer = new byte[8 * 1024];  
Magic Number,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: buffer = new byte[8 * 1024];  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (LZMACompressedStream lzma = new LZMACompressedStream (inputStream)) {  			byte[] bytes = new byte[64 * 1024];  			int read = 0;  			while ((read = lzma.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (LZMACompressedStream lzma = new LZMACompressedStream (inputStream)) {  			byte[] bytes = new byte[64 * 1024];  			int read = 0;  			while ((read = lzma.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (LZMACompressedStream lzma = new LZMACompressedStream (inputStream)) {  		byte[] bytes = new byte[64 * 1024];  		int read = 0;  		while ((read = lzma.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (LZMACompressedStream lzma = new LZMACompressedStream (inputStream)) {  		byte[] bytes = new byte[64 * 1024];  		int read = 0;  		while ((read = lzma.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,The following statement contains a magic number: using (LZMACompressedStream lzma = new LZMACompressedStream (inputStream)) {  	byte[] bytes = new byte[64 * 1024];  	int read = 0;  	while ((read = lzma.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,Decompress,The following statement contains a magic number: using (LZMACompressedStream lzma = new LZMACompressedStream (inputStream)) {  	byte[] bytes = new byte[64 * 1024];  	int read = 0;  	while ((read = lzma.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: data = new byte[13];  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: length = this.Read (stream' data' 0' 5);  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: if (length > 0) {  	// If we didn't get enough data  	if (length < 5)  		throw new IOException ("There is not enough data in the stream to read a proper LZMA header.");  	// Create a LZMA compressor and disable the use of its header. We will make our own  	Decompressor decompressor = DecompressorFactory.CreateLzmaDecompressor (-1' -1' LZMAHeaderType.None);  	IManagedLzmaDecompressor managedLzmaDecompressor = (IManagedLzmaDecompressor)decompressor;  	// Read the LZMA properties and dictionary size  	managedLzmaDecompressor.SetLZMAProperties (data);  	/* Read the uncompressed size */length = this.Read (stream' data' 5' 8);  	managedLzmaDecompressor.UncompressedSize = BitConverter.ToInt64 (data' 5);  	// Wrap the stream in a CompressedStream that uses our LZMA decompressor  	CompressedStream compressedStream = new CompressedStream (stream' decompressor);  	compressedStream.Transient = true;  	return compressedStream;  }  else {  	// Just return the original stream  	return stream;  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: if (length > 0) {  	// If we didn't get enough data  	if (length < 5)  		throw new IOException ("There is not enough data in the stream to read a proper LZMA header.");  	// Create a LZMA compressor and disable the use of its header. We will make our own  	Decompressor decompressor = DecompressorFactory.CreateLzmaDecompressor (-1' -1' LZMAHeaderType.None);  	IManagedLzmaDecompressor managedLzmaDecompressor = (IManagedLzmaDecompressor)decompressor;  	// Read the LZMA properties and dictionary size  	managedLzmaDecompressor.SetLZMAProperties (data);  	/* Read the uncompressed size */length = this.Read (stream' data' 5' 8);  	managedLzmaDecompressor.UncompressedSize = BitConverter.ToInt64 (data' 5);  	// Wrap the stream in a CompressedStream that uses our LZMA decompressor  	CompressedStream compressedStream = new CompressedStream (stream' decompressor);  	compressedStream.Transient = true;  	return compressedStream;  }  else {  	// Just return the original stream  	return stream;  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: if (length > 0) {  	// If we didn't get enough data  	if (length < 5)  		throw new IOException ("There is not enough data in the stream to read a proper LZMA header.");  	// Create a LZMA compressor and disable the use of its header. We will make our own  	Decompressor decompressor = DecompressorFactory.CreateLzmaDecompressor (-1' -1' LZMAHeaderType.None);  	IManagedLzmaDecompressor managedLzmaDecompressor = (IManagedLzmaDecompressor)decompressor;  	// Read the LZMA properties and dictionary size  	managedLzmaDecompressor.SetLZMAProperties (data);  	/* Read the uncompressed size */length = this.Read (stream' data' 5' 8);  	managedLzmaDecompressor.UncompressedSize = BitConverter.ToInt64 (data' 5);  	// Wrap the stream in a CompressedStream that uses our LZMA decompressor  	CompressedStream compressedStream = new CompressedStream (stream' decompressor);  	compressedStream.Transient = true;  	return compressedStream;  }  else {  	// Just return the original stream  	return stream;  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: if (length > 0) {  	// If we didn't get enough data  	if (length < 5)  		throw new IOException ("There is not enough data in the stream to read a proper LZMA header.");  	// Create a LZMA compressor and disable the use of its header. We will make our own  	Decompressor decompressor = DecompressorFactory.CreateLzmaDecompressor (-1' -1' LZMAHeaderType.None);  	IManagedLzmaDecompressor managedLzmaDecompressor = (IManagedLzmaDecompressor)decompressor;  	// Read the LZMA properties and dictionary size  	managedLzmaDecompressor.SetLZMAProperties (data);  	/* Read the uncompressed size */length = this.Read (stream' data' 5' 8);  	managedLzmaDecompressor.UncompressedSize = BitConverter.ToInt64 (data' 5);  	// Wrap the stream in a CompressedStream that uses our LZMA decompressor  	CompressedStream compressedStream = new CompressedStream (stream' decompressor);  	compressedStream.Transient = true;  	return compressedStream;  }  else {  	// Just return the original stream  	return stream;  }  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: if (length < 5)  	throw new IOException ("There is not enough data in the stream to read a proper LZMA header.");  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: length = this.Read (stream' data' 5' 8);  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: length = this.Read (stream' data' 5' 8);  
Magic Number,Xceed.Compression.Formats,LZMACompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\LZMACompressedStream.cs,ReadHeader,The following statement contains a magic number: managedLzmaDecompressor.UncompressedSize = BitConverter.ToInt64 (data' 5);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (GZipCompressedStream gzip = new GZipCompressedStream (inputStream)) {  			byte[] bytes = new byte[32768];  			int read = 0;  			while ((read = gzip.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (GZipCompressedStream gzip = new GZipCompressedStream (inputStream)) {  		byte[] bytes = new byte[32768];  		int read = 0;  		while ((read = gzip.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,Decompress,The following statement contains a magic number: using (GZipCompressedStream gzip = new GZipCompressedStream (inputStream)) {  	byte[] bytes = new byte[32768];  	int read = 0;  	while ((read = gzip.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: try {  	// Read fixed part  	#if ( XCEEDCF )  	        // Bug on .NET CF with BinaryReader.ReadBytes. It does not return         // the right amount of bytes if the inner stream does not return         // all the bytes in a single call. Temporary workaround.         fixedHeader = new byte[ 10 ];         int patchOffset = 0;          while( patchOffset < fixedHeader.Length )         {           int patchRead = stream.Read( fixedHeader' patchOffset' fixedHeader.Length - patchOffset );            if( patchRead == 0 )           {             if( patchOffset == 0 )             {               // Reserved footer size is zero by default.               // We cannot simply return stream' as it must be transient.               return new TransientStream( stream );             }              throw new IOException( "Premature end-of-stream reached. The GZip header is incomplete.");           }            patchOffset += patchRead;         } #else  	fixedHeader = reader.ReadBytes (10);  	#endif  	if (fixedHeader == null || fixedHeader.Length == 0) {  		// Reserved footer size is zero by default.  		// We cannot simply return stream' as it must be transient.  		return new TransientStream (stream);  	}  	if (fixedHeader.Length != 10)  		throw new IOException ("There is not enough data in the stream.");  	// Our footer's size is always 8 bytes  	base.SetReservedFooter (8);  	// Check GZip signatures.  	if ((fixedHeader [0] != 0x1F) || (fixedHeader [1] != 0x8B))  		throw new IOException ("The compressed data contains an invalid header signature.");  	// Check to see if compression is not deflate.  	if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  		throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  	// Check relevant flags  	m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  	m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  	hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  	hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  	hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  	// We need to read the UNIX date-time as a UInt32  	uint modifiedTime = BitConverter.ToUInt32 (fixedHeader' 4);  	long fileTime = (long)modifiedTime * 10000000 + 116444736000000000;  	m_gzipHeader.LastWriteDateTime = DateTime.FromFileTime (fileTime).ToLocalTime ();  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Read the optional parts  	// Extra Header present?  	m_gzipHeader.ExtraHeader = null;  	if (hasExtraHeader) {  		ushort extraLength = reader.ReadUInt16 ();  		if (extraLength > 0) {  			#if ( XCEEDCF )  			            // Bug on .NET CF with BinaryReader.ReadBytes. It does not return             // the right amount of bytes if the inner stream does not return             // all the bytes in a single call. Temporary workaround.             byte[] patchExtraHeader = new byte[ extraLength ];             patchOffset = 0;              while( patchOffset < patchExtraHeader.Length )             {               int patchRead = stream.Read( patchExtraHeader' patchOffset' patchExtraHeader.Length - patchOffset );                if( patchRead == 0 )                 throw new IOException( "Premature end-of-stream reached. ");                patchOffset += patchRead;             }              m_gzipHeader.ExtraHeader = patchExtraHeader; #else  			m_gzipHeader.ExtraHeader = reader.ReadBytes (extraLength);  			#endif  		}  		// That damn CRC16!  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			if (extraLength > 0) {  				headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  			}  		}  	}  	// Filename present?  	m_gzipHeader.FileName = string.Empty;  	if (hasFileName) {  		using (MemoryStream memFileName = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memFileName.WriteByte (byteRead);  			}  			byte[] fileName = memFileName.ToArray ();  			byte[] fileNameForCrc = new byte[fileName.Length + 1];  			fileName.CopyTo (fileNameForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (fileNameForCrc' 0' fileNameForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.FileName = encoding.GetString (fileName' 0' fileName.Length);  		}  	}  	// Comment present?  	m_gzipHeader.Comment = string.Empty;  	if (hasComment) {  		using (MemoryStream memComment = new MemoryStream ()) {  			byte byteRead = 0;  			while ((byteRead = reader.ReadByte ()) != 0) {  				memComment.WriteByte (byteRead);  			}  			byte[] comment = memComment.ToArray ();  			byte[] commentForCrc = new byte[comment.Length + 1];  			comment.CopyTo (commentForCrc' 0);  			if (m_gzipHeader.HasHeaderChecksum) {  				headerChecksum = ChecksumStream.CalculateCrc32 (commentForCrc' 0' commentForCrc.Length' headerChecksum);  			}  			System.Text.Encoding encoding;  			#if !SILVERLIGHT  			encoding = System.Text.Encoding.Default;  			#else  			            encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;             #endif  			m_gzipHeader.Comment = encoding.GetString (comment' 0' comment.Length);  		}  	}  	// CRC16 checksum present?  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		ushort crc16 = reader.ReadUInt16 ();  		if (crc16 != lowOrderCrc) {  			ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  			if (crc16 != foldedCrc)  				throw new IOException ("The compressed data contains an invalid header checksum.");  		}  	}  }  finally {  	reader.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: fixedHeader = reader.ReadBytes (10);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: if (fixedHeader.Length != 10)  	throw new IOException ("There is not enough data in the stream.");  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: base.SetReservedFooter (8);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: if ((int)fixedHeader [2] != (int)CompressionMethod.Deflated)  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method. Only Deflate is supported by the GZipCompressedStream.");  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: m_gzipHeader.IsTextFile = ((fixedHeader [3] & IsTextFileBit) != 0);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: m_gzipHeader.HasHeaderChecksum = ((fixedHeader [3] & HasHeaderChecksumBit) != 0);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: hasExtraHeader = ((fixedHeader [3] & HasExtraHeaderBit) != 0);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: hasFileName = ((fixedHeader [3] & HasFilenameBit) != 0);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: hasComment = ((fixedHeader [3] & HasCommentBit) != 0);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: if (m_gzipHeader.HasHeaderChecksum) {  	ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  	ushort crc16 = reader.ReadUInt16 ();  	if (crc16 != lowOrderCrc) {  		ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  		if (crc16 != foldedCrc)  			throw new IOException ("The compressed data contains an invalid header checksum.");  	}  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadHeader,The following statement contains a magic number: if (crc16 != lowOrderCrc) {  	ushort foldedCrc = unchecked((ushort)(((uint)headerChecksum >> 16) ^ ((uint)headerChecksum & 0xffff)));  	if (crc16 != foldedCrc)  		throw new IOException ("The compressed data contains an invalid header checksum.");  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: try {  	// GZip signatures.  	fixedHeader [0] = 0x1F;  	fixedHeader [1] = 0x8B;  	// Compression method.  	fixedHeader [2] = (byte)CompressionMethod.Deflated;  	// Presence flags  	fixedHeader [3] = 0;  	if (m_gzipHeader.IsTextFile)  		fixedHeader [3] |= IsTextFileBit;  	if (m_gzipHeader.HasHeaderChecksum)  		fixedHeader [3] |= HasHeaderChecksumBit;  	if (m_gzipHeader.ExtraHeader.Length > 0) {  		hasExtraHeader = true;  		fixedHeader [3] |= HasExtraHeaderBit;  	}  	if (m_gzipHeader.FileName.Length > 0) {  		hasFileName = true;  		fixedHeader [3] |= HasFilenameBit;  	}  	if (m_gzipHeader.Comment.Length > 0) {  		hasComment = true;  		fixedHeader [3] |= HasCommentBit;  	}  	// We need to write the date-time as a UInt32  	DateTime modifiedUTC = m_gzipHeader.LastWriteDateTime.ToUniversalTime ();  	long fileTime = modifiedUTC.ToFileTime ();  	// UNIX-style modified date & time.  	uint modifiedTime = (uint)((fileTime - 116444736000000000) / 10000000);  	byte[] unixDateTime = BitConverter.GetBytes (modifiedTime);  	unixDateTime.CopyTo (fixedHeader' 4);  	// To be compliant with gzip standard:  	// A compliant compressor must produce files with correct ID1' ID2' CM' CRC32'   	// and ISIZE' but may set all the other fields in the fixed-length part of the   	// header to default values (255 for OS' 0 for all others).   	// The compressor must set all reserved bits to zero.   	// This info was taken in the rfc found at http://www.gzip.org  	// OS flags set to 255 for compliance.  	fixedHeader [9] = 255;  	writer.Write (fixedHeader);  	// Calculate CRC16 on fixed part  	if (m_gzipHeader.HasHeaderChecksum) {  		headerChecksum = ChecksumStream.CalculateCrc32 (fixedHeader' 0' fixedHeader.Length' headerChecksum);  	}  	// Write the optional parts  	if (hasExtraHeader) {  		ushort extraLength = (ushort)m_gzipHeader.ExtraHeader.Length;  		if (m_gzipHeader.HasHeaderChecksum) {  			byte[] lenBytes = BitConverter.GetBytes (extraLength);  			headerChecksum = ChecksumStream.CalculateCrc32 (lenBytes' 0' lenBytes.Length' headerChecksum);  			headerChecksum = ChecksumStream.CalculateCrc32 (m_gzipHeader.ExtraHeader' 0' extraLength' headerChecksum);  		}  		writer.Write (extraLength);  		writer.Write (m_gzipHeader.ExtraHeader);  	}  	if (hasFileName) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.FileName);  		byte[] fileName = new byte[bytes.Length + 1];  		bytes.CopyTo (fileName' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (fileName' 0' fileName.Length' headerChecksum);  		}  		writer.Write (fileName);  	}  	if (hasComment) {  		System.Text.Encoding encoding;  		#if !SILVERLIGHT  		encoding = System.Text.Encoding.Default;  		#else  		          encoding = Xceed.Utils.Text.DefaultUTF8Encoding.UTF8;           #endif  		byte[] bytes = encoding.GetBytes (m_gzipHeader.Comment);  		byte[] comment = new byte[bytes.Length + 1];  		bytes.CopyTo (comment' 0);  		if (m_gzipHeader.HasHeaderChecksum) {  			headerChecksum = ChecksumStream.CalculateCrc32 (comment' 0' comment.Length' headerChecksum);  		}  		writer.Write (comment);  	}  	if (m_gzipHeader.HasHeaderChecksum) {  		ushort lowOrderCrc = unchecked((ushort)(headerChecksum & 0xffff));  		writer.Write (lowOrderCrc);  	}  }  finally {  	writer.Close ();  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [2] = (byte)CompressionMethod.Deflated;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [3] = 0;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: if (m_gzipHeader.IsTextFile)  	fixedHeader [3] |= IsTextFileBit;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [3] |= IsTextFileBit;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: if (m_gzipHeader.HasHeaderChecksum)  	fixedHeader [3] |= HasHeaderChecksumBit;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [3] |= HasHeaderChecksumBit;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: if (m_gzipHeader.ExtraHeader.Length > 0) {  	hasExtraHeader = true;  	fixedHeader [3] |= HasExtraHeaderBit;  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [3] |= HasExtraHeaderBit;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: if (m_gzipHeader.FileName.Length > 0) {  	hasFileName = true;  	fixedHeader [3] |= HasFilenameBit;  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [3] |= HasFilenameBit;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: if (m_gzipHeader.Comment.Length > 0) {  	hasComment = true;  	fixedHeader [3] |= HasCommentBit;  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [3] |= HasCommentBit;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: unixDateTime.CopyTo (fixedHeader' 4);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [9] = 255;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteHeader,The following statement contains a magic number: fixedHeader [9] = 255;  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadFooter,The following statement contains a magic number: if (base.FooterSize > 0) {  	byte[] footer = new byte[8];  	base.GetFooter (footer' 0);  	uint crc32 = BitConverter.ToUInt32 (footer' 0);  	ChecksumStream checksumStream = base.InnerStream as ChecksumStream;  	System.Diagnostics.Debug.Assert (checksumStream != null' "Base innerstream not a ChecksumStream!");  	if (crc32 != unchecked((uint)checksumStream.Checksum))  		throw new IOException ("The calculated checksum differs from the stored checksum.");  	uint uncompressedSize = BitConverter.ToUInt32 (footer' 4);  	if ((uint)(m_uncompressedSize & 0xffffffff) != uncompressedSize)  		throw new IOException ("The calculated uncompressed size differs from the stored uncompressed size.");  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,ReadFooter,The following statement contains a magic number: if (base.FooterSize > 0) {  	byte[] footer = new byte[8];  	base.GetFooter (footer' 0);  	uint crc32 = BitConverter.ToUInt32 (footer' 0);  	ChecksumStream checksumStream = base.InnerStream as ChecksumStream;  	System.Diagnostics.Debug.Assert (checksumStream != null' "Base innerstream not a ChecksumStream!");  	if (crc32 != unchecked((uint)checksumStream.Checksum))  		throw new IOException ("The calculated checksum differs from the stored checksum.");  	uint uncompressedSize = BitConverter.ToUInt32 (footer' 4);  	if ((uint)(m_uncompressedSize & 0xffffffff) != uncompressedSize)  		throw new IOException ("The calculated uncompressed size differs from the stored uncompressed size.");  }  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteFooter,The following statement contains a magic number: stream.Write (BitConverter.GetBytes (unchecked((uint)checksumStream.Checksum))' 0' 4);  
Magic Number,Xceed.Compression.Formats,GZipCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\GZipCompressedStream.cs,WriteFooter,The following statement contains a magic number: stream.Write (BitConverter.GetBytes ((uint)(m_uncompressedSize & 0xffffffff))' 0' 4);  
Magic Number,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count' false)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (PPMdCompressedStream ppmd = new PPMdCompressedStream (inputStream)) {  			byte[] bytes = new byte[64 * 1024];  			int read = 0;  			while ((read = ppmd.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count' false)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (PPMdCompressedStream ppmd = new PPMdCompressedStream (inputStream)) {  			byte[] bytes = new byte[64 * 1024];  			int read = 0;  			while ((read = ppmd.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (PPMdCompressedStream ppmd = new PPMdCompressedStream (inputStream)) {  		byte[] bytes = new byte[64 * 1024];  		int read = 0;  		while ((read = ppmd.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (PPMdCompressedStream ppmd = new PPMdCompressedStream (inputStream)) {  		byte[] bytes = new byte[64 * 1024];  		int read = 0;  		while ((read = ppmd.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,The following statement contains a magic number: using (PPMdCompressedStream ppmd = new PPMdCompressedStream (inputStream)) {  	byte[] bytes = new byte[64 * 1024];  	int read = 0;  	while ((read = ppmd.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,Decompress,The following statement contains a magic number: using (PPMdCompressedStream ppmd = new PPMdCompressedStream (inputStream)) {  	byte[] bytes = new byte[64 * 1024];  	int read = 0;  	while ((read = ppmd.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,PPMdCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\PPMdCompressedStream.cs,WriteHeader,The following statement contains a magic number: stream.Write (header.GetBuffer ()' 0' 7);  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (XceedCompressedStream standard = new XceedCompressedStream (inputStream' encryptionPassword)) {  			byte[] bytes = new byte[32786];  			int read = 0;  			while ((read = standard.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (XceedCompressedStream standard = new XceedCompressedStream (inputStream' encryptionPassword)) {  		byte[] bytes = new byte[32786];  		int read = 0;  		while ((read = standard.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,Decompress,The following statement contains a magic number: using (XceedCompressedStream standard = new XceedCompressedStream (inputStream' encryptionPassword)) {  	byte[] bytes = new byte[32786];  	int read = 0;  	while ((read = standard.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The following statement contains a magic number: base.SetReservedFooter (4);  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The following statement contains a magic number: switch (header >> 4) {  case 0:  	// Deflated  	newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level);  	break;  case 1:  	// Stored  	newStream = new CompressedStream (stream' CompressionMethod.Stored' m_level);  	break;  case 2:  	// BurrowsWheeler  	newStream = new CompressedStream (stream' CompressionMethod.BWT' m_level);  	break;  case 3:  	// Deflated64  	newStream = new CompressedStream (stream' CompressionMethod.Deflated64' m_level);  	break;  case 4:  	// BZip2  	newStream = new CompressedStream (stream' CompressionMethod.BZip2' m_level);  	break;  case 5:  	// LZMA  	newStream = new CompressedStream (stream' DecompressorFactory.CreateLzmaDecompressor (LZMAHeaderType.Properties));  	break;  case 6:  	// PPMd  	newStream = new CompressedStream (stream' CompressionMethod.PPMd' m_level);  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The following statement contains a magic number: switch (header >> 4) {  case 0:  	// Deflated  	newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level);  	break;  case 1:  	// Stored  	newStream = new CompressedStream (stream' CompressionMethod.Stored' m_level);  	break;  case 2:  	// BurrowsWheeler  	newStream = new CompressedStream (stream' CompressionMethod.BWT' m_level);  	break;  case 3:  	// Deflated64  	newStream = new CompressedStream (stream' CompressionMethod.Deflated64' m_level);  	break;  case 4:  	// BZip2  	newStream = new CompressedStream (stream' CompressionMethod.BZip2' m_level);  	break;  case 5:  	// LZMA  	newStream = new CompressedStream (stream' DecompressorFactory.CreateLzmaDecompressor (LZMAHeaderType.Properties));  	break;  case 6:  	// PPMd  	newStream = new CompressedStream (stream' CompressionMethod.PPMd' m_level);  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The following statement contains a magic number: switch (header >> 4) {  case 0:  	// Deflated  	newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level);  	break;  case 1:  	// Stored  	newStream = new CompressedStream (stream' CompressionMethod.Stored' m_level);  	break;  case 2:  	// BurrowsWheeler  	newStream = new CompressedStream (stream' CompressionMethod.BWT' m_level);  	break;  case 3:  	// Deflated64  	newStream = new CompressedStream (stream' CompressionMethod.Deflated64' m_level);  	break;  case 4:  	// BZip2  	newStream = new CompressedStream (stream' CompressionMethod.BZip2' m_level);  	break;  case 5:  	// LZMA  	newStream = new CompressedStream (stream' DecompressorFactory.CreateLzmaDecompressor (LZMAHeaderType.Properties));  	break;  case 6:  	// PPMd  	newStream = new CompressedStream (stream' CompressionMethod.PPMd' m_level);  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The following statement contains a magic number: switch (header >> 4) {  case 0:  	// Deflated  	newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level);  	break;  case 1:  	// Stored  	newStream = new CompressedStream (stream' CompressionMethod.Stored' m_level);  	break;  case 2:  	// BurrowsWheeler  	newStream = new CompressedStream (stream' CompressionMethod.BWT' m_level);  	break;  case 3:  	// Deflated64  	newStream = new CompressedStream (stream' CompressionMethod.Deflated64' m_level);  	break;  case 4:  	// BZip2  	newStream = new CompressedStream (stream' CompressionMethod.BZip2' m_level);  	break;  case 5:  	// LZMA  	newStream = new CompressedStream (stream' DecompressorFactory.CreateLzmaDecompressor (LZMAHeaderType.Properties));  	break;  case 6:  	// PPMd  	newStream = new CompressedStream (stream' CompressionMethod.PPMd' m_level);  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The following statement contains a magic number: switch (header >> 4) {  case 0:  	// Deflated  	newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level);  	break;  case 1:  	// Stored  	newStream = new CompressedStream (stream' CompressionMethod.Stored' m_level);  	break;  case 2:  	// BurrowsWheeler  	newStream = new CompressedStream (stream' CompressionMethod.BWT' m_level);  	break;  case 3:  	// Deflated64  	newStream = new CompressedStream (stream' CompressionMethod.Deflated64' m_level);  	break;  case 4:  	// BZip2  	newStream = new CompressedStream (stream' CompressionMethod.BZip2' m_level);  	break;  case 5:  	// LZMA  	newStream = new CompressedStream (stream' DecompressorFactory.CreateLzmaDecompressor (LZMAHeaderType.Properties));  	break;  case 6:  	// PPMd  	newStream = new CompressedStream (stream' CompressionMethod.PPMd' m_level);  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadHeader,The following statement contains a magic number: switch (header >> 4) {  case 0:  	// Deflated  	newStream = new CompressedStream (stream' CompressionMethod.Deflated' m_level);  	break;  case 1:  	// Stored  	newStream = new CompressedStream (stream' CompressionMethod.Stored' m_level);  	break;  case 2:  	// BurrowsWheeler  	newStream = new CompressedStream (stream' CompressionMethod.BWT' m_level);  	break;  case 3:  	// Deflated64  	newStream = new CompressedStream (stream' CompressionMethod.Deflated64' m_level);  	break;  case 4:  	// BZip2  	newStream = new CompressedStream (stream' CompressionMethod.BZip2' m_level);  	break;  case 5:  	// LZMA  	newStream = new CompressedStream (stream' DecompressorFactory.CreateLzmaDecompressor (LZMAHeaderType.Properties));  	break;  case 6:  	// PPMd  	newStream = new CompressedStream (stream' CompressionMethod.PPMd' m_level);  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: switch (m_method) {  case CompressionMethod.Deflated:  	method = 0;  	break;  case CompressionMethod.Stored:  	method = 1;  	break;  case CompressionMethod.BWT:  	method = 2;  	break;  case CompressionMethod.Deflated64:  	method = 3;  	break;  case CompressionMethod.BZip2:  	method = 4;  	break;  case CompressionMethod.LZMA: {  	compressor = CompressorFactory.CreateLzmaCompressor (m_level' LZMAHeaderType.Properties);  	method = 5;  	break;  }  case CompressionMethod.PPMd:  	method = 6;  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method (" + m_method.ToString () + ").");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: switch (m_method) {  case CompressionMethod.Deflated:  	method = 0;  	break;  case CompressionMethod.Stored:  	method = 1;  	break;  case CompressionMethod.BWT:  	method = 2;  	break;  case CompressionMethod.Deflated64:  	method = 3;  	break;  case CompressionMethod.BZip2:  	method = 4;  	break;  case CompressionMethod.LZMA: {  	compressor = CompressorFactory.CreateLzmaCompressor (m_level' LZMAHeaderType.Properties);  	method = 5;  	break;  }  case CompressionMethod.PPMd:  	method = 6;  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method (" + m_method.ToString () + ").");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: switch (m_method) {  case CompressionMethod.Deflated:  	method = 0;  	break;  case CompressionMethod.Stored:  	method = 1;  	break;  case CompressionMethod.BWT:  	method = 2;  	break;  case CompressionMethod.Deflated64:  	method = 3;  	break;  case CompressionMethod.BZip2:  	method = 4;  	break;  case CompressionMethod.LZMA: {  	compressor = CompressorFactory.CreateLzmaCompressor (m_level' LZMAHeaderType.Properties);  	method = 5;  	break;  }  case CompressionMethod.PPMd:  	method = 6;  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method (" + m_method.ToString () + ").");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: switch (m_method) {  case CompressionMethod.Deflated:  	method = 0;  	break;  case CompressionMethod.Stored:  	method = 1;  	break;  case CompressionMethod.BWT:  	method = 2;  	break;  case CompressionMethod.Deflated64:  	method = 3;  	break;  case CompressionMethod.BZip2:  	method = 4;  	break;  case CompressionMethod.LZMA: {  	compressor = CompressorFactory.CreateLzmaCompressor (m_level' LZMAHeaderType.Properties);  	method = 5;  	break;  }  case CompressionMethod.PPMd:  	method = 6;  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method (" + m_method.ToString () + ").");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: switch (m_method) {  case CompressionMethod.Deflated:  	method = 0;  	break;  case CompressionMethod.Stored:  	method = 1;  	break;  case CompressionMethod.BWT:  	method = 2;  	break;  case CompressionMethod.Deflated64:  	method = 3;  	break;  case CompressionMethod.BZip2:  	method = 4;  	break;  case CompressionMethod.LZMA: {  	compressor = CompressorFactory.CreateLzmaCompressor (m_level' LZMAHeaderType.Properties);  	method = 5;  	break;  }  case CompressionMethod.PPMd:  	method = 6;  	break;  default:  	throw new NotSupportedException ("An attempt was made to use an unsupported compression method (" + m_method.ToString () + ").");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: method = 2;  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: method = 3;  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: method = 4;  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: method = 5;  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: method = 6;  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteHeader,The following statement contains a magic number: header |= (method << 4);  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadFooter,The following statement contains a magic number: if (base.FooterSize > 0) {  	System.Diagnostics.Debug.Assert (base.FooterSize == 4' "Reserved footer size should always be 4 bytes.");  	byte[] footer = new byte[4];  	base.GetFooter (footer' 0);  	uint adler32 = BitConverter.ToUInt32 (footer' 0);  	ChecksumStream checksumStream = base.InnerStream as ChecksumStream;  	System.Diagnostics.Debug.Assert (checksumStream != null' "Base innerstream not a ChecksumStream!");  	if (adler32 != unchecked((uint)checksumStream.Checksum))  		throw new IOException ("The calculated checksum differs from the stored checksum.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadFooter,The following statement contains a magic number: if (base.FooterSize > 0) {  	System.Diagnostics.Debug.Assert (base.FooterSize == 4' "Reserved footer size should always be 4 bytes.");  	byte[] footer = new byte[4];  	base.GetFooter (footer' 0);  	uint adler32 = BitConverter.ToUInt32 (footer' 0);  	ChecksumStream checksumStream = base.InnerStream as ChecksumStream;  	System.Diagnostics.Debug.Assert (checksumStream != null' "Base innerstream not a ChecksumStream!");  	if (adler32 != unchecked((uint)checksumStream.Checksum))  		throw new IOException ("The calculated checksum differs from the stored checksum.");  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,ReadFooter,The following statement contains a magic number: System.Diagnostics.Debug.Assert (base.FooterSize == 4' "Reserved footer size should always be 4 bytes.");  
Magic Number,Xceed.Compression.Formats,XceedCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStream.cs,WriteFooter,The following statement contains a magic number: stream.Write (BitConverter.GetBytes (unchecked((uint)checksumStream.Checksum))' 0' 4);  
Magic Number,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (XceedCompressedStreamEx standard = new XceedCompressedStreamEx (inputStream' encryptionPassword)) {  			byte[] bytes = new byte[32786];  			int read = 0;  			while ((read = standard.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (XceedCompressedStreamEx standard = new XceedCompressedStreamEx (inputStream' encryptionPassword)) {  		byte[] bytes = new byte[32786];  		int read = 0;  		while ((read = standard.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,XceedCompressedStreamEx,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\XceedCompressedStreamEx.cs,Decompress,The following statement contains a magic number: using (XceedCompressedStreamEx standard = new XceedCompressedStreamEx (inputStream' encryptionPassword)) {  	byte[] bytes = new byte[32786];  	int read = 0;  	while ((read = standard.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream inputStream = new MemoryStream (buffer' offset' count)) {  	using (MemoryStream outputStream = new MemoryStream ()) {  		using (ZLibCompressedStream zlib = new ZLibCompressedStream (inputStream)) {  			byte[] bytes = new byte[32768];  			int read = 0;  			while ((read = zlib.Read (bytes' 0' bytes.Length)) > 0) {  				outputStream.Write (bytes' 0' read);  			}  		}  		outputBytes = outputStream.ToArray ();  	}  }  
Magic Number,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Decompress,The following statement contains a magic number: using (MemoryStream outputStream = new MemoryStream ()) {  	using (ZLibCompressedStream zlib = new ZLibCompressedStream (inputStream)) {  		byte[] bytes = new byte[32768];  		int read = 0;  		while ((read = zlib.Read (bytes' 0' bytes.Length)) > 0) {  			outputStream.Write (bytes' 0' read);  		}  	}  	outputBytes = outputStream.ToArray ();  }  
Magic Number,Xceed.Compression.Formats,ZLibCompressedStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ZLibCompressedStream.cs,Decompress,The following statement contains a magic number: using (ZLibCompressedStream zlib = new ZLibCompressedStream (inputStream)) {  	byte[] bytes = new byte[32768];  	int read = 0;  	while ((read = zlib.Read (bytes' 0' bytes.Length)) > 0) {  		outputStream.Write (bytes' 0' read);  	}  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: while (--count >= 0) {  	previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateCrc32,The following statement contains a magic number: previousCrc = crcTable [(previousCrc ^ (buffer [++offset])) & 0xff] ^ (previousCrc >> 8);  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,UniqueCrc32,The following statement contains a magic number: return (uint)(crcTable [(crc ^ input) & 0xff] ^ (crc >> 8));  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		s1 += buf [startindex++];  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += buf [startindex++];  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: while (k >= 16) {  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	s1 += buf [startindex++];  	s2 += s1;  	k -= 16;  }  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: k -= 16;  
Magic Number,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,ReadHeader,The following statement contains a magic number: if (m_zcrypt.Header [HeaderLength - 1] != ((m_zcrypt.UserSeed >> 8) & 0xff))  	throw new ZCryptException ("Invalid decryption Password");  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: unchecked {  	ushort temp = (ushort)(m_zcrypt.Keys [2] | 2);  	return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: unchecked {  	ushort temp = (ushort)(m_zcrypt.Keys [2] | 2);  	return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: unchecked {  	ushort temp = (ushort)(m_zcrypt.Keys [2] | 2);  	return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,DecryptByte,The following statement contains a magic number: return (byte)(((ushort)(temp * (temp ^ 1)) >> 8) & 0xff);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: for (int i = 0; i < (HeaderLength - 2); i++)  	m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [i] = (byte)((((randomLong >> (i * 3)) & 0xff) + (i * 23)) % 256);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [HeaderLength - 2] = (byte)(m_zcrypt.UserSeed & 0xff);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,RandomizeHeader,The following statement contains a magic number: m_zcrypt.Header [HeaderLength - 1] = (byte)((m_zcrypt.UserSeed >> 8) & 0xff);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,InitializeKeys,The following statement contains a magic number: m_zcrypt.Keys = new uint[3];  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,InitializeKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = 878082192U;  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,InitializeKeys,The following statement contains a magic number: if (m_zcryptFast [m_zcrypt.Keys [1] % 16] == 0)  	throw new ZCryptException ("Cannot initialize random encryption header");  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: unchecked {  	m_zcrypt.Keys [0] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [0]' b);  	m_zcrypt.Keys [1] += m_zcrypt.Keys [0] & 0xff;  	m_zcrypt.Keys [1] = m_zcrypt.Keys [1] * 134775813U + 1;  	m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: unchecked {  	m_zcrypt.Keys [0] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [0]' b);  	m_zcrypt.Keys [1] += m_zcrypt.Keys [0] & 0xff;  	m_zcrypt.Keys [1] = m_zcrypt.Keys [1] * 134775813U + 1;  	m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: unchecked {  	m_zcrypt.Keys [0] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [0]' b);  	m_zcrypt.Keys [1] += m_zcrypt.Keys [0] & 0xff;  	m_zcrypt.Keys [1] = m_zcrypt.Keys [1] * 134775813U + 1;  	m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  }  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  
Magic Number,Xceed.Utils.Streams,ZCrypt,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ZCrypt.cs,UpdateKeys,The following statement contains a magic number: m_zcrypt.Keys [2] = ChecksumStream.UniqueCrc32 (m_zcrypt.Keys [2]' m_zcrypt.Keys [1] >> 24);  
Duplicate Code,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46)' (29' 48)' (31' 50))
Duplicate Code,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((19' 47)' (21' 49))
Duplicate Code,Xceed.Compression.Formats,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((19' 38)' (23' 42)' (25' 44)' (27' 46)' (29' 48)' (31' 50))
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 43)' (17' 45))
Duplicate Code,Xceed.Utils.Streams,ChecksumStream,C:\repos\SA-ratha_DigPack\Xceed Components\Blueprints\Xceed Zip for .NET 4.x-5.4.13572.13590\Xceed.Compression.Formats.Blueprint\Utils\Streams\ChecksumStream.cs,CalculateAdler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
