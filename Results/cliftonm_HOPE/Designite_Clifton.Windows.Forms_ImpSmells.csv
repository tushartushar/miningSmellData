Implementation smell,Namespace,Class,File,Method,Description
Long Method,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The method has 202 lines of code.
Complex Method,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,BuildContextMenu,Cyclomatic complexity of the method is 12
Complex Method,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnMouseDown,Cyclomatic complexity of the method is 8
Long Parameter List,Clifton.Windows.Forms.XmlTree,NodeMenuItem,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XmlTree\NodeMenuItem.cs,NodeMenuItem,The method has 5 parameters. Parameters: text' tn' parentNode' childNode' popup
Long Parameter List,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,BuildChildPopups,The method has 5 parameters. Parameters: nmi' popup' tn' n' refNode
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,AddNode,The length of the statement  "				throw new ApplicationException("The controller instance "+inst.GetType().AssemblyQualifiedName+" is expected but not defined in a TypeName attribute of the tree schema."); " is 171.
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,BuildFlatNodeList,The length of the statement  "				// System.Diagnostics.Debug.WriteLine("Adding controller node map:" + (child.ImplementingType==null ? "null" : child.ImplementingType.ToString()) + "' " + (child.TypeData==null ? "null" : child.TypeData.ToString())); " is 216.
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The length of the statement  "			if (NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)))) " is 133.
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The length of the statement  "				// So we need to add an AND expression' that if we're at the last node AND the mouse Y is at the top third or bottom third of the node' " is 135.
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The length of the statement  "					else if ((NodeOver.Parent != null && NodeOver.Index == 0) && (OffsetY > (NodeOver.Bounds.Height - (NodeOver.Bounds.Height / 3)))) " is 129.
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The length of the statement  "			g.DrawLine(new System.Drawing.Pen(Color.Black' 2)' new Point(LeftPos' NodeOver.Bounds.Top)' new Point(RightPos' NodeOver.Bounds.Top)); " is 134.
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The length of the statement  "			g.DrawLine(new System.Drawing.Pen(Color.Black' 2)' new Point(LeftPos' NodeOver.Bounds.Bottom)' new Point(RightPos' NodeOver.Bounds.Bottom)); " is 140.
Long Statement,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The length of the statement  "			g.DrawLine(new System.Drawing.Pen(Color.Black' 2)' new Point(LeftPos' NodeOver.Bounds.Top)' new Point(RightPos' NodeOver.Bounds.Top)); " is 134.
Complex Conditional,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The conditional expression  "NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)))"  is complex.
Complex Conditional,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The conditional expression  "(NodeOver.Nodes.Count > 0) ||   					( (NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)) &&  					  ( (OffsetY < NodeOver.Bounds.Height / 3) || (OffsetY > 2*NodeOver.Bounds.Height/3) ) )"  is complex.
Magic Number,Clifton.Windows.Forms.XmlTree,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XmlTree\NodeDef.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms.XmlTree,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XmlTree\NodeDef.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms.XmlTree,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XmlTree\NodeDef.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms.XmlTree,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XmlTree\NodeDef.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms.XmlTree,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XmlTree\NodeDef.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,GetResourceInfo,The following statement contains a magic number: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnMouseDown,The following statement contains a magic number: if (selNode != null)  			{  				if (e.Button == MouseButtons.Left)  				{  					if (e.Clicks == 2)  					{  						if (TreeDoubleClick != null)  						{  							TreeDoubleClick(this' EventArgs.Empty);  						}  					}    					// clicked twice on the same node?  					if (selNode == SelectedNode)  					{  						// Is writeable?  						if (!((NodeInstance)selNode.Tag).NodeDef.IsReadOnly)  						{  							// Not currently editing?  							if (!selNode.IsEditing)  							{  								// Then begin edit of the label.  								LabelEdit = true;  								selNode.BeginEdit();  							}  						}  						else  						{  							// Re-select the same node' in case we're binding to a property grid that has  							// displayed some other information' we now want to update any dependent controls.  							((NodeInstance)selNode.Tag).Instance.Select(selNode);  						}  					}  					else  					{  						// Clicked on a different node.  Select it and call  						// the controller's Select method.  						SelectedNode = selNode;  						((NodeInstance)selNode.Tag).Instance.Select(selNode);  					}  				}  				else  				{  					// Other mouse button.  Still select the node.  					SelectedNode = selNode;  					((NodeInstance)selNode.Tag).Instance.Select(selNode);  				}    				// Get the backing node instance of the selected node.  				selectedNodeInstance = ((NodeInstance)SelectedNode.Tag).Instance;  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The following statement contains a magic number: if (NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))))  			{  				int OffsetY = PointToClient(Cursor.Position).Y - NodeOver.Bounds.Top;  //				int NodeOverImageWidth = ImageList.Images[NodeOver.ImageIndex].Size.Width + 8;  				Graphics g = CreateGraphics();    				// Image index of 1 is the non-folder icon  //				if (NodeOver.ImageIndex == 1)  				// MTC  				// If there are subnodes already' or we're at the last node' then draw the "before/after" markers.  				// What this prevents happening is the ability to add subnodes to a last node that has no children.  				// So we need to add an AND expression' that if we're at the last node AND the mouse Y is at the top third or bottom third of the node'  				// THEN we want to treat this as a "before/after" selection.  Otherwise' treat it as adding a child node.  				if ( (NodeOver.Nodes.Count > 0) ||   					( (NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)) &&  					  ( (OffsetY < NodeOver.Bounds.Height / 3) || (OffsetY > 2*NodeOver.Bounds.Height/3) ) )  					)  				{  					#region Standard Node  					if (OffsetY < (NodeOver.Bounds.Height / 2))  					{  						//this.lblDebug.Text = "top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawLeafTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Allow drag drop to parent branches  						TreeNode ParentDragDrop = null;  						// If the node the mouse is over is the last node of the branch we should allow  						// the ability to drop the "nodemoving" node BELOW the parent node  						if (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))  						{  							int XPos = PointToClient(Cursor.Position).X;  							if (XPos < NodeOver.Bounds.Left)  							{  								ParentDragDrop = NodeOver.Parent;    								// MTC - commented out--maybe there isn't an image list!!!  								//if (XPos < (ParentDragDrop.Bounds.Left - ImageList.Images[ParentDragDrop.ImageIndex].Size.Width))  								//{  								//    if (ParentDragDrop.Parent != null)  								//        ParentDragDrop = ParentDragDrop.Parent;  								//}  							}  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						// Since we are in a special case here' use the ParentDragDrop node as the current "nodeover"  						SetNewNodeMap(ParentDragDrop != null ? ParentDragDrop : NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawLeafBottomPlaceholders(NodeOver' ParentDragDrop);  						#endregion  					}  					#endregion  				}  				else  				{  					#region Folder Node  					if (OffsetY < (NodeOver.Bounds.Height / 3))  					{  						//this.lblDebug.Text = "folder top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else if ((NodeOver.Parent != null && NodeOver.Index == 0) && (OffsetY > (NodeOver.Bounds.Height - (NodeOver.Bounds.Height / 3))))  					{  						//this.lblDebug.Text = "folder bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "folder over";    						if (NodeOver.Nodes.Count > 0)  						{  							NodeOver.Expand();  							//this.Refresh();  						}  						else  						{  							#region Prevent the node from being dragged onto itself  							if (NodeMoving == NodeOver)  								return;  							#endregion  							#region If NodeOver is a child then cancel  							TreeNode tnParadox = NodeOver;  							while (tnParadox.Parent != null)  							{  								if (tnParadox.Parent == NodeMoving)  								{  									this.NodeMap = "";  									return;  								}    								tnParadox = tnParadox.Parent;  							}  							#endregion  							#region Store the placeholder info into a pipe delimited string  							SetNewNodeMap(NodeOver' false);  							NewNodeMap = NewNodeMap.Insert(NewNodeMap.Length' "|0");    							if (SetMapsEqual() == true)  								return;  							#endregion  							#region Clear placeholders above and below  							this.Refresh();  							#endregion  							#region Draw the "add to folder" placeholder  							DrawAddToFolderPlaceholder(NodeOver);  							#endregion  						}  					}  					#endregion  				}  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The following statement contains a magic number: if (NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))))  			{  				int OffsetY = PointToClient(Cursor.Position).Y - NodeOver.Bounds.Top;  //				int NodeOverImageWidth = ImageList.Images[NodeOver.ImageIndex].Size.Width + 8;  				Graphics g = CreateGraphics();    				// Image index of 1 is the non-folder icon  //				if (NodeOver.ImageIndex == 1)  				// MTC  				// If there are subnodes already' or we're at the last node' then draw the "before/after" markers.  				// What this prevents happening is the ability to add subnodes to a last node that has no children.  				// So we need to add an AND expression' that if we're at the last node AND the mouse Y is at the top third or bottom third of the node'  				// THEN we want to treat this as a "before/after" selection.  Otherwise' treat it as adding a child node.  				if ( (NodeOver.Nodes.Count > 0) ||   					( (NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)) &&  					  ( (OffsetY < NodeOver.Bounds.Height / 3) || (OffsetY > 2*NodeOver.Bounds.Height/3) ) )  					)  				{  					#region Standard Node  					if (OffsetY < (NodeOver.Bounds.Height / 2))  					{  						//this.lblDebug.Text = "top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawLeafTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Allow drag drop to parent branches  						TreeNode ParentDragDrop = null;  						// If the node the mouse is over is the last node of the branch we should allow  						// the ability to drop the "nodemoving" node BELOW the parent node  						if (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))  						{  							int XPos = PointToClient(Cursor.Position).X;  							if (XPos < NodeOver.Bounds.Left)  							{  								ParentDragDrop = NodeOver.Parent;    								// MTC - commented out--maybe there isn't an image list!!!  								//if (XPos < (ParentDragDrop.Bounds.Left - ImageList.Images[ParentDragDrop.ImageIndex].Size.Width))  								//{  								//    if (ParentDragDrop.Parent != null)  								//        ParentDragDrop = ParentDragDrop.Parent;  								//}  							}  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						// Since we are in a special case here' use the ParentDragDrop node as the current "nodeover"  						SetNewNodeMap(ParentDragDrop != null ? ParentDragDrop : NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawLeafBottomPlaceholders(NodeOver' ParentDragDrop);  						#endregion  					}  					#endregion  				}  				else  				{  					#region Folder Node  					if (OffsetY < (NodeOver.Bounds.Height / 3))  					{  						//this.lblDebug.Text = "folder top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else if ((NodeOver.Parent != null && NodeOver.Index == 0) && (OffsetY > (NodeOver.Bounds.Height - (NodeOver.Bounds.Height / 3))))  					{  						//this.lblDebug.Text = "folder bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "folder over";    						if (NodeOver.Nodes.Count > 0)  						{  							NodeOver.Expand();  							//this.Refresh();  						}  						else  						{  							#region Prevent the node from being dragged onto itself  							if (NodeMoving == NodeOver)  								return;  							#endregion  							#region If NodeOver is a child then cancel  							TreeNode tnParadox = NodeOver;  							while (tnParadox.Parent != null)  							{  								if (tnParadox.Parent == NodeMoving)  								{  									this.NodeMap = "";  									return;  								}    								tnParadox = tnParadox.Parent;  							}  							#endregion  							#region Store the placeholder info into a pipe delimited string  							SetNewNodeMap(NodeOver' false);  							NewNodeMap = NewNodeMap.Insert(NewNodeMap.Length' "|0");    							if (SetMapsEqual() == true)  								return;  							#endregion  							#region Clear placeholders above and below  							this.Refresh();  							#endregion  							#region Draw the "add to folder" placeholder  							DrawAddToFolderPlaceholder(NodeOver);  							#endregion  						}  					}  					#endregion  				}  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The following statement contains a magic number: if (NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))))  			{  				int OffsetY = PointToClient(Cursor.Position).Y - NodeOver.Bounds.Top;  //				int NodeOverImageWidth = ImageList.Images[NodeOver.ImageIndex].Size.Width + 8;  				Graphics g = CreateGraphics();    				// Image index of 1 is the non-folder icon  //				if (NodeOver.ImageIndex == 1)  				// MTC  				// If there are subnodes already' or we're at the last node' then draw the "before/after" markers.  				// What this prevents happening is the ability to add subnodes to a last node that has no children.  				// So we need to add an AND expression' that if we're at the last node AND the mouse Y is at the top third or bottom third of the node'  				// THEN we want to treat this as a "before/after" selection.  Otherwise' treat it as adding a child node.  				if ( (NodeOver.Nodes.Count > 0) ||   					( (NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)) &&  					  ( (OffsetY < NodeOver.Bounds.Height / 3) || (OffsetY > 2*NodeOver.Bounds.Height/3) ) )  					)  				{  					#region Standard Node  					if (OffsetY < (NodeOver.Bounds.Height / 2))  					{  						//this.lblDebug.Text = "top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawLeafTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Allow drag drop to parent branches  						TreeNode ParentDragDrop = null;  						// If the node the mouse is over is the last node of the branch we should allow  						// the ability to drop the "nodemoving" node BELOW the parent node  						if (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))  						{  							int XPos = PointToClient(Cursor.Position).X;  							if (XPos < NodeOver.Bounds.Left)  							{  								ParentDragDrop = NodeOver.Parent;    								// MTC - commented out--maybe there isn't an image list!!!  								//if (XPos < (ParentDragDrop.Bounds.Left - ImageList.Images[ParentDragDrop.ImageIndex].Size.Width))  								//{  								//    if (ParentDragDrop.Parent != null)  								//        ParentDragDrop = ParentDragDrop.Parent;  								//}  							}  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						// Since we are in a special case here' use the ParentDragDrop node as the current "nodeover"  						SetNewNodeMap(ParentDragDrop != null ? ParentDragDrop : NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawLeafBottomPlaceholders(NodeOver' ParentDragDrop);  						#endregion  					}  					#endregion  				}  				else  				{  					#region Folder Node  					if (OffsetY < (NodeOver.Bounds.Height / 3))  					{  						//this.lblDebug.Text = "folder top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else if ((NodeOver.Parent != null && NodeOver.Index == 0) && (OffsetY > (NodeOver.Bounds.Height - (NodeOver.Bounds.Height / 3))))  					{  						//this.lblDebug.Text = "folder bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "folder over";    						if (NodeOver.Nodes.Count > 0)  						{  							NodeOver.Expand();  							//this.Refresh();  						}  						else  						{  							#region Prevent the node from being dragged onto itself  							if (NodeMoving == NodeOver)  								return;  							#endregion  							#region If NodeOver is a child then cancel  							TreeNode tnParadox = NodeOver;  							while (tnParadox.Parent != null)  							{  								if (tnParadox.Parent == NodeMoving)  								{  									this.NodeMap = "";  									return;  								}    								tnParadox = tnParadox.Parent;  							}  							#endregion  							#region Store the placeholder info into a pipe delimited string  							SetNewNodeMap(NodeOver' false);  							NewNodeMap = NewNodeMap.Insert(NewNodeMap.Length' "|0");    							if (SetMapsEqual() == true)  								return;  							#endregion  							#region Clear placeholders above and below  							this.Refresh();  							#endregion  							#region Draw the "add to folder" placeholder  							DrawAddToFolderPlaceholder(NodeOver);  							#endregion  						}  					}  					#endregion  				}  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The following statement contains a magic number: if (NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))))  			{  				int OffsetY = PointToClient(Cursor.Position).Y - NodeOver.Bounds.Top;  //				int NodeOverImageWidth = ImageList.Images[NodeOver.ImageIndex].Size.Width + 8;  				Graphics g = CreateGraphics();    				// Image index of 1 is the non-folder icon  //				if (NodeOver.ImageIndex == 1)  				// MTC  				// If there are subnodes already' or we're at the last node' then draw the "before/after" markers.  				// What this prevents happening is the ability to add subnodes to a last node that has no children.  				// So we need to add an AND expression' that if we're at the last node AND the mouse Y is at the top third or bottom third of the node'  				// THEN we want to treat this as a "before/after" selection.  Otherwise' treat it as adding a child node.  				if ( (NodeOver.Nodes.Count > 0) ||   					( (NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)) &&  					  ( (OffsetY < NodeOver.Bounds.Height / 3) || (OffsetY > 2*NodeOver.Bounds.Height/3) ) )  					)  				{  					#region Standard Node  					if (OffsetY < (NodeOver.Bounds.Height / 2))  					{  						//this.lblDebug.Text = "top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawLeafTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Allow drag drop to parent branches  						TreeNode ParentDragDrop = null;  						// If the node the mouse is over is the last node of the branch we should allow  						// the ability to drop the "nodemoving" node BELOW the parent node  						if (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))  						{  							int XPos = PointToClient(Cursor.Position).X;  							if (XPos < NodeOver.Bounds.Left)  							{  								ParentDragDrop = NodeOver.Parent;    								// MTC - commented out--maybe there isn't an image list!!!  								//if (XPos < (ParentDragDrop.Bounds.Left - ImageList.Images[ParentDragDrop.ImageIndex].Size.Width))  								//{  								//    if (ParentDragDrop.Parent != null)  								//        ParentDragDrop = ParentDragDrop.Parent;  								//}  							}  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						// Since we are in a special case here' use the ParentDragDrop node as the current "nodeover"  						SetNewNodeMap(ParentDragDrop != null ? ParentDragDrop : NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawLeafBottomPlaceholders(NodeOver' ParentDragDrop);  						#endregion  					}  					#endregion  				}  				else  				{  					#region Folder Node  					if (OffsetY < (NodeOver.Bounds.Height / 3))  					{  						//this.lblDebug.Text = "folder top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else if ((NodeOver.Parent != null && NodeOver.Index == 0) && (OffsetY > (NodeOver.Bounds.Height - (NodeOver.Bounds.Height / 3))))  					{  						//this.lblDebug.Text = "folder bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "folder over";    						if (NodeOver.Nodes.Count > 0)  						{  							NodeOver.Expand();  							//this.Refresh();  						}  						else  						{  							#region Prevent the node from being dragged onto itself  							if (NodeMoving == NodeOver)  								return;  							#endregion  							#region If NodeOver is a child then cancel  							TreeNode tnParadox = NodeOver;  							while (tnParadox.Parent != null)  							{  								if (tnParadox.Parent == NodeMoving)  								{  									this.NodeMap = "";  									return;  								}    								tnParadox = tnParadox.Parent;  							}  							#endregion  							#region Store the placeholder info into a pipe delimited string  							SetNewNodeMap(NodeOver' false);  							NewNodeMap = NewNodeMap.Insert(NewNodeMap.Length' "|0");    							if (SetMapsEqual() == true)  								return;  							#endregion  							#region Clear placeholders above and below  							this.Refresh();  							#endregion  							#region Draw the "add to folder" placeholder  							DrawAddToFolderPlaceholder(NodeOver);  							#endregion  						}  					}  					#endregion  				}  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The following statement contains a magic number: if (NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))))  			{  				int OffsetY = PointToClient(Cursor.Position).Y - NodeOver.Bounds.Top;  //				int NodeOverImageWidth = ImageList.Images[NodeOver.ImageIndex].Size.Width + 8;  				Graphics g = CreateGraphics();    				// Image index of 1 is the non-folder icon  //				if (NodeOver.ImageIndex == 1)  				// MTC  				// If there are subnodes already' or we're at the last node' then draw the "before/after" markers.  				// What this prevents happening is the ability to add subnodes to a last node that has no children.  				// So we need to add an AND expression' that if we're at the last node AND the mouse Y is at the top third or bottom third of the node'  				// THEN we want to treat this as a "before/after" selection.  Otherwise' treat it as adding a child node.  				if ( (NodeOver.Nodes.Count > 0) ||   					( (NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)) &&  					  ( (OffsetY < NodeOver.Bounds.Height / 3) || (OffsetY > 2*NodeOver.Bounds.Height/3) ) )  					)  				{  					#region Standard Node  					if (OffsetY < (NodeOver.Bounds.Height / 2))  					{  						//this.lblDebug.Text = "top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawLeafTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Allow drag drop to parent branches  						TreeNode ParentDragDrop = null;  						// If the node the mouse is over is the last node of the branch we should allow  						// the ability to drop the "nodemoving" node BELOW the parent node  						if (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))  						{  							int XPos = PointToClient(Cursor.Position).X;  							if (XPos < NodeOver.Bounds.Left)  							{  								ParentDragDrop = NodeOver.Parent;    								// MTC - commented out--maybe there isn't an image list!!!  								//if (XPos < (ParentDragDrop.Bounds.Left - ImageList.Images[ParentDragDrop.ImageIndex].Size.Width))  								//{  								//    if (ParentDragDrop.Parent != null)  								//        ParentDragDrop = ParentDragDrop.Parent;  								//}  							}  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						// Since we are in a special case here' use the ParentDragDrop node as the current "nodeover"  						SetNewNodeMap(ParentDragDrop != null ? ParentDragDrop : NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawLeafBottomPlaceholders(NodeOver' ParentDragDrop);  						#endregion  					}  					#endregion  				}  				else  				{  					#region Folder Node  					if (OffsetY < (NodeOver.Bounds.Height / 3))  					{  						//this.lblDebug.Text = "folder top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else if ((NodeOver.Parent != null && NodeOver.Index == 0) && (OffsetY > (NodeOver.Bounds.Height - (NodeOver.Bounds.Height / 3))))  					{  						//this.lblDebug.Text = "folder bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "folder over";    						if (NodeOver.Nodes.Count > 0)  						{  							NodeOver.Expand();  							//this.Refresh();  						}  						else  						{  							#region Prevent the node from being dragged onto itself  							if (NodeMoving == NodeOver)  								return;  							#endregion  							#region If NodeOver is a child then cancel  							TreeNode tnParadox = NodeOver;  							while (tnParadox.Parent != null)  							{  								if (tnParadox.Parent == NodeMoving)  								{  									this.NodeMap = "";  									return;  								}    								tnParadox = tnParadox.Parent;  							}  							#endregion  							#region Store the placeholder info into a pipe delimited string  							SetNewNodeMap(NodeOver' false);  							NewNodeMap = NewNodeMap.Insert(NewNodeMap.Length' "|0");    							if (SetMapsEqual() == true)  								return;  							#endregion  							#region Clear placeholders above and below  							this.Refresh();  							#endregion  							#region Draw the "add to folder" placeholder  							DrawAddToFolderPlaceholder(NodeOver);  							#endregion  						}  					}  					#endregion  				}  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The following statement contains a magic number: if (NodeOver != null && (NodeOver != NodeMoving || (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))))  			{  				int OffsetY = PointToClient(Cursor.Position).Y - NodeOver.Bounds.Top;  //				int NodeOverImageWidth = ImageList.Images[NodeOver.ImageIndex].Size.Width + 8;  				Graphics g = CreateGraphics();    				// Image index of 1 is the non-folder icon  //				if (NodeOver.ImageIndex == 1)  				// MTC  				// If there are subnodes already' or we're at the last node' then draw the "before/after" markers.  				// What this prevents happening is the ability to add subnodes to a last node that has no children.  				// So we need to add an AND expression' that if we're at the last node AND the mouse Y is at the top third or bottom third of the node'  				// THEN we want to treat this as a "before/after" selection.  Otherwise' treat it as adding a child node.  				if ( (NodeOver.Nodes.Count > 0) ||   					( (NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1)) &&  					  ( (OffsetY < NodeOver.Bounds.Height / 3) || (OffsetY > 2*NodeOver.Bounds.Height/3) ) )  					)  				{  					#region Standard Node  					if (OffsetY < (NodeOver.Bounds.Height / 2))  					{  						//this.lblDebug.Text = "top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawLeafTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Allow drag drop to parent branches  						TreeNode ParentDragDrop = null;  						// If the node the mouse is over is the last node of the branch we should allow  						// the ability to drop the "nodemoving" node BELOW the parent node  						if (NodeOver.Parent != null && NodeOver.Index == (NodeOver.Parent.Nodes.Count - 1))  						{  							int XPos = PointToClient(Cursor.Position).X;  							if (XPos < NodeOver.Bounds.Left)  							{  								ParentDragDrop = NodeOver.Parent;    								// MTC - commented out--maybe there isn't an image list!!!  								//if (XPos < (ParentDragDrop.Bounds.Left - ImageList.Images[ParentDragDrop.ImageIndex].Size.Width))  								//{  								//    if (ParentDragDrop.Parent != null)  								//        ParentDragDrop = ParentDragDrop.Parent;  								//}  							}  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						// Since we are in a special case here' use the ParentDragDrop node as the current "nodeover"  						SetNewNodeMap(ParentDragDrop != null ? ParentDragDrop : NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawLeafBottomPlaceholders(NodeOver' ParentDragDrop);  						#endregion  					}  					#endregion  				}  				else  				{  					#region Folder Node  					if (OffsetY < (NodeOver.Bounds.Height / 3))  					{  						//this.lblDebug.Text = "folder top";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' false);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						this.DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else if ((NodeOver.Parent != null && NodeOver.Index == 0) && (OffsetY > (NodeOver.Bounds.Height - (NodeOver.Bounds.Height / 3))))  					{  						//this.lblDebug.Text = "folder bottom";    						#region If NodeOver is a child then cancel  						TreeNode tnParadox = NodeOver;  						while (tnParadox.Parent != null)  						{  							if (tnParadox.Parent == NodeMoving)  							{  								this.NodeMap = "";  								return;  							}    							tnParadox = tnParadox.Parent;  						}  						#endregion  						#region Store the placeholder info into a pipe delimited string  						SetNewNodeMap(NodeOver' true);  						if (SetMapsEqual() == true)  							return;  						#endregion  						#region Clear placeholders above and below  						this.Refresh();  						#endregion  						#region Draw the placeholders  						DrawFolderTopPlaceholders(NodeOver);  						#endregion  					}  					else  					{  						//this.lblDebug.Text = "folder over";    						if (NodeOver.Nodes.Count > 0)  						{  							NodeOver.Expand();  							//this.Refresh();  						}  						else  						{  							#region Prevent the node from being dragged onto itself  							if (NodeMoving == NodeOver)  								return;  							#endregion  							#region If NodeOver is a child then cancel  							TreeNode tnParadox = NodeOver;  							while (tnParadox.Parent != null)  							{  								if (tnParadox.Parent == NodeMoving)  								{  									this.NodeMap = "";  									return;  								}    								tnParadox = tnParadox.Parent;  							}  							#endregion  							#region Store the placeholder info into a pipe delimited string  							SetNewNodeMap(NodeOver' false);  							NewNodeMap = NewNodeMap.Insert(NewNodeMap.Length' "|0");    							if (SetMapsEqual() == true)  								return;  							#endregion  							#region Clear placeholders above and below  							this.Refresh();  							#endregion  							#region Draw the "add to folder" placeholder  							DrawAddToFolderPlaceholder(NodeOver);  							#endregion  						}  					}  					#endregion  				}  			}
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: int RightPos = Width - 4;
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafTopPlaceholders,The following statement contains a magic number: g.DrawLine(new System.Drawing.Pen(Color.Black' 2)' new Point(LeftPos' NodeOver.Bounds.Top)' new Point(RightPos' NodeOver.Bounds.Top));
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: RightPos = Width - 4;
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Bottom - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Bottom - 4)'  													new Point(RightPos' NodeOver.Bounds.Bottom + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom - 1)'  													new Point(RightPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Bottom - 4)'  													new Point(RightPos' NodeOver.Bounds.Bottom + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom - 1)'  													new Point(RightPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Bottom - 4)'  													new Point(RightPos' NodeOver.Bounds.Bottom + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom - 1)'  													new Point(RightPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Bottom - 4)'  													new Point(RightPos' NodeOver.Bounds.Bottom + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom - 1)'  													new Point(RightPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Bottom - 4)'  													new Point(RightPos' NodeOver.Bounds.Bottom + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom - 1)'  													new Point(RightPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Bottom - 4)'  													new Point(RightPos' NodeOver.Bounds.Bottom + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom)'  													new Point(RightPos - 4' NodeOver.Bounds.Bottom - 1)'  													new Point(RightPos' NodeOver.Bounds.Bottom - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawLeafBottomPlaceholders,The following statement contains a magic number: g.DrawLine(new System.Drawing.Pen(Color.Black' 2)' new Point(LeftPos' NodeOver.Bounds.Bottom)' new Point(RightPos' NodeOver.Bounds.Bottom));
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: RightPos = Width - 4;
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] LeftTriangle = new Point[5]{  												   new Point(LeftPos' NodeOver.Bounds.Top - 4)'  												   new Point(LeftPos' NodeOver.Bounds.Top + 4)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Y)'  												   new Point(LeftPos + 4' NodeOver.Bounds.Top - 1)'  												   new Point(LeftPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Top - 4)'  													new Point(RightPos' NodeOver.Bounds.Top + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y)'  													new Point(RightPos - 4' NodeOver.Bounds.Top - 1)'  													new Point(RightPos' NodeOver.Bounds.Top - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawFolderTopPlaceholders,The following statement contains a magic number: g.DrawLine(new System.Drawing.Pen(Color.Black' 2)' new Point(LeftPos' NodeOver.Bounds.Top)' new Point(RightPos' NodeOver.Bounds.Top));
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: int RightPos = NodeOver.Bounds.Right + 6;
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Magic Number,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,DrawAddToFolderPlaceholder,The following statement contains a magic number: Point[] RightTriangle = new Point[5]{  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) + 4)'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2))'  													new Point(RightPos - 4' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 1)'  													new Point(RightPos' NodeOver.Bounds.Y + (NodeOver.Bounds.Height / 2) - 5)};
Duplicate Code,Clifton.Windows.Forms,XTree,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,OnXTreeDragOver,The method contains a code clone-set at the following line numbers (starting from the method definition): ((31' 53)' (115' 137))
Missing Default,Clifton.Windows.Forms.XmlTree,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XmlTree\NodeDef.cs,GetResourceInfo,The following switch statement is missing a default case: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
Missing Default,Clifton.Windows.Forms,Helper,C:\repos\cliftonm_HOPE\Clifton.Windows.Forms\XTree.cs,GetResourceInfo,The following switch statement is missing a default case: switch (res.Length)  			{  				case 1:  					assyName = "XTreeResources";  					className = "ApplicationIcons";  					resName = res[0];  					break;    				case 3:  					assyName = res[0];  					className = res[1];  					resName = res[2];  					break;    				case 4:  					assyName = res[0] + "." + res[1];  					className = res[2];  					resName = res[3];  					break;  			}
