Implementation smell,Namespace,Class,File,Method,Description
Long Method,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The method has 100 lines of code.
Long Method,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The method has 228 lines of code.
Long Method,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The method has 214 lines of code.
Long Method,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The method has 203 lines of code.
Long Method,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The method has 186 lines of code.
Long Method,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The method has 186 lines of code.
Long Method,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The method has 186 lines of code.
Long Method,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,ProcessAttributes,The method has 104 lines of code.
Complex Method,NCalc,Expression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Expression.cs,Evaluate,Cyclomatic complexity of the method is 13
Complex Method,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,ProcessNode,Cyclomatic complexity of the method is 8
Long Parameter List,Clifton.Tools.Data,JoinExtensions,C:\repos\cliftonm_HOPE\lib\JoinExtensions.cs,LeftJoin,The method has 5 parameters. Parameters: source' inner' pk' fk' result
Long Parameter List,Clifton.Tools.Data,JoinExtensions,C:\repos\cliftonm_HOPE\lib\JoinExtensions.cs,RightJoin,The method has 5 parameters. Parameters: source' inner' pk' fk' result
Long Parameter List,Clifton.Tools.Data,JoinExtensions,C:\repos\cliftonm_HOPE\lib\JoinExtensions.cs,FullOuterJoinJoin,The method has 5 parameters. Parameters: source' inner' pk' fk' result
Long Parameter List,Clifton.Tools.Data,JoinExtensions,C:\repos\cliftonm_HOPE\lib\JoinExtensions.cs,LeftExcludingJoin,The method has 5 parameters. Parameters: source' inner' pk' fk' result
Long Parameter List,Clifton.Tools.Data,JoinExtensions,C:\repos\cliftonm_HOPE\lib\JoinExtensions.cs,RightExcludingJoin,The method has 5 parameters. Parameters: source' inner' pk' fk' result
Long Parameter List,Clifton.Tools.Data,JoinExtensions,C:\repos\cliftonm_HOPE\lib\JoinExtensions.cs,FullExcludingJoin,The method has 5 parameters. Parameters: source' inner' pk' fk' result
Long Parameter List,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,MruStripMenu,The method has 5 parameters. Parameters: recentFileMenuItem' clickedHandler' registryKeyName' loadFromRegistry' maxEntries
Long Parameter List,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,Init,The method has 5 parameters. Parameters: recentFileMenuItem' clickedHandler' registryKeyName' loadFromRegistry' maxEntries
Long Parameter List,Clifton.Windows.Forms,MruStripMenuInline,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,MruStripMenuInline,The method has 5 parameters. Parameters: owningMenu' recentFileMenuItem' clickedHandler' registryKeyName' maxEntries
Long Parameter List,Clifton.Windows.Forms,MruStripMenuInline,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,MruStripMenuInline,The method has 5 parameters. Parameters: owningMenu' recentFileMenuItem' clickedHandler' registryKeyName' loadFromRegistry
Long Parameter List,Clifton.Windows.Forms,MruStripMenuInline,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,MruStripMenuInline,The method has 6 parameters. Parameters: owningMenu' recentFileMenuItem' clickedHandler' registryKeyName' loadFromRegistry' maxEntries
Long Parameter List,Clifton.MycroParser,EventEventArgs,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,EventEventArgs,The method has 5 parameters. Parameters: ei' ret' sink' srcName' methodName
Long Parameter List,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,OnAssignEvent,The method has 5 parameters. Parameters: ei' ret' sink' srcName' methodName
Long Parameter List,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,OnAddToCollection,The method has 6 parameters. Parameters: pi' propObject' obj' t' parentType' parent
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "                    Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1]))); " is 134.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "                    Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1]))); " is 124.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "                    Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1]))); " is 124.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "                    MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven; " is 170.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "                    Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding); " is 135.
Long Statement,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The length of the statement  "                        char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0]; " is 131.
Long Statement,NCalc,Expression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Expression.cs,Evaluate,The length of the statement  "                            throw new EvaluationException("When IterateParameters option is used' IEnumerable parameters must have the same number of items"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'bool'");  " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Byte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  " is 128.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.SByte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Int16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.UInt16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Int32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.UInt32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Int64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Single: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Double: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'byte' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'sbyte' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'sbyte' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'short' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'short' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ushort' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'int' and 'bool'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'int' and 'ulong'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'unit' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'long' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'long' and 'ulong'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.SByte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'sbyte'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Int16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'short'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Int32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'int'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Int64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'ulong'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'float' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'float' and 'decimal'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'double' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'double' and 'decimal'"); " is 136.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'bool'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Single: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'float'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The length of the statement  "                        case TypeCode.Double: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'double'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Byte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 128.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.SByte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Int16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.UInt16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Int32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.UInt32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Int64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Single: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Double: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'byte' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'sbyte' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'sbyte' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'short' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'short' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ushort' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'int' and 'bool'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'int' and 'ulong'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'uint' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'long' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'long' and 'ulong'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.SByte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'double'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Int16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'short'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Int32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'int'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Int64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'long'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'float' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'float' and 'decimal'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'double' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'double' and 'decimal'"); " is 136.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'bool'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Single: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'float'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The length of the statement  "                        case TypeCode.Double: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'double'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'byte' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'sbyte' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'sbyte' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'short' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'short' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ushort' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'int' and 'bool'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'int' and 'ulong'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'uint' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'long' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'long' and 'ulong'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.SByte: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'sbyte'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Int16: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'short'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Int32: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'int'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Int64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'long'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'float' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'float' and 'decimal'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'double' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'double' and 'decimal'"); " is 136.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'bool'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Single: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'float'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The length of the statement  "                        case TypeCode.Double: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'double'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'byte' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'sbyte' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'sbyte' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'short' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'short' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ushort' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'int' and 'bool'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'int' and 'ulong'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'uint' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'long' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'long' and 'ulong'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.SByte: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'sbyte'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Int16: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'short'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Int32: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'int'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Int64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'long'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'float' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'float' and 'decimal'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'double' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'double' and 'decimal'"); " is 136.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'bool'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Single: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'float'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The length of the statement  "                        case TypeCode.Double: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'double'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'byte' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'sbyte' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'sbyte' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'short' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'short' and 'ulong'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ushort' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'int' and 'bool'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'int' and 'ulong'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'uint' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'long' and 'bool'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'long' and 'ulong'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.SByte: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'sbyte'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Int16: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'short'"); " is 131.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Int32: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'int'"); " is 129.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Int64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'long'"); " is 130.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'float' and 'bool'"); " is 132.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'float' and 'decimal'"); " is 135.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'double' and 'bool'"); " is 133.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Decimal: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'double' and 'decimal'"); " is 136.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'bool'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Single: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'float'"); " is 134.
Long Statement,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The length of the statement  "                        case TypeCode.Double: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'decimal'"); " is 136.
Long Statement,Clifton.ExtensionMethods,ExtensionMethods,C:\repos\cliftonm_HOPE\lib\ExtensionMethods.cs,KeyFromValue,The length of the statement  "			// "Instead of calling Equals' it's better to use an IComparer<T> - and if you have no more information' EqualityComparer<T>.Default is a good choice: Aside from anything else' this avoids boxing/casting." " is 205.
Long Statement,Clifton.Collections,ObservableSortedList<T>,C:\repos\cliftonm_HOPE\lib\ObservableSortedList.cs,collectionChanged_Moved,The length of the statement  "				CollectionChanged(this' new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Move' item' newIndex' oldIndex)); " is 124.
Long Statement,Clifton.Threading,LockTimeoutException,C:\repos\cliftonm_HOPE\lib\Threading\TimedLock.cs,GetBlockingStackTrace,The length of the statement  "				throw new InvalidOperationException("We'd all like to be able to go back in time' but this is not allowed. Please choose a positive wait time."); " is 145.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,AssignProperties,The length of the statement  "			target.GetType().GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy | BindingFlags.Instance).ForEach(pi => " is 146.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,AssignFields,The length of the statement  "			target.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy | BindingFlags.Instance).ForEach(field => " is 145.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,OnAssignEvent,The length of the statement  "					MethodInfo mi = sink.GetType().GetMethod(methodName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static); " is 145.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,ProcessNode,The length of the statement  "			// If the referenced object has additional properties that have been set (attributeCount > 1' as the first attribute is the ref:)' " is 130.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,ProcessNode,The length of the statement  "			// then we call EndInit again because the object might need to do initialization with the attribute values that have now been assigned. " is 135.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,ProcessNode,The length of the statement  "			// If the referenced object has additional properties that have been set (attributeCount > 1' as the first attribute is the ref:)' " is 130.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,ProcessNode,The length of the statement  "			// then we call EndInit again because the object might need to do initialization with the attribute values that have now been assigned. " is 135.
Long Statement,Clifton.MycroParser,MycroParser,C:\repos\cliftonm_HOPE\lib\MycroParser.cs,ProcessChildProperties,The length of the statement  "						PropertyInfo pi = parentType.GetProperty(pname); //' BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.NonPublic); " is 131.
Long Statement,Clifton.ApplicationStateManagement,StatePersistence,C:\repos\cliftonm_HOPE\lib\StatePersistence.cs,Register,The length of the statement  "				stateObjects.ContainsKey(objectKey).Then(() => { throw new ApplicationException("The instance " + objectKey + " has already been registered as persistable."); }); " is 162.
Long Statement,Clifton.ApplicationStateManagement,StatePersistence,C:\repos\cliftonm_HOPE\lib\StatePersistence.cs,SaveState,The length of the statement  "			appState.ObjectStates = (List<ObjectState>)appState.ObjectStates.Replace(objState' (a' b) => (a.StateObjectKey == b.StateObjectKey)); " is 133.
Complex Conditional,Clifton.Collections,ObservableSortedList<T>,C:\repos\cliftonm_HOPE\lib\ObservableSortedList.cs,ItemPropertyChanged,The conditional expression  "Count <= 1 || (oldIndex == 0 || _comparer.Compare(_list[oldIndex - 1]' item) <= 0)  				&& (oldIndex == Count - 1 || _comparer.Compare(item' _list[oldIndex + 1]) <= 0)"  is complex.
Empty Catch Block,Clifton.Threading,ManagedThreadPool,C:\repos\cliftonm_HOPE\lib\Threading\ManagedThreadPool.cs,EmptyQueue,The method has an empty catch block.
Empty Catch Block,Clifton.Threading,ManagedThreadPool,C:\repos\cliftonm_HOPE\lib\Threading\ManagedThreadPool.cs,ProcessQueuedItems,The method has an empty catch block.
Empty Catch Block,Clifton.Threading,ManagedThreadPool,C:\repos\cliftonm_HOPE\lib\Threading\ManagedThreadPool.cs,ProcessQueuedItems,The method has an empty catch block.
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower())              {                  #region Abs                  case "abs":                        CheckCase("Abs"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Abs() takes exactly 1 argument");                        Result = Math.Abs(Convert.ToDecimal(                          Evaluate(function.Expressions[0]))                          );                        break;                    #endregion                    #region Acos                  case "acos":                        CheckCase("Acos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Acos() takes exactly 1 argument");                        Result = Math.Acos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Asin                  case "asin":                        CheckCase("Asin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Asin() takes exactly 1 argument");                        Result = Math.Asin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Atan                  case "atan":                        CheckCase("Atan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Atan() takes exactly 1 argument");                        Result = Math.Atan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Ceiling                  case "ceiling":                        CheckCase("Ceiling"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Ceiling() takes exactly 1 argument");                        Result = Math.Ceiling(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Cos                    case "cos":                        CheckCase("Cos"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Cos() takes exactly 1 argument");                        Result = Math.Cos(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Exp                  case "exp":                        CheckCase("Exp"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Exp() takes exactly 1 argument");                        Result = Math.Exp(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Floor                  case "floor":                        CheckCase("Floor"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Floor() takes exactly 1 argument");                        Result = Math.Floor(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region IEEERemainder                  case "ieeeremainder":                        CheckCase("IEEERemainder"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("IEEERemainder() takes exactly 2 arguments");                        Result = Math.IEEERemainder(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log                  case "log":                        CheckCase("Log"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Log() takes exactly 2 arguments");                        Result = Math.Log(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Log10                  case "log10":                        CheckCase("Log10"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Log10() takes exactly 1 argument");                        Result = Math.Log10(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Pow                  case "pow":                        CheckCase("Pow"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Pow() takes exactly 2 arguments");                        Result = Math.Pow(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToDouble(Evaluate(function.Expressions[1])));                        break;                    #endregion                    #region Round                  case "round":                        CheckCase("Round"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Round() takes exactly 2 arguments");                        MidpointRounding rounding = (_options & EvaluateOptions.RoundAwayFromZero) == EvaluateOptions.RoundAwayFromZero ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;                        Result = Math.Round(Convert.ToDouble(Evaluate(function.Expressions[0]))' Convert.ToInt16(Evaluate(function.Expressions[1]))' rounding);                        break;                    #endregion                    #region Sign                  case "sign":                        CheckCase("Sign"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sign() takes exactly 1 argument");                        Result = Math.Sign(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sin                  case "sin":                        CheckCase("Sin"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sin() takes exactly 1 argument");                        Result = Math.Sin(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Sqrt                  case "sqrt":                        CheckCase("Sqrt"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Sqrt() takes exactly 1 argument");                        Result = Math.Sqrt(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Tan                  case "tan":                        CheckCase("Tan"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Tan() takes exactly 1 argument");                        Result = Math.Tan(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                    #region Truncate                  case "truncate":                        CheckCase("Truncate"' function.Identifier.Name);                        if (function.Expressions.Length != 1)                          throw new ArgumentException("Truncate() takes exactly 1 argument");                        Result = Math.Truncate(Convert.ToDouble(Evaluate(function.Expressions[0])));                        break;                    #endregion                                    #region Max                  case "max":                        CheckCase("Max"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Max() takes exactly 2 arguments");                        object maxleft = Evaluate(function.Expressions[0]);                      object maxright = Evaluate(function.Expressions[1]);                        Result = Numbers.Max(maxleft' maxright);                      break;                    #endregion                    #region Min                  case "min":                        CheckCase("Min"' function.Identifier.Name);                        if (function.Expressions.Length != 2)                          throw new ArgumentException("Min() takes exactly 2 arguments");                        object minleft = Evaluate(function.Expressions[0]);                      object minright = Evaluate(function.Expressions[1]);                        Result = Numbers.Min(minleft' minright);                      break;                    #endregion                    #region if                  case "if":                        CheckCase("if"' function.Identifier.Name);                        if (function.Expressions.Length != 3)                          throw new ArgumentException("if() takes exactly 3 arguments");                        bool cond = Convert.ToBoolean(Evaluate(function.Expressions[0]));                        Result = cond ? Evaluate(function.Expressions[1]) : Evaluate(function.Expressions[2]);                      break;                    #endregion                    #region in                  case "in":                        CheckCase("in"' function.Identifier.Name);                        if (function.Expressions.Length < 2)                          throw new ArgumentException("in() takes at least 2 arguments");                        object parameter = Evaluate(function.Expressions[0]);                        bool evaluation = false;                        // Goes through any values' and stop whe one is found                      for (int i = 1; i < function.Expressions.Length; i++)                      {                          object argument = Evaluate(function.Expressions[i]);                          if (CompareUsingMostPreciseType(parameter' argument) == 0)                          {                              evaluation = true;                              break;                          }                      }                        Result = evaluation;                      break;                    #endregion                    default:                      throw new ArgumentException("Function not found"'                           function.Identifier.Name);              }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString().IndexOf(BS' startIndex)) != -1)              {                  char escapeType = sb[slashIndex + 1];                  switch (escapeType)                  {                      case 'u':                          string hcode = String.Concat(sb[slashIndex + 4]' sb[slashIndex + 5]);                          string lcode = String.Concat(sb[slashIndex + 2]' sb[slashIndex + 3]);                          char unicodeChar = Encoding.Unicode.GetChars(new byte[] { System.Convert.ToByte(hcode' 16)' System.Convert.ToByte(lcode' 16) })[0];                          sb.Remove(slashIndex' 6).Insert(slashIndex' unicodeChar);                          break;                      case 'n': sb.Remove(slashIndex' 2).Insert(slashIndex' '\n'); break;                      case 'r': sb.Remove(slashIndex' 2).Insert(slashIndex' '\r'); break;                      case 't': sb.Remove(slashIndex' 2).Insert(slashIndex' '\t'); break;                      case '\'': sb.Remove(slashIndex' 2).Insert(slashIndex' '\''); break;                      case '\\': sb.Remove(slashIndex' 2).Insert(slashIndex' '\\'); break;                      default: throw new ApplicationException("Unvalid escape sequence: \\" + escapeType);                  }                    startIndex = slashIndex + 1;                }
Magic Number,Clifton.Threading,TimedLock,C:\repos\cliftonm_HOPE\lib\Threading\TimedLock.cs,Lock,The following statement contains a magic number: return Lock(o' TimeSpan.FromSeconds(10));
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,FixupEntryname,The following statement contains a magic number: if (number < 9)  				return "&" + (number + 1) + "  " + entryname;  			else if (number == 9)  				return "1&0" + "  " + entryname;  			else  				return (number + 1) + "  " + entryname;
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,FixupEntryname,The following statement contains a magic number: if (number < 9)  				return "&" + (number + 1) + "  " + entryname;  			else if (number == 9)  				return "1&0" + "  " + entryname;  			else  				return (number + 1) + "  " + entryname;
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,FixupPrefixes,The following statement contains a magic number: if (startNumber < maxEntries)  			{  				for (int i = StartIndex + startNumber; i < EndIndex; i++' startNumber++)  				{  					MenuItems[i].Text = FixupEntryname(startNumber' MenuItems[i].Text.Substring(startNumber == 9 ? 5 : 4));  				}  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,FixupPrefixes,The following statement contains a magic number: if (startNumber < maxEntries)  			{  				for (int i = StartIndex + startNumber; i < EndIndex; i++' startNumber++)  				{  					MenuItems[i].Text = FixupEntryname(startNumber' MenuItems[i].Text.Substring(startNumber == 9 ? 5 : 4));  				}  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,FixupPrefixes,The following statement contains a magic number: if (startNumber < maxEntries)  			{  				for (int i = StartIndex + startNumber; i < EndIndex; i++' startNumber++)  				{  					MenuItems[i].Text = FixupEntryname(startNumber' MenuItems[i].Text.Substring(startNumber == 9 ? 5 : 4));  				}  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (root.Length > 3)  				root += Path.DirectorySeparatorChar;
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,ShortenPathname,The following statement contains a magic number: if (elements.GetLength(0) == 1) // pathname is just a root and filename  			{  				if (elements[0].Length > 5) // long enough to shorten  				{  					// if path is a UNC path' root may be rather long  					if (root.Length + 6 >= maxLength)  					{  						return root + elements[0].Substring(0' 3) + "...";  					}  					else  					{  						return pathname.Substring(0' maxLength - 3) + "...";  					}  				}  			}  			else if ((root.Length + 4 + elements[filenameIndex].Length) > maxLength) // pathname is just a root and filename  			{  				root += "...\\";    				int len = elements[filenameIndex].Length;  				if (len < 6)  					return root + elements[filenameIndex];    				if ((root.Length + 6) >= maxLength)  				{  					len = 3;  				}  				else  				{  					len = maxLength - root.Length - 3;  				}  				return root + elements[filenameIndex].Substring(0' len) + "...";  			}  			else if (elements.GetLength(0) == 2)  			{  				return root + "...\\" + elements[1];  			}  			else  			{  				int len = 0;  				int begin = 0;    				for (int i = 0; i < filenameIndex; i++)  				{  					if (elements[i].Length > len)  					{  						begin = i;  						len = elements[i].Length;  					}  				}    				int totalLength = pathname.Length - len + 3;  				int end = begin + 1;    				while (totalLength > maxLength)  				{  					if (begin > 0)  						totalLength -= elements[--begin].Length - 1;    					if (totalLength <= maxLength)  						break;    					if (end < filenameIndex)  						totalLength -= elements[++end].Length - 1;    					if (begin == 0 && end == filenameIndex)  						break;  				}    				// assemble final string    				for (int i = 0; i < begin; i++)  				{  					root += elements[i] + '\\';  				}    				root += "...\\";    				for (int i = end; i < filenameIndex; i++)  				{  					root += elements[i] + '\\';  				}    				return root + elements[filenameIndex];  			}
Magic Number,Clifton.Windows.Forms,MruStripMenu,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,SaveToRegistry,The following statement contains a magic number: if (registryKeyName != null)  			{  				mruStripMutex.WaitOne();    				RegistryKey regKey = Registry.CurrentUser.CreateSubKey(registryKeyName);  				if (regKey != null)  				{  					regKey.SetValue("max"' maxEntries);    					int number = 1;  					int i = StartIndex;  					for (; i < EndIndex; i++' number++)  					{  						regKey.SetValue("File" + number.ToString()' ((MruMenuItem)MenuItems[i]).Filename);  					}    					for (; number <= 16; number++)  					{  						regKey.DeleteValue("File" + number.ToString()' false);  					}    					regKey.Close();  				}  				mruStripMutex.ReleaseMutex();  			}
Magic Number,Clifton.Windows.Forms,MruStripMenuInline,C:\repos\cliftonm_HOPE\lib\MruStripMenu.cs,MruStripMenuInline,The following statement contains a magic number: maxShortenPathLength = 48;
Magic Number,Clifton.Tools.Strings.Extensions,StringHelpersExtensions,C:\repos\cliftonm_HOPE\lib\StringHelperExtensions.cs,Contains,The following statement contains a magic number: int firstIndex=9999;
Magic Number,Clifton.Tools.Strings.Extensions,StringHelpersExtensions,C:\repos\cliftonm_HOPE\lib\StringHelperExtensions.cs,LimitLength,The following statement contains a magic number: if (s.Length > len)  			{  				ret = s.Substring(0' len - 3) + "...";  			}
Missing Default,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type)              {                  case BinaryExpressionType.And:                      Result = Convert.ToBoolean(left()) && Convert.ToBoolean(right());                      break;                    case BinaryExpressionType.Or:                      Result = Convert.ToBoolean(left()) || Convert.ToBoolean(right());                      break;                    case BinaryExpressionType.Div:                      Result = IsReal(left()) || IsReal(right())                                   ? Numbers.Divide(left()' right())                                   : Numbers.Divide(Convert.ToDouble(left())' right());                      break;                    case BinaryExpressionType.Equal:                      // Use the type of the left operand to make the comparison                      Result = CompareUsingMostPreciseType(left()' right()) == 0;                      break;                    case BinaryExpressionType.Greater:                      // Use the type of the left operand to make the comparison                      Result = CompareUsingMostPreciseType(left()' right()) > 0;                      break;                    case BinaryExpressionType.GreaterOrEqual:                      // Use the type of the left operand to make the comparison                      Result = CompareUsingMostPreciseType(left()' right()) >= 0;                      break;                    case BinaryExpressionType.Lesser:                      // Use the type of the left operand to make the comparison                      Result = CompareUsingMostPreciseType(left()' right()) < 0;                      break;                    case BinaryExpressionType.LesserOrEqual:                      // Use the type of the left operand to make the comparison                      Result = CompareUsingMostPreciseType(left()' right()) <= 0;                      break;                    case BinaryExpressionType.Minus:                      Result = Numbers.Soustract(left()' right());                      break;                    case BinaryExpressionType.Modulo:                      Result = Numbers.Modulo(left()' right());                      break;                    case BinaryExpressionType.NotEqual:                      // Use the type of the left operand to make the comparison                      Result = CompareUsingMostPreciseType(left()' right()) != 0;                      break;                    case BinaryExpressionType.Plus:                      if (left() is string)                      {                          Result = String.Concat(left()' right());                      }                      else                      {                          Result = Numbers.Add(left()' right());                      }                        break;                    case BinaryExpressionType.Times:                      Result = Numbers.Multiply(left()' right());                      break;                    case BinaryExpressionType.BitwiseAnd:                      Result = Convert.ToUInt16(left()) & Convert.ToUInt16(right());                      break;                      case BinaryExpressionType.BitwiseOr:                      Result = Convert.ToUInt16(left()) | Convert.ToUInt16(right());                      break;                      case BinaryExpressionType.BitwiseXOr:                      Result = Convert.ToUInt16(left()) ^ Convert.ToUInt16(right());                      break;                      case BinaryExpressionType.LeftShift:                      Result = Convert.ToUInt16(left()) << Convert.ToUInt16(right());                      break;                      case BinaryExpressionType.RightShift:                      Result = Convert.ToUInt16(left()) >> Convert.ToUInt16(right());                      break;              }
Missing Default,NCalc.Domain,EvaluationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\EvaluationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type)              {                  case UnaryExpressionType.Not:                      Result = !Convert.ToBoolean(Result);                      break;                    case UnaryExpressionType.Negate:                      Result = Numbers.Soustract(0' Result);                      break;                    case UnaryExpressionType.BitwiseNot:                      Result = ~Convert.ToUInt16(Result);                      break;              }
Missing Default,NCalc.Domain,SerializationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\SerializationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type)              {                  case BinaryExpressionType.And:                      Result.Append("and ");                      break;                    case BinaryExpressionType.Or:                      Result.Append("or ");                      break;                    case BinaryExpressionType.Div:                      Result.Append("/ ");                      break;                    case BinaryExpressionType.Equal:                      Result.Append("= ");                      break;                    case BinaryExpressionType.Greater:                      Result.Append("> ");                      break;                    case BinaryExpressionType.GreaterOrEqual:                      Result.Append(">= ");                      break;                    case BinaryExpressionType.Lesser:                      Result.Append("< ");                      break;                    case BinaryExpressionType.LesserOrEqual:                      Result.Append("<= ");                      break;                    case BinaryExpressionType.Minus:                      Result.Append("- ");                      break;                    case BinaryExpressionType.Modulo:                      Result.Append("% ");                      break;                    case BinaryExpressionType.NotEqual:                      Result.Append("!= ");                      break;                    case BinaryExpressionType.Plus:                      Result.Append("+ ");                      break;                    case BinaryExpressionType.Times:                      Result.Append("* ");                      break;                    case BinaryExpressionType.BitwiseAnd:                      Result.Append("& ");                      break;                    case BinaryExpressionType.BitwiseOr:                      Result.Append("| ");                      break;                    case BinaryExpressionType.BitwiseXOr:                      Result.Append("~ ");                      break;                    case BinaryExpressionType.LeftShift:                      Result.Append("<< ");                      break;                    case BinaryExpressionType.RightShift:                      Result.Append(">> ");                      break;              }
Missing Default,NCalc.Domain,SerializationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\SerializationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type)              {                  case UnaryExpressionType.Not:                      Result.Append("!");                      break;                    case UnaryExpressionType.Negate:                      Result.Append("-");                      break;                    case UnaryExpressionType.BitwiseNot:                      Result.Append("~");                      break;              }
Missing Default,NCalc.Domain,SerializationVisitor,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Domain\SerializationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type)              {                  case ValueType.Boolean:                      Result.Append(expression.Value.ToString()).Append(" ");                      break;                    case ValueType.DateTime:                      Result.Append("#").Append(expression.Value.ToString()).Append("#").Append(" ");                      break;                    case ValueType.Float:                      Result.Append(decimal.Parse(expression.Value.ToString()).ToString(_numberFormatInfo)).Append(" ");                      break;                    case ValueType.Integer:                      Result.Append(expression.Value.ToString()).Append(" ");                      break;                    case ValueType.String:                      Result.Append("'").Append(expression.Value.ToString()).Append("'").Append(" ");                      break;              }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeA)              {                  case TypeCode.Boolean:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'bool'");                           case TypeCode.Byte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                           case TypeCode.SByte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                           case TypeCode.Int16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Single: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                      }                      break;                  case TypeCode.Byte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.Byte: return (Byte)a + (Byte)b;                          case TypeCode.SByte: return (Byte)a + (SByte)b;                          case TypeCode.Int16: return (Byte)a + (Int16)b;                          case TypeCode.UInt16: return (Byte)a + (UInt16)b;                          case TypeCode.Int32: return (Byte)a + (Int32)b;                          case TypeCode.UInt32: return (Byte)a + (UInt32)b;                          case TypeCode.Int64: return (Byte)a + (Int64)b;                          case TypeCode.UInt64: return (Byte)a + (UInt64)b;                          case TypeCode.Single: return (Byte)a + (Single)b;                          case TypeCode.Double: return (Byte)a + (Double)b;                          case TypeCode.Decimal: return (Byte)a + (Decimal)b;                      }                      break;                  case TypeCode.SByte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.Byte: return (SByte)a + (Byte)b;                          case TypeCode.SByte: return (SByte)a + (SByte)b;                          case TypeCode.Int16: return (SByte)a + (Int16)b;                          case TypeCode.UInt16: return (SByte)a + (UInt16)b;                          case TypeCode.Int32: return (SByte)a + (Int32)b;                          case TypeCode.UInt32: return (SByte)a + (UInt32)b;                          case TypeCode.Int64: return (SByte)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a + (Single)b;                          case TypeCode.Double: return (SByte)a + (Double)b;                          case TypeCode.Decimal: return (SByte)a + (Decimal)b;                      }                      break;                    case TypeCode.Int16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.Byte: return (Int16)a + (Byte)b;                          case TypeCode.SByte: return (Int16)a + (SByte)b;                          case TypeCode.Int16: return (Int16)a + (Int16)b;                          case TypeCode.UInt16: return (Int16)a + (UInt16)b;                          case TypeCode.Int32: return (Int16)a + (Int32)b;                          case TypeCode.UInt32: return (Int16)a + (UInt32)b;                          case TypeCode.Int64: return (Int16)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a + (Single)b;                          case TypeCode.Double: return (Int16)a + (Double)b;                          case TypeCode.Decimal: return (Int16)a + (Decimal)b;                      }                      break;                    case TypeCode.UInt16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.Byte: return (UInt16)a + (Byte)b;                          case TypeCode.SByte: return (UInt16)a + (SByte)b;                          case TypeCode.Int16: return (UInt16)a + (Int16)b;                          case TypeCode.UInt16: return (UInt16)a + (UInt16)b;                          case TypeCode.Int32: return (UInt16)a + (Int32)b;                          case TypeCode.UInt32: return (UInt16)a + (UInt32)b;                          case TypeCode.Int64: return (UInt16)a + (Int64)b;                          case TypeCode.UInt64: return (UInt16)a + (UInt64)b;                          case TypeCode.Single: return (UInt16)a + (Single)b;                          case TypeCode.Double: return (UInt16)a + (Double)b;                          case TypeCode.Decimal: return (UInt16)a + (Decimal)b;                      }                      break;                    case TypeCode.Int32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.Byte: return (Int32)a + (Byte)b;                          case TypeCode.SByte: return (Int32)a + (SByte)b;                          case TypeCode.Int16: return (Int32)a + (Int16)b;                          case TypeCode.UInt16: return (Int32)a + (UInt16)b;                          case TypeCode.Int32: return (Int32)a + (Int32)b;                          case TypeCode.UInt32: return (Int32)a + (UInt32)b;                          case TypeCode.Int64: return (Int32)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a + (Single)b;                          case TypeCode.Double: return (Int32)a + (Double)b;                          case TypeCode.Decimal: return (Int32)a + (Decimal)b;                      }                      break;                    case TypeCode.UInt32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'unit' and 'bool'");                          case TypeCode.Byte: return (UInt32)a + (Byte)b;                          case TypeCode.SByte: return (UInt32)a + (SByte)b;                          case TypeCode.Int16: return (UInt32)a + (Int16)b;                          case TypeCode.UInt16: return (UInt32)a + (UInt16)b;                          case TypeCode.Int32: return (UInt32)a + (Int32)b;                          case TypeCode.UInt32: return (UInt32)a + (UInt32)b;                          case TypeCode.Int64: return (UInt32)a + (Int64)b;                          case TypeCode.UInt64: return (UInt32)a + (UInt64)b;                          case TypeCode.Single: return (UInt32)a + (Single)b;                          case TypeCode.Double: return (UInt32)a + (Double)b;                          case TypeCode.Decimal: return (UInt32)a + (Decimal)b;                      }                      break;                    case TypeCode.Int64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.Byte: return (Int64)a + (Byte)b;                          case TypeCode.SByte: return (Int64)a + (SByte)b;                          case TypeCode.Int16: return (Int64)a + (Int16)b;                          case TypeCode.UInt16: return (Int64)a + (UInt16)b;                          case TypeCode.Int32: return (Int64)a + (Int32)b;                          case TypeCode.UInt32: return (Int64)a + (UInt32)b;                          case TypeCode.Int64: return (Int64)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a + (Single)b;                          case TypeCode.Double: return (Int64)a + (Double)b;                          case TypeCode.Decimal: return (Int64)a + (Decimal)b;                      }                      break;                    case TypeCode.UInt64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.Byte: return (UInt64)a + (Byte)b;                          case TypeCode.SByte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a + (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a + (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'ulong'");                          case TypeCode.UInt64: return (UInt64)a + (UInt64)b;                          case TypeCode.Single: return (UInt64)a + (Single)b;                          case TypeCode.Double: return (UInt64)a + (Double)b;                          case TypeCode.Decimal: return (UInt64)a + (Decimal)b;                      }                      break;                    case TypeCode.Single:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.Byte: return (Single)a + (Byte)b;                          case TypeCode.SByte: return (Single)a + (SByte)b;                          case TypeCode.Int16: return (Single)a + (Int16)b;                          case TypeCode.UInt16: return (Single)a + (UInt16)b;                          case TypeCode.Int32: return (Single)a + (Int32)b;                          case TypeCode.UInt32: return (Single)a + (UInt32)b;                          case TypeCode.Int64: return (Single)a + (Int64)b;                          case TypeCode.UInt64: return (Single)a + (UInt64)b;                          case TypeCode.Single: return (Single)a + (Single)b;                          case TypeCode.Double: return (Single)a + (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'float' and 'decimal'");                      }                      break;                    case TypeCode.Double:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.Byte: return (Double)a + (Byte)b;                          case TypeCode.SByte: return (Double)a + (SByte)b;                          case TypeCode.Int16: return (Double)a + (Int16)b;                          case TypeCode.UInt16: return (Double)a + (UInt16)b;                          case TypeCode.Int32: return (Double)a + (Int32)b;                          case TypeCode.UInt32: return (Double)a + (UInt32)b;                          case TypeCode.Int64: return (Double)a + (Int64)b;                          case TypeCode.UInt64: return (Double)a + (UInt64)b;                          case TypeCode.Single: return (Double)a + (Single)b;                          case TypeCode.Double: return (Double)a + (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'double' and 'decimal'");                      }                      break;                    case TypeCode.Decimal:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.Byte: return (Decimal)a + (Byte)b;                          case TypeCode.SByte: return (Decimal)a + (SByte)b;                          case TypeCode.Int16: return (Decimal)a + (Int16)b;                          case TypeCode.UInt16: return (Decimal)a + (UInt16)b;                          case TypeCode.Int32: return (Decimal)a + (Int32)b;                          case TypeCode.UInt32: return (Decimal)a + (UInt32)b;                          case TypeCode.Int64: return (Decimal)a + (Int64)b;                          case TypeCode.UInt64: return (Decimal)a + (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a + (Decimal)b;                      }                      break;              }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'bool'");                           case TypeCode.Byte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                           case TypeCode.SByte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                           case TypeCode.Int16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Single: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'bool' and 'byte'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.Byte: return (Byte)a + (Byte)b;                          case TypeCode.SByte: return (Byte)a + (SByte)b;                          case TypeCode.Int16: return (Byte)a + (Int16)b;                          case TypeCode.UInt16: return (Byte)a + (UInt16)b;                          case TypeCode.Int32: return (Byte)a + (Int32)b;                          case TypeCode.UInt32: return (Byte)a + (UInt32)b;                          case TypeCode.Int64: return (Byte)a + (Int64)b;                          case TypeCode.UInt64: return (Byte)a + (UInt64)b;                          case TypeCode.Single: return (Byte)a + (Single)b;                          case TypeCode.Double: return (Byte)a + (Double)b;                          case TypeCode.Decimal: return (Byte)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.Byte: return (SByte)a + (Byte)b;                          case TypeCode.SByte: return (SByte)a + (SByte)b;                          case TypeCode.Int16: return (SByte)a + (Int16)b;                          case TypeCode.UInt16: return (SByte)a + (UInt16)b;                          case TypeCode.Int32: return (SByte)a + (Int32)b;                          case TypeCode.UInt32: return (SByte)a + (UInt32)b;                          case TypeCode.Int64: return (SByte)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a + (Single)b;                          case TypeCode.Double: return (SByte)a + (Double)b;                          case TypeCode.Decimal: return (SByte)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.Byte: return (Int16)a + (Byte)b;                          case TypeCode.SByte: return (Int16)a + (SByte)b;                          case TypeCode.Int16: return (Int16)a + (Int16)b;                          case TypeCode.UInt16: return (Int16)a + (UInt16)b;                          case TypeCode.Int32: return (Int16)a + (Int32)b;                          case TypeCode.UInt32: return (Int16)a + (UInt32)b;                          case TypeCode.Int64: return (Int16)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a + (Single)b;                          case TypeCode.Double: return (Int16)a + (Double)b;                          case TypeCode.Decimal: return (Int16)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.Byte: return (UInt16)a + (Byte)b;                          case TypeCode.SByte: return (UInt16)a + (SByte)b;                          case TypeCode.Int16: return (UInt16)a + (Int16)b;                          case TypeCode.UInt16: return (UInt16)a + (UInt16)b;                          case TypeCode.Int32: return (UInt16)a + (Int32)b;                          case TypeCode.UInt32: return (UInt16)a + (UInt32)b;                          case TypeCode.Int64: return (UInt16)a + (Int64)b;                          case TypeCode.UInt64: return (UInt16)a + (UInt64)b;                          case TypeCode.Single: return (UInt16)a + (Single)b;                          case TypeCode.Double: return (UInt16)a + (Double)b;                          case TypeCode.Decimal: return (UInt16)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.Byte: return (Int32)a + (Byte)b;                          case TypeCode.SByte: return (Int32)a + (SByte)b;                          case TypeCode.Int16: return (Int32)a + (Int16)b;                          case TypeCode.UInt16: return (Int32)a + (UInt16)b;                          case TypeCode.Int32: return (Int32)a + (Int32)b;                          case TypeCode.UInt32: return (Int32)a + (UInt32)b;                          case TypeCode.Int64: return (Int32)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a + (Single)b;                          case TypeCode.Double: return (Int32)a + (Double)b;                          case TypeCode.Decimal: return (Int32)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'unit' and 'bool'");                          case TypeCode.Byte: return (UInt32)a + (Byte)b;                          case TypeCode.SByte: return (UInt32)a + (SByte)b;                          case TypeCode.Int16: return (UInt32)a + (Int16)b;                          case TypeCode.UInt16: return (UInt32)a + (UInt16)b;                          case TypeCode.Int32: return (UInt32)a + (Int32)b;                          case TypeCode.UInt32: return (UInt32)a + (UInt32)b;                          case TypeCode.Int64: return (UInt32)a + (Int64)b;                          case TypeCode.UInt64: return (UInt32)a + (UInt64)b;                          case TypeCode.Single: return (UInt32)a + (Single)b;                          case TypeCode.Double: return (UInt32)a + (Double)b;                          case TypeCode.Decimal: return (UInt32)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.Byte: return (Int64)a + (Byte)b;                          case TypeCode.SByte: return (Int64)a + (SByte)b;                          case TypeCode.Int16: return (Int64)a + (Int16)b;                          case TypeCode.UInt16: return (Int64)a + (UInt16)b;                          case TypeCode.Int32: return (Int64)a + (Int32)b;                          case TypeCode.UInt32: return (Int64)a + (UInt32)b;                          case TypeCode.Int64: return (Int64)a + (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a + (Single)b;                          case TypeCode.Double: return (Int64)a + (Double)b;                          case TypeCode.Decimal: return (Int64)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.Byte: return (UInt64)a + (Byte)b;                          case TypeCode.SByte: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a + (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a + (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'ulong' and 'ulong'");                          case TypeCode.UInt64: return (UInt64)a + (UInt64)b;                          case TypeCode.Single: return (UInt64)a + (Single)b;                          case TypeCode.Double: return (UInt64)a + (Double)b;                          case TypeCode.Decimal: return (UInt64)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.Byte: return (Single)a + (Byte)b;                          case TypeCode.SByte: return (Single)a + (SByte)b;                          case TypeCode.Int16: return (Single)a + (Int16)b;                          case TypeCode.UInt16: return (Single)a + (UInt16)b;                          case TypeCode.Int32: return (Single)a + (Int32)b;                          case TypeCode.UInt32: return (Single)a + (UInt32)b;                          case TypeCode.Int64: return (Single)a + (Int64)b;                          case TypeCode.UInt64: return (Single)a + (UInt64)b;                          case TypeCode.Single: return (Single)a + (Single)b;                          case TypeCode.Double: return (Single)a + (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'float' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.Byte: return (Double)a + (Byte)b;                          case TypeCode.SByte: return (Double)a + (SByte)b;                          case TypeCode.Int16: return (Double)a + (Int16)b;                          case TypeCode.UInt16: return (Double)a + (UInt16)b;                          case TypeCode.Int32: return (Double)a + (Int32)b;                          case TypeCode.UInt32: return (Double)a + (UInt32)b;                          case TypeCode.Int64: return (Double)a + (Int64)b;                          case TypeCode.UInt64: return (Double)a + (UInt64)b;                          case TypeCode.Single: return (Double)a + (Single)b;                          case TypeCode.Double: return (Double)a + (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'double' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.Byte: return (Decimal)a + (Byte)b;                          case TypeCode.SByte: return (Decimal)a + (SByte)b;                          case TypeCode.Int16: return (Decimal)a + (Int16)b;                          case TypeCode.UInt16: return (Decimal)a + (UInt16)b;                          case TypeCode.Int32: return (Decimal)a + (Int32)b;                          case TypeCode.UInt32: return (Decimal)a + (UInt32)b;                          case TypeCode.Int64: return (Decimal)a + (Int64)b;                          case TypeCode.UInt64: return (Decimal)a + (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '+' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a + (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeA)              {                  case TypeCode.Boolean:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'bool'");                          case TypeCode.Byte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Single: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                      }                      break;                  case TypeCode.Byte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a - (SByte)b;                          case TypeCode.Int16: return (Byte)a - (Int16)b;                          case TypeCode.UInt16: return (Byte)a - (UInt16)b;                          case TypeCode.Int32: return (Byte)a - (Int32)b;                          case TypeCode.UInt32: return (Byte)a - (UInt32)b;                          case TypeCode.Int64: return (Byte)a - (Int64)b;                          case TypeCode.UInt64: return (Byte)a - (UInt64)b;                          case TypeCode.Single: return (Byte)a - (Single)b;                          case TypeCode.Double: return (Byte)a - (Double)b;                          case TypeCode.Decimal: return (Byte)a - (Decimal)b;                      }                      break;                  case TypeCode.SByte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a - (SByte)b;                          case TypeCode.Int16: return (SByte)a - (Int16)b;                          case TypeCode.UInt16: return (SByte)a - (UInt16)b;                          case TypeCode.Int32: return (SByte)a - (Int32)b;                          case TypeCode.UInt32: return (SByte)a - (UInt32)b;                          case TypeCode.Int64: return (SByte)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a - (Single)b;                          case TypeCode.Double: return (SByte)a - (Double)b;                          case TypeCode.Decimal: return (SByte)a - (Decimal)b;                      }                      break;                    case TypeCode.Int16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a - (SByte)b;                          case TypeCode.Int16: return (Int16)a - (Int16)b;                          case TypeCode.UInt16: return (Int16)a - (UInt16)b;                          case TypeCode.Int32: return (Int16)a - (Int32)b;                          case TypeCode.UInt32: return (Int16)a - (UInt32)b;                          case TypeCode.Int64: return (Int16)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a - (Single)b;                          case TypeCode.Double: return (Int16)a - (Double)b;                          case TypeCode.Decimal: return (Int16)a - (Decimal)b;                      }                      break;                    case TypeCode.UInt16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a - (SByte)b;                          case TypeCode.Int16: return (UInt16)a - (Int16)b;                          case TypeCode.UInt16: return (UInt16)a - (UInt16)b;                          case TypeCode.Int32: return (UInt16)a - (Int32)b;                          case TypeCode.UInt32: return (UInt16)a - (UInt32)b;                          case TypeCode.Int64: return (UInt16)a - (Int64)b;                          case TypeCode.UInt64: return (UInt16)a - (UInt64)b;                          case TypeCode.Single: return (UInt16)a - (Single)b;                          case TypeCode.Double: return (UInt16)a - (Double)b;                          case TypeCode.Decimal: return (UInt16)a - (Decimal)b;                      }                      break;                    case TypeCode.Int32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a - (SByte)b;                          case TypeCode.Int16: return (Int32)a - (Int16)b;                          case TypeCode.UInt16: return (Int32)a - (UInt16)b;                          case TypeCode.Int32: return (Int32)a - (Int32)b;                          case TypeCode.UInt32: return (Int32)a - (UInt32)b;                          case TypeCode.Int64: return (Int32)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a - (Single)b;                          case TypeCode.Double: return (Int32)a - (Double)b;                          case TypeCode.Decimal: return (Int32)a - (Decimal)b;                      }                      break;                    case TypeCode.UInt32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a - (SByte)b;                          case TypeCode.Int16: return (UInt32)a - (Int16)b;                          case TypeCode.UInt16: return (UInt32)a - (UInt16)b;                          case TypeCode.Int32: return (UInt32)a - (Int32)b;                          case TypeCode.UInt32: return (UInt32)a - (UInt32)b;                          case TypeCode.Int64: return (UInt32)a - (Int64)b;                          case TypeCode.UInt64: return (UInt32)a - (UInt64)b;                          case TypeCode.Single: return (UInt32)a - (Single)b;                          case TypeCode.Double: return (UInt32)a - (Double)b;                          case TypeCode.Decimal: return (UInt32)a - (Decimal)b;                      }                      break;                    case TypeCode.Int64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a - (SByte)b;                          case TypeCode.Int16: return (Int64)a - (Int16)b;                          case TypeCode.UInt16: return (Int64)a - (UInt16)b;                          case TypeCode.Int32: return (Int64)a - (Int32)b;                          case TypeCode.UInt32: return (Int64)a - (UInt32)b;                          case TypeCode.Int64: return (Int64)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a - (Single)b;                          case TypeCode.Double: return (Int64)a - (Double)b;                          case TypeCode.Decimal: return (Int64)a - (Decimal)b;                      }                      break;                    case TypeCode.UInt64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'double'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a - (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a - (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a - (UInt64)b;                          case TypeCode.Single: return (UInt64)a - (Single)b;                          case TypeCode.Double: return (UInt64)a - (Double)b;                          case TypeCode.Decimal: return (UInt64)a - (Decimal)b;                      }                      break;                    case TypeCode.Single:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a - (SByte)b;                          case TypeCode.Int16: return (Single)a - (Int16)b;                          case TypeCode.UInt16: return (Single)a - (UInt16)b;                          case TypeCode.Int32: return (Single)a - (Int32)b;                          case TypeCode.UInt32: return (Single)a - (UInt32)b;                          case TypeCode.Int64: return (Single)a - (Int64)b;                          case TypeCode.UInt64: return (Single)a - (UInt64)b;                          case TypeCode.Single: return (Single)a - (Single)b;                          case TypeCode.Double: return (Single)a - (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'float' and 'decimal'");                      }                      break;                    case TypeCode.Double:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a - (SByte)b;                          case TypeCode.Int16: return (Double)a - (Int16)b;                          case TypeCode.UInt16: return (Double)a - (UInt16)b;                          case TypeCode.Int32: return (Double)a - (Int32)b;                          case TypeCode.UInt32: return (Double)a - (UInt32)b;                          case TypeCode.Int64: return (Double)a - (Int64)b;                          case TypeCode.UInt64: return (Double)a - (UInt64)b;                          case TypeCode.Single: return (Double)a - (Single)b;                          case TypeCode.Double: return (Double)a - (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'double' and 'decimal'");                      }                      break;                    case TypeCode.Decimal:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a - (SByte)b;                          case TypeCode.Int16: return (Decimal)a - (Int16)b;                          case TypeCode.UInt16: return (Decimal)a - (UInt16)b;                          case TypeCode.Int32: return (Decimal)a - (Int32)b;                          case TypeCode.UInt32: return (Decimal)a - (UInt32)b;                          case TypeCode.Int64: return (Decimal)a - (Int64)b;                          case TypeCode.UInt64: return (Decimal)a - (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a - (Decimal)b;                      }                      break;              }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'bool'");                          case TypeCode.Byte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Int64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Single: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'bool' and 'byte'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a - (SByte)b;                          case TypeCode.Int16: return (Byte)a - (Int16)b;                          case TypeCode.UInt16: return (Byte)a - (UInt16)b;                          case TypeCode.Int32: return (Byte)a - (Int32)b;                          case TypeCode.UInt32: return (Byte)a - (UInt32)b;                          case TypeCode.Int64: return (Byte)a - (Int64)b;                          case TypeCode.UInt64: return (Byte)a - (UInt64)b;                          case TypeCode.Single: return (Byte)a - (Single)b;                          case TypeCode.Double: return (Byte)a - (Double)b;                          case TypeCode.Decimal: return (Byte)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a - (SByte)b;                          case TypeCode.Int16: return (SByte)a - (Int16)b;                          case TypeCode.UInt16: return (SByte)a - (UInt16)b;                          case TypeCode.Int32: return (SByte)a - (Int32)b;                          case TypeCode.UInt32: return (SByte)a - (UInt32)b;                          case TypeCode.Int64: return (SByte)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a - (Single)b;                          case TypeCode.Double: return (SByte)a - (Double)b;                          case TypeCode.Decimal: return (SByte)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a - (SByte)b;                          case TypeCode.Int16: return (Int16)a - (Int16)b;                          case TypeCode.UInt16: return (Int16)a - (UInt16)b;                          case TypeCode.Int32: return (Int16)a - (Int32)b;                          case TypeCode.UInt32: return (Int16)a - (UInt32)b;                          case TypeCode.Int64: return (Int16)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a - (Single)b;                          case TypeCode.Double: return (Int16)a - (Double)b;                          case TypeCode.Decimal: return (Int16)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a - (SByte)b;                          case TypeCode.Int16: return (UInt16)a - (Int16)b;                          case TypeCode.UInt16: return (UInt16)a - (UInt16)b;                          case TypeCode.Int32: return (UInt16)a - (Int32)b;                          case TypeCode.UInt32: return (UInt16)a - (UInt32)b;                          case TypeCode.Int64: return (UInt16)a - (Int64)b;                          case TypeCode.UInt64: return (UInt16)a - (UInt64)b;                          case TypeCode.Single: return (UInt16)a - (Single)b;                          case TypeCode.Double: return (UInt16)a - (Double)b;                          case TypeCode.Decimal: return (UInt16)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a - (SByte)b;                          case TypeCode.Int16: return (Int32)a - (Int16)b;                          case TypeCode.UInt16: return (Int32)a - (UInt16)b;                          case TypeCode.Int32: return (Int32)a - (Int32)b;                          case TypeCode.UInt32: return (Int32)a - (UInt32)b;                          case TypeCode.Int64: return (Int32)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a - (Single)b;                          case TypeCode.Double: return (Int32)a - (Double)b;                          case TypeCode.Decimal: return (Int32)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a - (SByte)b;                          case TypeCode.Int16: return (UInt32)a - (Int16)b;                          case TypeCode.UInt16: return (UInt32)a - (UInt16)b;                          case TypeCode.Int32: return (UInt32)a - (Int32)b;                          case TypeCode.UInt32: return (UInt32)a - (UInt32)b;                          case TypeCode.Int64: return (UInt32)a - (Int64)b;                          case TypeCode.UInt64: return (UInt32)a - (UInt64)b;                          case TypeCode.Single: return (UInt32)a - (Single)b;                          case TypeCode.Double: return (UInt32)a - (Double)b;                          case TypeCode.Decimal: return (UInt32)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a - (SByte)b;                          case TypeCode.Int16: return (Int64)a - (Int16)b;                          case TypeCode.UInt16: return (Int64)a - (UInt16)b;                          case TypeCode.Int32: return (Int64)a - (Int32)b;                          case TypeCode.UInt32: return (Int64)a - (UInt32)b;                          case TypeCode.Int64: return (Int64)a - (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a - (Single)b;                          case TypeCode.Double: return (Int64)a - (Double)b;                          case TypeCode.Decimal: return (Int64)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'double'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a - (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a - (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a - (UInt64)b;                          case TypeCode.Single: return (UInt64)a - (Single)b;                          case TypeCode.Double: return (UInt64)a - (Double)b;                          case TypeCode.Decimal: return (UInt64)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a - (SByte)b;                          case TypeCode.Int16: return (Single)a - (Int16)b;                          case TypeCode.UInt16: return (Single)a - (UInt16)b;                          case TypeCode.Int32: return (Single)a - (Int32)b;                          case TypeCode.UInt32: return (Single)a - (UInt32)b;                          case TypeCode.Int64: return (Single)a - (Int64)b;                          case TypeCode.UInt64: return (Single)a - (UInt64)b;                          case TypeCode.Single: return (Single)a - (Single)b;                          case TypeCode.Double: return (Single)a - (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'float' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a - (SByte)b;                          case TypeCode.Int16: return (Double)a - (Int16)b;                          case TypeCode.UInt16: return (Double)a - (UInt16)b;                          case TypeCode.Int32: return (Double)a - (Int32)b;                          case TypeCode.UInt32: return (Double)a - (UInt32)b;                          case TypeCode.Int64: return (Double)a - (Int64)b;                          case TypeCode.UInt64: return (Double)a - (UInt64)b;                          case TypeCode.Single: return (Double)a - (Single)b;                          case TypeCode.Double: return (Double)a - (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'double' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a - (SByte)b;                          case TypeCode.Int16: return (Decimal)a - (Int16)b;                          case TypeCode.UInt16: return (Decimal)a - (UInt16)b;                          case TypeCode.Int32: return (Decimal)a - (Int32)b;                          case TypeCode.UInt32: return (Decimal)a - (UInt32)b;                          case TypeCode.Int64: return (Decimal)a - (Int64)b;                          case TypeCode.UInt64: return (Decimal)a - (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a - (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeA)              {                  case TypeCode.Byte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a * (SByte)b;                          case TypeCode.Int16: return (Byte)a * (Int16)b;                          case TypeCode.UInt16: return (Byte)a * (UInt16)b;                          case TypeCode.Int32: return (Byte)a * (Int32)b;                          case TypeCode.UInt32: return (Byte)a * (UInt32)b;                          case TypeCode.Int64: return (Byte)a * (Int64)b;                          case TypeCode.UInt64: return (Byte)a * (UInt64)b;                          case TypeCode.Single: return (Byte)a * (Single)b;                          case TypeCode.Double: return (Byte)a * (Double)b;                          case TypeCode.Decimal: return (Byte)a * (Decimal)b;                      }                      break;                  case TypeCode.SByte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a * (SByte)b;                          case TypeCode.Int16: return (SByte)a * (Int16)b;                          case TypeCode.UInt16: return (SByte)a * (UInt16)b;                          case TypeCode.Int32: return (SByte)a * (Int32)b;                          case TypeCode.UInt32: return (SByte)a * (UInt32)b;                          case TypeCode.Int64: return (SByte)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a * (Single)b;                          case TypeCode.Double: return (SByte)a * (Double)b;                          case TypeCode.Decimal: return (SByte)a * (Decimal)b;                      }                      break;                    case TypeCode.Int16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a * (SByte)b;                          case TypeCode.Int16: return (Int16)a * (Int16)b;                          case TypeCode.UInt16: return (Int16)a * (UInt16)b;                          case TypeCode.Int32: return (Int16)a * (Int32)b;                          case TypeCode.UInt32: return (Int16)a * (UInt32)b;                          case TypeCode.Int64: return (Int16)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a * (Single)b;                          case TypeCode.Double: return (Int16)a * (Double)b;                          case TypeCode.Decimal: return (Int16)a * (Decimal)b;                      }                      break;                    case TypeCode.UInt16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a * (SByte)b;                          case TypeCode.Int16: return (UInt16)a * (Int16)b;                          case TypeCode.UInt16: return (UInt16)a * (UInt16)b;                          case TypeCode.Int32: return (UInt16)a * (Int32)b;                          case TypeCode.UInt32: return (UInt16)a * (UInt32)b;                          case TypeCode.Int64: return (UInt16)a * (Int64)b;                          case TypeCode.UInt64: return (UInt16)a * (UInt64)b;                          case TypeCode.Single: return (UInt16)a * (Single)b;                          case TypeCode.Double: return (UInt16)a * (Double)b;                          case TypeCode.Decimal: return (UInt16)a * (Decimal)b;                      }                      break;                    case TypeCode.Int32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a * (SByte)b;                          case TypeCode.Int16: return (Int32)a * (Int16)b;                          case TypeCode.UInt16: return (Int32)a * (UInt16)b;                          case TypeCode.Int32: return (Int32)a * (Int32)b;                          case TypeCode.UInt32: return (Int32)a * (UInt32)b;                          case TypeCode.Int64: return (Int32)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a * (Single)b;                          case TypeCode.Double: return (Int32)a * (Double)b;                          case TypeCode.Decimal: return (Int32)a * (Decimal)b;                      }                      break;                    case TypeCode.UInt32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a * (SByte)b;                          case TypeCode.Int16: return (UInt32)a * (Int16)b;                          case TypeCode.UInt16: return (UInt32)a * (UInt16)b;                          case TypeCode.Int32: return (UInt32)a * (Int32)b;                          case TypeCode.UInt32: return (UInt32)a * (UInt32)b;                          case TypeCode.Int64: return (UInt32)a * (Int64)b;                          case TypeCode.UInt64: return (UInt32)a * (UInt64)b;                          case TypeCode.Single: return (UInt32)a * (Single)b;                          case TypeCode.Double: return (UInt32)a * (Double)b;                          case TypeCode.Decimal: return (UInt32)a * (Decimal)b;                      }                      break;                    case TypeCode.Int64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a * (SByte)b;                          case TypeCode.Int16: return (Int64)a * (Int16)b;                          case TypeCode.UInt16: return (Int64)a * (UInt16)b;                          case TypeCode.Int32: return (Int64)a * (Int32)b;                          case TypeCode.UInt32: return (Int64)a * (UInt32)b;                          case TypeCode.Int64: return (Int64)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a * (Single)b;                          case TypeCode.Double: return (Int64)a * (Double)b;                          case TypeCode.Decimal: return (Int64)a * (Decimal)b;                      }                      break;                    case TypeCode.UInt64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a * (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a * (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a * (UInt64)b;                          case TypeCode.Single: return (UInt64)a * (Single)b;                          case TypeCode.Double: return (UInt64)a * (Double)b;                          case TypeCode.Decimal: return (UInt64)a * (Decimal)b;                      }                      break;                    case TypeCode.Single:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a * (SByte)b;                          case TypeCode.Int16: return (Single)a * (Int16)b;                          case TypeCode.UInt16: return (Single)a * (UInt16)b;                          case TypeCode.Int32: return (Single)a * (Int32)b;                          case TypeCode.UInt32: return (Single)a * (UInt32)b;                          case TypeCode.Int64: return (Single)a * (Int64)b;                          case TypeCode.UInt64: return (Single)a * (UInt64)b;                          case TypeCode.Single: return (Single)a * (Single)b;                          case TypeCode.Double: return (Single)a * (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'float' and 'decimal'");                      }                      break;                    case TypeCode.Double:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a * (SByte)b;                          case TypeCode.Int16: return (Double)a * (Int16)b;                          case TypeCode.UInt16: return (Double)a * (UInt16)b;                          case TypeCode.Int32: return (Double)a * (Int32)b;                          case TypeCode.UInt32: return (Double)a * (UInt32)b;                          case TypeCode.Int64: return (Double)a * (Int64)b;                          case TypeCode.UInt64: return (Double)a * (UInt64)b;                          case TypeCode.Single: return (Double)a * (Single)b;                          case TypeCode.Double: return (Double)a * (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'double' and 'decimal'");                      }                      break;                    case TypeCode.Decimal:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a * (SByte)b;                          case TypeCode.Int16: return (Decimal)a * (Int16)b;                          case TypeCode.UInt16: return (Decimal)a * (UInt16)b;                          case TypeCode.Int32: return (Decimal)a * (Int32)b;                          case TypeCode.UInt32: return (Decimal)a * (UInt32)b;                          case TypeCode.Int64: return (Decimal)a * (Int64)b;                          case TypeCode.UInt64: return (Decimal)a * (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a * (Decimal)b;                      }                      break;              }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a * (SByte)b;                          case TypeCode.Int16: return (Byte)a * (Int16)b;                          case TypeCode.UInt16: return (Byte)a * (UInt16)b;                          case TypeCode.Int32: return (Byte)a * (Int32)b;                          case TypeCode.UInt32: return (Byte)a * (UInt32)b;                          case TypeCode.Int64: return (Byte)a * (Int64)b;                          case TypeCode.UInt64: return (Byte)a * (UInt64)b;                          case TypeCode.Single: return (Byte)a * (Single)b;                          case TypeCode.Double: return (Byte)a * (Double)b;                          case TypeCode.Decimal: return (Byte)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a * (SByte)b;                          case TypeCode.Int16: return (SByte)a * (Int16)b;                          case TypeCode.UInt16: return (SByte)a * (UInt16)b;                          case TypeCode.Int32: return (SByte)a * (Int32)b;                          case TypeCode.UInt32: return (SByte)a * (UInt32)b;                          case TypeCode.Int64: return (SByte)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a * (Single)b;                          case TypeCode.Double: return (SByte)a * (Double)b;                          case TypeCode.Decimal: return (SByte)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a * (SByte)b;                          case TypeCode.Int16: return (Int16)a * (Int16)b;                          case TypeCode.UInt16: return (Int16)a * (UInt16)b;                          case TypeCode.Int32: return (Int16)a * (Int32)b;                          case TypeCode.UInt32: return (Int16)a * (UInt32)b;                          case TypeCode.Int64: return (Int16)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a * (Single)b;                          case TypeCode.Double: return (Int16)a * (Double)b;                          case TypeCode.Decimal: return (Int16)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a * (SByte)b;                          case TypeCode.Int16: return (UInt16)a * (Int16)b;                          case TypeCode.UInt16: return (UInt16)a * (UInt16)b;                          case TypeCode.Int32: return (UInt16)a * (Int32)b;                          case TypeCode.UInt32: return (UInt16)a * (UInt32)b;                          case TypeCode.Int64: return (UInt16)a * (Int64)b;                          case TypeCode.UInt64: return (UInt16)a * (UInt64)b;                          case TypeCode.Single: return (UInt16)a * (Single)b;                          case TypeCode.Double: return (UInt16)a * (Double)b;                          case TypeCode.Decimal: return (UInt16)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a * (SByte)b;                          case TypeCode.Int16: return (Int32)a * (Int16)b;                          case TypeCode.UInt16: return (Int32)a * (UInt16)b;                          case TypeCode.Int32: return (Int32)a * (Int32)b;                          case TypeCode.UInt32: return (Int32)a * (UInt32)b;                          case TypeCode.Int64: return (Int32)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a * (Single)b;                          case TypeCode.Double: return (Int32)a * (Double)b;                          case TypeCode.Decimal: return (Int32)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a * (SByte)b;                          case TypeCode.Int16: return (UInt32)a * (Int16)b;                          case TypeCode.UInt16: return (UInt32)a * (UInt16)b;                          case TypeCode.Int32: return (UInt32)a * (Int32)b;                          case TypeCode.UInt32: return (UInt32)a * (UInt32)b;                          case TypeCode.Int64: return (UInt32)a * (Int64)b;                          case TypeCode.UInt64: return (UInt32)a * (UInt64)b;                          case TypeCode.Single: return (UInt32)a * (Single)b;                          case TypeCode.Double: return (UInt32)a * (Double)b;                          case TypeCode.Decimal: return (UInt32)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a * (SByte)b;                          case TypeCode.Int16: return (Int64)a * (Int16)b;                          case TypeCode.UInt16: return (Int64)a * (UInt16)b;                          case TypeCode.Int32: return (Int64)a * (Int32)b;                          case TypeCode.UInt32: return (Int64)a * (UInt32)b;                          case TypeCode.Int64: return (Int64)a * (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a * (Single)b;                          case TypeCode.Double: return (Int64)a * (Double)b;                          case TypeCode.Decimal: return (Int64)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a * (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a * (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a * (UInt64)b;                          case TypeCode.Single: return (UInt64)a * (Single)b;                          case TypeCode.Double: return (UInt64)a * (Double)b;                          case TypeCode.Decimal: return (UInt64)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a * (SByte)b;                          case TypeCode.Int16: return (Single)a * (Int16)b;                          case TypeCode.UInt16: return (Single)a * (UInt16)b;                          case TypeCode.Int32: return (Single)a * (Int32)b;                          case TypeCode.UInt32: return (Single)a * (UInt32)b;                          case TypeCode.Int64: return (Single)a * (Int64)b;                          case TypeCode.UInt64: return (Single)a * (UInt64)b;                          case TypeCode.Single: return (Single)a * (Single)b;                          case TypeCode.Double: return (Single)a * (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'float' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a * (SByte)b;                          case TypeCode.Int16: return (Double)a * (Int16)b;                          case TypeCode.UInt16: return (Double)a * (UInt16)b;                          case TypeCode.Int32: return (Double)a * (Int32)b;                          case TypeCode.UInt32: return (Double)a * (UInt32)b;                          case TypeCode.Int64: return (Double)a * (Int64)b;                          case TypeCode.UInt64: return (Double)a * (UInt64)b;                          case TypeCode.Single: return (Double)a * (Single)b;                          case TypeCode.Double: return (Double)a * (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'double' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a * (SByte)b;                          case TypeCode.Int16: return (Decimal)a * (Int16)b;                          case TypeCode.UInt16: return (Decimal)a * (UInt16)b;                          case TypeCode.Int32: return (Decimal)a * (Int32)b;                          case TypeCode.UInt32: return (Decimal)a * (UInt32)b;                          case TypeCode.Int64: return (Decimal)a * (Int64)b;                          case TypeCode.UInt64: return (Decimal)a * (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '*' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a * (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeA)              {                  case TypeCode.Byte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a / (SByte)b;                          case TypeCode.Int16: return (Byte)a / (Int16)b;                          case TypeCode.UInt16: return (Byte)a / (UInt16)b;                          case TypeCode.Int32: return (Byte)a / (Int32)b;                          case TypeCode.UInt32: return (Byte)a / (UInt32)b;                          case TypeCode.Int64: return (Byte)a / (Int64)b;                          case TypeCode.UInt64: return (Byte)a / (UInt64)b;                          case TypeCode.Single: return (Byte)a / (Single)b;                          case TypeCode.Double: return (Byte)a / (Double)b;                          case TypeCode.Decimal: return (Byte)a / (Decimal)b;                      }                      break;                  case TypeCode.SByte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a / (SByte)b;                          case TypeCode.Int16: return (SByte)a / (Int16)b;                          case TypeCode.UInt16: return (SByte)a / (UInt16)b;                          case TypeCode.Int32: return (SByte)a / (Int32)b;                          case TypeCode.UInt32: return (SByte)a / (UInt32)b;                          case TypeCode.Int64: return (SByte)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a / (Single)b;                          case TypeCode.Double: return (SByte)a / (Double)b;                          case TypeCode.Decimal: return (SByte)a / (Decimal)b;                      }                      break;                    case TypeCode.Int16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a / (SByte)b;                          case TypeCode.Int16: return (Int16)a / (Int16)b;                          case TypeCode.UInt16: return (Int16)a / (UInt16)b;                          case TypeCode.Int32: return (Int16)a / (Int32)b;                          case TypeCode.UInt32: return (Int16)a / (UInt32)b;                          case TypeCode.Int64: return (Int16)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a / (Single)b;                          case TypeCode.Double: return (Int16)a / (Double)b;                          case TypeCode.Decimal: return (Int16)a / (Decimal)b;                      }                      break;                    case TypeCode.UInt16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a / (SByte)b;                          case TypeCode.Int16: return (UInt16)a / (Int16)b;                          case TypeCode.UInt16: return (UInt16)a / (UInt16)b;                          case TypeCode.Int32: return (UInt16)a / (Int32)b;                          case TypeCode.UInt32: return (UInt16)a / (UInt32)b;                          case TypeCode.Int64: return (UInt16)a / (Int64)b;                          case TypeCode.UInt64: return (UInt16)a / (UInt64)b;                          case TypeCode.Single: return (UInt16)a / (Single)b;                          case TypeCode.Double: return (UInt16)a / (Double)b;                          case TypeCode.Decimal: return (UInt16)a / (Decimal)b;                      }                      break;                    case TypeCode.Int32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a / (SByte)b;                          case TypeCode.Int16: return (Int32)a / (Int16)b;                          case TypeCode.UInt16: return (Int32)a / (UInt16)b;                          case TypeCode.Int32: return (Int32)a / (Int32)b;                          case TypeCode.UInt32: return (Int32)a / (UInt32)b;                          case TypeCode.Int64: return (Int32)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a / (Single)b;                          case TypeCode.Double: return (Int32)a / (Double)b;                          case TypeCode.Decimal: return (Int32)a / (Decimal)b;                      }                      break;                    case TypeCode.UInt32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a / (SByte)b;                          case TypeCode.Int16: return (UInt32)a / (Int16)b;                          case TypeCode.UInt16: return (UInt32)a / (UInt16)b;                          case TypeCode.Int32: return (UInt32)a / (Int32)b;                          case TypeCode.UInt32: return (UInt32)a / (UInt32)b;                          case TypeCode.Int64: return (UInt32)a / (Int64)b;                          case TypeCode.UInt64: return (UInt32)a / (UInt64)b;                          case TypeCode.Single: return (UInt32)a / (Single)b;                          case TypeCode.Double: return (UInt32)a / (Double)b;                          case TypeCode.Decimal: return (UInt32)a / (Decimal)b;                      }                      break;                    case TypeCode.Int64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a / (SByte)b;                          case TypeCode.Int16: return (Int64)a / (Int16)b;                          case TypeCode.UInt16: return (Int64)a / (UInt16)b;                          case TypeCode.Int32: return (Int64)a / (Int32)b;                          case TypeCode.UInt32: return (Int64)a / (UInt32)b;                          case TypeCode.Int64: return (Int64)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a / (Single)b;                          case TypeCode.Double: return (Int64)a / (Double)b;                          case TypeCode.Decimal: return (Int64)a / (Decimal)b;                      }                      break;                    case TypeCode.UInt64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a / (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a / (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a / (UInt64)b;                          case TypeCode.Single: return (UInt64)a / (Single)b;                          case TypeCode.Double: return (UInt64)a / (Double)b;                          case TypeCode.Decimal: return (UInt64)a / (Decimal)b;                      }                      break;                    case TypeCode.Single:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a / (SByte)b;                          case TypeCode.Int16: return (Single)a / (Int16)b;                          case TypeCode.UInt16: return (Single)a / (UInt16)b;                          case TypeCode.Int32: return (Single)a / (Int32)b;                          case TypeCode.UInt32: return (Single)a / (UInt32)b;                          case TypeCode.Int64: return (Single)a / (Int64)b;                          case TypeCode.UInt64: return (Single)a / (UInt64)b;                          case TypeCode.Single: return (Single)a / (Single)b;                          case TypeCode.Double: return (Single)a / (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'float' and 'decimal'");                      }                      break;                    case TypeCode.Double:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a / (SByte)b;                          case TypeCode.Int16: return (Double)a / (Int16)b;                          case TypeCode.UInt16: return (Double)a / (UInt16)b;                          case TypeCode.Int32: return (Double)a / (Int32)b;                          case TypeCode.UInt32: return (Double)a / (UInt32)b;                          case TypeCode.Int64: return (Double)a / (Int64)b;                          case TypeCode.UInt64: return (Double)a / (UInt64)b;                          case TypeCode.Single: return (Double)a / (Single)b;                          case TypeCode.Double: return (Double)a / (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'double' and 'decimal'");                      }                      break;                    case TypeCode.Decimal:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a / (SByte)b;                          case TypeCode.Int16: return (Decimal)a / (Int16)b;                          case TypeCode.UInt16: return (Decimal)a / (UInt16)b;                          case TypeCode.Int32: return (Decimal)a / (Int32)b;                          case TypeCode.UInt32: return (Decimal)a / (UInt32)b;                          case TypeCode.Int64: return (Decimal)a / (Int64)b;                          case TypeCode.UInt64: return (Decimal)a / (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a / (Decimal)b;                      }                      break;              }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a / (SByte)b;                          case TypeCode.Int16: return (Byte)a / (Int16)b;                          case TypeCode.UInt16: return (Byte)a / (UInt16)b;                          case TypeCode.Int32: return (Byte)a / (Int32)b;                          case TypeCode.UInt32: return (Byte)a / (UInt32)b;                          case TypeCode.Int64: return (Byte)a / (Int64)b;                          case TypeCode.UInt64: return (Byte)a / (UInt64)b;                          case TypeCode.Single: return (Byte)a / (Single)b;                          case TypeCode.Double: return (Byte)a / (Double)b;                          case TypeCode.Decimal: return (Byte)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a / (SByte)b;                          case TypeCode.Int16: return (SByte)a / (Int16)b;                          case TypeCode.UInt16: return (SByte)a / (UInt16)b;                          case TypeCode.Int32: return (SByte)a / (Int32)b;                          case TypeCode.UInt32: return (SByte)a / (UInt32)b;                          case TypeCode.Int64: return (SByte)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a / (Single)b;                          case TypeCode.Double: return (SByte)a / (Double)b;                          case TypeCode.Decimal: return (SByte)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a / (SByte)b;                          case TypeCode.Int16: return (Int16)a / (Int16)b;                          case TypeCode.UInt16: return (Int16)a / (UInt16)b;                          case TypeCode.Int32: return (Int16)a / (Int32)b;                          case TypeCode.UInt32: return (Int16)a / (UInt32)b;                          case TypeCode.Int64: return (Int16)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a / (Single)b;                          case TypeCode.Double: return (Int16)a / (Double)b;                          case TypeCode.Decimal: return (Int16)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a / (SByte)b;                          case TypeCode.Int16: return (UInt16)a / (Int16)b;                          case TypeCode.UInt16: return (UInt16)a / (UInt16)b;                          case TypeCode.Int32: return (UInt16)a / (Int32)b;                          case TypeCode.UInt32: return (UInt16)a / (UInt32)b;                          case TypeCode.Int64: return (UInt16)a / (Int64)b;                          case TypeCode.UInt64: return (UInt16)a / (UInt64)b;                          case TypeCode.Single: return (UInt16)a / (Single)b;                          case TypeCode.Double: return (UInt16)a / (Double)b;                          case TypeCode.Decimal: return (UInt16)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a / (SByte)b;                          case TypeCode.Int16: return (Int32)a / (Int16)b;                          case TypeCode.UInt16: return (Int32)a / (UInt16)b;                          case TypeCode.Int32: return (Int32)a / (Int32)b;                          case TypeCode.UInt32: return (Int32)a / (UInt32)b;                          case TypeCode.Int64: return (Int32)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a / (Single)b;                          case TypeCode.Double: return (Int32)a / (Double)b;                          case TypeCode.Decimal: return (Int32)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a / (SByte)b;                          case TypeCode.Int16: return (UInt32)a / (Int16)b;                          case TypeCode.UInt16: return (UInt32)a / (UInt16)b;                          case TypeCode.Int32: return (UInt32)a / (Int32)b;                          case TypeCode.UInt32: return (UInt32)a / (UInt32)b;                          case TypeCode.Int64: return (UInt32)a / (Int64)b;                          case TypeCode.UInt64: return (UInt32)a / (UInt64)b;                          case TypeCode.Single: return (UInt32)a / (Single)b;                          case TypeCode.Double: return (UInt32)a / (Double)b;                          case TypeCode.Decimal: return (UInt32)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a / (SByte)b;                          case TypeCode.Int16: return (Int64)a / (Int16)b;                          case TypeCode.UInt16: return (Int64)a / (UInt16)b;                          case TypeCode.Int32: return (Int64)a / (Int32)b;                          case TypeCode.UInt32: return (Int64)a / (UInt32)b;                          case TypeCode.Int64: return (Int64)a / (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a / (Single)b;                          case TypeCode.Double: return (Int64)a / (Double)b;                          case TypeCode.Decimal: return (Int64)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a / (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a / (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a / (UInt64)b;                          case TypeCode.Single: return (UInt64)a / (Single)b;                          case TypeCode.Double: return (UInt64)a / (Double)b;                          case TypeCode.Decimal: return (UInt64)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a / (SByte)b;                          case TypeCode.Int16: return (Single)a / (Int16)b;                          case TypeCode.UInt16: return (Single)a / (UInt16)b;                          case TypeCode.Int32: return (Single)a / (Int32)b;                          case TypeCode.UInt32: return (Single)a / (UInt32)b;                          case TypeCode.Int64: return (Single)a / (Int64)b;                          case TypeCode.UInt64: return (Single)a / (UInt64)b;                          case TypeCode.Single: return (Single)a / (Single)b;                          case TypeCode.Double: return (Single)a / (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'float' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a / (SByte)b;                          case TypeCode.Int16: return (Double)a / (Int16)b;                          case TypeCode.UInt16: return (Double)a / (UInt16)b;                          case TypeCode.Int32: return (Double)a / (Int32)b;                          case TypeCode.UInt32: return (Double)a / (UInt32)b;                          case TypeCode.Int64: return (Double)a / (Int64)b;                          case TypeCode.UInt64: return (Double)a / (UInt64)b;                          case TypeCode.Single: return (Double)a / (Single)b;                          case TypeCode.Double: return (Double)a / (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'double' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a / (SByte)b;                          case TypeCode.Int16: return (Decimal)a / (Int16)b;                          case TypeCode.UInt16: return (Decimal)a / (UInt16)b;                          case TypeCode.Int32: return (Decimal)a / (Int32)b;                          case TypeCode.UInt32: return (Decimal)a / (UInt32)b;                          case TypeCode.Int64: return (Decimal)a / (Int64)b;                          case TypeCode.UInt64: return (Decimal)a / (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '/' can't be applied to operands of types 'decimal' and 'double'");                          case TypeCode.Decimal: return (Decimal)a / (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeA)              {                  case TypeCode.Byte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a % (SByte)b;                          case TypeCode.Int16: return (Byte)a % (Int16)b;                          case TypeCode.UInt16: return (Byte)a % (UInt16)b;                          case TypeCode.Int32: return (Byte)a % (Int32)b;                          case TypeCode.UInt32: return (Byte)a % (UInt32)b;                          case TypeCode.Int64: return (Byte)a % (Int64)b;                          case TypeCode.UInt64: return (Byte)a % (UInt64)b;                          case TypeCode.Single: return (Byte)a % (Single)b;                          case TypeCode.Double: return (Byte)a % (Double)b;                          case TypeCode.Decimal: return (Byte)a % (Decimal)b;                      }                      break;                  case TypeCode.SByte:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a % (SByte)b;                          case TypeCode.Int16: return (SByte)a % (Int16)b;                          case TypeCode.UInt16: return (SByte)a % (UInt16)b;                          case TypeCode.Int32: return (SByte)a % (Int32)b;                          case TypeCode.UInt32: return (SByte)a % (UInt32)b;                          case TypeCode.Int64: return (SByte)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a % (Single)b;                          case TypeCode.Double: return (SByte)a % (Double)b;                          case TypeCode.Decimal: return (SByte)a % (Decimal)b;                      }                      break;                    case TypeCode.Int16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a % (SByte)b;                          case TypeCode.Int16: return (Int16)a % (Int16)b;                          case TypeCode.UInt16: return (Int16)a % (UInt16)b;                          case TypeCode.Int32: return (Int16)a % (Int32)b;                          case TypeCode.UInt32: return (Int16)a % (UInt32)b;                          case TypeCode.Int64: return (Int16)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a % (Single)b;                          case TypeCode.Double: return (Int16)a % (Double)b;                          case TypeCode.Decimal: return (Int16)a % (Decimal)b;                      }                      break;                    case TypeCode.UInt16:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a % (SByte)b;                          case TypeCode.Int16: return (UInt16)a % (Int16)b;                          case TypeCode.UInt16: return (UInt16)a % (UInt16)b;                          case TypeCode.Int32: return (UInt16)a % (Int32)b;                          case TypeCode.UInt32: return (UInt16)a % (UInt32)b;                          case TypeCode.Int64: return (UInt16)a % (Int64)b;                          case TypeCode.UInt64: return (UInt16)a % (UInt64)b;                          case TypeCode.Single: return (UInt16)a % (Single)b;                          case TypeCode.Double: return (UInt16)a % (Double)b;                          case TypeCode.Decimal: return (UInt16)a % (Decimal)b;                      }                      break;                    case TypeCode.Int32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a % (SByte)b;                          case TypeCode.Int16: return (Int32)a % (Int16)b;                          case TypeCode.UInt16: return (Int32)a % (UInt16)b;                          case TypeCode.Int32: return (Int32)a % (Int32)b;                          case TypeCode.UInt32: return (Int32)a % (UInt32)b;                          case TypeCode.Int64: return (Int32)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a % (Single)b;                          case TypeCode.Double: return (Int32)a % (Double)b;                          case TypeCode.Decimal: return (Int32)a % (Decimal)b;                      }                      break;                    case TypeCode.UInt32:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a % (SByte)b;                          case TypeCode.Int16: return (UInt32)a % (Int16)b;                          case TypeCode.UInt16: return (UInt32)a % (UInt16)b;                          case TypeCode.Int32: return (UInt32)a % (Int32)b;                          case TypeCode.UInt32: return (UInt32)a % (UInt32)b;                          case TypeCode.Int64: return (UInt32)a % (Int64)b;                          case TypeCode.UInt64: return (UInt32)a % (UInt64)b;                          case TypeCode.Single: return (UInt32)a % (Single)b;                          case TypeCode.Double: return (UInt32)a % (Double)b;                          case TypeCode.Decimal: return (UInt32)a % (Decimal)b;                      }                      break;                    case TypeCode.Int64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a % (SByte)b;                          case TypeCode.Int16: return (Int64)a % (Int16)b;                          case TypeCode.UInt16: return (Int64)a % (UInt16)b;                          case TypeCode.Int32: return (Int64)a % (Int32)b;                          case TypeCode.UInt32: return (Int64)a % (UInt32)b;                          case TypeCode.Int64: return (Int64)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a % (Single)b;                          case TypeCode.Double: return (Int64)a % (Double)b;                          case TypeCode.Decimal: return (Int64)a % (Decimal)b;                      }                      break;                    case TypeCode.UInt64:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a % (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a % (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a % (UInt64)b;                          case TypeCode.Single: return (UInt64)a % (Single)b;                          case TypeCode.Double: return (UInt64)a % (Double)b;                          case TypeCode.Decimal: return (UInt64)a % (Decimal)b;                      }                      break;                    case TypeCode.Single:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a % (SByte)b;                          case TypeCode.Int16: return (Single)a % (Int16)b;                          case TypeCode.UInt16: return (Single)a % (UInt16)b;                          case TypeCode.Int32: return (Single)a % (Int32)b;                          case TypeCode.UInt32: return (Single)a % (UInt32)b;                          case TypeCode.Int64: return (Single)a % (Int64)b;                          case TypeCode.UInt64: return (Single)a % (UInt64)b;                          case TypeCode.Single: return (Single)a % (Single)b;                          case TypeCode.Double: return (Single)a % (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'float' and 'decimal'");                      }                      break;                    case TypeCode.Double:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a % (SByte)b;                          case TypeCode.Int16: return (Double)a % (Int16)b;                          case TypeCode.UInt16: return (Double)a % (UInt16)b;                          case TypeCode.Int32: return (Double)a % (Int32)b;                          case TypeCode.UInt32: return (Double)a % (UInt32)b;                          case TypeCode.Int64: return (Double)a % (Int64)b;                          case TypeCode.UInt64: return (Double)a % (UInt64)b;                          case TypeCode.Single: return (Double)a % (Single)b;                          case TypeCode.Double: return (Double)a % (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'double' and 'decimal'");                      }                      break;                    case TypeCode.Decimal:                      switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a % (SByte)b;                          case TypeCode.Int16: return (Decimal)a % (Int16)b;                          case TypeCode.UInt16: return (Decimal)a % (UInt16)b;                          case TypeCode.Int32: return (Decimal)a % (Int32)b;                          case TypeCode.UInt32: return (Decimal)a % (UInt32)b;                          case TypeCode.Int64: return (Decimal)a % (Int64)b;                          case TypeCode.UInt64: return (Decimal)a % (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'decimal'");                          case TypeCode.Decimal: return (Decimal)a % (Decimal)b;                      }                      break;              }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'byte' and 'bool'");                          case TypeCode.SByte: return (Byte)a % (SByte)b;                          case TypeCode.Int16: return (Byte)a % (Int16)b;                          case TypeCode.UInt16: return (Byte)a % (UInt16)b;                          case TypeCode.Int32: return (Byte)a % (Int32)b;                          case TypeCode.UInt32: return (Byte)a % (UInt32)b;                          case TypeCode.Int64: return (Byte)a % (Int64)b;                          case TypeCode.UInt64: return (Byte)a % (UInt64)b;                          case TypeCode.Single: return (Byte)a % (Single)b;                          case TypeCode.Double: return (Byte)a % (Double)b;                          case TypeCode.Decimal: return (Byte)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'sbyte' and 'bool'");                          case TypeCode.SByte: return (SByte)a % (SByte)b;                          case TypeCode.Int16: return (SByte)a % (Int16)b;                          case TypeCode.UInt16: return (SByte)a % (UInt16)b;                          case TypeCode.Int32: return (SByte)a % (Int32)b;                          case TypeCode.UInt32: return (SByte)a % (UInt32)b;                          case TypeCode.Int64: return (SByte)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'sbyte' and 'ulong'");                          case TypeCode.Single: return (SByte)a % (Single)b;                          case TypeCode.Double: return (SByte)a % (Double)b;                          case TypeCode.Decimal: return (SByte)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'short' and 'bool'");                          case TypeCode.SByte: return (Int16)a % (SByte)b;                          case TypeCode.Int16: return (Int16)a % (Int16)b;                          case TypeCode.UInt16: return (Int16)a % (UInt16)b;                          case TypeCode.Int32: return (Int16)a % (Int32)b;                          case TypeCode.UInt32: return (Int16)a % (UInt32)b;                          case TypeCode.Int64: return (Int16)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'short' and 'ulong'");                          case TypeCode.Single: return (Int16)a % (Single)b;                          case TypeCode.Double: return (Int16)a % (Double)b;                          case TypeCode.Decimal: return (Int16)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ushort' and 'bool'");                          case TypeCode.SByte: return (UInt16)a % (SByte)b;                          case TypeCode.Int16: return (UInt16)a % (Int16)b;                          case TypeCode.UInt16: return (UInt16)a % (UInt16)b;                          case TypeCode.Int32: return (UInt16)a % (Int32)b;                          case TypeCode.UInt32: return (UInt16)a % (UInt32)b;                          case TypeCode.Int64: return (UInt16)a % (Int64)b;                          case TypeCode.UInt64: return (UInt16)a % (UInt64)b;                          case TypeCode.Single: return (UInt16)a % (Single)b;                          case TypeCode.Double: return (UInt16)a % (Double)b;                          case TypeCode.Decimal: return (UInt16)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'int' and 'bool'");                          case TypeCode.SByte: return (Int32)a % (SByte)b;                          case TypeCode.Int16: return (Int32)a % (Int16)b;                          case TypeCode.UInt16: return (Int32)a % (UInt16)b;                          case TypeCode.Int32: return (Int32)a % (Int32)b;                          case TypeCode.UInt32: return (Int32)a % (UInt32)b;                          case TypeCode.Int64: return (Int32)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'int' and 'ulong'");                          case TypeCode.Single: return (Int32)a % (Single)b;                          case TypeCode.Double: return (Int32)a % (Double)b;                          case TypeCode.Decimal: return (Int32)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'uint' and 'bool'");                          case TypeCode.SByte: return (UInt32)a % (SByte)b;                          case TypeCode.Int16: return (UInt32)a % (Int16)b;                          case TypeCode.UInt16: return (UInt32)a % (UInt16)b;                          case TypeCode.Int32: return (UInt32)a % (Int32)b;                          case TypeCode.UInt32: return (UInt32)a % (UInt32)b;                          case TypeCode.Int64: return (UInt32)a % (Int64)b;                          case TypeCode.UInt64: return (UInt32)a % (UInt64)b;                          case TypeCode.Single: return (UInt32)a % (Single)b;                          case TypeCode.Double: return (UInt32)a % (Double)b;                          case TypeCode.Decimal: return (UInt32)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'long' and 'bool'");                          case TypeCode.SByte: return (Int64)a % (SByte)b;                          case TypeCode.Int16: return (Int64)a % (Int16)b;                          case TypeCode.UInt16: return (Int64)a % (UInt16)b;                          case TypeCode.Int32: return (Int64)a % (Int32)b;                          case TypeCode.UInt32: return (Int64)a % (UInt32)b;                          case TypeCode.Int64: return (Int64)a % (Int64)b;                          case TypeCode.UInt64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'long' and 'ulong'");                          case TypeCode.Single: return (Int64)a % (Single)b;                          case TypeCode.Double: return (Int64)a % (Double)b;                          case TypeCode.Decimal: return (Int64)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'bool'");                          case TypeCode.SByte: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'sbyte'");                          case TypeCode.Int16: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'short'");                          case TypeCode.UInt16: return (UInt64)a % (UInt16)b;                          case TypeCode.Int32: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'int'");                          case TypeCode.UInt32: return (UInt64)a % (UInt32)b;                          case TypeCode.Int64: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'ulong' and 'long'");                          case TypeCode.UInt64: return (UInt64)a % (UInt64)b;                          case TypeCode.Single: return (UInt64)a % (Single)b;                          case TypeCode.Double: return (UInt64)a % (Double)b;                          case TypeCode.Decimal: return (UInt64)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'float' and 'bool'");                          case TypeCode.SByte: return (Single)a % (SByte)b;                          case TypeCode.Int16: return (Single)a % (Int16)b;                          case TypeCode.UInt16: return (Single)a % (UInt16)b;                          case TypeCode.Int32: return (Single)a % (Int32)b;                          case TypeCode.UInt32: return (Single)a % (UInt32)b;                          case TypeCode.Int64: return (Single)a % (Int64)b;                          case TypeCode.UInt64: return (Single)a % (UInt64)b;                          case TypeCode.Single: return (Single)a % (Single)b;                          case TypeCode.Double: return (Single)a % (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'float' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'double' and 'bool'");                          case TypeCode.SByte: return (Double)a % (SByte)b;                          case TypeCode.Int16: return (Double)a % (Int16)b;                          case TypeCode.UInt16: return (Double)a % (UInt16)b;                          case TypeCode.Int32: return (Double)a % (Int32)b;                          case TypeCode.UInt32: return (Double)a % (UInt32)b;                          case TypeCode.Int64: return (Double)a % (Int64)b;                          case TypeCode.UInt64: return (Double)a % (UInt64)b;                          case TypeCode.Single: return (Double)a % (Single)b;                          case TypeCode.Double: return (Double)a % (Double)b;                          case TypeCode.Decimal: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'double' and 'decimal'");                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB)                      {                          case TypeCode.Boolean: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'bool'");                          case TypeCode.SByte: return (Decimal)a % (SByte)b;                          case TypeCode.Int16: return (Decimal)a % (Int16)b;                          case TypeCode.UInt16: return (Decimal)a % (UInt16)b;                          case TypeCode.Int32: return (Decimal)a % (Int32)b;                          case TypeCode.UInt32: return (Decimal)a % (UInt32)b;                          case TypeCode.Int64: return (Decimal)a % (Int64)b;                          case TypeCode.UInt64: return (Decimal)a % (UInt64)b;                          case TypeCode.Single: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'float'");                          case TypeCode.Double: throw new InvalidOperationException("Operator '%' can't be applied to operands of types 'decimal' and 'decimal'");                          case TypeCode.Decimal: return (Decimal)a % (Decimal)b;                      }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Max,The following switch statement is missing a default case: switch (typeCodeA)              {                  case TypeCode.Byte:                      return Math.Max((Byte)a' Convert.ToByte(b));                  case TypeCode.SByte:                      return Math.Max((SByte)a' Convert.ToSByte(b));                  case TypeCode.Int16:                      return Math.Max((Int16)a' Convert.ToInt16(b));                  case TypeCode.UInt16:                      return Math.Max((UInt16)a' Convert.ToUInt16(b));                  case TypeCode.Int32:                      return Math.Max((Int32)a' Convert.ToInt32(b));                  case TypeCode.UInt32:                      return Math.Max((UInt32)a' Convert.ToUInt32(b));                  case TypeCode.Int64:                      return Math.Max((Int64)a' Convert.ToInt64(b));                  case TypeCode.UInt64:                      return Math.Max((UInt64)a' Convert.ToUInt64(b));                  case TypeCode.Single:                      return Math.Max((Single)a' Convert.ToSingle(b));                  case TypeCode.Double:                      return Math.Max((Double)a' Convert.ToDouble(b));                  case TypeCode.Decimal:                      return Math.Max((Decimal)a' Convert.ToDecimal(b));              }
Missing Default,NCalc,Numbers,C:\repos\cliftonm_HOPE\lib\ExpressionEvaluator\Numbers.cs,Min,The following switch statement is missing a default case: switch (typeCodeA)              {                  case TypeCode.Byte:                      return Math.Min((Byte)a' Convert.ToByte(b));                  case TypeCode.SByte:                      return Math.Min((SByte)a' Convert.ToSByte(b));                  case TypeCode.Int16:                      return Math.Min((Int16)a' Convert.ToInt16(b));                  case TypeCode.UInt16:                      return Math.Min((UInt16)a' Convert.ToUInt16(b));                  case TypeCode.Int32:                      return Math.Min((Int32)a' Convert.ToInt32(b));                  case TypeCode.UInt32:                      return Math.Min((UInt32)a' Convert.ToUInt32(b));                  case TypeCode.Int64:                      return Math.Min((Int64)a' Convert.ToInt64(b));                  case TypeCode.UInt64:                      return Math.Min((UInt64)a' Convert.ToUInt64(b));                  case TypeCode.Single:                      return Math.Min((Single)a' Convert.ToSingle(b));                  case TypeCode.Double:                      return Math.Min((Double)a' Convert.ToDouble(b));                  case TypeCode.Decimal:                      return Math.Min((Decimal)a' Convert.ToDecimal(b));              }
