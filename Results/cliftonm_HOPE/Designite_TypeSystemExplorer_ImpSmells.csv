Implementation smell,Namespace,Class,File,Method,Description
Long Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The method has 101 lines of code.
Long Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The method has 101 lines of code.
Long Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The method has 143 lines of code.
Long Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The method has 549 lines of code.
Complex Method,TypeSystemExplorer.Controllers,VisualizerController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\VisualizerController.cs,DragDropEvent,Cyclomatic complexity of the method is 10
Complex Method,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,Cyclomatic complexity of the method is 8
Complex Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,Cyclomatic complexity of the method is 8
Complex Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,Cyclomatic complexity of the method is 9
Complex Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseMoveEvent,Cyclomatic complexity of the method is 9
Complex Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDoubleClickEvent,Cyclomatic complexity of the method is 8
Complex Method,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,Cyclomatic complexity of the method is 14
Long Parameter List,TypeSystemExplorer.Views,DrawTextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The method has 5 parameters. Parameters: e' start' end' text' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 6 parameters. Parameters: graphics' s' font' brush' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 8 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 6 parameters. Parameters: graphics' s' font' brush' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 8 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 9 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 9 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The method has 10 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' rotateDegree' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The method has 10 parameters. Parameters: graphics' s' font' brush' textPathAlign' textPathPosition' letterSpace' rotateDegree' graphicsPath' vOffset
Long Parameter List,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The method has 7 parameters. Parameters: pathdata' text' font' color' fillcolor' letterspacepercentage' vOffset
Long Parameter List,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The method has 7 parameters. Parameters: r' m1' prot1' permeableProtocol' rPoint' source' rootOnly
Long Statement,TypeSystemExplorer.Actions,InitializeMruMenu,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Actions\InitializeMruMenu.cs,EndInit,The length of the statement  "			mruMenu = new MruStripMenuInline(MenuFile' MenuRecentFiles' new MruStripMenu.ClickedHandler(OnMruFile)' mruRegKey + "\\MRU"' true' 9); " is 134.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => View.Location = new Point(state.Single(t => t.Key == "X").Value.to_i()' state.Single(t => t.Key == "Y").Value.to_i())); " is 142.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => View.Size = new Size(state.Single(t => t.Key == "W").Value.to_i()' state.Single(t => t.Key == "H").Value.to_i())); " is 137.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => appletUiContainerForm.Location = new Point(state.Single(t => t.Key == "UIX").Value.to_i()' state.Single(t => t.Key == "UIY").Value.to_i())); " is 163.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => appletUiContainerForm.Size = new Size(state.Single(t => t.Key == "UIW").Value.to_i()' state.Single(t => t.Key == "UIH").Value.to_i())); " is 158.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,RegisterUserStateOperations,The length of the statement  "					Assert.SilentTry(() => appletUiContainerForm.WindowState = state.Single(t => t.Key == "UIWindowState").Value.ToEnum<FormWindowState>()); " is 136.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,AddAppletUI,The length of the statement  "//				GenericDocument gd = AppletUiContainerView.DockPanel.Documents.Cast<GenericDocument>().SingleOrDefault(d => d.ContentMetadata == strLayoutId); " is 148.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,AddAppletUI,The length of the statement  "				// GenericPane gp = AppletUiContainerView.DockPanel.Panes.Cast<GenericPane>().SingleOrDefault(p => p.ContentMetadata == strLayoutId); " is 133.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,CreateTypes,The length of the statement  "							sts.NativeTypes.Add(new Clifton.SemanticTypeSystem.NativeType() { Name = nt.Name' ImplementingType = nt.ImplementingType' Alias = nt.Alias' Ordinality = nt.Ordinality' UniqueField = nt.UniqueField }); " is 200.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,CreateTypes,The length of the statement  "							sts.SemanticElements.Add(new Clifton.SemanticTypeSystem.SemanticElement() { Name = subt.Name' Alias = subt.Alias' UniqueField = subt.UniqueField' Ordinality = subt.Ordinality }); " is 178.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SaveReceptorsInternal,The length of the statement  "			AddAttribute(appletNode' "SurfaceOffset"' visualizerController.View.SurfaceOffset.X + "'" + visualizerController.View.SurfaceOffset.Y); " is 135.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "				XmlNode rpNodes = rNode.OwnerDocument.CreateElement("ixm"' "ReceiveProtocols"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 128.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "						XmlNode rpNode = rNode.OwnerDocument.CreateElement("ixm"' "ReceiveProtocol"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 126.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "				XmlNode epNodes = rNode.OwnerDocument.CreateElement("ixm"' "EmitProtocols"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 125.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorProtocolStates,The length of the statement  "					XmlNode epNode = rNode.OwnerDocument.CreateElement("ixm"' "EmitProtocol"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 123.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,SerializeReceptorUserConfigurableProperties,The length of the statement  "								XmlNode uiNode = uiConfigs.OwnerDocument.CreateElement("ixm"' "UserConfig"' "TypeSystemExplorer.Models' TypeSystemExplorer"); " is 125.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,LoadAppletInternal,The length of the statement  "			VisualizerController.View.ShowMembranes = false;		// don't show membranes while we're loading the applet.  Causes problems because the model isn't fully loaded! " is 160.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							// Kludgy' but we need to cache the emit protocol enable states for receptors that dynamically register emit protocols based on user configuration or other info. " is 161.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							rec.Instance.GetEmittedProtocols().SingleOrDefault(p => p.Protocol == ep.Protocol).IfNotNull(p => p.Enabled = ep.Enabled); " is 122.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							// Kludgy' but we need to cache the receive protocol enable states for receptors that dynamically register receive protocols based on user configuration or other info. " is 167.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "							rec.Instance.GetReceiveProtocols().SingleOrDefault(p => p.Protocol == rp.Protocol).IfNotNull(p => p.Enabled = rp.Enabled); " is 122.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "								// TODO: A property name is now invalid.  Is this because the name was changed intentionally or because of an actual fault? " is 123.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,DeserializeMembranes,The length of the statement  "					membrane.ProtocolPermeability[new PermeabilityKey() { Protocol = p.Protocol' Direction = p.Direction }] = new PermeabilityConfiguration() { Permeable = p.Permeable' RootOnly = p.RootOnly }; " is 189.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,LogException,The length of the statement  "			MessageBox.Show(ex.Message + "\r\n" + Assert.ErrorMessage + "\r\n" + ex.StackTrace' "An error has occurred."' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 154.
Long Statement,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,GetReceiveProtocols,The length of the statement  "			(new string[] { "SystemMessage"' "CarrierAnimation"' "SystemShowImage"' "HaveImageMetadata" }).ForEach(p => ret.Add(new ReceiveQualifier(p))); " is 142.
Long Statement,TypeSystemExplorer.Controllers,PropertyGridController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\PropertyGridController.cs,OnPropertyValueChanged,The length of the statement  "			// Annoyingly' the property grid change notifier doesn't give us the property name' it gives us the display name for the property being changed. " is 144.
Long Statement,TypeSystemExplorer.Controllers,PropertyGridController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\PropertyGridController.cs,OnPropertyValueChanged,The length of the statement  "			// TODO: We might be better off trying to figure out how to wire up an event for the Name property when instances are created. " is 126.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The length of the statement  "				ApplicationController.VisualizerController.View.ClientDropPoint = ApplicationController.VisualizerController.View.NegativeSurfaceOffsetAdjust(new Point(x' 100)); " is 161.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,InitializeReceptorEntriesList,The length of the statement  "			receptors.Add(new ReceptorEntry() { Name = "Carrier List Viewer"' Filename = "CarrierListViewerReceptor.dll" });		// TODO: "Carrier" or "Signal" ?  What's the difference ? " is 171.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,InitializeReceptorEntriesList,The length of the statement  "			receptors.Add(new ReceptorEntry() { Name = "Carrier Tree Viewer"' Filename = "CarrierTreeViewerReceptor.dll" });		// TODO: "Carrier" or "Signal" ?  What's the difference ? " is 171.
Long Statement,TypeSystemExplorer.Controllers,ReceptorChooserController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,InitializeReceptorEntriesList,The length of the statement  "			receptors.Add(new ReceptorEntry() { Name = "Tabbed Carrier List Viewer"' Filename = "CarrierTabbedListViewerReceptor.dll" });		// TODO: "Carrier" or "Signal" ?  What's the difference ? " is 184.
Long Statement,TypeSystemExplorer.Controllers,VisualizerController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\VisualizerController.cs,DragDropEvent,The length of the statement  "					else if (fn.ToLower().RightOfRightmostOf('.').ToLower().Contains(new string[] {"jpg"' "png"' "bmp"' "gif"}) != String.Empty) " is 124.
Long Statement,TypeSystemExplorer.Controllers,VisualizerController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\VisualizerController.cs,DragDropEvent,The length of the statement  "						// TODO: We need to figure out how to do computed types' so that I can assign a fully qualified name and set the discrete sub-types Path' Name' and FileExtension. " is 162.
Long Statement,TypeSystemExplorer,ToolWindow,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The length of the statement  "			this.DockAreas = ((WeifenLuo.WinFormsUI.Docking.DockAreas)(((((WeifenLuo.WinFormsUI.Docking.DockAreas.Float | WeifenLuo.WinFormsUI.Docking.DockAreas.DockLeft)  " is 158.
Long Statement,TypeSystemExplorer,ToolWindow,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The length of the statement  "			this.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 149.
Long Statement,TypeSystemExplorer.Models,ImplementingTypeNameConverter,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Models\TypeConverters.cs,GetStandardValues,The length of the statement  "			List<string> names = new List<string>() { "char"' "string"' "bool"' "int"' "long"' "float"' "double"' "decimal"' "DateTime"' "Object"}; " is 135.
Long Statement,TypeSystemExplorer.Views,DrawTextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The length of the statement  "			System.Drawing.RectangleF[] regions = e.Graphics.MeasureString(text' new Font(FontFamily.GenericSansSerif' fontSize' FontStyle.Regular)' new SolidBrush(textColor)' TextPathAlign.Center' TextPathPosition.OverPath' letterSpacing' 0' myPath' vOffset); " is 248.
Long Statement,TypeSystemExplorer.Views,DrawTextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The length of the statement  "			e.Graphics.DrawString(text' new Font(FontFamily.GenericSansSerif' fontSize' FontStyle.Regular)' new SolidBrush(textColor)' TextPathAlign.Center' TextPathPosition.OverPath' letterSpacing' 0' myPath' vOffset); " is 207.
Long Statement,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The length of the statement  "			return MeasureString(graphics' s' font' brush' TextPathAlign.Left' TextPathPosition.CenterPath' 100' graphicsPath' vOffset); " is 124.
Long Statement,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The length of the statement  "					if (gp.PathTypes[i + 1] == (byte)PathPointType.Start | (gp.PathTypes[i] & (byte)PathPointType.CloseSubpath) == (byte)PathPointType.CloseSubpath) " is 144.
Long Statement,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The length of the statement  "					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size - VerticalOffset))' stringFormat); " is 145.
Long Statement,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The length of the statement  "					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size / 2))' stringFormat); " is 132.
Long Statement,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The length of the statement  "					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' y + VerticalOffset)' stringFormat); " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				// Oops.  The carrier animation has been consumed' but there are more receptors for this carrier' so we need to add another carrier animation now. " is 146.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				// Get an existing animation for this carrier.  We don't care what carrier we get' because they're all going to be originating from the same receptor. " is 150.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "					carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = existing.StartPosition' OnArrivalDo = action' Target = to' Carrier = carrier }); " is 147.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "					// We have a carrier that wasn't registered by our event handler' so we have absolutely no clue where it goes.  Place it randomly. " is 130.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "					// carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' OnArrivalDo = action' Target = to' Carrier = carrier }); " is 129.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' OnArrivalDo = action' Target = to' Carrier=carrier }); " is 124.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AnimateCarrier,The length of the statement  "				carrierAnimations.Add(new CarrierAnimationItem() { StartPosition = p' OnArrivalDo = action' Target = to' Carrier = carrier }); " is 126.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,ProcessImageMetadata,The length of the statement  "			// Get the the first carousel key-value pair (Receptor' CarouselState) which contains the image for which we received the metadata. " is 131.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,ProcessImageMetadata,The length of the statement  "			var carousel = carousels.FirstOrDefault(kvp => kvp.Value.Images.Count(imeta => Path.GetFileName(imeta.Image.Tag.ToString().Surrounding("-thumbnail")) == fn) > 0); " is 162.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,ProcessImageMetadata,The length of the statement  "				List<MetadataPacket> packets = carousel.Value.Images.First(m => Path.GetFileName(m.Image.Tag.ToString().Surrounding("-thumbnail")) == fn).MetadataPackets; " is 154.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The length of the statement  "			// TODO: We need to check if any receptors exist and whether any are hidden or not.  If it's hidden' then we don't create a carrier animation instance. " is 151.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnNewCarrier,The length of the statement  "					p.Offset((int)(ReceptorSize.Width * Math.Cos(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3' (int)(ReceptorSize.Height * Math.Sin(Math.PI * 2.0 * orbitCount / OrbitCountMax)) - 3); " is 182.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The length of the statement  "					// Sometimes membranes can contain other membranes where the outer membrane has no receptors' resulting in the nubs being in exactly the same locations. " is 152.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The length of the statement  "					var selectedMembranes = membraneLocation.Where(kvp => PointInCircle(SurfaceOffsetAdjust(kvp.Value.Center)' MembraneNubRadius' testPoint)); " is 138.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y)); " is 197.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				List<IReceptor> receptors = receptorLocation.Where(kvp => parentMembrane.Receptors.Contains(kvp.Key) && testR.Contains(kvp.Value) && !kvp.Key.Instance.IsHidden).Select(kvp => kvp.Key).ToList(); " is 193.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				List<IMembrane> membranes = membraneLocation.Where(kvp => (kvp.Key.ParentMembrane == parentMembrane) && testR.Contains(CircleToBoundingRectangle(kvp.Value.Center' kvp.Value.Radius))).Select(kvp => kvp.Key).ToList(); " is 215.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				// Get receptors inside the rectangle' ignoring any hidden receptors--a defensive measure if we ever decide to show the system receptor. " is 136.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseUpEvent,The length of the statement  "				// List<IReceptor> receptors = receptorLocation.Where(kvp => testR.Contains(kvp.Value) && !kvp.Key.Instance.IsHidden).Select(kvp => kvp.Key).ToList(); " is 150.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseWheelEvent,The length of the statement  "			var hoverReceptors = receptorLocation.Where(kvp => (new Rectangle(Point.Subtract(kvp.Value' ReceptorHalfSize)' ReceptorSize)).Contains(testPoint)); " is 147.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "						Rectangle metaRect = new Rectangle(imgArea.Left' imgArea.Bottom + 10 + (MetadataHeight * idx)' imgArea.Width' MetadataHeight); " is 126.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "									string implementingPropertyName = sts.GetSemanticTypeStruct(meta.ProtocolName).SemanticElements.Single(e => e.Name == meta.PropertyName).GetImplementingName(sts); " is 162.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "									protocol.AllTypes.Single(e => e.Name == implementingPropertyName).SetValue(Program.SemanticTypeSystem' signal' meta.Value); " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The length of the statement  "									sts.GetSemanticTypeStruct(meta.ProtocolName).NativeTypes.Single(st => st.Name == meta.PropertyName).SetValue(Program.SemanticTypeSystem' signal' meta.Value); " is 157.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PopulateControls,The length of the statement  "				foreach (PropertyControlEntry pce in ((PropertyControlMap)mp.ObjectCollection["ControlMap"]).Entries)		// TODO: magic name. " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PopulateControls,The length of the statement  "					PropertyInfo piReceptor = r.Instance.GetType().GetProperty(pce.PropertyName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); " is 147.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PopulateControls,The length of the statement  "					PropertyInfo piControl = control.GetType().GetProperty(pce.ControlPropertyName' BindingFlags.Public | BindingFlags.Instance); " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,SaveValues,The length of the statement  "				foreach (PropertyControlEntry pce in ((PropertyControlMap)mp.ObjectCollection["ControlMap"]).Entries)		// TODO: magic name. " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,SaveValues,The length of the statement  "					PropertyInfo piReceptor = r.GetType().GetProperty(pce.PropertyName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); " is 138.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,SaveValues,The length of the statement  "					PropertyInfo piControl = control.GetType().GetProperty(pce.ControlPropertyName' BindingFlags.Public | BindingFlags.Instance); " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnReceptorConfigOK,The length of the statement  "					MessageBox.Show(ci.Receptor.Instance.ConfigurationError' "Please correct..."' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 122.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "				CarrierAnimationItem item = carrierAnimations.FirstOrDefault(a => a.CurrentRegion.Contains(NegativeSurfaceOffsetAdjust(mousePosition))); " is 136.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					// The property grid is sort of stupid' so we'll put together an anonymous object for displaying the carrier protocol and signal. " is 129.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					// new { Protocol = item.Carrier.Protocol.DeclTypeName' from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new {Name = t.Name' Value = t.GetValue(item.Carrier.Signal)}}; " is 232.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					// var obj = (from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new { Name = t.Name' Value = t.GetValue(item.Carrier.Signal) }).First(); " is 200.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The length of the statement  "					var kvpList = (from t in Program.SemanticTypeSystem.GetSemanticTypeStruct(item.Carrier.Protocol.DeclTypeName).NativeTypes select new { Name = t.Name' Value = t.GetValue(Program.SemanticTypeSystem' item.Carrier.Signal) }); // .ForEach((item) = " is 242.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CreateReceptorConnections,The length of the statement  "			// The "System" receptor can also be the originator of protocols.  Any protocol that the membrane's receptors receive protocols that aren't mapped to emitting receptors should be mapped to system. " is 196.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CreateReceptorConnections,The length of the statement  "			// However' because carriers are dropped into a particular membrane' we can't just assign the global system receptor to a bunch of receiving receptors' as these could be in different membranes. " is 193.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CreateReceptorConnections,The length of the statement  "			// the master receptor connection list is keyed by receptor instances in particular membranes' so this is ok.  The same cannot be said of the global system receptor.  Therefore' we have to " is 188.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "						// var intersection = kvp2.Key.Instance.GetEnabledReceiveProtocols().Select(rp => rp.Protocol).Intersect(r.Instance.GetEnabledEmittedProtocols().Select(ep => ep.Protocol)); " is 172.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								trace.AppendLine("Connecting receiver '" + kvp2.Key.Instance.Name + "' with transmitter '" + r.Instance.Name + "' on root only protocol " + prot1 + " permeable via " + permeableProtocol); " is 187.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								trace.AppendLine("Connecting receiver '" + kvp2.Key.Instance.Name + "' with transmitter '" + r.Instance.Name + "' on protocol " + prot1 + " permeable via " + permeableProtocol); " is 177.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "							// Horrid check for duplicates.  We get duplicates because we scan each receptor (regardless of membrane) and try to find matches. " is 130.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "					trace.AppendLine(level.ToString() + ": Membrane is outbound permeable to " + prot1 + ((rootOnly || pconfig2.RootOnly) ? " root only " : "")); " is 141.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								trace.AppendLine("Testing receptor '" + r.Instance.Name + "' emit protocol " + prot1A.Protocol); // + "' Root only = " + (rootOnly || pconfig2.RootOnly).ToString()); " is 165.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "							trace.AppendLine(level.ToString() + ": Membrane is inbound permeable to " + prot1 + ((rootOnly || pconfig2.RootOnly) ? " root only " : "")); " is 140.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "								// Get the emitted protocols of this receptor and check them all with receive protocols of receptors in the inner membrane. " is 123.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,FindConnectionsWith,The length of the statement  "										trace.AppendLine("Testing receptor '" + r.Instance.Name + "' emit protocol " + prot1A.Protocol);// + "' Root only = " + (rootOnly || pconfig2.RootOnly).ToString()); " is 164.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The length of the statement  "					else if (m.ParentMembrane != null) // Obviously' don't remove the Skin membrane (not that it's in the list at the moment anyways.) " is 130.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle))); " is 146.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						e.Graphics.DrawBezier(pen' SurfaceOffsetAdjust(start)' SurfaceOffsetAdjust(cp1)' SurfaceOffsetAdjust(cp2)' SurfaceOffsetAdjust(line.P2)); " is 137.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2 " is 121.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2 " is 121.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "							// from nearly full width as we go around the arc to where we have the smallest width at the top of the arc' then back again. " is 125.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "							e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 20' ip.Y - 30 * img.Width / img.Height)' new Size(sizeZ' sizeZ * img.Height / img.Width))); " is 148.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100 " is 126.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width))); " is 151.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)); " is 142.
Long Statement,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The length of the statement  "					Rectangle r = Rectangle.FromLTRB(Math.Min(mouseStart.X' mousePosition.X)' Math.Min(mouseStart.Y' mousePosition.Y)' Math.Max(mouseStart.X' mousePosition.X)' Math.Max(mouseStart.Y' mousePosition.Y)); " is 197.
Magic Number,TypeSystemExplorer.Actions,InitializeMruMenu,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Actions\InitializeMruMenu.cs,EndInit,The following statement contains a magic number: mruMenu = new MruStripMenuInline(MenuFile' MenuRecentFiles' new MruStripMenu.ClickedHandler(OnMruFile)' mruRegKey + "\\MRU"' true' 9);
Magic Number,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,FitToScreen,The following statement contains a magic number: Size sz = new Size(SystemInformation.VirtualScreen.Width / 4' SystemInformation.VirtualScreen.Height / 4);
Magic Number,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,FitToScreen,The following statement contains a magic number: Size sz = new Size(SystemInformation.VirtualScreen.Width / 4' SystemInformation.VirtualScreen.Height / 4);
Magic Number,TypeSystemExplorer.Controllers,ReceptorChooserController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The following statement contains a magic number: int x = 100;
Magic Number,TypeSystemExplorer.Controllers,ReceptorChooserController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The following statement contains a magic number: ApplicationController.VisualizerController.View.ClientDropPoint = ApplicationController.VisualizerController.View.NegativeSurfaceOffsetAdjust(new Point(x' 100));
Magic Number,TypeSystemExplorer.Controllers,ReceptorChooserController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ReceptorChooserController.cs,OnAddReceptors,The following statement contains a magic number: x += 80;
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,LabeledTextBox,The following statement contains a magic number: tbData.KeyPress += ((object sender' KeyPressEventArgs args) =>  				{  					if (args.KeyChar == 13)  					{  						OnTextChanged();  					}  				});
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Location = new System.Drawing.Point(5' 3);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Location = new System.Drawing.Point(5' 3);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Size = new System.Drawing.Size(78' 23);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.lblTextBox.Size = new System.Drawing.Size(78' 23);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.tbData.Location = new System.Drawing.Point(89' 0);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.tbData.Size = new System.Drawing.Size(245' 20);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.tbData.Size = new System.Drawing.Size(245' 20);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(337' 20);
Magic Number,TypeSystemExplorer.Controls,LabeledTextBox,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\LabeledTextBox.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(337' 20);
Magic Number,TypeSystemExplorer.Controls,OutputControl,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\OutputControl.cs,InitializeProperties,The following statement contains a magic number: properties.Font = new Font("Consolas"' 8' FontStyle.Regular);
Magic Number,TypeSystemExplorer.Controls,OutputControl,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\OutputControl.cs,InitializeProperties,The following statement contains a magic number: properties.TabIndent = 2;
Magic Number,TypeSystemExplorer.Controls,XmlTextEditorControl,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\XmlTextEditorControl.cs,InitializeProperties,The following statement contains a magic number: properties.Font = new Font("Consolas"' 8' FontStyle.Regular);
Magic Number,TypeSystemExplorer.Controls,XmlTextEditorControl,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controls\XmlTextEditorControl.cs,InitializeProperties,The following statement contains a magic number: properties.TabIndent = 2;
Magic Number,TypeSystemExplorer,ToolWindow,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,TypeSystemExplorer,ToolWindow,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,TypeSystemExplorer,ToolWindow,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 266);
Magic Number,TypeSystemExplorer,ToolWindow,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 266);
Magic Number,TypeSystemExplorer,ToolWindow,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\GenericDockContent\ToolWindow.cs,InitializeComponent,The following statement contains a magic number: this.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0)));
Magic Number,TypeSystemExplorer,MouseWheelMessageFilter,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Program.cs,PreFilterMessage,The following statement contains a magic number: Point pos = new Point(m.LParam.ToInt32() & 0xffff' m.LParam.ToInt32() >> 16);
Magic Number,TypeSystemExplorer.Views,DrawTextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The following statement contains a magic number: int fontSize = 10;
Magic Number,TypeSystemExplorer.Views,DrawTextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,Draw,The following statement contains a magic number: int letterSpacing = 100;
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The following statement contains a magic number: return MeasureString(graphics' s' font' brush' TextPathAlign.Left' TextPathPosition.CenterPath' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The following statement contains a magic number: return MeasureString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The following statement contains a magic number: DrawString(graphics' s' font' brush' TextPathAlign.Left' TextPathPosition.CenterPath' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The following statement contains a magic number: DrawString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,MeasureString,The following statement contains a magic number: return MeasureString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' 0' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,GraphicsExtension,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawString,The following statement contains a magic number: DrawString(graphics' s' font' brush' textPathAlign' textPathPosition' 100' 0' graphicsPath' vOffset);
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The following statement contains a magic number: PointF[] points = new PointF[25001];
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawTextOnPath,The following statement contains a magic number: i <= gp.PathPoints.Length - 2
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: switch (_pathalign)  			{  				case TextPathAlign.Left:  					point1 = points[0];  					count = 0;  					break;  				case TextPathAlign.Center:  					count = (int)((maxPoints - maxWidthText) / 2);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  				case TextPathAlign.Right:  					count = (int)(maxPoints - maxWidthText - (double)StringRegion(g' _text.Length - 1) * LetterSpacePercentage / 100);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: switch (_pathalign)  			{  				case TextPathAlign.Left:  					point1 = points[0];  					count = 0;  					break;  				case TextPathAlign.Center:  					count = (int)((maxPoints - maxWidthText) / 2);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  				case TextPathAlign.Right:  					count = (int)(maxPoints - maxWidthText - (double)StringRegion(g' _text.Length - 1) * LetterSpacePercentage / 100);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: int lStrWidth = (int)(StringRegion(g' charStep) * LetterSpacePercentage / 100);
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: PointF point = points[count - lStrWidth / 2];
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following statement contains a magic number: (count + lStrWidth / 2) >= 0 & (count + lStrWidth) < maxPoints
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,StringRegionValue,The following statement contains a magic number: SizeF size = g.MeasureString(_text' _font' 100);
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: double c = Math.Sqrt(Math.Pow((point2.X - point1.X)' 2) + Math.Pow((point2.Y - point1.Y)' 2));
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: double c = Math.Sqrt(Math.Pow((point2.X - point1.X)' 2) + Math.Pow((point2.Y - point1.Y)' 2));
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: return Math.Asin((point1.Y - point2.Y) / c) * 180 / Math.PI - 180;
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: return Math.Asin((point1.Y - point2.Y) / c) * 180 / Math.PI - 180;
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetAngle,The following statement contains a magic number: return Math.Asin((point2.Y - point1.Y) / c) * 180 / Math.PI;
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The following statement contains a magic number: switch (TextPathPathPosition)  			{  				case TextPathPosition.OverPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size - VerticalOffset))' stringFormat);  					break;  				case TextPathPosition.CenterPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size / 2))' stringFormat);  					break;  				case TextPathPosition.UnderPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' y + VerticalOffset)' stringFormat);  					break;  			}
Magic Number,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,GetLinePoints,The following statement contains a magic number: PointF[] tmpPoints = new PointF[10001];
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VisualizerView,The following statement contains a magic number: font = new Font(FontFamily.GenericSansSerif' 8);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VisualizerView,The following statement contains a magic number: timer.Interval = 1000 / 30;
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VisualizerView,The following statement contains a magic number: timer.Interval = 1000 / 30;
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,Flyout,The following statement contains a magic number: flyouts.Add(new FlyoutItem() { Text = msg' Location = p' Direction = new Size(5' -3) });
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,Flyout,The following statement contains a magic number: flyouts.Add(new FlyoutItem() { Text = msg' Location = p' Direction = new Size(5' -3) });
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,AddImage,The following statement contains a magic number: cstate.Images.Count < 100
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,GetRandomLocation,The following statement contains a magic number: return new Point(rnd.Next(ClientRectangle.Width - 80) + 40' rnd.Next(ClientRectangle.Height - 80) + 40);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseDownEvent,The following statement contains a magic number: var selectedReceptors = receptorLocation.Where(kvp => PointInCircle(kvp.Value' ReceptorSize.Width/2' testPoint));
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,HorizontalShakeTest,The following statement contains a magic number: (offset.X == 0) && ts.TotalMilliseconds > 500
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,VerticalShakeTest,The following statement contains a magic number: (offset.Y == 0) && ts.TotalMilliseconds > 500
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,MouseWheelEvent,The following statement contains a magic number: int spin = args.Delta / 120;
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestImageMetadataDoubleClick,The following statement contains a magic number: Rectangle metaRect = new Rectangle(imgArea.Left' imgArea.Bottom + 10 + (MetadataHeight * idx)' imgArea.Width' MetadataHeight);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestForReceptorAt,The following statement contains a magic number: rp.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestForReceptorAt,The following statement contains a magic number: rp.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestMembraneDoubleClick,The following statement contains a magic number: membrane.ProtocolPermeability.ForEach(kvp =>  					{  						DataRow row = dt.NewRow();  						row[0] = kvp.Key.Protocol;  						row[1] = kvp.Key.Direction;  						row[2] = kvp.Value.Permeable;  						row[3] = kvp.Value.RootOnly;  						dt.Rows.Add(row);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,TestMembraneDoubleClick,The following statement contains a magic number: membrane.ProtocolPermeability.ForEach(kvp =>  					{  						DataRow row = dt.NewRow();  						row[0] = kvp.Key.Protocol;  						row[1] = kvp.Key.Direction;  						row[2] = kvp.Value.Permeable;  						row[3] = kvp.Value.RootOnly;  						dt.Rows.Add(row);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnPermeabilityFormClosing,The following statement contains a magic number: dv.ForEach(row =>  				{  					string protocol = (string)row[0];  					PermeabilityDirection pd = ((string)row[1]).ToEnum<PermeabilityDirection>();  					PermeabilityKey pk = new PermeabilityKey() { Protocol = protocol' Direction = pd };  					bool permeable = (bool)row[2];  					bool rootOnly = (bool)row[3];  					membraneBeingConfigured.ProtocolPermeability[pk].Permeable = permeable;  					membraneBeingConfigured.ProtocolPermeability[pk].RootOnly = rootOnly;  				});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnPermeabilityFormClosing,The following statement contains a magic number: dv.ForEach(row =>  				{  					string protocol = (string)row[0];  					PermeabilityDirection pd = ((string)row[1]).ToEnum<PermeabilityDirection>();  					PermeabilityKey pk = new PermeabilityKey() { Protocol = protocol' Direction = pd };  					bool permeable = (bool)row[2];  					bool rootOnly = (bool)row[3];  					membraneBeingConfigured.ProtocolPermeability[pk].Permeable = permeable;  					membraneBeingConfigured.ProtocolPermeability[pk].RootOnly = rootOnly;  				});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CheckMouseHover,The following statement contains a magic number: (DateTime.Now - mouseHoverStartTime).TotalMilliseconds > 500
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The following statement contains a magic number: radius += 50;
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,RecalcMembranes,The following statement contains a magic number: radius += 50;
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: membraneLocation.Values.ForEach(m =>  					{  						// Draw the surrounding membrane.  						GraphicsPath gp = new GraphicsPath();  						Rectangle r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' m.Radius);  						r.Inflate(-20' -20);  						gp.AddEllipse(r);  						r.Inflate(20' 20);  						gp.AddEllipse(r);  						PathGradientBrush pgb = new PathGradientBrush(gp);  						// Read about blending here: http://msdn.microsoft.com/en-us/library/system.drawing.drawing2d.blend.aspx  						Blend b = new Blend();  						b.Factors = new float[] { 0' 1' 1 };  						b.Positions = new float[] { 0' .1f' 1 };  						pgb.Blend = b;  						// pgb.CenterPoint = m.Center;  						pgb.CenterColor = surfaceColor;  						pgb.SurroundColors = new Color[] { Color.LightSlateGray };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();    						// Draw a nub at the center of the membrane.  						gp = new GraphicsPath();  						r = CircleToBoundingRectangle(SurfaceOffsetAdjust(m.Center)' MembraneNubRadius);  						gp.AddEllipse(r);  						pgb = new PathGradientBrush(gp);  						pgb.CenterPoint = SurfaceOffsetAdjust(m.Center);  						pgb.CenterColor = Color.LightSlateGray;  						pgb.SurroundColors = new Color[] { surfaceColor };  						e.Graphics.FillPath(pgb' gp);  						pgb.Dispose();  						gp.Dispose();      					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: int protocolLabelOffset = 2;
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: Point start = new Point((int)(line.P1.X - ReceptorSize.Width / 2 * Math.Cos(angle))' (int)(line.P1.Y - ReceptorSize.Width / 2 * Math.Sin(angle)));
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: e.Graphics.FillEllipse(new SolidBrush(pen.Color)' new Rectangle(ctr.X - 3' ctr.Y - 3' 6' 6));
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: protocolLabelOffset += 15;
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: receptorLocation.ForEach(kvp =>  					{  						// red for disabled receptors' green for enabled.  						Pen pen = kvp.Key.Instance.Enabled ? penColors[1] : penColors[0];  						Point p = SurfaceOffsetAdjust(kvp.Value);  						p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						Point bottom = p;  						bottom.Offset(0' ReceptorSize.Height);  						Point bottomCenter = bottom;  						bottomCenter.Offset(ReceptorSize.Width / 2' 0);    						// Double plot because it looks better.  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));  						e.Graphics.DrawEllipse(pen' new Rectangle(p' ReceptorSize));    						// A double circle represents an edge receptor.  						//if (kvp.Key.Instance.IsEdgeReceptor)  						//{  						//	p.Offset(3' 3);		// GDI draws from the UL corner.  						//	Size s = Size.Subtract(ReceptorSize' new Size(6' 6));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//	e.Graphics.DrawEllipse(pen' new Rectangle(p' s));  						//}    						// Name  						SizeF strSize = e.Graphics.MeasureString(kvp.Key.Instance.Name' font);  						Point center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' 0));  						e.Graphics.DrawString(kvp.Key.Name' font' textBrush' center);    						// Subname  						if (!String.IsNullOrEmpty(kvp.Key.Instance.Subname))  						{  							strSize = e.Graphics.MeasureString(kvp.Key.Instance.Subname' font);  							center = Point.Subtract(bottomCenter' new Size((int)strSize.Width / 2' -15));  							e.Graphics.DrawString(kvp.Key.Instance.Subname' font' textBrush' center);  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target != null).ForEach(a =>  					{  						// Get current target location in case user has moved it.  						Point p = receptorLocation.Single(kvp => kvp.Key.Instance == a.Target).Value;  						double dx = p.X - a.StartPosition.X;  						double dy = p.Y - a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carrierAnimations.Where(q => q.Target == null).ForEach(a =>  					{  						double dx = a.StartPosition.X;  						double dy = a.StartPosition.Y;    						// Where are we on the curve?  						double q = Math.Sin((Math.PI / 2) * ((double)a.CurveIndex - CarrierTime / 2) / (CarrierTime / 2)) + 1;		// - PI/2 .. PI/2  						int idx = (int)(dx * q / 2.0);  						int idy = (int)(dy * q / 2.0);    						a.CurrentRegion = new Rectangle(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy - 5' 10' 10);    						Point[] triangle = new Point[]   					{   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx - 5' a.StartPosition.Y + idy + 5))'   						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx + 5' a.StartPosition.Y + idy + 5))'  						SurfaceOffsetAdjust(new Point(a.StartPosition.X + idx' a.StartPosition.Y + idy))'   					};    						e.Graphics.DrawLines(carrierPen' triangle);  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,OnVisualizerPaint,The following statement contains a magic number: carousels.ForEach(kvp =>  					{  						Point p = receptorLocation[kvp.Key];  						// p.Offset(-ReceptorSize.Width / 2' -ReceptorSize.Height / 2);  						int images = kvp.Value.Images.Count;  						int offset = kvp.Value.Offset;  						int idx0 = 0;    						kvp.Value.Images.ForEachWithIndex((imeta' idx) =>  						{  							Image img = imeta.Image;  							int idxReal = (idx + offset) % images;    							// idxReal of 0 is the bottom-most image' which we draw larger than the images on the carousel itself.  							if (idxReal == 0)  							{  								idx0 = idx;  							}  							else  							{  								Point ip = p;		// Receptor center    								// Calculate our location along an ellipse.  idxReal of 0 gives us the bottom-most coordinate.  								double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								double dy = 75 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);    								// Our image center:  								ip.Offset((int)dx' (int)dy);    								// Scale the image so that the image at the top of the ellipse is the smallest.  								// We want the scaling to be a factor from 0.25 to 1  								// This gives us a value on a sin curve from 1..-1..1  								double calc = Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  								// We shift this to 2..0..2  								calc = calc + 1;  								// We divide by 2' giving us 1..0..1  								calc = calc / 2;  								// We take 1/2 of this   								calc = calc / 2;  								// Add back 1/2 as our minimum width range' so now our range is 0.5 to 1.0' multiplied by our width factor' and we get 50..100  								int width = (int)(100 * (0.50 + calc));  								// We want the height to always be 75% of the width.  								int height = width * 3 / 4;	  /*  								System.Diagnostics.Debug.WriteLine("IdxReal = " + idxReal.ToString());  								System.Diagnostics.Debug.WriteLine("      dx = " + dx.ToString());  								System.Diagnostics.Debug.WriteLine("      dy = " + dy.ToString());  								System.Diagnostics.Debug.WriteLine("    Calc = " + calc.ToString());  								System.Diagnostics.Debug.WriteLine("   Width = " + width.ToString());  */  								// Even though it'll distort our image' we always want a 100 x 75 image.  								// e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - 50' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width)));  								e.Graphics.DrawImage(img' new Rectangle(new Point(ip.X - width/2' ip.Y - height/2)' new Size(width' height)));  							}  						});    						{  							// Draw idx0 last so it appears on top.  							int idxReal = (idx0 + offset) % images;  							Point ip = p;  							double dx = 150 * Math.Cos((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							double dy = 150 * Math.Sin((2 * Math.PI * 1 / 4) + 2 * Math.PI * idxReal / images);  							ip.Offset((int)dx' (int)dy);  							int sizer = (idxReal == 0) ? 150 : 100;  							Image img = kvp.Value.Images[idx0].Image;  							Rectangle location = new Rectangle(new Point(ip.X - 75' ip.Y - 50 * img.Height / img.Width)' new Size(sizer' sizer * img.Height / img.Width));  							e.Graphics.DrawImage(img' location);  							kvp.Value.ActiveImageFilename = img.Tag.ToString();  							kvp.Value.ActiveImageLocation = location;  							kvp.Value.ActiveImageIndex = idx0;    							int y = location.Bottom + 10;    							// We use ForEachWithIndex to ensure the same ordering as when the user double-clicks on the metadata.  							kvp.Value.Images[idx0].MetadataPackets.ForEachWithIndex((meta' idx) =>  								{  									Rectangle region = new Rectangle(location.X' y' location.Width' MetadataHeight);  									string data = meta.Name + ": " + meta.Value;  									e.Graphics.DrawString(data' font' whiteBrush' region);  									y += MetadataHeight;  								});  						}  					});
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PointInCircle,The following statement contains a magic number: (s.Width ^ 2 + s.Height ^ 2) < (r ^ 2)
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PointInCircle,The following statement contains a magic number: (s.Width ^ 2 + s.Height ^ 2) < (r ^ 2)
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,PointInCircle,The following statement contains a magic number: (s.Width ^ 2 + s.Height ^ 2) < (r ^ 2)
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CircleToBoundingRectangle,The following statement contains a magic number: return new Rectangle(ctr.X - radius' ctr.Y - radius' radius * 2' radius * 2);
Magic Number,TypeSystemExplorer.Views,VisualizerView,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\VisualizerView.cs,CircleToBoundingRectangle,The following statement contains a magic number: return new Rectangle(ctr.X - radius' ctr.Y - radius' radius * 2' radius * 2);
Missing Default,TypeSystemExplorer.Controllers,ApplicationFormController,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Controllers\ApplicationFormController.cs,ProcessCarrier,The following switch statement is missing a default case: switch (carrier.Protocol.DeclTypeName)  			{  				case "SystemMessage":  					{  						string action = carrier.Signal.Action;  						string data = carrier.Signal.Data;  						IReceptorInstance receptorInstance = carrier.Signal.Source;    						if (action == "Flyout")  						{  							VisualizerController.View.Flyout(data' receptorInstance);  						}    						break;  					}    				case "CarrierAnimation":  					{  						Action action = carrier.Signal.Process;  						IReceptorInstance from = carrier.Signal.From;  						IReceptorInstance to = carrier.Signal.To;  						ICarrier outCarrier = carrier.Signal.Carrier;  						VisualizerController.View.AnimateCarrier(action' from' to' outCarrier);  						break;  					}    				case "SystemShowImage":  					{  						IReceptorInstance target = carrier.Signal.From;  						Bitmap image = carrier.Signal.Image.Value;  						dynamic filename = carrier.Signal.Filename;  						VisualizerController.View.AddImage(target' image' filename);  						break;  					}    				case "HaveImageMetadata":  					{  						VisualizerController.View.ProcessImageMetadata(carrier.Signal);  						break;  					}  			}
Missing Default,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawText,The following switch statement is missing a default case: switch (_pathalign)  			{  				case TextPathAlign.Left:  					point1 = points[0];  					count = 0;  					break;  				case TextPathAlign.Center:  					count = (int)((maxPoints - maxWidthText) / 2);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  				case TextPathAlign.Right:  					count = (int)(maxPoints - maxWidthText - (double)StringRegion(g' _text.Length - 1) * LetterSpacePercentage / 100);  					if (count > 0)  					{  						point1 = points[count];  					}  					else  					{  						point1 = points[0];  					}    					break;  			}
Missing Default,TypeSystemExplorer.Views,TextOnPath,D:\research\architectureSmells\repos\cliftonm_HOPE\TypeSystemExplorer\Views\TextOnPath.cs,DrawRotatedText,The following switch statement is missing a default case: switch (TextPathPathPosition)  			{  				case TextPathPosition.OverPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size - VerticalOffset))' stringFormat);  					break;  				case TextPathPosition.CenterPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' (int)(y - _font.Size / 2))' stringFormat);  					break;  				case TextPathPosition.UnderPath:  					graphicsPath.AddString(text' _font.FontFamily' (int)_font.Style' _font.Size' new Point(x' y + VerticalOffset)' stringFormat);  					break;  			}
